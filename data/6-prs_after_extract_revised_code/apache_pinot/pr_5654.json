{"pr_number": 5654, "pr_title": "[Part 1] Add geo support", "pr_createdAt": "2020-07-02T21:20:46Z", "pr_url": "https://github.com/apache/pinot/pull/5654", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjIzMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449272231", "bodyText": "plz ignore this, seems some search/replace error", "author": "yupeng9", "createdAt": "2020-07-02T21:23:22Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java", "diffHunk": "@@ -96,7 +96,7 @@ public HelixTaskResult handleMessage() {\n \n     @Override\n     public void onError(Exception e, ErrorCode code, ErrorType type) {\n-      LOGGER.error(\"Got error while refreshing segment: {} of table: {} (error code: {}, error type: {})\", _segmentName,", "originalCommit": "f84b1a9c9e9213c7f37aafd77ea1b4000e4cfb60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "chunk": "diff --git a/pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java b/pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java\nindex 0df6e67a1b..74771ab132 100644\n--- a/pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java\n+++ b/pinot-broker/src/main/java/org/apache/pinot/broker/broker/helix/BrokerUserDefinedMessageHandlerFactory.java\n\n@@ -96,7 +96,7 @@ public class BrokerUserDefinedMessageHandlerFactory implements MessageHandlerFac\n \n     @Override\n     public void onError(Exception e, ErrorCode code, ErrorType type) {\n-      LOGGER.error(\"Got error while refreshing segment: {} of table: {} (error id: {}, error type: {})\", _segmentName,\n+      LOGGER.error(\"Got error while refreshing segment: {} of table: {} (error code: {}, error type: {})\", _segmentName,\n           _tableNameWithType, code, type, e);\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800440", "bodyText": "what does this function do? please add java docs", "author": "kishoreg", "createdAt": "2020-07-04T19:47:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5NDk1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450994950", "bodyText": "Added. This is an abstract class for implementing the geo constructor functions like StGeomFromText and StGeogFromText", "author": "yupeng9", "createdAt": "2020-07-07T16:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ0MA=="}], "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 51c7e4a0f2..8160cffda6 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,7 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800481", "bodyText": "function -> functions", "author": "kishoreg", "createdAt": "2020-07-04T19:48:16Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzNzExMA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449837110", "bodyText": "hmm, then I cannot define scalar function in this package for inbuilt transformation functions.", "author": "yupeng9", "createdAt": "2020-07-05T05:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\nindex 576a2e592b..d9197e0345 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\n\n@@ -35,52 +35,55 @@ import org.slf4j.LoggerFactory;\n import java.util.List;\n import java.util.Map;\n \n+\n+/**\n+ * Returns the text representation of the geometry object.\n+ */\n public class StAsTextFunction extends BaseTransformFunction {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n-    private TransformFunction _transformFunction;\n-    private static WKTWriter _writer;\n-    public static final String FUNCTION_NAME = \"ST_AsText\";\n-    private String[] _results;\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n+  private TransformFunction _transformFunction;\n+  private static WKTWriter _writer;\n+  public static final String FUNCTION_NAME = \"ST_AsText\";\n+  private String[] _results;\n \n-    @Override\n-    public String getName() {\n-        return FUNCTION_NAME;\n-    }\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n \n-    @Override\n-    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n-        Preconditions\n-                .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\",\n-                        getName());\n-        TransformFunction transformFunction = arguments.get(0);\n-        Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n-                \"Argument must be single-valued for transform function: %s\", getName());\n-        _transformFunction = transformFunction;\n-        _writer = new WKTWriter();\n-    }\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _writer = new WKTWriter();\n+  }\n \n-    @Override\n-    public TransformResultMetadata getResultMetadata() {\n-        return STRING_SV_NO_DICTIONARY_METADATA;\n-    }\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;\n+  }\n \n-    @Override\n-    public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n-        if (_results == null) {\n-            _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n-        }\n-        byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n-        Geometry geometry;\n-        for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n-                geometry = GeometrySerializer.deserialize(values[i]);\n-            _results[i] = _writer.write(geometry);\n-        }\n-        return _results;\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n     }\n-\n-    @ScalarFunction\n-    public static String stAsText(byte[] bytes) {\n-        WKTWriter writer = new WKTWriter();\n-        return writer.write(GeometrySerializer.deserialize(bytes));\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = _writer.write(geometry);\n     }\n+    return _results;\n+  }\n+\n+  @ScalarFunction\n+  public static String stAsText(byte[] bytes) {\n+    WKTWriter writer = new WKTWriter();\n+    return writer.write(GeometrySerializer.deserialize(bytes));\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDU3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800578", "bodyText": "sweet", "author": "kishoreg", "createdAt": "2020-07-04T19:49:42Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));\n                   if (group != null) {\n                     extracted.set(\"group_city\", group.get(\"group_city\"));\n                     extracted.set(\"group_country\", group.get(\"group_country\"));\n                     extracted.set(\"group_id\", group.get(\"group_id\"));\n                     extracted.set(\"group_name\", group.get(\"group_name\"));\n+                    extracted.set(\"group_lat\", group.get(\"group_lat\"));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\nindex 6244bde6dc..86a89db868 100644\n--- a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n+++ b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n\n@@ -90,7 +88,6 @@ public class MeetupRsvpStream {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n-                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));\n                   if (group != null) {\n                     extracted.set(\"group_city\", group.get(\"group_city\"));\n                     extracted.set(\"group_country\", group.get(\"group_country\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgwMDYwMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449800602", "bodyText": "logger?", "author": "kishoreg", "createdAt": "2020-07-04T19:50:05Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -101,18 +107,18 @@ public void onMessage(String message) {\n                     producer.produce(\"meetupRSVPEvents\", extracted.toString().getBytes(StandardCharsets.UTF_8));\n                   }\n                 } catch (Exception e) {\n-                  //LOGGER.error(\"error processing raw event \", e);\n+                  LOGGER.error(\"error processing raw event \", e);\n                 }\n               }\n             });\n             session.getBasicRemote().sendText(\"\");\n           } catch (IOException e) {\n-            //LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\");\n+            LOGGER.error(\"found an event where data did not have all the fields, don't care about for quickstart\", e);\n           }\n         }\n       }, cec, new URI(\"ws://stream.meetup.com/2/rsvps\"));\n     } catch (Exception e) {\n-      //e.printStackTrace();\n+      e.printStackTrace();", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\nindex 6244bde6dc..86a89db868 100644\n--- a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n+++ b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n\n@@ -118,7 +115,7 @@ public class MeetupRsvpStream {\n         }\n       }, cec, new URI(\"ws://stream.meetup.com/2/rsvps\"));\n     } catch (Exception e) {\n-      e.printStackTrace();\n+      LOGGER.error(\"encountered an error running the meetupRSVPEvents stream\", e);\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjQ4Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826482", "bodyText": "Tab space indicates not following Pinot code-styling.", "author": "mayankshriv", "createdAt": "2020-07-05T03:09:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex c87cc52fdf..9f42a6c222 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -56,6 +56,8 @@ import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n public class GeometrySerde extends Serializer {\n     private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n \n+\n+\n     @Override\n     public void write(Kryo kryo, Output output, Object object) {\n         if (!(object instanceof Geometry)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNjU1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449826559", "bodyText": "Initialize list with size if known.", "author": "mayankshriv", "createdAt": "2020-07-05T03:11:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+    @Override\n+    public void write(Kryo kryo, Output output, Object object) {\n+        if (!(object instanceof Geometry)) {\n+            throw new UnsupportedOperationException(\"Cannot serialize object of type \" +\n+                    object.getClass().getName());\n+        }\n+        writeGeometry(output, (Geometry) object);\n+    }\n+\n+    @Override\n+    public Object read(Kryo kryo, Input input, Class aClass) {\n+        byte typeByte = input.readByte();\n+        GeometrySerializationType type = readGeometryType(typeByte);\n+        GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+        return readGeometry(input, type, factory);\n+    }\n+\n+    private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+        switch (type) {\n+            case POINT:\n+                return readPoint(input, factory);\n+            case MULTI_POINT:\n+                return readMultiPoint(input, factory);\n+            case LINE_STRING:\n+                return readPolyline(input, false, factory);\n+            case MULTI_LINE_STRING:\n+                return readPolyline(input, true, factory);\n+            case POLYGON:\n+                return readPolygon(input, false, factory);\n+            case MULTI_POLYGON:\n+                return readPolygon(input, true, factory);\n+            case GEOMETRY_COLLECTION:\n+                return readGeometryCollection(input, factory);\n+            default:\n+                throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+        }\n+    }\n+\n+    private Point readPoint(Input input, GeometryFactory factory) {\n+        Coordinate coordinates = readCoordinate(input);\n+        if (isNaN(coordinates.x) || isNaN(coordinates.y)) {\n+            return factory.createPoint();\n+        }\n+        return factory.createPoint(coordinates);\n+    }\n+\n+    private Coordinate readCoordinate(Input input) {\n+        return new Coordinate(input.readDouble(), input.readDouble());\n+    }\n+\n+    private Coordinate[] readCoordinates(Input input, int count) {\n+        requireNonNull(input, \"input is null\");\n+        verify(count > 0);\n+        Coordinate[] coordinates = new Coordinate[count];\n+        for (int i = 0; i < count; i++) {\n+            coordinates[i] = readCoordinate(input);\n+        }\n+        return coordinates;\n+    }\n+\n+    private Geometry readMultiPoint(Input input, GeometryFactory factory) {\n+        int pointCount = input.readInt();\n+        Point[] points = new Point[pointCount];\n+        for (int i = 0; i < pointCount; i++) {\n+            points[i] = readPoint(input, factory);\n+        }\n+        return factory.createMultiPoint(points);\n+    }\n+\n+    private GeometrySerializationType readGeometryType(byte typeByte) {\n+        return GeometrySerializationType.fromID(typeByte & GEOGRAPHY_GET_MASK);\n+    }\n+\n+    private Geometry readPolyline(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiLineString();\n+            }\n+            return factory.createLineString();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LineString[] lineStrings = new LineString[partCount];\n+\n+        for (int i = 0; i < partCount; i++) {\n+            lineStrings[i] = factory.createLineString(readCoordinates(input, partLengths[i]));\n+        }\n+\n+        if (multitype) {\n+            return factory.createMultiLineString(lineStrings);\n+        }\n+        verify(lineStrings.length == 1);\n+        return lineStrings[0];\n+    }\n+\n+    private Geometry readPolygon(Input input, boolean multitype, GeometryFactory factory) {\n+        int partCount = input.readInt();\n+        if (partCount == 0) {\n+            if (multitype) {\n+                return factory.createMultiPolygon();\n+            }\n+            return factory.createPolygon();\n+        }\n+\n+        int pointCount = input.readInt();\n+        int[] startIndexes = new int[partCount];\n+        for (int i = 0; i < partCount; i++) {\n+            startIndexes[i] = input.readInt();\n+        }\n+\n+        int[] partLengths = new int[partCount];\n+        if (partCount > 1) {\n+            partLengths[0] = startIndexes[1];\n+            for (int i = 1; i < partCount - 1; i++) {\n+                partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n+            }\n+        }\n+        partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n+\n+        LinearRing shell = null;\n+        List<LinearRing> holes = new ArrayList<>();", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex c87cc52fdf..9f42a6c222 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -56,6 +56,8 @@ import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n public class GeometrySerde extends Serializer {\n     private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n \n+\n+\n     @Override\n     public void write(Kryo kryo, Output output, Object object) {\n         if (!(object instanceof Geometry)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830148", "bodyText": "Please use Pinot code style (name of member variables starts with _ to avoid qualifying with this.", "author": "mayankshriv", "createdAt": "2020-07-05T03:38:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODgwMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450628803", "bodyText": "Sure. thanks.", "author": "yupeng9", "createdAt": "2020-07-07T06:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\nindex 19b56e5af7..85fc679c45 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n\n@@ -73,4 +73,4 @@ public enum GeometrySerializationType\n                 throw new IllegalArgumentException(\"Invalid type id: \" + id);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830313", "bodyText": "Consider using a Static Map, if this list has a chance to grow.", "author": "mayankshriv", "createdAt": "2020-07-05T03:41:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+public enum GeometrySerializationType\n+{\n+    POINT(0, GeometryType.POINT),\n+    MULTI_POINT(1, GeometryType.MULTI_POINT),\n+    LINE_STRING(2, GeometryType.LINE_STRING),\n+    MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+    POLYGON(4, GeometryType.POLYGON),\n+    MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+    GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+    ENVELOPE(7, GeometryType.POLYGON);\n+\n+    private final int id;\n+    private final GeometryType geometryType;\n+\n+    GeometrySerializationType(int id, GeometryType geometryType)\n+    {\n+        this.id = id;\n+        this.geometryType = geometryType;\n+    }\n+\n+    public int id()\n+    {\n+        return id;\n+    }\n+\n+    public GeometryType getGeometryType()\n+    {\n+        return geometryType;\n+    }\n+\n+    public static GeometrySerializationType fromID(int id)\n+    {\n+        switch (id) {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyOTQ3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r450629478", "bodyText": "This list is unlikely to grow, given the OGC geo is a well-defined standard per https://www.ogc.org/standards/sfa", "author": "yupeng9", "createdAt": "2020-07-07T06:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\nindex 19b56e5af7..85fc679c45 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n\n@@ -73,4 +73,4 @@ public enum GeometrySerializationType\n                 throw new IllegalArgumentException(\"Invalid type id: \" + id);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDM1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830350", "bodyText": "Please add Java doc to all classes and their public methods.", "author": "mayankshriv", "createdAt": "2020-07-05T03:41:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+\n+public class GeometrySerializer {", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\nindex 210294a145..285711c2fe 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\n\n@@ -26,25 +26,39 @@ import org.locationtech.jts.geom.Geometry;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n \n+\n+/**\n+ * A serializer that serializes a geometry object into bytes and vice versa.\n+ */\n public class GeometrySerializer {\n-    private static GeometrySerde serde = new GeometrySerde();\n+  private static GeometrySerde serde = new GeometrySerde();\n \n-    private GeometrySerializer() {\n-    }\n+  private GeometrySerializer() {\n+  }\n \n-    public static byte[] serialize(Geometry geometry) {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        Output output = new Output(out);\n-        serde.write(new Kryo(), output, geometry);\n-        output.close();\n-        return out.toByteArray();\n-    }\n+  /**\n+   * Serializes a geometry object into bytes\n+   * @param geometry the geometry object to serialize\n+   * @return the serialized bytes\n+   */\n+  public static byte[] serialize(Geometry geometry) {\n+    ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    Output output = new Output(out);\n+    serde.write(new Kryo(), output, geometry);\n+    output.close();\n+    return out.toByteArray();\n+  }\n \n-    public static Geometry deserialize(byte[] bytes) {\n-        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n-        Input input = new Input(in);\n-        Object deserialized = serde.read(new Kryo(), input, Geometry.class);\n-        input.close();\n-        return (Geometry) deserialized;\n-    }\n+  /**\n+   * Deserializes bytes into a geometry object\n+   * @param bytes the bytes to deserialize\n+   * @return the deserialized object\n+   */\n+  public static Geometry deserialize(byte[] bytes) {\n+    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n+    Input input = new Input(in);\n+    Object deserialized = serde.read(new Kryo(), input, Geometry.class);\n+    input.close();\n+    return (Geometry) deserialized;\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830462", "bodyText": "Utils.rethrow will preserve the original exception.", "author": "mayankshriv", "createdAt": "2020-07-05T03:42:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+    private TransformFunction _transformFunction;\n+    private byte[][] _results;\n+    private WKTReader _reader;\n+\n+    @Override\n+    public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+        Preconditions\n+                .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\",\n+                        getName());\n+        TransformFunction transformFunction = arguments.get(0);\n+        Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+                \"The argument must be single-valued for transform function: %s\", getName());\n+        _transformFunction = transformFunction;\n+        _reader = new WKTReader(getGeometryFactory());\n+    }\n+\n+    abstract protected GeometryFactory getGeometryFactory();\n+\n+    @Override\n+    public TransformResultMetadata getResultMetadata() {\n+        return BYTES_SV_NO_DICTIONARY_METADATA;\n+    }\n+\n+    @Override\n+    public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+        if (_results == null) {\n+            _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+        }\n+        String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+        int length = projectionBlock.getNumDocs();\n+        for (int i = 0; i < length; i++) {\n+            try {\n+                Geometry geometry = _reader.read(argumentValues[i]);\n+                _results[i] = GeometrySerializer.serialize(geometry);\n+            } catch (ParseException e) {\n+                throw new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i]));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzIyMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027221", "bodyText": "Good to see this util", "author": "yupeng9", "createdAt": "2020-07-07T17:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 51c7e4a0f2..8160cffda6 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,7 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830731", "bodyText": "Would be good to add the benchmark results in the PR description.", "author": "mayankshriv", "createdAt": "2020-07-05T03:47:55Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.io.Resources;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+\n+import static com.google.common.io.Resources.getResource;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.openjdk.jmh.annotations.Mode.Throughput;\n+\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.serialize;\n+import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.deserialize;\n+\n+@State(Scope.Thread)\n+@Fork(2)\n+@Warmup(iterations = 3, time = 3, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 4, timeUnit = SECONDS)\n+@OutputTimeUnit(SECONDS)\n+@BenchmarkMode(Throughput)\n+public class BenchmarkSerde", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyNzcyNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451027727", "bodyText": "Sounds good", "author": "yupeng9", "createdAt": "2020-07-07T17:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA2ODk4Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451068987", "bodyText": "Added https://gist.github.com/yupeng9/8e2b081ffb372593492ebb6a41da97fd to the description", "author": "yupeng9", "createdAt": "2020-07-07T18:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDczMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java b/pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java\nindex 744c909359..d513b44594 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/core/geospatial/serde/BenchmarkSerde.java\n\n@@ -49,308 +49,274 @@ import static org.openjdk.jmh.annotations.Mode.Throughput;\n import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.serialize;\n import static org.apache.pinot.core.geospatial.serde.GeometrySerializer.deserialize;\n \n+\n @State(Scope.Thread)\n @Fork(2)\n @Warmup(iterations = 3, time = 3, timeUnit = SECONDS)\n @Measurement(iterations = 5, time = 4, timeUnit = SECONDS)\n @OutputTimeUnit(SECONDS)\n @BenchmarkMode(Throughput)\n-public class BenchmarkSerde\n-{\n+public class BenchmarkSerde {\n+  // POINT\n+  @Benchmark\n+  public Object serializePoint(BenchmarkData data) {\n+    return serialize(data.point);\n+  }\n+\n+  @Benchmark\n+  public Object deserializePoint(BenchmarkData data) {\n+    return deserialize(data.pointSerialized);\n+  }\n+\n+  // MULTI POINT\n+  @Benchmark\n+  public Object serializeSimpleMultipoint(BenchmarkData data) {\n+    return serialize(data.simpleMultipoint);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimpleMultipoint(BenchmarkData data) {\n+    return deserialize(data.simpleMultipointSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexMultipoint(BenchmarkData data) {\n+    return serialize(data.complexMultipoint);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexMultipoint(BenchmarkData data) {\n+    return deserialize(data.complexMultipointSerialized);\n+  }\n+\n+  // LINE STRING\n+  @Benchmark\n+  public Object serializeSimpleLineString(BenchmarkData data) {\n+    return serialize(data.simpleLineString);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimpleLineString(BenchmarkData data) {\n+    return deserialize(data.simpleLineStringSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexLineString(BenchmarkData data) {\n+    return serialize(data.complexLineString);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexLineString(BenchmarkData data) {\n+    return deserialize(data.complexLineStringSerialized);\n+  }\n+\n+  // MULTILINE STRING\n+  @Benchmark\n+  public Object serializeSimpleMultiLineString(BenchmarkData data) {\n+    return serialize(data.simpleMultiLineString);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimpleMultiLineString(BenchmarkData data) {\n+    return deserialize(data.simpleMultiLineStringSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexMultiLineString(BenchmarkData data) {\n+    return serialize(data.complexMultiLineString);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexMultiLineString(BenchmarkData data) {\n+    return deserialize(data.complexMultiLineStringSerialized);\n+  }\n+\n+  // POLYGON\n+  @Benchmark\n+  public Object serializeSimplePolygon(BenchmarkData data) {\n+    return serialize(data.simplePolygon);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimplePolygon(BenchmarkData data) {\n+    return deserialize(data.simplePolygonSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexPolygon(BenchmarkData data) {\n+    return serialize(data.complexPolygon);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexPolygon(BenchmarkData data) {\n+    return deserialize(data.complexPolygonSerialized);\n+  }\n+\n+  // MULTI POLYGON\n+  @Benchmark\n+  public Object serializeSimpleMultiPolygon(BenchmarkData data) {\n+    return serialize(data.simpleMultiPolygon);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimpleMultiPolygon(BenchmarkData data) {\n+    return deserialize(data.simpleMultiPolygonSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexMultiPolygon(BenchmarkData data) {\n+    return serialize(data.complexMultiPolygon);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexMultiPolygon(BenchmarkData data) {\n+    return deserialize(data.complexMultiPolygonSerialized);\n+  }\n+\n+  // GEOMETRY COLLECTION\n+  @Benchmark\n+  public Object serializeSimpleGeometryCollection(BenchmarkData data) {\n+    return serialize(data.simpleGeometryCollection);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeSimpleGeometryCollection(BenchmarkData data) {\n+    return deserialize(data.simpleGeometryCollectionSerialized);\n+  }\n+\n+  @Benchmark\n+  public Object serializeComplexGeometryCollection(BenchmarkData data) {\n+    return serialize(data.complexGeometryCollection);\n+  }\n+\n+  @Benchmark\n+  public Object deserializeComplexGeometryCollection(BenchmarkData data) {\n+    return deserialize(data.complexGeometryCollectionSerialized);\n+  }\n+\n+  @State(Scope.Thread)\n+  public static class BenchmarkData {\n     // POINT\n-    @Benchmark\n-    public Object serializePoint(BenchmarkData data)\n-    {\n-        return serialize(data.point);\n-    }\n-\n-    @Benchmark\n-    public Object deserializePoint(BenchmarkData data)\n-    {\n-        return deserialize(data.pointSerialized);\n-    }\n+    private Geometry point;\n+    private byte[] pointSerialized;\n \n     // MULTI POINT\n-    @Benchmark\n-    public Object serializeSimpleMultipoint(BenchmarkData data)\n-    {\n-        return serialize(data.simpleMultipoint);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeSimpleMultipoint(BenchmarkData data)\n-    {\n-        return deserialize(data.simpleMultipointSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexMultipoint(BenchmarkData data)\n-    {\n-        return serialize(data.complexMultipoint);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexMultipoint(BenchmarkData data)\n-    {\n-        return deserialize(data.complexMultipointSerialized);\n-    }\n+    private Geometry simpleMultipoint;\n+    private byte[] simpleMultipointSerialized;\n+    private Geometry complexMultipoint;\n+    private byte[] complexMultipointSerialized;\n \n     // LINE STRING\n-    @Benchmark\n-    public Object serializeSimpleLineString(BenchmarkData data)\n-    {\n-        return serialize(data.simpleLineString);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeSimpleLineString(BenchmarkData data)\n-    {\n-        return deserialize(data.simpleLineStringSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexLineString(BenchmarkData data)\n-    {\n-        return serialize(data.complexLineString);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexLineString(BenchmarkData data)\n-    {\n-        return deserialize(data.complexLineStringSerialized);\n-    }\n+    private Geometry simpleLineString;\n+    private byte[] simpleLineStringSerialized;\n+    private Geometry complexLineString;\n+    private byte[] complexLineStringSerialized;\n \n     // MULTILINE STRING\n-    @Benchmark\n-    public Object serializeSimpleMultiLineString(BenchmarkData data)\n-    {\n-        return serialize(data.simpleMultiLineString);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeSimpleMultiLineString(BenchmarkData data)\n-    {\n-        return deserialize(data.simpleMultiLineStringSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexMultiLineString(BenchmarkData data)\n-    {\n-        return serialize(data.complexMultiLineString);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexMultiLineString(BenchmarkData data)\n-    {\n-        return deserialize(data.complexMultiLineStringSerialized);\n-    }\n+    private Geometry simpleMultiLineString;\n+    private byte[] simpleMultiLineStringSerialized;\n+    private Geometry complexMultiLineString;\n+    private byte[] complexMultiLineStringSerialized;\n \n     // POLYGON\n-    @Benchmark\n-    public Object serializeSimplePolygon(BenchmarkData data)\n-    {\n-        return serialize(data.simplePolygon);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeSimplePolygon(BenchmarkData data)\n-    {\n-        return deserialize(data.simplePolygonSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexPolygon(BenchmarkData data)\n-    {\n-        return serialize(data.complexPolygon);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexPolygon(BenchmarkData data)\n-    {\n-        return deserialize(data.complexPolygonSerialized);\n-    }\n+    private Geometry simplePolygon;\n+    private byte[] simplePolygonSerialized;\n+    private Geometry complexPolygon;\n+    private byte[] complexPolygonSerialized;\n \n     // MULTI POLYGON\n-    @Benchmark\n-    public Object serializeSimpleMultiPolygon(BenchmarkData data)\n-    {\n-        return serialize(data.simpleMultiPolygon);\n+    private Geometry simpleMultiPolygon;\n+    private byte[] simpleMultiPolygonSerialized;\n+    private Geometry complexMultiPolygon;\n+    private byte[] complexMultiPolygonSerialized;\n+\n+    // COLLECTION\n+    private Geometry simpleGeometryCollection;\n+    private byte[] simpleGeometryCollectionSerialized;\n+    private Geometry complexGeometryCollection;\n+    private byte[] complexGeometryCollectionSerialized;\n+\n+    @Setup\n+    public void setup() {\n+      point = fromText(BenchmarkResource.POINT);\n+      pointSerialized = serialize(point);\n+\n+      simpleMultipoint = fromText(BenchmarkResource.MULTIPOINT);\n+      simpleMultipointSerialized = serialize(simpleMultipoint);\n+      complexMultipoint = fromText(BenchmarkResource.readResource(\"geospatial/complex-multipoint.txt\"));\n+      complexMultipointSerialized = serialize(complexMultipoint);\n+\n+      simpleLineString = fromText(BenchmarkResource.LINESTRING);\n+      simpleLineStringSerialized = serialize(simpleLineString);\n+      complexLineString = fromText(BenchmarkResource.readResource(\"geospatial/complex-linestring.txt\"));\n+      complexLineStringSerialized = serialize(complexLineString);\n+\n+      simpleMultiLineString = fromText(BenchmarkResource.MULTILINESTRING);\n+      simpleMultiLineStringSerialized = serialize(simpleMultiLineString);\n+      complexMultiLineString = fromText(BenchmarkResource.readResource(\"geospatial/complex-multilinestring.txt\"));\n+      complexMultiLineStringSerialized = serialize(complexMultiLineString);\n+\n+      simplePolygon = fromText(BenchmarkResource.POLYGON);\n+      simplePolygonSerialized = serialize(simplePolygon);\n+      complexPolygon = fromText(BenchmarkResource.readResource(\"geospatial/complex-polygon.txt\"));\n+      complexPolygonSerialized = serialize(complexPolygon);\n+\n+      simpleMultiPolygon = fromText(BenchmarkResource.MULTIPOLYGON);\n+      simpleMultiPolygonSerialized = serialize(simpleMultiPolygon);\n+      complexMultiPolygon = fromText(BenchmarkResource.readResource(\"geospatial/complex-multipolygon.txt\"));\n+      complexMultiPolygonSerialized = serialize(complexMultiPolygon);\n+\n+      simpleGeometryCollection = fromText(BenchmarkResource.GEOMETRYCOLLECTION);\n+      simpleGeometryCollectionSerialized = serialize(simpleGeometryCollection);\n+      complexGeometryCollection = fromText(\"GEOMETRYCOLLECTION (\" + Joiner.on(\", \")\n+          .join(BenchmarkResource.readResource(\"geospatial/complex-multipoint.txt\"),\n+              BenchmarkResource.readResource(\"geospatial/complex-linestring.txt\"),\n+              BenchmarkResource.readResource(\"geospatial/complex-multilinestring.txt\"),\n+              BenchmarkResource.readResource(\"geospatial/complex-polygon.txt\"),\n+              BenchmarkResource.readResource(\"geospatial/complex-multipolygon.txt\")) + \")\");\n+      complexGeometryCollectionSerialized = serialize(complexGeometryCollection);\n     }\n-\n-    @Benchmark\n-    public Object deserializeSimpleMultiPolygon(BenchmarkData data)\n-    {\n-        return deserialize(data.simpleMultiPolygonSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexMultiPolygon(BenchmarkData data)\n-    {\n-        return serialize(data.complexMultiPolygon);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexMultiPolygon(BenchmarkData data)\n-    {\n-        return deserialize(data.complexMultiPolygonSerialized);\n-    }\n-\n-    // GEOMETRY COLLECTION\n-    @Benchmark\n-    public Object serializeSimpleGeometryCollection(BenchmarkData data)\n-    {\n-        return serialize(data.simpleGeometryCollection);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeSimpleGeometryCollection(BenchmarkData data)\n-    {\n-        return deserialize(data.simpleGeometryCollectionSerialized);\n-    }\n-\n-    @Benchmark\n-    public Object serializeComplexGeometryCollection(BenchmarkData data)\n-    {\n-        return serialize(data.complexGeometryCollection);\n-    }\n-\n-    @Benchmark\n-    public Object deserializeComplexGeometryCollection(BenchmarkData data)\n-    {\n-        return deserialize(data.complexGeometryCollectionSerialized);\n-    }\n-\n-    @State(Scope.Thread)\n-    public static class BenchmarkData\n-    {\n-        // POINT\n-        private Geometry point;\n-        private byte[] pointSerialized;\n-\n-        // MULTI POINT\n-        private Geometry simpleMultipoint;\n-        private byte[] simpleMultipointSerialized;\n-        private Geometry complexMultipoint;\n-        private byte[] complexMultipointSerialized;\n-\n-        // LINE STRING\n-        private Geometry simpleLineString;\n-        private byte[] simpleLineStringSerialized;\n-        private Geometry complexLineString;\n-        private byte[] complexLineStringSerialized;\n-\n-        // MULTILINE STRING\n-        private Geometry simpleMultiLineString;\n-        private byte[] simpleMultiLineStringSerialized;\n-        private Geometry complexMultiLineString;\n-        private byte[] complexMultiLineStringSerialized;\n-\n-        // POLYGON\n-        private Geometry simplePolygon;\n-        private byte[] simplePolygonSerialized;\n-        private Geometry complexPolygon;\n-        private byte[] complexPolygonSerialized;\n-\n-        // MULTI POLYGON\n-        private Geometry simpleMultiPolygon;\n-        private byte[] simpleMultiPolygonSerialized;\n-        private Geometry complexMultiPolygon;\n-        private byte[] complexMultiPolygonSerialized;\n-\n-        // COLLECTION\n-        private Geometry simpleGeometryCollection;\n-        private byte[] simpleGeometryCollectionSerialized;\n-        private Geometry complexGeometryCollection;\n-        private byte[] complexGeometryCollectionSerialized;\n-\n-        @Setup\n-        public void setup()\n-        {\n-            point = fromText(BenchmarkResource.POINT);\n-            pointSerialized = serialize(point);\n-\n-            simpleMultipoint = fromText(BenchmarkResource.MULTIPOINT);\n-            simpleMultipointSerialized = serialize(simpleMultipoint);\n-            complexMultipoint = fromText(BenchmarkResource.readResource(\"geospatial/complex-multipoint.txt\"));\n-            complexMultipointSerialized = serialize(complexMultipoint);\n-\n-            simpleLineString = fromText(BenchmarkResource.LINESTRING);\n-            simpleLineStringSerialized = serialize(simpleLineString);\n-            complexLineString = fromText(BenchmarkResource.readResource(\"geospatial/complex-linestring.txt\"));\n-            complexLineStringSerialized = serialize(complexLineString);\n-\n-            simpleMultiLineString = fromText(BenchmarkResource.MULTILINESTRING);\n-            simpleMultiLineStringSerialized = serialize(simpleMultiLineString);\n-            complexMultiLineString = fromText(BenchmarkResource.readResource(\"geospatial/complex-multilinestring.txt\"));\n-            complexMultiLineStringSerialized = serialize(complexMultiLineString);\n-\n-            simplePolygon = fromText(BenchmarkResource.POLYGON);\n-            simplePolygonSerialized = serialize(simplePolygon);\n-            complexPolygon = fromText(BenchmarkResource.readResource(\"geospatial/complex-polygon.txt\"));\n-            complexPolygonSerialized = serialize(complexPolygon);\n-\n-            simpleMultiPolygon = fromText(BenchmarkResource.MULTIPOLYGON);\n-            simpleMultiPolygonSerialized = serialize(simpleMultiPolygon);\n-            complexMultiPolygon = fromText(BenchmarkResource.readResource(\"geospatial/complex-multipolygon.txt\"));\n-            complexMultiPolygonSerialized = serialize(complexMultiPolygon);\n-\n-            simpleGeometryCollection = fromText(BenchmarkResource.GEOMETRYCOLLECTION);\n-            simpleGeometryCollectionSerialized = serialize(simpleGeometryCollection);\n-            complexGeometryCollection = fromText(\"GEOMETRYCOLLECTION (\" + Joiner.on(\", \").join(\n-                    BenchmarkResource.readResource(\"geospatial/complex-multipoint.txt\"),\n-                    BenchmarkResource.readResource(\"geospatial/complex-linestring.txt\"),\n-                    BenchmarkResource.readResource(\"geospatial/complex-multilinestring.txt\"),\n-                    BenchmarkResource.readResource(\"geospatial/complex-polygon.txt\"),\n-                    BenchmarkResource.readResource(\"geospatial/complex-multipolygon.txt\")) + \")\");\n-            complexGeometryCollectionSerialized = serialize(complexGeometryCollection);\n-        }\n-    }\n-\n-    public static class BenchmarkResource\n-    {\n-        public static final String POINT = \"POINT (-2e3 -4e33)\";\n-        public static final String MULTIPOINT = \"MULTIPOINT (-2e3 -4e33, 0 0, 1 1, 2 3)\";\n-        public static final String LINESTRING = \"LINESTRING (-2e3 -4e33, 0 0, 1 1, 2 3)\";\n-        public static final String MULTILINESTRING = \"MULTILINESTRING ((-2e3 -4e33, 0 0, 1 1, 2 3), (0 1, 2 3, 4 5), (0 1, 2 3, 4 6), (0 1, 2 3, 4 7))\";\n-        public static final String POLYGON = \"POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))\";\n-        public static final String MULTIPOLYGON = \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)), ((30 10, 40 40, 20 40, 10 20, 30 10)))\";\n-        public static final String GEOMETRYCOLLECTION = \"GEOMETRYCOLLECTION (\" +\n-                \"POINT (-2e3 -4e33), \" +\n-                \"MULTIPOINT (-2e3 -4e33, 0 0, 1 1, 2 3), \" +\n-                \"LINESTRING (-2e3 -4e33, 0 0, 1 1, 2 3), \" +\n-                \"MULTILINESTRING ((-2e3 -4e33, 0 0, 1 1, 2 3), (0 1, 2 3, 4 5), (0 1, 2 3, 4 6), (0 1, 2 3, 4 7)), \" +\n-                \"POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10)), \" +\n-                \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)), ((30 10, 40 40, 20 40, 10 20, 30 10))))\";\n-\n-        public static String readResource(String resource)\n-        {\n-            try {\n-                return Resources.toString(getResource(resource), UTF_8);\n-            }\n-            catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-    }\n-\n-    private static Geometry fromText(String text)\n-    {\n-        try {\n-            return new WKTReader().read(text);\n-        }\n-        catch (ParseException e) {\n-            throw new RuntimeException(e);\n-        }\n+  }\n+\n+  public static class BenchmarkResource {\n+    public static final String POINT = \"POINT (-2e3 -4e33)\";\n+    public static final String MULTIPOINT = \"MULTIPOINT (-2e3 -4e33, 0 0, 1 1, 2 3)\";\n+    public static final String LINESTRING = \"LINESTRING (-2e3 -4e33, 0 0, 1 1, 2 3)\";\n+    public static final String MULTILINESTRING =\n+        \"MULTILINESTRING ((-2e3 -4e33, 0 0, 1 1, 2 3), (0 1, 2 3, 4 5), (0 1, 2 3, 4 6), (0 1, 2 3, 4 7))\";\n+    public static final String POLYGON = \"POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))\";\n+    public static final String MULTIPOLYGON =\n+        \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)), ((30 10, 40 40, 20 40, 10 20, 30 10)))\";\n+    public static final String GEOMETRYCOLLECTION =\n+        \"GEOMETRYCOLLECTION (\" + \"POINT (-2e3 -4e33), \" + \"MULTIPOINT (-2e3 -4e33, 0 0, 1 1, 2 3), \"\n+            + \"LINESTRING (-2e3 -4e33, 0 0, 1 1, 2 3), \"\n+            + \"MULTILINESTRING ((-2e3 -4e33, 0 0, 1 1, 2 3), (0 1, 2 3, 4 5), (0 1, 2 3, 4 6), (0 1, 2 3, 4 7)), \"\n+            + \"POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10)), \"\n+            + \"MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)), ((30 10, 40 40, 20 40, 10 20, 30 10))))\";\n+\n+    public static String readResource(String resource) {\n+      try {\n+        return Resources.toString(getResource(resource), UTF_8);\n+      } catch (IOException e) {\n+        throw new UncheckedIOException(e);\n+      }\n     }\n+  }\n \n-    public static void main(String[] args)\n-            throws RunnerException\n-    {\n-        Options options = new OptionsBuilder()\n-                .verbosity(VerboseMode.NORMAL)\n-                .include(\".*\" + BenchmarkSerde.class.getSimpleName() + \".*\")\n-                .build();\n-        new Runner(options).run();\n+  private static Geometry fromText(String text) {\n+    try {\n+      return new WKTReader().read(text);\n+    } catch (ParseException e) {\n+      throw new RuntimeException(e);\n     }\n+  }\n+\n+  public static void main(String[] args)\n+      throws RunnerException {\n+    Options options =\n+        new OptionsBuilder().verbosity(VerboseMode.NORMAL).include(\".*\" + BenchmarkSerde.class.getSimpleName() + \".*\")\n+            .build();\n+    new Runner(options).run();\n+  }\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r449830877", "bodyText": "Unsure if LOGGER should be used here?", "author": "mayankshriv", "createdAt": "2020-07-05T03:50:23Z", "path": "pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java", "diffHunk": "@@ -87,11 +90,14 @@ public void onMessage(String message) {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n+                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));", "originalCommit": "0d99aa8a2e51e1f05da3290aaeff84e1f17d2f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAyOTg3Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451029872", "bodyText": "removed. it was for debugging purpose.", "author": "yupeng9", "createdAt": "2020-07-07T17:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgzMDg3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "chunk": "diff --git a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\nindex 6244bde6dc..86a89db868 100644\n--- a/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n+++ b/pinot-tools/src/main/java/org/apache/pinot/tools/streams/MeetupRsvpStream.java\n\n@@ -90,7 +88,6 @@ public class MeetupRsvpStream {\n                   }\n \n                   JsonNode group = messageJSON.get(\"group\");\n-                  System.out.println(String.format(\"reading group %s\", group.get(\"group_id\")));\n                   if (group != null) {\n                     extracted.set(\"group_city\", group.get(\"group_city\"));\n                     extracted.set(\"group_country\", group.get(\"group_country\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0Mjg1MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451242850", "bodyText": "Please follow the Pinot coding convention of using underscore as the prefix for member variables. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-08T02:14:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;", "originalCommit": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 95edefef72..45f2d4a296 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -18,32 +18,29 @@\n  */\n package org.apache.pinot.core.geospatial;\n \n-/**\n- * The geometry type.\n- */\n public enum GeometryType {\n \n-  POINT(false, \"ST_Point\"),\n-  MULTI_POINT(true, \"ST_MultiPoint\"),\n-  LINE_STRING(false, \"ST_LineString\"),\n-  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n-  POLYGON(false, \"ST_Polygon\"),\n-  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+    POINT(false, \"ST_Point\"),\n+    MULTI_POINT(true, \"ST_MultiPoint\"),\n+    LINE_STRING(false, \"ST_LineString\"),\n+    MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+    POLYGON(false, \"ST_Polygon\"),\n+    MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+    GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n \n-  private final boolean multitype;\n-  private final String name;\n+    private final boolean multitype;\n+    private final String name;\n \n-  GeometryType(boolean multitype, String name) {\n-    this.multitype = multitype;\n-    this.name = name;\n-  }\n+    GeometryType(boolean multitype, String name) {\n+        this.multitype = multitype;\n+        this.name = name;\n+    }\n \n-  public boolean isMultitype() {\n-    return multitype;\n-  }\n+    public boolean isMultitype() {\n+        return multitype;\n+    }\n \n-  public String getName() {\n-    return name;\n-  }\n+    public String getName() {\n+        return name;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r451243023", "bodyText": "As an example of Pinot coding convention\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.multitype = multitype;\n          \n          \n            \n                _multitype = multitype;", "author": "Jackie-Jiang", "createdAt": "2020-07-08T02:15:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean multitype;\n+  private final String name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    this.multitype = multitype;", "originalCommit": "6eb63ccd911373dbfd817f6a680c553ee2a6a44d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4NjgxNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452386815", "bodyText": "Thanks for taking a pass, updated the style", "author": "yupeng9", "createdAt": "2020-07-09T17:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQxOTUxNg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452419516", "bodyText": "@Jackie-Jiang any reason we set checkstyle severity to warning but not error. I saw we have such a rule for member variable, but the maven checkstyle does not fail the build", "author": "yupeng9", "createdAt": "2020-07-09T18:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODQzOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r452448439", "bodyText": "Good suggestion. We can switch it to error once we fixed all the existing code with wrong code styles. Opened issue #5675 to track this", "author": "Jackie-Jiang", "createdAt": "2020-07-09T19:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MzAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 95edefef72..45f2d4a296 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -18,32 +18,29 @@\n  */\n package org.apache.pinot.core.geospatial;\n \n-/**\n- * The geometry type.\n- */\n public enum GeometryType {\n \n-  POINT(false, \"ST_Point\"),\n-  MULTI_POINT(true, \"ST_MultiPoint\"),\n-  LINE_STRING(false, \"ST_LineString\"),\n-  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n-  POLYGON(false, \"ST_Polygon\"),\n-  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+    POINT(false, \"ST_Point\"),\n+    MULTI_POINT(true, \"ST_MultiPoint\"),\n+    LINE_STRING(false, \"ST_LineString\"),\n+    MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+    POLYGON(false, \"ST_Polygon\"),\n+    MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+    GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n \n-  private final boolean multitype;\n-  private final String name;\n+    private final boolean multitype;\n+    private final String name;\n \n-  GeometryType(boolean multitype, String name) {\n-    this.multitype = multitype;\n-    this.name = name;\n-  }\n+    GeometryType(boolean multitype, String name) {\n+        this.multitype = multitype;\n+        this.name = name;\n+    }\n \n-  public boolean isMultitype() {\n-    return multitype;\n-  }\n+    public boolean isMultitype() {\n+        return multitype;\n+    }\n \n-  public String getName() {\n-    return name;\n-  }\n+    public String getName() {\n+        return name;\n+    }\n }\n"}}, {"oid": "5329f2fb56cf3b7c43c11371f91f39d98be5df39", "url": "https://github.com/apache/pinot/commit/5329f2fb56cf3b7c43c11371f91f39d98be5df39", "message": "add geo support\n\n - add geo-spatial data model\n - add serde\n - add benchmark\n - add geospatial functions", "committedDate": "2020-07-16T03:56:34Z", "type": "commit"}, {"oid": "e778f612067ad12f6b007339b2b413003b4efa54", "url": "https://github.com/apache/pinot/commit/e778f612067ad12f6b007339b2b413003b4efa54", "message": "cleanup", "committedDate": "2020-07-16T03:56:34Z", "type": "commit"}, {"oid": "b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "url": "https://github.com/apache/pinot/commit/b4cf2ad048c6127ce5f69350c5cd8f2577455a64", "message": "revert id/code change", "committedDate": "2020-07-16T03:56:36Z", "type": "commit"}, {"oid": "2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "url": "https://github.com/apache/pinot/commit/2ac9fe3a6ecc078d9cc69fa5a2b7f386a3c364ea", "message": "more cleanup", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "d548d2488bb52bd2915c89dfa7782fd030e381c5", "url": "https://github.com/apache/pinot/commit/d548d2488bb52bd2915c89dfa7782fd030e381c5", "message": "address comments", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "0ebb9c5078119d7d8ad7918d9221ab775995b00a", "url": "https://github.com/apache/pinot/commit/0ebb9c5078119d7d8ad7918d9221ab775995b00a", "message": "more styling", "committedDate": "2020-07-16T03:57:20Z", "type": "commit"}, {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "message": "Change the relationship function not applicable to geographical functions", "committedDate": "2020-07-17T01:57:30Z", "type": "commit"}, {"oid": "b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "url": "https://github.com/apache/pinot/commit/b14d7c53eb23b9b94a9ec6fe902edcf87d053201", "message": "Change the relationship function not applicable to geographical functions", "committedDate": "2020-07-17T01:57:30Z", "type": "forcePushed"}, {"oid": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "url": "https://github.com/apache/pinot/commit/bb51f43a4419008e9a727d7c8355330d232ec9b9", "message": "fix test failure", "committedDate": "2020-07-17T02:36:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM4OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811389", "bodyText": "(nit) Add an empty line in front, and capitalize the comment", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:38:03Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\nindex 5f80eaaf24..583e67882e 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n\n@@ -58,7 +58,8 @@ public enum TransformFunctionType {\n \n   // Special type for annotation based scalar functions\n   SCALAR(\"scalar\"),\n-  // geo constructors\n+\n+  // Geo constructors\n   ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n   ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n   ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTM5NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811395", "bodyText": "(nit) Empty line after", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:38:17Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n+\n+  // geo outputs\n+  ST_AS_BINARY(\"ST_AsBinary\"),\n+  ST_AS_TEXT(\"ST_AsText\"),\n+\n+  // geo relationship\n+  ST_CONTAINS(\"ST_Contains\"),\n+  ST_EQUALS(\"ST_Equals\");", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\nindex 5f80eaaf24..583e67882e 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n\n@@ -58,7 +58,8 @@ public enum TransformFunctionType {\n \n   // Special type for annotation based scalar functions\n   SCALAR(\"scalar\"),\n-  // geo constructors\n+\n+  // Geo constructors\n   ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n   ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n   ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456811665", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),\n          \n          \n            \n              ST_GEOMETRY_TYPE(\"ST_GeometryType\"),", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:41:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java", "diffHunk": "@@ -57,8 +57,27 @@\n   MAPVALUE(\"mapValue\"),\n \n   // Special type for annotation based scalar functions\n-  SCALAR(\"scalar\");\n+  SCALAR(\"scalar\"),\n+  // geo constructors\n+  ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n+  ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n+  ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n+  ST_GEOM_FROM_WKB(\"ST_GeomFromWKB\"),\n+  ST_POINT(\"ST_Point\"),\n+  ST_POLYGON(\"ST_Polygon\"),\n \n+  // geo measurements\n+  ST_AREA(\"ST_Area\"),\n+  ST_DISTANCE(\"ST_Distance\"),\n+  ST_GEOMETRY_TYPE(\"ST_GEOMETRY_TYPE\"),", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzQ3Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813477", "bodyText": "Is there a standard function to return the SRID of the geometry? (Identify whether it is geometry or geography)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NzI4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457857286", "bodyText": "Yes, it returns the type of the geometry as a string. EG: 'ST_Linestring', 'ST_Polygon','ST_MultiPolygon' etc", "author": "yupeng9", "createdAt": "2020-07-21T06:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\nindex 5f80eaaf24..583e67882e 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/TransformFunctionType.java\n\n@@ -58,7 +58,8 @@ public enum TransformFunctionType {\n \n   // Special type for annotation based scalar functions\n   SCALAR(\"scalar\"),\n-  // geo constructors\n+\n+  // Geo constructors\n   ST_GEOG_FROM_TEXT(\"ST_GeogFromText\"),\n   ST_GEOM_FROM_TEXT(\"ST_GeomFromText\"),\n   ST_GEOG_FROM_WKB(\"ST_GeogFromWKB\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjEzNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456812135", "bodyText": "Thanks for updating the javadoc. Add BYTES here as well", "author": "Jackie-Jiang", "createdAt": "2020-07-18T17:47:23Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/Schema.java", "diffHunk": "@@ -400,7 +400,7 @@ public String toSingleLineJsonString() {\n    * Validates a pinot schema.\n    * <p>The following validations are performed:\n    * <ul>\n-   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING</li>\n+   *   <li>For dimension, time, date time fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE, STRING, BYTES</li>\n    *   <li>For non-derived metric fields, support {@link DataType}: INT, LONG, FLOAT, DOUBLE</li>", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzM2OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813369", "bodyText": "Avoid static import.\nPlease re-order the imports using PinotStyle within config/codestyle-intellij.xml or config/codestyle-eclipse.xml", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:02:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex 44eafc43c7..e79313886c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -18,12 +18,15 @@\n  */\n package org.apache.pinot.core.geospatial.serde;\n \n-import com.esotericsoftware.kryo.Kryo;\n-import com.esotericsoftware.kryo.Serializer;\n-import com.esotericsoftware.kryo.io.Input;\n-import com.esotericsoftware.kryo.io.Output;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Envelope;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.geom.LineString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcwNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813707", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final boolean _multitype;\n          \n          \n            \n              private final boolean _multiType;", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:06:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 08babb413d..124f050b59 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -23,19 +23,21 @@ package org.apache.pinot.core.geospatial;\n  */\n public enum GeometryType {\n \n-  POINT(false, \"ST_Point\"),\n-  MULTI_POINT(true, \"ST_MultiPoint\"),\n-  LINE_STRING(false, \"ST_LineString\"),\n-  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n-  POLYGON(false, \"ST_Polygon\"),\n-  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n \n   private final boolean _multitype;\n+  private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, String name) {\n+  GeometryType(boolean multitype, int id, String name) {\n     _multitype = multitype;\n+    _id = id;\n     _name = name;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456813725", "bodyText": "Seems never used. How are you planning to use the multi-type info?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T18:06:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n+  POLYGON(false, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, String name) {\n+    _multitype = multitype;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTYzMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457861633", "bodyText": "not in this PR. It's useful in function like https://postgis.net/docs/ST_GeometryN.html", "author": "yupeng9", "createdAt": "2020-07-21T06:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzcyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 08babb413d..124f050b59 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -23,19 +23,21 @@ package org.apache.pinot.core.geospatial;\n  */\n public enum GeometryType {\n \n-  POINT(false, \"ST_Point\"),\n-  MULTI_POINT(true, \"ST_MultiPoint\"),\n-  LINE_STRING(false, \"ST_LineString\"),\n-  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n-  POLYGON(false, \"ST_Polygon\"),\n-  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n \n   private final boolean _multitype;\n+  private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, String name) {\n+  GeometryType(boolean multitype, int id, String name) {\n     _multitype = multitype;\n+    _id = id;\n     _name = name;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456819937", "bodyText": "Checked the Kryo implementation, it is only providing a buffer to the stream (very similar to BufferedInputStream and BufferedOutputStream). So I'm pretty sure reading/writing with pre-sized ByteBuffer will be much faster and the garbage generated will be much less. Also, with ByteBuffer we can store values with LITTLE_ENDIEN (linux native) to further improve the performance.\nI'd recommend revisiting this part because once the data is persistent, it will be hard to change", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:24:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NDk5Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458374996", "bodyText": "Thanks. This is a very good suggestion. It's true that using pre-sized ByteBuffer would be more performant than the stream API. I run a benchmark on three implementations: stream, ByteBuffer with Big_Endian, ByteBuffer with Little_Endian: https://docs.google.com/spreadsheets/d/1ANkC7I4N-TxtzFI-fDbchJ9uGmyQtOG_ViYY0mSstNM/edit#gid=0.\nThe benchmark confirms the performance gain. Also, the result shows BIG_ENDIAN is more performant, as it's Java's default order. I will go with the default order.", "author": "yupeng9", "createdAt": "2020-07-21T20:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxOTkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex 44eafc43c7..e79313886c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -18,12 +18,15 @@\n  */\n package org.apache.pinot.core.geospatial.serde;\n \n-import com.esotericsoftware.kryo.Kryo;\n-import com.esotericsoftware.kryo.Serializer;\n-import com.esotericsoftware.kryo.io.Input;\n-import com.esotericsoftware.kryo.io.Output;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Envelope;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.geom.LineString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820059", "bodyText": "Can we use GeometryType instead of introducing this extra type? I don't think ENVELOPE is used", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:25:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3OTgzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458379837", "bodyText": "removed.", "author": "yupeng9", "createdAt": "2020-07-21T20:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\nindex b96610ac20..6b5659da06 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n\n@@ -31,8 +31,7 @@ public enum GeometrySerializationType {\n   MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n   POLYGON(4, GeometryType.POLYGON),\n   MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n-  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n-  ENVELOPE(7, GeometryType.POLYGON);\n+  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION);\n \n   private final int _id;\n   private final GeometryType _geometryType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMDEyMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456820122", "bodyText": "You can keep a static array with id as the index to prevent the branching of switch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T19:26:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {\n+  POINT(0, GeometryType.POINT),\n+  MULTI_POINT(1, GeometryType.MULTI_POINT),\n+  LINE_STRING(2, GeometryType.LINE_STRING),\n+  MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n+  POLYGON(4, GeometryType.POLYGON),\n+  MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n+  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n+  ENVELOPE(7, GeometryType.POLYGON);\n+\n+  private final int _id;\n+  private final GeometryType _geometryType;\n+\n+  GeometrySerializationType(int id, GeometryType geometryType) {\n+    _id = id;\n+    _geometryType = geometryType;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * @return the type in the geometry model\n+   */\n+  public GeometryType getGeometryType() {\n+    return _geometryType;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometrySerializationType fromID(int id) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\nindex b96610ac20..6b5659da06 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n\n@@ -31,8 +31,7 @@ public enum GeometrySerializationType {\n   MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n   POLYGON(4, GeometryType.POLYGON),\n   MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n-  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION),\n-  ENVELOPE(7, GeometryType.POLYGON);\n+  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION);\n \n   private final int _id;\n   private final GeometryType _geometryType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456822948", "bodyText": "Based on https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/Geometry.html, there is another type LINEAR_RING. Should we include that?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:01:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, \"ST_Point\"),\n+  MULTI_POINT(true, \"ST_MultiPoint\"),\n+  LINE_STRING(false, \"ST_LineString\"),", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MDcxNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r457860717", "bodyText": "LINEAR_RING is a subtype of LINEAR_STRING", "author": "yupeng9", "createdAt": "2020-07-21T06:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMjk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 08babb413d..124f050b59 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -23,19 +23,21 @@ package org.apache.pinot.core.geospatial;\n  */\n public enum GeometryType {\n \n-  POINT(false, \"ST_Point\"),\n-  MULTI_POINT(true, \"ST_MultiPoint\"),\n-  LINE_STRING(false, \"ST_LineString\"),\n-  MULTI_LINE_STRING(true, \"ST_MultiLineString\"),\n-  POLYGON(false, \"ST_Polygon\"),\n-  MULTI_POLYGON(true, \"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, \"ST_GeomCollection\");\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n \n   private final boolean _multitype;\n+  private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, String name) {\n+  GeometryType(boolean multitype, int id, String name) {\n     _multitype = multitype;\n+    _id = id;\n     _name = name;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823102", "bodyText": "Seems the code is borrowed from Presto? (https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java)\nCan you please include that in the javadoc?\nAlso, do we need to keep the same serialization format as presto? Using LITTLE_ENDIEN (linux native order) can improve the performance of ser/de", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:04:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM2MjU4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458362580", "bodyText": "They are not exactly same, in particular, the differences are:\n\nPresto uses schema to indicate geometry vs geography info, while we encode this in the type byte.\nPresto serializes additional information such as envelope to be compatible with ESRI serialization, but the serde here does not, which is simpler and faster\n\nAdded this to the comments", "author": "yupeng9", "createdAt": "2020-07-21T20:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzEwMg=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex 44eafc43c7..e79313886c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -18,12 +18,15 @@\n  */\n package org.apache.pinot.core.geospatial.serde;\n \n-import com.esotericsoftware.kryo.Kryo;\n-import com.esotericsoftware.kryo.Serializer;\n-import com.esotericsoftware.kryo.io.Input;\n-import com.esotericsoftware.kryo.io.Output;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Envelope;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.geom.LineString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzI3NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823274", "bodyText": "Javadoc describing the format of the serialized bytes will be preferred", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:06:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.lang.Double.NaN;\n+import static java.lang.Double.isNaN;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_FACTORY;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_GET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SET_MASK;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOGRAPHY_SRID;\n+import static org.apache.pinot.core.geospatial.GeometryUtils.GEOMETRY_FACTORY;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ */\n+public class GeometrySerde extends Serializer {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+\n+  @Override\n+  public void write(Kryo kryo, Output output, Object object) {\n+    if (!(object instanceof Geometry)) {\n+      throw new UnsupportedOperationException(\"Cannot serialize object of type \" + object.getClass().getName());\n+    }\n+    writeGeometry(output, (Geometry) object);\n+  }\n+\n+  @Override\n+  public Object read(Kryo kryo, Input input, Class aClass) {\n+    byte typeByte = input.readByte();\n+    GeometrySerializationType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+\n+    return readGeometry(input, type, factory);\n+  }\n+\n+  private Geometry readGeometry(Input input, GeometrySerializationType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(input, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(input, factory);\n+      case LINE_STRING:\n+        return readPolyline(input, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(input, true, factory);\n+      case POLYGON:\n+        return readPolygon(input, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(input, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(input, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(Input input, GeometryFactory factory) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\nindex 44eafc43c7..e79313886c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n\n@@ -18,12 +18,15 @@\n  */\n package org.apache.pinot.core.geospatial.serde;\n \n-import com.esotericsoftware.kryo.Kryo;\n-import com.esotericsoftware.kryo.Serializer;\n-import com.esotericsoftware.kryo.io.Input;\n-import com.esotericsoftware.kryo.io.Output;\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Envelope;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.geom.LineString;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823523", "bodyText": "Also check the data type, should be STRING", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:09:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3Nzc4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458477786", "bodyText": "added", "author": "yupeng9", "createdAt": "2020-07-22T01:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 8160cffda6..9ab63cc50c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,8 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzYzMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823633", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:10:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from String %s\", argumentValues[i])));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 8160cffda6..9ab63cc50c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,8 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY1NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823654", "bodyText": "(nit) re-order imports. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:11:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 8160cffda6..9ab63cc50c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,8 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzY4Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823686", "bodyText": "Also check data type, should be BYTES", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:11:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\nindex bbd529e3ff..3a82f3dafe 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n\n@@ -26,6 +26,8 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.BytesUtils;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.io.ParseException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from bytes: %s\", BytesUtils.toHexString(argumentValues[i])));", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:12:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        throw new RuntimeException(String.format(\"Failed to parse geometry from bytes %s\", argumentValues[i]));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MTA5OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458481098", "bodyText": "good catch", "author": "yupeng9", "createdAt": "2020-07-22T01:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\nindex bbd529e3ff..3a82f3dafe 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n\n@@ -26,6 +26,8 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.BytesUtils;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.io.ParseException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823834", "bodyText": "Move this line out of the try-catch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:13:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3ODE4NA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458478184", "bodyText": "then i have to have another line to initialize geometry", "author": "yupeng9", "createdAt": "2020-07-22T01:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\nindex 8160cffda6..9ab63cc50c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java\n\n@@ -19,6 +19,8 @@\n package org.apache.pinot.core.geospatial.transform.function;\n \n import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzgzOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823838", "bodyText": "Move this line out of the try-catch", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:13:47Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKBReader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from well-known binary (WKB) format.\n+ */\n+abstract class ConstructFromWKBFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  private byte[][] _results;\n+  private WKBReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _reader = new WKBReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    byte[][] argumentValues = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\nindex bbd529e3ff..3a82f3dafe 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromWKBFunction.java\n\n@@ -26,6 +26,8 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.utils.BytesUtils;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n import org.locationtech.jts.io.ParseException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyMzg3OQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456823879", "bodyText": "Also check data type, should be BYTES. Same for other classes", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:14:37Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824301", "bodyText": "(nit) Cache numDocs, same for other classes\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Geometry geometry;\n          \n          \n            \n                for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n          \n          \n            \n                  geometry = GeometrySerializer.deserialize(values[i]);\n          \n          \n            \n                int numDocs = projectionBlock.getNumDocs();\n          \n          \n            \n                for (int i = 0; i < numDocs; i++) {\n          \n          \n            \n                  Geometry geometry = GeometrySerializer.deserialize(values[i]);", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:19:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MjQ3MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458482471", "bodyText": "I don't think it's needed. JIT will take care of it", "author": "yupeng9", "createdAt": "2020-07-22T01:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMzc0MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459023740", "bodyText": "Not necessary. I did some benchmark on this and there is performance difference", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDQ4Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824487", "bodyText": "I don't quite follow the comment. Where is isExteriorRing() used?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:22:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNDY3Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456824676", "bodyText": "Prefix with _ for member variables", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:24:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825581", "bodyText": "I believe start point is always the same as end point? Or the more than 3 points check does not stand?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:35:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4NTc5Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458485792", "bodyText": "true. can be optimized.", "author": "yupeng9", "createdAt": "2020-07-22T01:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNTkwMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456825903", "bodyText": "Cool, thanks for adding the reference of the algorithm.\nDidn't review the algorithm implementation carefully, please make sure it is covered by test", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:39:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826092", "bodyText": "Do you mean should be close to 2Pi or -2Pi?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:42:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.lang.Math.PI;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that calculates the area of the given geo-spatial object. For geometry type, it returns the 2D Euclidean\n+ * area of a geometry. For geography, returns the area of a polygon or multi-polygon in square meters using a spherical\n+ * model for Earth.\n+ */\n+public class StAreaFunction extends BaseTransformFunction {\n+  private TransformFunction _transformFunction;\n+  public static final String FUNCTION_NAME = \"ST_Area\";\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = GeometryUtils.isGeography(geometry) ? calculateGeographyArea(geometry) : geometry.getArea();\n+    }\n+    return _results;\n+  }\n+\n+  private double calculateGeographyArea(Geometry geometry) {\n+    Polygon polygon = (Polygon) geometry;\n+\n+    // See https://www.movable-type.co.uk/scripts/latlong.html\n+    // and http://osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html\n+    // and https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\n+    // for the underlying Maths\n+\n+    double sphericalExcess = Math.abs(computeSphericalExcess(polygon.getExteriorRing()));\n+\n+    for (int i = 0; i < polygon.getNumInteriorRing(); i++) {\n+      sphericalExcess -= Math.abs(computeSphericalExcess(polygon.getInteriorRingN(i)));\n+    }\n+\n+    // Math.abs is required here because for Polygons with a 2D area of 0\n+    // isExteriorRing returns false for the exterior ring\n+    return Math.abs(sphericalExcess * GeometryUtils.EARTH_RADIUS_M * GeometryUtils.EARTH_RADIUS_M);\n+  }\n+\n+  private static double computeSphericalExcess(LineString lineString) {\n+    if (lineString.getNumPoints() < 3) {\n+      // A path with less than 3 distinct points is not valid for calculating an area\n+      throw new RuntimeException(\"Polygon is not valid: a loop contains less then 3 vertices.\");\n+    }\n+\n+    // Initialize the calculator with the last point\n+    SphericalExcessCalculator calculator = new SphericalExcessCalculator(lineString.getEndPoint());\n+\n+    // Our calculations rely on not processing the same point twice\n+    int start = lineString.getStartPoint().equals(lineString.getEndPoint()) ? 1 : 0;\n+\n+    for (int i = start; i < lineString.getNumPoints(); i++) {\n+      calculator.add(lineString.getPointN(i));\n+    }\n+    return calculator.computeSphericalExcess();\n+  }\n+\n+  private static class SphericalExcessCalculator {\n+    private static final double TWO_PI = 2 * Math.PI;\n+    private static final double THREE_PI = 3 * Math.PI;\n+\n+    private double sphericalExcess;\n+    private double courseDelta;\n+\n+    private boolean firstPoint;\n+    private double firstInitialBearing;\n+    private double previousFinalBearing;\n+\n+    private double previousPhi;\n+    private double previousCos;\n+    private double previousSin;\n+    private double previousTan;\n+    private double previousLongitude;\n+\n+    private boolean done;\n+\n+    public SphericalExcessCalculator(Point endPoint) {\n+      previousPhi = toRadians(endPoint.getY());\n+      previousSin = Math.sin(previousPhi);\n+      previousCos = Math.cos(previousPhi);\n+      previousTan = Math.tan(previousPhi / 2);\n+      previousLongitude = toRadians(endPoint.getX());\n+      firstPoint = true;\n+    }\n+\n+    private void add(Point point)\n+        throws IllegalStateException {\n+      checkState(!done, \"Computation of spherical excess is complete\");\n+\n+      double phi = toRadians(point.getY());\n+      double tan = Math.tan(phi / 2);\n+      double longitude = toRadians(point.getX());\n+\n+      // We need to check for that specifically\n+      // Otherwise calculating the bearing is not deterministic\n+      if (longitude == previousLongitude && phi == previousPhi) {\n+        throw new RuntimeException(\"Polygon is not valid: it has two identical consecutive vertices\");\n+      }\n+\n+      double deltaLongitude = longitude - previousLongitude;\n+      sphericalExcess += 2 * Math.atan2(Math.tan(deltaLongitude / 2) * (previousTan + tan), 1 + previousTan * tan);\n+\n+      double cos = Math.cos(phi);\n+      double sin = Math.sin(phi);\n+      double sinOfDeltaLongitude = Math.sin(deltaLongitude);\n+      double cosOfDeltaLongitude = Math.cos(deltaLongitude);\n+\n+      // Initial bearing from previous to current\n+      double y = sinOfDeltaLongitude * cos;\n+      double x = previousCos * sin - previousSin * cos * cosOfDeltaLongitude;\n+      double initialBearing = (Math.atan2(y, x) + TWO_PI) % TWO_PI;\n+\n+      // Final bearing from previous to current = opposite of bearing from current to previous\n+      double finalY = -sinOfDeltaLongitude * previousCos;\n+      double finalX = previousSin * cos - previousCos * sin * cosOfDeltaLongitude;\n+      double finalBearing = (Math.atan2(finalY, finalX) + PI) % TWO_PI;\n+\n+      // When processing our first point we don't yet have a previousFinalBearing\n+      if (firstPoint) {\n+        // So keep our initial bearing around, and we'll use it at the end\n+        // with the last final bearing\n+        firstInitialBearing = initialBearing;\n+        firstPoint = false;\n+      } else {\n+        courseDelta += (initialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+      }\n+\n+      courseDelta += (finalBearing - initialBearing + THREE_PI) % TWO_PI - PI;\n+\n+      previousFinalBearing = finalBearing;\n+      previousCos = cos;\n+      previousSin = sin;\n+      previousPhi = phi;\n+      previousTan = tan;\n+      previousLongitude = longitude;\n+    }\n+\n+    public double computeSphericalExcess() {\n+      if (!done) {\n+        // Now that we have our last final bearing, we can calculate the remaining course delta\n+        courseDelta += (firstInitialBearing - previousFinalBearing + THREE_PI) % TWO_PI - PI;\n+\n+        // The courseDelta should be 2Pi or - 2Pi, unless a pole is enclosed (and then it should be ~ 0)", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NDMwMA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458494300", "bodyText": "it shall be 2PI or 2PI per https://www.element84.com/blog/determining-if-a-spherical-polygon-contains-a-pole\nSince it makes 360 degree complete turn", "author": "yupeng9", "createdAt": "2020-07-22T02:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjA5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\nindex f965fa2467..f114ff802a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAreaFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.LineString;\n import org.locationtech.jts.geom.Point;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826809", "bodyText": "Maybe better to use a separate class for all the scalar functions?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:51:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Returns the text representation of the geometry object.\n+ */\n+public class StAsTextFunction extends BaseTransformFunction {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StAsTextFunction.class);\n+  private TransformFunction _transformFunction;\n+  private static WKTWriter _writer;\n+  public static final String FUNCTION_NAME = \"ST_AsText\";\n+  private String[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Argument must be single-valued for transform function: %s\", getName());\n+    _transformFunction = transformFunction;\n+    _writer = new WKTWriter();\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return STRING_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public String[] transformToStringValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new String[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] values = _transformFunction.transformToBytesValuesSV(projectionBlock);\n+    Geometry geometry;\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      geometry = GeometrySerializer.deserialize(values[i]);\n+      _results[i] = _writer.write(geometry);\n+    }\n+    return _results;\n+  }\n+\n+  @ScalarFunction\n+  public static String stAsText(byte[] bytes) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5ODMyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458498323", "bodyText": "sure. moved", "author": "yupeng9", "createdAt": "2020-07-22T02:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\nindex d9197e0345..9ee0a44b72 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StAsTextFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.io.WKTWriter;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456826997", "bodyText": "null cannot be added to double[]\nCheck empty point before calculating the distance (for both geometry and geography)", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:54:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5OTAzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458499037", "bodyText": "hmm, without null handling, what's the default value we return for bytes?", "author": "yupeng9", "createdAt": "2020-07-22T02:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODI5Nw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028297", "bodyText": "I think you can return Double.NaN here to indicate empty geometry", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNjk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzA2Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new RuntimeException(\n          \n          \n            \n                        String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n          \n          \n            \n                    throw new RuntimeException(\"The first and second arguments shall either all be geometry or all geography\");", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:55:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzI3MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827270", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n          \n          \n            \n                  throw new RuntimeException(\"Latitude must be between -90 and 90\");\n          \n          \n            \n                }\n          \n          \n            \n                Preconditions.checkArgument(latitude >= MIN_LATITUDE && latitude <= MAX_LATITUDE, \"Latitude must be between -90 and 90\");", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:57:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzQyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827423", "bodyText": "Return primitive double, or it will throw NPE", "author": "Jackie-Jiang", "createdAt": "2020-07-18T20:59:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827621", "bodyText": "Does it work on line across dateline?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:01:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));\n+    validateGeographyType(\"ST_Distance\", rightGeometry, EnumSet.of(GeometryType.POINT));\n+    Point leftPoint = (Point) leftGeometry;\n+    Point rightPoint = (Point) rightGeometry;\n+\n+    // greatCircleDistance returns distance in KM.\n+    return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;\n+  }\n+\n+  /**\n+   * Calculate the distance between two points on Earth.\n+   * <p>\n+   * This assumes a spherical Earth, and uses the Vincenty formula. (https://en.wikipedia\n+   * .org/wiki/Great-circle_distance)\n+   */\n+  public static double greatCircleDistance(double latitude1, double longitude1, double latitude2, double longitude2) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzc3Mw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827773", "bodyText": "Directly return value in meter instead of km?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTAwNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501007", "bodyText": "yes, per https://en.wikipedia.org/wiki/Great-circle_distance", "author": "yupeng9", "createdAt": "2020-07-22T02:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827738", "bodyText": "Can be simplified to geometry instanceof Point", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:03:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {\n+    if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < MIN_LATITUDE || latitude > MAX_LATITUDE) {\n+      throw new RuntimeException(\"Latitude must be between -90 and 90\");\n+    }\n+  }\n+\n+  public static void checkLongitude(double longitude) {\n+    if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < MIN_LONGITUDE\n+        || longitude > MAX_LONGITUDE) {\n+      throw new RuntimeException(\"Longitude must be between -180 and 180\");\n+    }\n+  }\n+\n+  public static Double sphericalDistance(Geometry leftGeometry, Geometry rightGeometry) {\n+    if (leftGeometry.isEmpty() || rightGeometry.isEmpty()) {\n+      return null;\n+    }\n+\n+    validateGeographyType(\"ST_Distance\", leftGeometry, EnumSet.of(GeometryType.POINT));", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMDU4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458500580", "bodyText": "try to reuse the same error msg template of several functions", "author": "yupeng9", "createdAt": "2020-07-22T02:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyNjE4MA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459026180", "bodyText": "There will be quite big performance difference, especially for per-value check", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzczOA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzgxOQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827819", "bodyText": "Make all helper methods private", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:04:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.atan2;\n+import static java.lang.Math.cos;\n+import static java.lang.Math.sin;\n+import static java.lang.Math.sqrt;\n+import static java.lang.Math.toRadians;\n+\n+\n+/**\n+ * Function that measures the distance between the two geo-spatial objects. For geometry type, returns the 2-dimensional\n+ * cartesian minimum distance (based on spatial ref) between two geometries in projected units. For geography, returns\n+ * the great-circle distance in meters between two SphericalGeography points. Note that g1, g2 shall have the same type.\n+ */\n+public class StDistanceFunction extends BaseTransformFunction {\n+  private static final float MIN_LATITUDE = -90;\n+  private static final float MAX_LATITUDE = 90;\n+  private static final float MIN_LONGITUDE = -180;\n+  private static final float MAX_LONGITUDE = 180;\n+  public static final String FUNCTION_NAME = \"ST_Distance\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private double[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return DOUBLE_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public double[] transformToDoubleValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new double[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) != GeometryUtils.isGeography(secondGeometry)) {\n+        throw new RuntimeException(\n+            String.format(\"The first and second arguments shall either all be geometry\" + \" or all geography\"));\n+      }\n+      if (GeometryUtils.isGeography(firstGeometry)) {\n+        _results[i] = sphericalDistance(firstGeometry, secondGeometry);\n+      } else {\n+        _results[i] =\n+            firstGeometry.isEmpty() || secondGeometry.isEmpty() ? null : firstGeometry.distance(secondGeometry);\n+      }\n+    }\n+    return _results;\n+  }\n+\n+  public static void checkLatitude(double latitude) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\nindex 14e9b9ac96..5102a189a4 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StDistanceFunction.java\n\n@@ -28,6 +28,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.Point;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456827934", "bodyText": "Equals should work on geography as well?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:05:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Function that returns true if the given geometries represent the same geometry.\n+ */\n+public class StEqualsFunction extends BaseTransformFunction {\n+  public static final String FUNCTION_NAME = \"ST_Equals\";\n+  private TransformFunction _firstArgument;\n+  private TransformFunction _secondArgument;\n+  private int[] _results;\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 2, \"2 arguments are required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"First argument must be single-valued for transform function: %s\", getName());\n+    _firstArgument = transformFunction;\n+    transformFunction = arguments.get(1);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"Second argument must be single-valued for transform function: %s\", getName());\n+    _secondArgument = transformFunction;\n+  }\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return INT_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public int[] transformToIntValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new int[DocIdSetPlanNode.MAX_DOC_PER_CALL];\n+    }\n+    byte[][] firstValues = _firstArgument.transformToBytesValuesSV(projectionBlock);\n+    byte[][] secondValues = _secondArgument.transformToBytesValuesSV(projectionBlock);\n+    for (int i = 0; i < projectionBlock.getNumDocs(); i++) {\n+      Geometry firstGeometry = GeometrySerializer.deserialize(firstValues[i]);\n+      Geometry secondGeometry = GeometrySerializer.deserialize(secondValues[i]);\n+      if (GeometryUtils.isGeography(firstGeometry) || GeometryUtils.isGeography(secondGeometry)) {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMTc2OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458501768", "bodyText": "yes, it should", "author": "yupeng9", "createdAt": "2020-07-22T02:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyNzkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java\nindex 62cffad361..9e0c63837b 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StEqualsFunction.java\n\n@@ -27,6 +27,7 @@ import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n import org.apache.pinot.core.operator.transform.function.TransformFunction;\n import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n import org.locationtech.jts.geom.Geometry;\n \n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828278", "bodyText": "This doesn't seem right that St_Polygon is the same as ST_GeomFromText", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:10:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.GeometryFactory;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUwMjk3Mg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458502972", "bodyText": "yup, added the constraint of checking polygon type", "author": "yupeng9", "createdAt": "2020-07-22T02:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\nindex e1e7feeab4..7b7bc091e1 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\n\n@@ -18,8 +18,17 @@\n  */\n package org.apache.pinot.core.geospatial.transform.function;\n \n+import com.google.common.base.Preconditions;\n+import java.util.EnumSet;\n+import org.apache.pinot.common.Utils;\n import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.io.ParseException;\n \n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgyODMyOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r456828328", "bodyText": "Remove?", "author": "Jackie-Jiang", "createdAt": "2020-07-18T21:11:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java", "diffHunk": "@@ -41,7 +41,10 @@\n       new TransformResultMetadata(DataType.STRING, true, false);\n   protected static final TransformResultMetadata STRING_MV_NO_DICTIONARY_METADATA =\n       new TransformResultMetadata(DataType.STRING, false, false);\n+  protected static final TransformResultMetadata BYTES_SV_NO_DICTIONARY_METADATA =\n+          new TransformResultMetadata(DataType.BYTES, true, false);\n \n+  private boolean[] _booleanValuesSV;", "originalCommit": "bb51f43a4419008e9a727d7c8355330d232ec9b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java\nindex a3e99b2d37..27492ebacc 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/transform/function/BaseTransformFunction.java\n\n@@ -44,7 +44,6 @@ public abstract class BaseTransformFunction implements TransformFunction {\n   protected static final TransformResultMetadata BYTES_SV_NO_DICTIONARY_METADATA =\n           new TransformResultMetadata(DataType.BYTES, true, false);\n \n-  private boolean[] _booleanValuesSV;\n   private int[] _intValuesSV;\n   private long[] _longValuesSV;\n   private float[] _floatValuesSV;\n"}}, {"oid": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "url": "https://github.com/apache/pinot/commit/b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "message": "addressed comments", "committedDate": "2020-07-22T03:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODIzNw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998237", "bodyText": "(nit) reformat", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:30:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 124f050b59..6f45fb1022 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -22,27 +22,28 @@ package org.apache.pinot.core.geospatial;\n  * The geometry type.\n  */\n public enum GeometryType {\n+  POINT(false, 0, \"ST_Point\"),\n+  MULTI_POINT(true, 1, \"ST_MultiPoint\"),\n+  LINE_STRING(false, 2, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3, \"ST_MultiLineString\"),\n+  POLYGON(false, 4, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6, \"ST_GeomCollection\");\n \n-  POINT(false, 0,\"ST_Point\"),\n-  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n-  LINE_STRING(false, 2,\"ST_LineString\"),\n-  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n-  POLYGON(false, 4,\"ST_Polygon\"),\n-  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n-\n-  private final boolean _multitype;\n+  private static final GeometryType[] ID_TO_TYPE_MAP =\n+      new GeometryType[]{POINT, MULTI_POINT, LINE_STRING, MULTI_LINE_STRING, POLYGON, MULTI_POLYGON, GEOMETRY_COLLECTION};\n+  private final boolean _multiType;\n   private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, int id, String name) {\n-    _multitype = multitype;\n+  GeometryType(boolean multiType, int id, String name) {\n+    _multiType = multiType;\n     _id = id;\n     _name = name;\n   }\n \n-  public boolean isMultitype() {\n-    return _multitype;\n+  public boolean isMultiType() {\n+    return _multiType;\n   }\n \n   public String getName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5ODkwOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458998908", "bodyText": "(nit) _multiType? (IDE identify multitype as typo)", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:31:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 124f050b59..6f45fb1022 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -22,27 +22,28 @@ package org.apache.pinot.core.geospatial;\n  * The geometry type.\n  */\n public enum GeometryType {\n+  POINT(false, 0, \"ST_Point\"),\n+  MULTI_POINT(true, 1, \"ST_MultiPoint\"),\n+  LINE_STRING(false, 2, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3, \"ST_MultiLineString\"),\n+  POLYGON(false, 4, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6, \"ST_GeomCollection\");\n \n-  POINT(false, 0,\"ST_Point\"),\n-  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n-  LINE_STRING(false, 2,\"ST_LineString\"),\n-  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n-  POLYGON(false, 4,\"ST_Polygon\"),\n-  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n-\n-  private final boolean _multitype;\n+  private static final GeometryType[] ID_TO_TYPE_MAP =\n+      new GeometryType[]{POINT, MULTI_POINT, LINE_STRING, MULTI_LINE_STRING, POLYGON, MULTI_POLYGON, GEOMETRY_COLLECTION};\n+  private final boolean _multiType;\n   private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, int id, String name) {\n-    _multitype = multitype;\n+  GeometryType(boolean multiType, int id, String name) {\n+    _multiType = multiType;\n     _id = id;\n     _name = name;\n   }\n \n-  public boolean isMultitype() {\n-    return _multitype;\n+  public boolean isMultiType() {\n+    return _multiType;\n   }\n \n   public String getName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5OTE4MQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r458999181", "bodyText": "Remove this class", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:31:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.apache.pinot.core.geospatial.GeometryType;\n+\n+\n+/**\n+ * The geometry type used in serialization\n+ */\n+public enum GeometrySerializationType {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\ndeleted file mode 100644\nindex 6b5659da06..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializationType.java\n+++ /dev/null\n\n@@ -1,82 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.geospatial.serde;\n-\n-import org.apache.pinot.core.geospatial.GeometryType;\n-\n-\n-/**\n- * The geometry type used in serialization\n- */\n-public enum GeometrySerializationType {\n-  POINT(0, GeometryType.POINT),\n-  MULTI_POINT(1, GeometryType.MULTI_POINT),\n-  LINE_STRING(2, GeometryType.LINE_STRING),\n-  MULTI_LINE_STRING(3, GeometryType.MULTI_LINE_STRING),\n-  POLYGON(4, GeometryType.POLYGON),\n-  MULTI_POLYGON(5, GeometryType.MULTI_POLYGON),\n-  GEOMETRY_COLLECTION(6, GeometryType.GEOMETRY_COLLECTION);\n-\n-  private final int _id;\n-  private final GeometryType _geometryType;\n-\n-  GeometrySerializationType(int id, GeometryType geometryType) {\n-    _id = id;\n-    _geometryType = geometryType;\n-  }\n-\n-  /**\n-   * @return the id of the serialization type\n-   */\n-  public int id() {\n-    return _id;\n-  }\n-\n-  /**\n-   * @return the type in the geometry model\n-   */\n-  public GeometryType getGeometryType() {\n-    return _geometryType;\n-  }\n-\n-  /**\n-   * Constructs the serialization type from the id\n-   * @param id id of the serialization type\n-   * @return the serialization type\n-   */\n-  public static GeometrySerializationType fromID(int id) {\n-    switch (id) {\n-      case 0:\n-        return POINT;\n-      case 1:\n-        return MULTI_POINT;\n-      case 2:\n-        return LINE_STRING;\n-      case 3:\n-        return MULTI_LINE_STRING;\n-      case 4:\n-        return POLYGON;\n-      case 5:\n-        return MULTI_POLYGON;\n-      case 6:\n-        return GEOMETRY_COLLECTION;\n-      default:\n-        throw new IllegalArgumentException(\"Invalid type id: \" + id);\n-    }\n-  }}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMTEzMQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459001131", "bodyText": "Keep an static GeometryType array\nprivate static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...};\nThen you can avoid the switch branching for better performance\nreturn ID_TO_TYPE_MAP[id];", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:34:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial;\n+\n+/**\n+ * The geometry type.\n+ */\n+public enum GeometryType {\n+\n+  POINT(false, 0,\"ST_Point\"),\n+  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n+  LINE_STRING(false, 2,\"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n+  POLYGON(false, 4,\"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n+\n+  private final boolean _multitype;\n+  private final int _id;\n+  private final String _name;\n+\n+  GeometryType(boolean multitype, int id, String name) {\n+    _multitype = multitype;\n+    _id = id;\n+    _name = name;\n+  }\n+\n+  public boolean isMultitype() {\n+    return _multitype;\n+  }\n+\n+  public String getName() {\n+    return _name;\n+  }\n+\n+  /**\n+   * @return the id of the serialization type\n+   */\n+  public int id() {\n+    return _id;\n+  }\n+\n+  /**\n+   * Constructs the serialization type from the id\n+   * @param id id of the serialization type\n+   * @return the serialization type\n+   */\n+  public static GeometryType fromID(int id) {\n+    switch (id) {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\nindex 124f050b59..6f45fb1022 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/GeometryType.java\n\n@@ -22,27 +22,28 @@ package org.apache.pinot.core.geospatial;\n  * The geometry type.\n  */\n public enum GeometryType {\n+  POINT(false, 0, \"ST_Point\"),\n+  MULTI_POINT(true, 1, \"ST_MultiPoint\"),\n+  LINE_STRING(false, 2, \"ST_LineString\"),\n+  MULTI_LINE_STRING(true, 3, \"ST_MultiLineString\"),\n+  POLYGON(false, 4, \"ST_Polygon\"),\n+  MULTI_POLYGON(true, 5, \"ST_MultiPolygon\"),\n+  GEOMETRY_COLLECTION(true, 6, \"ST_GeomCollection\");\n \n-  POINT(false, 0,\"ST_Point\"),\n-  MULTI_POINT(true, 1,\"ST_MultiPoint\"),\n-  LINE_STRING(false, 2,\"ST_LineString\"),\n-  MULTI_LINE_STRING(true, 3,\"ST_MultiLineString\"),\n-  POLYGON(false, 4,\"ST_Polygon\"),\n-  MULTI_POLYGON(true, 5,\"ST_MultiPolygon\"),\n-  GEOMETRY_COLLECTION(true, 6,\"ST_GeomCollection\");\n-\n-  private final boolean _multitype;\n+  private static final GeometryType[] ID_TO_TYPE_MAP =\n+      new GeometryType[]{POINT, MULTI_POINT, LINE_STRING, MULTI_LINE_STRING, POLYGON, MULTI_POLYGON, GEOMETRY_COLLECTION};\n+  private final boolean _multiType;\n   private final int _id;\n   private final String _name;\n \n-  GeometryType(boolean multitype, int id, String name) {\n-    _multitype = multitype;\n+  GeometryType(boolean multiType, int id, String name) {\n+    _multiType = multiType;\n     _id = id;\n     _name = name;\n   }\n \n-  public boolean isMultitype() {\n-    return _multitype;\n+  public boolean isMultiType() {\n+    return _multiType;\n   }\n \n   public String getName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwMjI3Ng==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459002276", "bodyText": "(nit) Remove the unused LOGGER (we don't want to log within serde as it is per-value based and can easily flood the log)", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:36:44Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\ndeleted file mode 100644\nindex e79313886c..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ /dev/null\n\n@@ -1,510 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.geospatial.serde;\n-\n-import com.google.common.base.Verify;\n-import com.google.common.collect.Iterables;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import org.apache.pinot.core.geospatial.GeometryType;\n-import org.apache.pinot.core.geospatial.GeometryUtils;\n-import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Geometry;\n-import org.locationtech.jts.geom.GeometryFactory;\n-import org.locationtech.jts.geom.LineString;\n-import org.locationtech.jts.geom.LinearRing;\n-import org.locationtech.jts.geom.MultiPoint;\n-import org.locationtech.jts.geom.Point;\n-import org.locationtech.jts.geom.Polygon;\n-import org.locationtech.jts.geom.TopologyException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Provides methods to efficiently serialize and deserialize geometry types.\n- *\n- * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n- * with the following differences:\n- *  - The geometry vs geography info is encoded in the type byte.\n- *  - The envelope info is not serialized\n- */\n-public class GeometrySerde {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n-  private static final int TYPE_SIZE = Byte.BYTES;\n-  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n-\n-  byte[] writeGeometry(Geometry geometry) {\n-    byte[] bytes = new byte[getByteSize(geometry)];\n-    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-    writeGeometryByteBuffer(byteBuffer, geometry);\n-    return bytes;\n-  }\n-\n-  public Geometry readGeometry(byte[] bytes) {\n-    return readGeometry(ByteBuffer.wrap(bytes));\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer) {\n-    byte typeByte = byteBuffer.get();\n-    GeometryType type = readGeometryType(typeByte);\n-    GeometryFactory factory = getGeometryFactory(typeByte);\n-    Geometry geometry = readGeometry(byteBuffer, type, factory);\n-    return geometry;\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n-    switch (type) {\n-      case POINT:\n-        return readPoint(byteBuffer, factory);\n-      case MULTI_POINT:\n-        return readMultiPoint(byteBuffer, factory);\n-      case LINE_STRING:\n-        return readPolyline(byteBuffer, false, factory);\n-      case MULTI_LINE_STRING:\n-        return readPolyline(byteBuffer, true, factory);\n-      case POLYGON:\n-        return readPolygon(byteBuffer, false, factory);\n-      case MULTI_POLYGON:\n-        return readPolygon(byteBuffer, true, factory);\n-      case GEOMETRY_COLLECTION:\n-        return readGeometryCollection(byteBuffer, factory);\n-      default:\n-        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n-    }\n-  }\n-\n-  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    Coordinate coordinates = readCoordinate(byteBuffer);\n-    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n-      return factory.createPoint();\n-    }\n-    return factory.createPoint(coordinates);\n-  }\n-\n-  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n-    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n-  }\n-\n-  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n-    Objects.requireNonNull(byteBuffer, \"input is null\");\n-    Verify.verify(count > 0);\n-    Coordinate[] coordinates = new Coordinate[count];\n-    for (int i = 0; i < count; i++) {\n-      coordinates[i] = readCoordinate(byteBuffer);\n-    }\n-    return coordinates;\n-  }\n-\n-  private Geometry readMultiPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    int pointCount = byteBuffer.getInt();\n-    Point[] points = new Point[pointCount];\n-    for (int i = 0; i < pointCount; i++) {\n-      points[i] = readPoint(byteBuffer, factory);\n-    }\n-    return factory.createMultiPoint(points);\n-  }\n-\n-  private GeometryType readGeometryType(byte typeByte) {\n-    return GeometryType.fromID(typeByte & GeometryUtils.GEOGRAPHY_GET_MASK);\n-  }\n-\n-  private Geometry readPolyline(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiLineString();\n-      }\n-      return factory.createLineString();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LineString[] lineStrings = new LineString[partCount];\n-\n-    for (int i = 0; i < partCount; i++) {\n-      lineStrings[i] = factory.createLineString(readCoordinates(byteBuffer, partLengths[i]));\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiLineString(lineStrings);\n-    }\n-    Verify.verify(lineStrings.length == 1);\n-    return lineStrings[0];\n-  }\n-\n-  private Geometry readPolygon(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiPolygon();\n-      }\n-      return factory.createPolygon();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LinearRing shell = null;\n-    List<LinearRing> holes = new ArrayList<>();\n-    List<Polygon> polygons = new ArrayList<>();\n-    try {\n-      for (int i = 0; i < partCount; i++) {\n-        Coordinate[] coordinates = readCoordinates(byteBuffer, partLengths[i]);\n-        if (isClockwise(coordinates)) {\n-          // next polygon has started\n-          if (shell != null) {\n-            polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-            holes.clear();\n-          }\n-          shell = factory.createLinearRing(coordinates);\n-        } else {\n-          holes.add(factory.createLinearRing(coordinates));\n-        }\n-      }\n-      polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-    } catch (IllegalArgumentException e) {\n-      throw new TopologyException(\"Error constructing Polygon: \" + e.getMessage());\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiPolygon(polygons.toArray(new Polygon[0]));\n-    }\n-    return Iterables.getOnlyElement(polygons);\n-  }\n-\n-  private Geometry readGeometryCollection(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    List<Geometry> geometries = new ArrayList<>();\n-    while (true) {\n-      if (!byteBuffer.hasRemaining()) {\n-        break;\n-      }\n-      byte typeByte = byteBuffer.get();\n-      GeometryType type = readGeometryType(typeByte);\n-      GeometryFactory geometryFactory = getGeometryFactory(typeByte);\n-      geometries.add(readGeometry(byteBuffer, type, geometryFactory));\n-    }\n-    return factory.createGeometryCollection(geometries.toArray(new Geometry[0]));\n-  }\n-\n-  private boolean isClockwise(Coordinate[] coordinates) {\n-    return isClockwise(coordinates, 0, coordinates.length);\n-  }\n-\n-  private static boolean isClockwise(Coordinate[] coordinates, int start, int end) {\n-    // Sum over the edges: (x2 \u2212 x1) * (y2 + y1).\n-    // If the result is positive the curve is clockwise,\n-    // if it's negative the curve is counter-clockwise.\n-    double area = 0;\n-    for (int i = start + 1; i < end; i++) {\n-      area += (coordinates[i].x - coordinates[i - 1].x) * (coordinates[i].y + coordinates[i - 1].y);\n-    }\n-    area += (coordinates[start].x - coordinates[end - 1].x) * (coordinates[start].y + coordinates[end - 1].y);\n-    return area > 0;\n-  }\n-\n-  private GeometryFactory getGeometryFactory(byte typeByte) {\n-    return typeByte < 0 ? GeometryUtils.GEOGRAPHY_FACTORY : GeometryUtils.GEOMETRY_FACTORY;\n-  }\n-\n-  private void writeGeometryByteBuffer(ByteBuffer byteBuffer, Geometry geometry) {\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        writePoint(byteBuffer, (Point) geometry);\n-        break;\n-      case \"MultiPoint\":\n-        writeMultiPoint(byteBuffer, (MultiPoint) geometry);\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        writePolyline(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        writePolyline(byteBuffer, geometry, true);\n-        break;\n-      case \"Polygon\":\n-        writePolygon(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        writePolygon(byteBuffer, geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        writeGeometryCollection(byteBuffer, geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-  }\n-\n-  private int getByteSize(Geometry geometry) {\n-    int size = TYPE_SIZE;\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        size += COORDINATE_SIZE;\n-        break;\n-      case \"MultiPoint\":\n-        size += Integer.BYTES + geometry.getNumPoints() * COORDINATE_SIZE;\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        size += getPolylineByteSize(geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        size += getPolylineByteSize(geometry, true);\n-        break;\n-      case \"Polygon\":\n-        size += getPolygonByteSize(geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        size += getPolygonByteSize(geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        size += getGeometryCollectionByteSize(geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-    return size;\n-  }\n-\n-  private void writeType(ByteBuffer byteBuffer, GeometryType serializationType, int SRID) {\n-    byte type = Integer.valueOf(serializationType.id()).byteValue();\n-    if (SRID == GeometryUtils.GEOGRAPHY_SRID) {\n-      type |= GeometryUtils.GEOGRAPHY_SET_MASK;\n-    }\n-    byteBuffer.put(type);\n-  }\n-\n-  /**\n-   * Writes the byte of type, followed by the two coordinates in double.\n-   */\n-  private void writePoint(ByteBuffer byteBuffer, Point point) {\n-    writeType(byteBuffer, GeometryType.POINT, point.getSRID());\n-    if (point.isEmpty()) {\n-      byteBuffer.putDouble(Double.NaN);\n-      byteBuffer.putDouble(Double.NaN);\n-    } else {\n-      writeCoordinate(byteBuffer, point.getCoordinate());\n-    }\n-  }\n-\n-  private void writeCoordinate(ByteBuffer byteBuffer, Coordinate coordinate) {\n-    byteBuffer.putDouble(coordinate.getX());\n-    byteBuffer.putDouble(coordinate.getY());\n-  }\n-\n-  /**\n-   * Writes the byte of type, number of points in int, followed by the collection of points\n-   */\n-  private void writeMultiPoint(ByteBuffer byteBuffer, MultiPoint geometry) {\n-    writeType(byteBuffer, GeometryType.MULTI_POINT, geometry.getSRID());\n-    byteBuffer.putInt(geometry.getNumPoints());\n-    for (Coordinate coordinate : geometry.getCoordinates()) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolylineByteSize(Geometry geometry, boolean multitype) {\n-    int numPoints = geometry.getNumPoints();\n-    int numParts = multitype ? geometry.getNumGeometries() : numPoints > 0 ? 1 : 0;\n-    return Integer.BYTES + Integer.BYTES + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by collection of coordinates\n-   */\n-  private void writePolyline(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numParts;\n-    int numPoints = geometry.getNumPoints();\n-    if (multitype) {\n-      numParts = geometry.getNumGeometries();\n-      writeType(byteBuffer, GeometryType.MULTI_LINE_STRING, geometry.getSRID());\n-    } else {\n-      numParts = numPoints > 0 ? 1 : 0;\n-      writeType(byteBuffer, GeometryType.LINE_STRING, geometry.getSRID());\n-    }\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    int partIndex = 0;\n-    for (int i = 0; i < numParts; i++) {\n-      byteBuffer.putInt(partIndex);\n-      partIndex += geometry.getGeometryN(i).getNumPoints();\n-    }\n-\n-    writeCoordinates(byteBuffer, geometry.getCoordinates());\n-  }\n-\n-  private void writeCoordinates(ByteBuffer byteBuffer, Coordinate[] coordinates) {\n-    for (Coordinate coordinate : coordinates) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolygonByteSize(Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-    int size = Integer.BYTES + Integer.BYTES;\n-    if (numParts == 0) {\n-      return size;\n-    }\n-    return size + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by the canonicalized coordinates.\n-   */\n-  private void writePolygon(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-\n-    if (multitype) {\n-      writeType(byteBuffer, GeometryType.MULTI_POLYGON, geometry.getSRID());\n-    } else {\n-      writeType(byteBuffer, GeometryType.POLYGON, geometry.getSRID());\n-    }\n-\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    if (numParts == 0) {\n-      return;\n-    }\n-\n-    int[] partIndexes = new int[numParts];\n-    boolean[] shellPart = new boolean[numParts];\n-\n-    int currentPart = 0;\n-    int currentPoint = 0;\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-\n-      partIndexes[currentPart] = currentPoint;\n-      shellPart[currentPart] = true;\n-      currentPart++;\n-      currentPoint += polygon.getExteriorRing().getNumPoints();\n-\n-      int holesCount = polygon.getNumInteriorRing();\n-      for (int holeIndex = 0; holeIndex < holesCount; holeIndex++) {\n-        partIndexes[currentPart] = currentPoint;\n-        shellPart[currentPart] = false;\n-        currentPart++;\n-        currentPoint += polygon.getInteriorRingN(holeIndex).getNumPoints();\n-      }\n-    }\n-\n-    for (int partIndex : partIndexes) {\n-      byteBuffer.putInt(partIndex);\n-    }\n-\n-    Coordinate[] coordinates = geometry.getCoordinates();\n-    canonicalizePolygonCoordinates(coordinates, partIndexes, shellPart);\n-    writeCoordinates(byteBuffer, coordinates);\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int[] partIndexes, boolean[] shellPart) {\n-    for (int part = 0; part < partIndexes.length - 1; part++) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[part], partIndexes[part + 1], shellPart[part]);\n-    }\n-    if (partIndexes.length > 0) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[partIndexes.length - 1], coordinates.length,\n-          shellPart[partIndexes.length - 1]);\n-    }\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int start, int end, boolean isShell) {\n-    boolean isClockwise = isClockwise(coordinates, start, end);\n-\n-    if ((isShell && !isClockwise) || (!isShell && isClockwise)) {\n-      // shell has to be counter clockwise\n-      reverse(coordinates, start, end);\n-    }\n-  }\n-\n-  private void reverse(Coordinate[] coordinates, int start, int end) {\n-    Verify.verify(start <= end, \"start must be less or equal than end\");\n-    for (int i = start; i < start + ((end - start) / 2); i++) {\n-      Coordinate buffer = coordinates[i];\n-      coordinates[i] = coordinates[start + end - i - 1];\n-      coordinates[start + end - i - 1] = buffer;\n-    }\n-  }\n-\n-  private int getGeometryCollectionByteSize(Geometry collection) {\n-    int size = 0;\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      size += getByteSize(geometry);\n-    }\n-    return size;\n-  }\n-\n-  private void writeGeometryCollection(ByteBuffer byteBuffer, Geometry collection) {\n-    writeType(byteBuffer, GeometryType.GEOMETRY_COLLECTION, collection.getSRID());\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      writeGeometryByteBuffer(byteBuffer, geometry);\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwNDcxNQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459004715", "bodyText": "Merge GeometrySerde into this class? I don't see the value of keeping them separate", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:40:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import org.locationtech.jts.geom.Geometry;\n+\n+\n+/**\n+ * A serializer that serializes a geometry object into bytes and vice versa.\n+ */\n+public class GeometrySerializer {", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\nindex 7169654d3a..7cf2b9ec76 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerializer.java\n\n@@ -18,17 +18,35 @@\n  */\n package org.apache.pinot.core.geospatial.serde;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n \n \n /**\n- * A serializer that serializes a geometry object into bytes and vice versa.\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n  */\n-public class GeometrySerializer {\n-  private static final GeometrySerde SERDE = new GeometrySerde();\n-\n-  private GeometrySerializer() {\n-  }\n+public final class GeometrySerializer {\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n \n   /**\n    * Serializes a geometry object into bytes\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMDQ4NQ==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459010485", "bodyText": "(nit) Redundant check", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:50:29Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\ndeleted file mode 100644\nindex e79313886c..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ /dev/null\n\n@@ -1,510 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.geospatial.serde;\n-\n-import com.google.common.base.Verify;\n-import com.google.common.collect.Iterables;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import org.apache.pinot.core.geospatial.GeometryType;\n-import org.apache.pinot.core.geospatial.GeometryUtils;\n-import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Geometry;\n-import org.locationtech.jts.geom.GeometryFactory;\n-import org.locationtech.jts.geom.LineString;\n-import org.locationtech.jts.geom.LinearRing;\n-import org.locationtech.jts.geom.MultiPoint;\n-import org.locationtech.jts.geom.Point;\n-import org.locationtech.jts.geom.Polygon;\n-import org.locationtech.jts.geom.TopologyException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Provides methods to efficiently serialize and deserialize geometry types.\n- *\n- * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n- * with the following differences:\n- *  - The geometry vs geography info is encoded in the type byte.\n- *  - The envelope info is not serialized\n- */\n-public class GeometrySerde {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n-  private static final int TYPE_SIZE = Byte.BYTES;\n-  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n-\n-  byte[] writeGeometry(Geometry geometry) {\n-    byte[] bytes = new byte[getByteSize(geometry)];\n-    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-    writeGeometryByteBuffer(byteBuffer, geometry);\n-    return bytes;\n-  }\n-\n-  public Geometry readGeometry(byte[] bytes) {\n-    return readGeometry(ByteBuffer.wrap(bytes));\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer) {\n-    byte typeByte = byteBuffer.get();\n-    GeometryType type = readGeometryType(typeByte);\n-    GeometryFactory factory = getGeometryFactory(typeByte);\n-    Geometry geometry = readGeometry(byteBuffer, type, factory);\n-    return geometry;\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n-    switch (type) {\n-      case POINT:\n-        return readPoint(byteBuffer, factory);\n-      case MULTI_POINT:\n-        return readMultiPoint(byteBuffer, factory);\n-      case LINE_STRING:\n-        return readPolyline(byteBuffer, false, factory);\n-      case MULTI_LINE_STRING:\n-        return readPolyline(byteBuffer, true, factory);\n-      case POLYGON:\n-        return readPolygon(byteBuffer, false, factory);\n-      case MULTI_POLYGON:\n-        return readPolygon(byteBuffer, true, factory);\n-      case GEOMETRY_COLLECTION:\n-        return readGeometryCollection(byteBuffer, factory);\n-      default:\n-        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n-    }\n-  }\n-\n-  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    Coordinate coordinates = readCoordinate(byteBuffer);\n-    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n-      return factory.createPoint();\n-    }\n-    return factory.createPoint(coordinates);\n-  }\n-\n-  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n-    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n-  }\n-\n-  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n-    Objects.requireNonNull(byteBuffer, \"input is null\");\n-    Verify.verify(count > 0);\n-    Coordinate[] coordinates = new Coordinate[count];\n-    for (int i = 0; i < count; i++) {\n-      coordinates[i] = readCoordinate(byteBuffer);\n-    }\n-    return coordinates;\n-  }\n-\n-  private Geometry readMultiPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    int pointCount = byteBuffer.getInt();\n-    Point[] points = new Point[pointCount];\n-    for (int i = 0; i < pointCount; i++) {\n-      points[i] = readPoint(byteBuffer, factory);\n-    }\n-    return factory.createMultiPoint(points);\n-  }\n-\n-  private GeometryType readGeometryType(byte typeByte) {\n-    return GeometryType.fromID(typeByte & GeometryUtils.GEOGRAPHY_GET_MASK);\n-  }\n-\n-  private Geometry readPolyline(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiLineString();\n-      }\n-      return factory.createLineString();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LineString[] lineStrings = new LineString[partCount];\n-\n-    for (int i = 0; i < partCount; i++) {\n-      lineStrings[i] = factory.createLineString(readCoordinates(byteBuffer, partLengths[i]));\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiLineString(lineStrings);\n-    }\n-    Verify.verify(lineStrings.length == 1);\n-    return lineStrings[0];\n-  }\n-\n-  private Geometry readPolygon(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiPolygon();\n-      }\n-      return factory.createPolygon();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LinearRing shell = null;\n-    List<LinearRing> holes = new ArrayList<>();\n-    List<Polygon> polygons = new ArrayList<>();\n-    try {\n-      for (int i = 0; i < partCount; i++) {\n-        Coordinate[] coordinates = readCoordinates(byteBuffer, partLengths[i]);\n-        if (isClockwise(coordinates)) {\n-          // next polygon has started\n-          if (shell != null) {\n-            polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-            holes.clear();\n-          }\n-          shell = factory.createLinearRing(coordinates);\n-        } else {\n-          holes.add(factory.createLinearRing(coordinates));\n-        }\n-      }\n-      polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-    } catch (IllegalArgumentException e) {\n-      throw new TopologyException(\"Error constructing Polygon: \" + e.getMessage());\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiPolygon(polygons.toArray(new Polygon[0]));\n-    }\n-    return Iterables.getOnlyElement(polygons);\n-  }\n-\n-  private Geometry readGeometryCollection(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    List<Geometry> geometries = new ArrayList<>();\n-    while (true) {\n-      if (!byteBuffer.hasRemaining()) {\n-        break;\n-      }\n-      byte typeByte = byteBuffer.get();\n-      GeometryType type = readGeometryType(typeByte);\n-      GeometryFactory geometryFactory = getGeometryFactory(typeByte);\n-      geometries.add(readGeometry(byteBuffer, type, geometryFactory));\n-    }\n-    return factory.createGeometryCollection(geometries.toArray(new Geometry[0]));\n-  }\n-\n-  private boolean isClockwise(Coordinate[] coordinates) {\n-    return isClockwise(coordinates, 0, coordinates.length);\n-  }\n-\n-  private static boolean isClockwise(Coordinate[] coordinates, int start, int end) {\n-    // Sum over the edges: (x2 \u2212 x1) * (y2 + y1).\n-    // If the result is positive the curve is clockwise,\n-    // if it's negative the curve is counter-clockwise.\n-    double area = 0;\n-    for (int i = start + 1; i < end; i++) {\n-      area += (coordinates[i].x - coordinates[i - 1].x) * (coordinates[i].y + coordinates[i - 1].y);\n-    }\n-    area += (coordinates[start].x - coordinates[end - 1].x) * (coordinates[start].y + coordinates[end - 1].y);\n-    return area > 0;\n-  }\n-\n-  private GeometryFactory getGeometryFactory(byte typeByte) {\n-    return typeByte < 0 ? GeometryUtils.GEOGRAPHY_FACTORY : GeometryUtils.GEOMETRY_FACTORY;\n-  }\n-\n-  private void writeGeometryByteBuffer(ByteBuffer byteBuffer, Geometry geometry) {\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        writePoint(byteBuffer, (Point) geometry);\n-        break;\n-      case \"MultiPoint\":\n-        writeMultiPoint(byteBuffer, (MultiPoint) geometry);\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        writePolyline(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        writePolyline(byteBuffer, geometry, true);\n-        break;\n-      case \"Polygon\":\n-        writePolygon(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        writePolygon(byteBuffer, geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        writeGeometryCollection(byteBuffer, geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-  }\n-\n-  private int getByteSize(Geometry geometry) {\n-    int size = TYPE_SIZE;\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        size += COORDINATE_SIZE;\n-        break;\n-      case \"MultiPoint\":\n-        size += Integer.BYTES + geometry.getNumPoints() * COORDINATE_SIZE;\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        size += getPolylineByteSize(geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        size += getPolylineByteSize(geometry, true);\n-        break;\n-      case \"Polygon\":\n-        size += getPolygonByteSize(geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        size += getPolygonByteSize(geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        size += getGeometryCollectionByteSize(geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-    return size;\n-  }\n-\n-  private void writeType(ByteBuffer byteBuffer, GeometryType serializationType, int SRID) {\n-    byte type = Integer.valueOf(serializationType.id()).byteValue();\n-    if (SRID == GeometryUtils.GEOGRAPHY_SRID) {\n-      type |= GeometryUtils.GEOGRAPHY_SET_MASK;\n-    }\n-    byteBuffer.put(type);\n-  }\n-\n-  /**\n-   * Writes the byte of type, followed by the two coordinates in double.\n-   */\n-  private void writePoint(ByteBuffer byteBuffer, Point point) {\n-    writeType(byteBuffer, GeometryType.POINT, point.getSRID());\n-    if (point.isEmpty()) {\n-      byteBuffer.putDouble(Double.NaN);\n-      byteBuffer.putDouble(Double.NaN);\n-    } else {\n-      writeCoordinate(byteBuffer, point.getCoordinate());\n-    }\n-  }\n-\n-  private void writeCoordinate(ByteBuffer byteBuffer, Coordinate coordinate) {\n-    byteBuffer.putDouble(coordinate.getX());\n-    byteBuffer.putDouble(coordinate.getY());\n-  }\n-\n-  /**\n-   * Writes the byte of type, number of points in int, followed by the collection of points\n-   */\n-  private void writeMultiPoint(ByteBuffer byteBuffer, MultiPoint geometry) {\n-    writeType(byteBuffer, GeometryType.MULTI_POINT, geometry.getSRID());\n-    byteBuffer.putInt(geometry.getNumPoints());\n-    for (Coordinate coordinate : geometry.getCoordinates()) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolylineByteSize(Geometry geometry, boolean multitype) {\n-    int numPoints = geometry.getNumPoints();\n-    int numParts = multitype ? geometry.getNumGeometries() : numPoints > 0 ? 1 : 0;\n-    return Integer.BYTES + Integer.BYTES + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by collection of coordinates\n-   */\n-  private void writePolyline(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numParts;\n-    int numPoints = geometry.getNumPoints();\n-    if (multitype) {\n-      numParts = geometry.getNumGeometries();\n-      writeType(byteBuffer, GeometryType.MULTI_LINE_STRING, geometry.getSRID());\n-    } else {\n-      numParts = numPoints > 0 ? 1 : 0;\n-      writeType(byteBuffer, GeometryType.LINE_STRING, geometry.getSRID());\n-    }\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    int partIndex = 0;\n-    for (int i = 0; i < numParts; i++) {\n-      byteBuffer.putInt(partIndex);\n-      partIndex += geometry.getGeometryN(i).getNumPoints();\n-    }\n-\n-    writeCoordinates(byteBuffer, geometry.getCoordinates());\n-  }\n-\n-  private void writeCoordinates(ByteBuffer byteBuffer, Coordinate[] coordinates) {\n-    for (Coordinate coordinate : coordinates) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolygonByteSize(Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-    int size = Integer.BYTES + Integer.BYTES;\n-    if (numParts == 0) {\n-      return size;\n-    }\n-    return size + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by the canonicalized coordinates.\n-   */\n-  private void writePolygon(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-\n-    if (multitype) {\n-      writeType(byteBuffer, GeometryType.MULTI_POLYGON, geometry.getSRID());\n-    } else {\n-      writeType(byteBuffer, GeometryType.POLYGON, geometry.getSRID());\n-    }\n-\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    if (numParts == 0) {\n-      return;\n-    }\n-\n-    int[] partIndexes = new int[numParts];\n-    boolean[] shellPart = new boolean[numParts];\n-\n-    int currentPart = 0;\n-    int currentPoint = 0;\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-\n-      partIndexes[currentPart] = currentPoint;\n-      shellPart[currentPart] = true;\n-      currentPart++;\n-      currentPoint += polygon.getExteriorRing().getNumPoints();\n-\n-      int holesCount = polygon.getNumInteriorRing();\n-      for (int holeIndex = 0; holeIndex < holesCount; holeIndex++) {\n-        partIndexes[currentPart] = currentPoint;\n-        shellPart[currentPart] = false;\n-        currentPart++;\n-        currentPoint += polygon.getInteriorRingN(holeIndex).getNumPoints();\n-      }\n-    }\n-\n-    for (int partIndex : partIndexes) {\n-      byteBuffer.putInt(partIndex);\n-    }\n-\n-    Coordinate[] coordinates = geometry.getCoordinates();\n-    canonicalizePolygonCoordinates(coordinates, partIndexes, shellPart);\n-    writeCoordinates(byteBuffer, coordinates);\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int[] partIndexes, boolean[] shellPart) {\n-    for (int part = 0; part < partIndexes.length - 1; part++) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[part], partIndexes[part + 1], shellPart[part]);\n-    }\n-    if (partIndexes.length > 0) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[partIndexes.length - 1], coordinates.length,\n-          shellPart[partIndexes.length - 1]);\n-    }\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int start, int end, boolean isShell) {\n-    boolean isClockwise = isClockwise(coordinates, start, end);\n-\n-    if ((isShell && !isClockwise) || (!isShell && isClockwise)) {\n-      // shell has to be counter clockwise\n-      reverse(coordinates, start, end);\n-    }\n-  }\n-\n-  private void reverse(Coordinate[] coordinates, int start, int end) {\n-    Verify.verify(start <= end, \"start must be less or equal than end\");\n-    for (int i = start; i < start + ((end - start) / 2); i++) {\n-      Coordinate buffer = coordinates[i];\n-      coordinates[i] = coordinates[start + end - i - 1];\n-      coordinates[start + end - i - 1] = buffer;\n-    }\n-  }\n-\n-  private int getGeometryCollectionByteSize(Geometry collection) {\n-    int size = 0;\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      size += getByteSize(geometry);\n-    }\n-    return size;\n-  }\n-\n-  private void writeGeometryCollection(ByteBuffer byteBuffer, Geometry collection) {\n-    writeType(byteBuffer, GeometryType.GEOMETRY_COLLECTION, collection.getSRID());\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      writeGeometryByteBuffer(byteBuffer, geometry);\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxNTQxNA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459015414", "bodyText": "Let's use Preconditions for argument check. Same for other places", "author": "Jackie-Jiang", "createdAt": "2020-07-22T18:59:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java", "diffHunk": "@@ -0,0 +1,510 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.serde;\n+\n+import com.google.common.base.Verify;\n+import com.google.common.collect.Iterables;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import org.apache.pinot.core.geospatial.GeometryType;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.LineString;\n+import org.locationtech.jts.geom.LinearRing;\n+import org.locationtech.jts.geom.MultiPoint;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.geom.TopologyException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Provides methods to efficiently serialize and deserialize geometry types.\n+ *\n+ * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n+ * with the following differences:\n+ *  - The geometry vs geography info is encoded in the type byte.\n+ *  - The envelope info is not serialized\n+ */\n+public class GeometrySerde {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n+  private static final int TYPE_SIZE = Byte.BYTES;\n+  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n+\n+  byte[] writeGeometry(Geometry geometry) {\n+    byte[] bytes = new byte[getByteSize(geometry)];\n+    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+    writeGeometryByteBuffer(byteBuffer, geometry);\n+    return bytes;\n+  }\n+\n+  public Geometry readGeometry(byte[] bytes) {\n+    return readGeometry(ByteBuffer.wrap(bytes));\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer) {\n+    byte typeByte = byteBuffer.get();\n+    GeometryType type = readGeometryType(typeByte);\n+    GeometryFactory factory = getGeometryFactory(typeByte);\n+    Geometry geometry = readGeometry(byteBuffer, type, factory);\n+    return geometry;\n+  }\n+\n+  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n+    switch (type) {\n+      case POINT:\n+        return readPoint(byteBuffer, factory);\n+      case MULTI_POINT:\n+        return readMultiPoint(byteBuffer, factory);\n+      case LINE_STRING:\n+        return readPolyline(byteBuffer, false, factory);\n+      case MULTI_LINE_STRING:\n+        return readPolyline(byteBuffer, true, factory);\n+      case POLYGON:\n+        return readPolygon(byteBuffer, false, factory);\n+      case MULTI_POLYGON:\n+        return readPolygon(byteBuffer, true, factory);\n+      case GEOMETRY_COLLECTION:\n+        return readGeometryCollection(byteBuffer, factory);\n+      default:\n+        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n+    }\n+  }\n+\n+  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n+    Coordinate coordinates = readCoordinate(byteBuffer);\n+    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n+      return factory.createPoint();\n+    }\n+    return factory.createPoint(coordinates);\n+  }\n+\n+  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n+    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n+  }\n+\n+  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n+    Objects.requireNonNull(byteBuffer, \"input is null\");\n+    Verify.verify(count > 0);", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\ndeleted file mode 100644\nindex e79313886c..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/serde/GeometrySerde.java\n+++ /dev/null\n\n@@ -1,510 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.geospatial.serde;\n-\n-import com.google.common.base.Verify;\n-import com.google.common.collect.Iterables;\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import org.apache.pinot.core.geospatial.GeometryType;\n-import org.apache.pinot.core.geospatial.GeometryUtils;\n-import org.locationtech.jts.geom.Coordinate;\n-import org.locationtech.jts.geom.Geometry;\n-import org.locationtech.jts.geom.GeometryFactory;\n-import org.locationtech.jts.geom.LineString;\n-import org.locationtech.jts.geom.LinearRing;\n-import org.locationtech.jts.geom.MultiPoint;\n-import org.locationtech.jts.geom.Point;\n-import org.locationtech.jts.geom.Polygon;\n-import org.locationtech.jts.geom.TopologyException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Provides methods to efficiently serialize and deserialize geometry types.\n- *\n- * This serialization is similar to Presto's https://github.com/prestodb/presto/blob/master/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/serde/JtsGeometrySerde.java,\n- * with the following differences:\n- *  - The geometry vs geography info is encoded in the type byte.\n- *  - The envelope info is not serialized\n- */\n-public class GeometrySerde {\n-  private static final Logger LOGGER = LoggerFactory.getLogger(GeometrySerde.class);\n-  private static final int TYPE_SIZE = Byte.BYTES;\n-  private static final int COORDINATE_SIZE = Double.BYTES + Double.BYTES;\n-\n-  byte[] writeGeometry(Geometry geometry) {\n-    byte[] bytes = new byte[getByteSize(geometry)];\n-    ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-    writeGeometryByteBuffer(byteBuffer, geometry);\n-    return bytes;\n-  }\n-\n-  public Geometry readGeometry(byte[] bytes) {\n-    return readGeometry(ByteBuffer.wrap(bytes));\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer) {\n-    byte typeByte = byteBuffer.get();\n-    GeometryType type = readGeometryType(typeByte);\n-    GeometryFactory factory = getGeometryFactory(typeByte);\n-    Geometry geometry = readGeometry(byteBuffer, type, factory);\n-    return geometry;\n-  }\n-\n-  private Geometry readGeometry(ByteBuffer byteBuffer, GeometryType type, GeometryFactory factory) {\n-    switch (type) {\n-      case POINT:\n-        return readPoint(byteBuffer, factory);\n-      case MULTI_POINT:\n-        return readMultiPoint(byteBuffer, factory);\n-      case LINE_STRING:\n-        return readPolyline(byteBuffer, false, factory);\n-      case MULTI_LINE_STRING:\n-        return readPolyline(byteBuffer, true, factory);\n-      case POLYGON:\n-        return readPolygon(byteBuffer, false, factory);\n-      case MULTI_POLYGON:\n-        return readPolygon(byteBuffer, true, factory);\n-      case GEOMETRY_COLLECTION:\n-        return readGeometryCollection(byteBuffer, factory);\n-      default:\n-        throw new UnsupportedOperationException(\"Unexpected type: \" + type);\n-    }\n-  }\n-\n-  private Point readPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    Coordinate coordinates = readCoordinate(byteBuffer);\n-    if (Double.isNaN(coordinates.x) || Double.isNaN(coordinates.y)) {\n-      return factory.createPoint();\n-    }\n-    return factory.createPoint(coordinates);\n-  }\n-\n-  private Coordinate readCoordinate(ByteBuffer byteBuffer) {\n-    return new Coordinate(byteBuffer.getDouble(), byteBuffer.getDouble());\n-  }\n-\n-  private Coordinate[] readCoordinates(ByteBuffer byteBuffer, int count) {\n-    Objects.requireNonNull(byteBuffer, \"input is null\");\n-    Verify.verify(count > 0);\n-    Coordinate[] coordinates = new Coordinate[count];\n-    for (int i = 0; i < count; i++) {\n-      coordinates[i] = readCoordinate(byteBuffer);\n-    }\n-    return coordinates;\n-  }\n-\n-  private Geometry readMultiPoint(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    int pointCount = byteBuffer.getInt();\n-    Point[] points = new Point[pointCount];\n-    for (int i = 0; i < pointCount; i++) {\n-      points[i] = readPoint(byteBuffer, factory);\n-    }\n-    return factory.createMultiPoint(points);\n-  }\n-\n-  private GeometryType readGeometryType(byte typeByte) {\n-    return GeometryType.fromID(typeByte & GeometryUtils.GEOGRAPHY_GET_MASK);\n-  }\n-\n-  private Geometry readPolyline(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiLineString();\n-      }\n-      return factory.createLineString();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LineString[] lineStrings = new LineString[partCount];\n-\n-    for (int i = 0; i < partCount; i++) {\n-      lineStrings[i] = factory.createLineString(readCoordinates(byteBuffer, partLengths[i]));\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiLineString(lineStrings);\n-    }\n-    Verify.verify(lineStrings.length == 1);\n-    return lineStrings[0];\n-  }\n-\n-  private Geometry readPolygon(ByteBuffer byteBuffer, boolean multitype, GeometryFactory factory) {\n-    int partCount = byteBuffer.getInt();\n-    if (partCount == 0) {\n-      if (multitype) {\n-        return factory.createMultiPolygon();\n-      }\n-      return factory.createPolygon();\n-    }\n-\n-    int pointCount = byteBuffer.getInt();\n-    int[] startIndexes = new int[partCount];\n-    for (int i = 0; i < partCount; i++) {\n-      startIndexes[i] = byteBuffer.getInt();\n-    }\n-\n-    int[] partLengths = new int[partCount];\n-    if (partCount > 1) {\n-      partLengths[0] = startIndexes[1];\n-      for (int i = 1; i < partCount - 1; i++) {\n-        partLengths[i] = startIndexes[i + 1] - startIndexes[i];\n-      }\n-    }\n-    partLengths[partCount - 1] = pointCount - startIndexes[partCount - 1];\n-\n-    LinearRing shell = null;\n-    List<LinearRing> holes = new ArrayList<>();\n-    List<Polygon> polygons = new ArrayList<>();\n-    try {\n-      for (int i = 0; i < partCount; i++) {\n-        Coordinate[] coordinates = readCoordinates(byteBuffer, partLengths[i]);\n-        if (isClockwise(coordinates)) {\n-          // next polygon has started\n-          if (shell != null) {\n-            polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-            holes.clear();\n-          }\n-          shell = factory.createLinearRing(coordinates);\n-        } else {\n-          holes.add(factory.createLinearRing(coordinates));\n-        }\n-      }\n-      polygons.add(factory.createPolygon(shell, holes.toArray(new LinearRing[0])));\n-    } catch (IllegalArgumentException e) {\n-      throw new TopologyException(\"Error constructing Polygon: \" + e.getMessage());\n-    }\n-\n-    if (multitype) {\n-      return factory.createMultiPolygon(polygons.toArray(new Polygon[0]));\n-    }\n-    return Iterables.getOnlyElement(polygons);\n-  }\n-\n-  private Geometry readGeometryCollection(ByteBuffer byteBuffer, GeometryFactory factory) {\n-    List<Geometry> geometries = new ArrayList<>();\n-    while (true) {\n-      if (!byteBuffer.hasRemaining()) {\n-        break;\n-      }\n-      byte typeByte = byteBuffer.get();\n-      GeometryType type = readGeometryType(typeByte);\n-      GeometryFactory geometryFactory = getGeometryFactory(typeByte);\n-      geometries.add(readGeometry(byteBuffer, type, geometryFactory));\n-    }\n-    return factory.createGeometryCollection(geometries.toArray(new Geometry[0]));\n-  }\n-\n-  private boolean isClockwise(Coordinate[] coordinates) {\n-    return isClockwise(coordinates, 0, coordinates.length);\n-  }\n-\n-  private static boolean isClockwise(Coordinate[] coordinates, int start, int end) {\n-    // Sum over the edges: (x2 \u2212 x1) * (y2 + y1).\n-    // If the result is positive the curve is clockwise,\n-    // if it's negative the curve is counter-clockwise.\n-    double area = 0;\n-    for (int i = start + 1; i < end; i++) {\n-      area += (coordinates[i].x - coordinates[i - 1].x) * (coordinates[i].y + coordinates[i - 1].y);\n-    }\n-    area += (coordinates[start].x - coordinates[end - 1].x) * (coordinates[start].y + coordinates[end - 1].y);\n-    return area > 0;\n-  }\n-\n-  private GeometryFactory getGeometryFactory(byte typeByte) {\n-    return typeByte < 0 ? GeometryUtils.GEOGRAPHY_FACTORY : GeometryUtils.GEOMETRY_FACTORY;\n-  }\n-\n-  private void writeGeometryByteBuffer(ByteBuffer byteBuffer, Geometry geometry) {\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        writePoint(byteBuffer, (Point) geometry);\n-        break;\n-      case \"MultiPoint\":\n-        writeMultiPoint(byteBuffer, (MultiPoint) geometry);\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        writePolyline(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        writePolyline(byteBuffer, geometry, true);\n-        break;\n-      case \"Polygon\":\n-        writePolygon(byteBuffer, geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        writePolygon(byteBuffer, geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        writeGeometryCollection(byteBuffer, geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-  }\n-\n-  private int getByteSize(Geometry geometry) {\n-    int size = TYPE_SIZE;\n-    switch (geometry.getGeometryType()) {\n-      case \"Point\":\n-        size += COORDINATE_SIZE;\n-        break;\n-      case \"MultiPoint\":\n-        size += Integer.BYTES + geometry.getNumPoints() * COORDINATE_SIZE;\n-        break;\n-      case \"LineString\":\n-      case \"LinearRing\":\n-        // LinearRings are a subclass of LineString\n-        size += getPolylineByteSize(geometry, false);\n-        break;\n-      case \"MultiLineString\":\n-        size += getPolylineByteSize(geometry, true);\n-        break;\n-      case \"Polygon\":\n-        size += getPolygonByteSize(geometry, false);\n-        break;\n-      case \"MultiPolygon\":\n-        size += getPolygonByteSize(geometry, true);\n-        break;\n-      case \"GeometryCollection\":\n-        size += getGeometryCollectionByteSize(geometry);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported geometry type : \" + geometry.getGeometryType());\n-    }\n-    return size;\n-  }\n-\n-  private void writeType(ByteBuffer byteBuffer, GeometryType serializationType, int SRID) {\n-    byte type = Integer.valueOf(serializationType.id()).byteValue();\n-    if (SRID == GeometryUtils.GEOGRAPHY_SRID) {\n-      type |= GeometryUtils.GEOGRAPHY_SET_MASK;\n-    }\n-    byteBuffer.put(type);\n-  }\n-\n-  /**\n-   * Writes the byte of type, followed by the two coordinates in double.\n-   */\n-  private void writePoint(ByteBuffer byteBuffer, Point point) {\n-    writeType(byteBuffer, GeometryType.POINT, point.getSRID());\n-    if (point.isEmpty()) {\n-      byteBuffer.putDouble(Double.NaN);\n-      byteBuffer.putDouble(Double.NaN);\n-    } else {\n-      writeCoordinate(byteBuffer, point.getCoordinate());\n-    }\n-  }\n-\n-  private void writeCoordinate(ByteBuffer byteBuffer, Coordinate coordinate) {\n-    byteBuffer.putDouble(coordinate.getX());\n-    byteBuffer.putDouble(coordinate.getY());\n-  }\n-\n-  /**\n-   * Writes the byte of type, number of points in int, followed by the collection of points\n-   */\n-  private void writeMultiPoint(ByteBuffer byteBuffer, MultiPoint geometry) {\n-    writeType(byteBuffer, GeometryType.MULTI_POINT, geometry.getSRID());\n-    byteBuffer.putInt(geometry.getNumPoints());\n-    for (Coordinate coordinate : geometry.getCoordinates()) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolylineByteSize(Geometry geometry, boolean multitype) {\n-    int numPoints = geometry.getNumPoints();\n-    int numParts = multitype ? geometry.getNumGeometries() : numPoints > 0 ? 1 : 0;\n-    return Integer.BYTES + Integer.BYTES + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by collection of coordinates\n-   */\n-  private void writePolyline(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numParts;\n-    int numPoints = geometry.getNumPoints();\n-    if (multitype) {\n-      numParts = geometry.getNumGeometries();\n-      writeType(byteBuffer, GeometryType.MULTI_LINE_STRING, geometry.getSRID());\n-    } else {\n-      numParts = numPoints > 0 ? 1 : 0;\n-      writeType(byteBuffer, GeometryType.LINE_STRING, geometry.getSRID());\n-    }\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    int partIndex = 0;\n-    for (int i = 0; i < numParts; i++) {\n-      byteBuffer.putInt(partIndex);\n-      partIndex += geometry.getGeometryN(i).getNumPoints();\n-    }\n-\n-    writeCoordinates(byteBuffer, geometry.getCoordinates());\n-  }\n-\n-  private void writeCoordinates(ByteBuffer byteBuffer, Coordinate[] coordinates) {\n-    for (Coordinate coordinate : coordinates) {\n-      writeCoordinate(byteBuffer, coordinate);\n-    }\n-  }\n-\n-  private int getPolygonByteSize(Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-    int size = Integer.BYTES + Integer.BYTES;\n-    if (numParts == 0) {\n-      return size;\n-    }\n-    return size + numParts * Integer.BYTES + numPoints * COORDINATE_SIZE;\n-  }\n-\n-  /**\n-   * Writes the byte of type, the number of parts in int, number of points in int, followed by collection of part index\n-   * in int, followed by the canonicalized coordinates.\n-   */\n-  private void writePolygon(ByteBuffer byteBuffer, Geometry geometry, boolean multitype) {\n-    int numGeometries = geometry.getNumGeometries();\n-    int numParts = 0;\n-    int numPoints = geometry.getNumPoints();\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-      if (polygon.getNumPoints() > 0) {\n-        numParts += polygon.getNumInteriorRing() + 1;\n-      }\n-    }\n-\n-    if (multitype) {\n-      writeType(byteBuffer, GeometryType.MULTI_POLYGON, geometry.getSRID());\n-    } else {\n-      writeType(byteBuffer, GeometryType.POLYGON, geometry.getSRID());\n-    }\n-\n-    byteBuffer.putInt(numParts);\n-    byteBuffer.putInt(numPoints);\n-\n-    if (numParts == 0) {\n-      return;\n-    }\n-\n-    int[] partIndexes = new int[numParts];\n-    boolean[] shellPart = new boolean[numParts];\n-\n-    int currentPart = 0;\n-    int currentPoint = 0;\n-    for (int i = 0; i < numGeometries; i++) {\n-      Polygon polygon = (Polygon) geometry.getGeometryN(i);\n-\n-      partIndexes[currentPart] = currentPoint;\n-      shellPart[currentPart] = true;\n-      currentPart++;\n-      currentPoint += polygon.getExteriorRing().getNumPoints();\n-\n-      int holesCount = polygon.getNumInteriorRing();\n-      for (int holeIndex = 0; holeIndex < holesCount; holeIndex++) {\n-        partIndexes[currentPart] = currentPoint;\n-        shellPart[currentPart] = false;\n-        currentPart++;\n-        currentPoint += polygon.getInteriorRingN(holeIndex).getNumPoints();\n-      }\n-    }\n-\n-    for (int partIndex : partIndexes) {\n-      byteBuffer.putInt(partIndex);\n-    }\n-\n-    Coordinate[] coordinates = geometry.getCoordinates();\n-    canonicalizePolygonCoordinates(coordinates, partIndexes, shellPart);\n-    writeCoordinates(byteBuffer, coordinates);\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int[] partIndexes, boolean[] shellPart) {\n-    for (int part = 0; part < partIndexes.length - 1; part++) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[part], partIndexes[part + 1], shellPart[part]);\n-    }\n-    if (partIndexes.length > 0) {\n-      canonicalizePolygonCoordinates(coordinates, partIndexes[partIndexes.length - 1], coordinates.length,\n-          shellPart[partIndexes.length - 1]);\n-    }\n-  }\n-\n-  private void canonicalizePolygonCoordinates(Coordinate[] coordinates, int start, int end, boolean isShell) {\n-    boolean isClockwise = isClockwise(coordinates, start, end);\n-\n-    if ((isShell && !isClockwise) || (!isShell && isClockwise)) {\n-      // shell has to be counter clockwise\n-      reverse(coordinates, start, end);\n-    }\n-  }\n-\n-  private void reverse(Coordinate[] coordinates, int start, int end) {\n-    Verify.verify(start <= end, \"start must be less or equal than end\");\n-    for (int i = start; i < start + ((end - start) / 2); i++) {\n-      Coordinate buffer = coordinates[i];\n-      coordinates[i] = coordinates[start + end - i - 1];\n-      coordinates[start + end - i - 1] = buffer;\n-    }\n-  }\n-\n-  private int getGeometryCollectionByteSize(Geometry collection) {\n-    int size = 0;\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      size += getByteSize(geometry);\n-    }\n-    return size;\n-  }\n-\n-  private void writeGeometryCollection(ByteBuffer byteBuffer, Geometry collection) {\n-    writeType(byteBuffer, GeometryType.GEOMETRY_COLLECTION, collection.getSRID());\n-    for (int geometryIndex = 0; geometryIndex < collection.getNumGeometries(); geometryIndex++) {\n-      Geometry geometry = collection.getGeometryN(geometryIndex);\n-      writeGeometryByteBuffer(byteBuffer, geometry);\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxODcyMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459018723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:04:46Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ConstructFromTextFunction.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.operator.transform.function.BaseTransformFunction;\n+import org.apache.pinot.core.operator.transform.function.TransformFunction;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.WKTReader;\n+\n+\n+/**\n+ * An abstract class for implementing the geo constructor functions from text.\n+ */\n+abstract class ConstructFromTextFunction extends BaseTransformFunction {\n+  protected TransformFunction _transformFunction;\n+  protected byte[][] _results;\n+  protected WKTReader _reader;\n+\n+  @Override\n+  public void init(List<TransformFunction> arguments, Map<String, DataSource> dataSourceMap) {\n+    Preconditions\n+        .checkArgument(arguments.size() == 1, \"Exactly 1 argument is required for transform function: %s\", getName());\n+    TransformFunction transformFunction = arguments.get(0);\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().isSingleValue(),\n+        \"The argument must be single-valued for transform function: %s\", getName());\n+    Preconditions.checkArgument(transformFunction.getResultMetadata().getDataType() == FieldSpec.DataType.STRING,\n+        \"The argument must be of string type\");\n+    _transformFunction = transformFunction;\n+    _reader = new WKTReader(getGeometryFactory());\n+  }\n+\n+  abstract protected GeometryFactory getGeometryFactory();\n+\n+  @Override\n+  public TransformResultMetadata getResultMetadata() {\n+    return BYTES_SV_NO_DICTIONARY_METADATA;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMDIyOA==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459020228", "bodyText": "(Major) Should this be GEOGRAPHY_FACTORY for longitude and latitude?", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:07:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import org.apache.pinot.common.function.annotations.ScalarFunction;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.io.WKTWriter;\n+\n+\n+/**\n+ * Geospatial scalar functions that can be used in transformation.\n+ */\n+public class ScalarFunctions {\n+\n+  /**\n+   * Creates a point.\n+   *\n+   * @param longitude longitude\n+   * @param latitude latitude\n+   * @return the created point\n+   */\n+  @ScalarFunction\n+  public static byte[] stPoint(double longitude, double latitude) {\n+    return GeometrySerializer\n+        .serialize(GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(longitude, latitude)));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE4MzczMw==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459183733", "bodyText": "good point. Changed the argument to x,y", "author": "yupeng9", "createdAt": "2020-07-23T02:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyMDIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java\nindex 7bae618d11..17f1bd071c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/ScalarFunctions.java\n\n@@ -33,14 +33,14 @@ public class ScalarFunctions {\n   /**\n    * Creates a point.\n    *\n-   * @param longitude longitude\n-   * @param latitude latitude\n+   * @param x x\n+   * @param y y\n    * @return the created point\n    */\n   @ScalarFunction\n-  public static byte[] stPoint(double longitude, double latitude) {\n+  public static byte[] stPoint(double x, double y) {\n     return GeometrySerializer\n-        .serialize(GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(longitude, latitude)));\n+        .serialize(GeometryUtils.GEOMETRY_FACTORY.createPoint(new Coordinate(x, y)));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAyODkyMg==", "url": "https://github.com/apache/pinot/pull/5654#discussion_r459028922", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Utils.rethrowException(\n          \n          \n            \n                        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n          \n          \n            \n                    throw new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));", "author": "Jackie-Jiang", "createdAt": "2020-07-22T19:23:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.geospatial.transform.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.EnumSet;\n+import org.apache.pinot.common.Utils;\n+import org.apache.pinot.core.geospatial.GeometryUtils;\n+import org.apache.pinot.core.geospatial.serde.GeometrySerializer;\n+import org.apache.pinot.core.operator.blocks.ProjectionBlock;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Polygon;\n+import org.locationtech.jts.io.ParseException;\n+\n+\n+/**\n+ * Constructor function for polygon object from text.\n+ */\n+public class StPolygonFunction extends ConstructFromTextFunction {\n+  public static final String FUNCTION_NAME = \"ST_Polygon\";\n+\n+  @Override\n+  protected GeometryFactory getGeometryFactory() {\n+    return GeometryUtils.GEOMETRY_FACTORY;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return FUNCTION_NAME;\n+  }\n+\n+  @Override\n+  public byte[][] transformToBytesValuesSV(ProjectionBlock projectionBlock) {\n+    if (_results == null) {\n+      _results = new byte[DocIdSetPlanNode.MAX_DOC_PER_CALL][];\n+    }\n+    String[] argumentValues = _transformFunction.transformToStringValuesSV(projectionBlock);\n+    int length = projectionBlock.getNumDocs();\n+    for (int i = 0; i < length; i++) {\n+      try {\n+        Geometry geometry = _reader.read(argumentValues[i]);\n+        Preconditions.checkArgument(geometry instanceof Polygon, \"The geometry object must be polygon\");\n+        _results[i] = GeometrySerializer.serialize(geometry);\n+      } catch (ParseException e) {\n+        Utils.rethrowException(\n+            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));", "originalCommit": "b3bfad3c0f56c6957eb88f4b55e28fa59fefc6bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d6285fc24af3b6869ba865c20205d91f38bb958", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\nindex 7b7bc091e1..77a80fc4ae 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/geospatial/transform/function/StPolygonFunction.java\n\n@@ -60,8 +60,7 @@ public class StPolygonFunction extends ConstructFromTextFunction {\n         Preconditions.checkArgument(geometry instanceof Polygon, \"The geometry object must be polygon\");\n         _results[i] = GeometrySerializer.serialize(geometry);\n       } catch (ParseException e) {\n-        Utils.rethrowException(\n-            new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i])));\n+        new RuntimeException(String.format(\"Failed to parse geometry from string: %s\", argumentValues[i]));\n       }\n     }\n     return _results;\n"}}, {"oid": "0d6285fc24af3b6869ba865c20205d91f38bb958", "url": "https://github.com/apache/pinot/commit/0d6285fc24af3b6869ba865c20205d91f38bb958", "message": "more comments", "committedDate": "2020-07-23T02:44:01Z", "type": "commit"}]}