{"pr_number": 5828, "pr_title": "Improving retention manager to handle segment lineage clean-up", "pr_createdAt": "2020-08-07T10:51:15Z", "pr_url": "https://github.com/apache/pinot/pull/5828", "timeline": [{"oid": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "url": "https://github.com/apache/pinot/commit/b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "message": "Improving retention manager to handle segment lineage clean-up\n\n1. Added the logic to handle segment lineage clean-up in the\n   retention manager.\n2. Added the unit test", "committedDate": "2020-08-07T10:50:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MzExNg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467173116", "bodyText": "Don't log this as this can flood the log for large cluster", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:26:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1Mjg3Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467352877", "bodyText": "removed", "author": "snleee", "createdAt": "2020-08-08T02:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3MzExNg=="}], "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NDM1Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467174357", "bodyText": "Remove the null check which is redundant", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:29:02Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDk5OA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467180998", "bodyText": "Don't use Assert, use Preconditions instead", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:42:57Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1Mjk0MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467352941", "bodyText": "Good catch. I was writing a testing code right before I wrote this part :)", "author": "snleee", "createdAt": "2020-08-08T02:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467181564", "bodyText": "This won't give you the up-to-date segment list because we delay the deletion of segment ZK metadata", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:44:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4Mjk3Mg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182972", "bodyText": "The lineage deletion can be handled along with the segment deletion", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1MzY5MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467353691", "bodyText": "Changed the logic to handle together.", "author": "snleee", "createdAt": "2020-08-08T03:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MTU2NA=="}], "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467182434", "bodyText": "Can we directly remove the lineage entry here? Why do we need to wait for all merged segments also being removed?", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:45:54Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);\n+          }\n+        }\n+\n+        // Write back to the lineage entry\n+        return SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+      });\n+    } catch (Exception e) {\n+      String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n+      LOGGER.error(errorMsg, e);\n+      throw new RuntimeException(errorMsg, e);\n+    }\n+    LOGGER.info(\"Segment lineage metadata clean-up is successfully processed for table: {}\", tableNameWithType);\n+  }\n+\n+  /**\n+   * Compute the segments that can be safely deleted based on the segment lineage.\n+   *\n+   * 1. The original segments can be deleted once the merged segments are successfully uploaded.\n+   * 2. If the segmentReplacement operation fails in the middle, there can be a case where partial segments are\n+   *    uploaded to the table. We should periodically clean up those zombie segments.\n+   */\n+  private List<String> computeSegmentsToDeleteFromSegmentLineage(SegmentLineage segmentLineage) {\n+    if (segmentLineage != null) {\n+      List<String> segmentsToDelete = new ArrayList<>();\n+      for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+        LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+        if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+          // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+          segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1MzY2NQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467353665", "bodyText": "I initially was thinking of the race condition.\n\nRetention manager invoke delete segments (happens with some delay in the background)\nRetention manager writes new lineage segment to ZK (this update happens first)\nbroker updates the routing table before segments get deleted.\n\nIn this case, it's possible that we may route the query to the original segments for the short term. How do you think on this?", "author": "snleee", "createdAt": "2020-08-08T03:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1NjM4Mg==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467356382", "bodyText": "Actually, if we don't send out the routing table refresh message explicitly, the routing table rebuild will only get triggered after the segment gets deleted. So, it will always be the following sequence:\n\nRetention manager deletes segments, update segment lineage metadata (one of 2 operation can happen earlier).\nBroker side routing table updates will only happen after the segment is deleted (by EV change).\n\nAs long as we have the guarantee that the routing table gets updated after the segment is deleted, we are good.", "author": "snleee", "createdAt": "2020-08-08T03:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUwMzIxMA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467503210", "bodyText": "Good point. In this case, we should always delete the lineage entry only if the segments are already deleted (for both COMPLETED and IN_PROGRESS).\nThe logic should be:\nIf any of the segments (segmentsFrom for COMPLETED and segmentsTo for IN_PROGRESS) still exists, delete the existing segments; if they are all already deleted, delete the lineage entry.", "author": "Jackie-Jiang", "createdAt": "2020-08-08T20:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczMjQ3Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467732477", "bodyText": "@Jackie-Jiang For checking whether the segment is deleted, do you think checking getSegmentsFor(tableName) <- looks at segment zk metadata is good enough? Or checking idealstate is preferred?", "author": "snleee", "createdAt": "2020-08-10T07:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2NjMzNw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468066337", "bodyText": "@snleee Checking ZK metadata is fine. That can prevent leaving orphan segment ZK metadata", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDY1MQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200651", "bodyText": "Sounds good.", "author": "snleee", "createdAt": "2020-08-10T21:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MzI4Mw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467183283", "bodyText": "This part is wrong. This will remove the real in-progress lineage", "author": "Jackie-Jiang", "createdAt": "2020-08-07T17:47:35Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,87 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // Delete segments based on the segment lineage\n+        PinotResourceManagerResponse response = _pinotHelixResourceManager\n+            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n+\n+        Assert.assertTrue(response.isSuccessful());\n+\n+        // Fetch available segments for the table\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+\n+        // Clean up the segment lineage\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // Zombie lineage entry is safe to remove. This will allow the task scheduler to re-schedule the\n+            // source segments to be merged again.\n+            segmentLineage.deleteLineageEntry(lineageEntryId);", "originalCommit": "b8fbed339339a04ecb47b49fabc7fe9e3fc77a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM1NjQ0Nw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r467356447", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-08-08T03:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MzI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "92635d800638f2a807919c912bffefc3d94d7686", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex dbe2cd8ab7..37cef9ca05 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -201,25 +201,21 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n             .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n         if (segmentLineageZNRecord == null) {\n-          LOGGER.info(\"Segment lineage does not exist for table: {}\", tableNameWithType);\n           return true;\n         }\n         SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n         int expectedVersion = segmentLineageZNRecord.getVersion();\n \n-        // Delete segments based on the segment lineage\n-        PinotResourceManagerResponse response = _pinotHelixResourceManager\n-            .deleteSegments(tableNameWithType, computeSegmentsToDeleteFromSegmentLineage(segmentLineage));\n-\n-        Assert.assertTrue(response.isSuccessful());\n-\n-        // Fetch available segments for the table\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the upload protocol failed in the middle\n         Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n-\n-        // Clean up the segment lineage\n+        List<String> segmentsToDelete = new ArrayList<>();\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n             // The lineage entry for 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n             // are all removed from the table.\n             if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n"}}, {"oid": "92635d800638f2a807919c912bffefc3d94d7686", "url": "https://github.com/apache/pinot/commit/92635d800638f2a807919c912bffefc3d94d7686", "message": "Addressing comments", "committedDate": "2020-08-08T03:41:53Z", "type": "forcePushed"}, {"oid": "9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "url": "https://github.com/apache/pinot/commit/9a35e7ae53dcefd59cf2c2d3a14074b06d918802", "message": "Addressing comments", "committedDate": "2020-08-08T03:43:20Z", "type": "forcePushed"}, {"oid": "2a5b3d491ad5201f1460d0272d92c65f74717904", "url": "https://github.com/apache/pinot/commit/2a5b3d491ad5201f1460d0272d92c65f74717904", "message": "Addressing comments", "committedDate": "2020-08-10T07:49:57Z", "type": "forcePushed"}, {"oid": "8bf18a75012e905f379a3a292099ad6333591af1", "url": "https://github.com/apache/pinot/commit/8bf18a75012e905f379a3a292099ad6333591af1", "message": "Addressing comments", "committedDate": "2020-08-10T07:55:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3MjcwOQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468072709", "bodyText": "We can simplify the logic as following, same for IN_PROGRESS\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n          \n          \n            \n            \n          \n          \n            \n                        // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n          \n          \n            \n                        // are all removed from the table.\n          \n          \n            \n                        if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n          \n          \n            \n                            .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        }\n          \n          \n            \n                        Set<String> sourceSegments = new HashSet<>(lineageEntry.getSegmentsFrom());\n          \n          \n            \n                        sourceSegments.retainAll(segmentsForTable);\n          \n          \n            \n                        if (sourceSegments.isEmpty()) {\n          \n          \n            \n                          segmentLineage.deleteLineageEntry(lineageEntryId);\n          \n          \n            \n                        } else {\n          \n          \n            \n                          segmentsToDelete.addAll(sourceSegments);\n          \n          \n            \n                        }", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:45:05Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }", "originalCommit": "8bf18a75012e905f379a3a292099ad6333591af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDUzMA==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200530", "bodyText": "Changed. Please double check the logic for IN_PROGRESS as well.", "author": "snleee", "createdAt": "2020-08-10T21:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3MjcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex a9c9c89485..7b53ad6e8c 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -214,36 +213,43 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n-            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n-            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n-\n-            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n-            // are all removed from the table.\n-            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n-                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+            Set<String> sourceSegments = new HashSet<>(lineageEntry.getSegmentsFrom());\n+            sourceSegments.retainAll(segmentsForTable);\n+            if (sourceSegments.isEmpty()) {\n+              // If the lineage state is 'COMPLETED' and segmentFrom are removed, it is safe clean up\n+              // the lineage entry\n               segmentLineage.deleteLineageEntry(lineageEntryId);\n+            } else {\n+              // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+              segmentsToDelete.addAll(sourceSegments);\n             }\n           } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n             // If the lineage state is 'IN_PROGRESS', we need to clean up the zombie lineage entry and its segments\n             if (lineageEntry.getTimestamp() < System.currentTimeMillis() - LINEAGE_ENTRY_CLEANUP_RETENTION_IN_MILLIS) {\n-              segmentsToDelete.addAll(lineageEntry.getSegmentsTo());\n-\n-              // The lineage entry with 'IN_PROGRESS' state can only be safely removed when segmentTo are all removed\n-              // from the table. Deleting lineage will allow the task scheduler to re-schedule the source segments to\n-              // be merged again.\n-              if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              Set<String> destinationSegments = new HashSet<>(lineageEntry.getSegmentsTo());\n+              destinationSegments.retainAll(segmentsForTable);\n+              if (destinationSegments.isEmpty()) {\n+                // If the lineage state is 'IN_PROGRESS' and source segments are already removed, it is safe to clean up\n+                // the lineage entry. Deleting lineage will allow the task scheduler to re-schedule the source segments\n+                // to be merged again.\n                 segmentLineage.deleteLineageEntry(lineageEntryId);\n+              } else {\n+                // If the lineage state is 'IN_PROGRESS', it is safe to delete all segments from 'segmentsTo'\n+                segmentsToDelete.addAll(destinationSegments);\n               }\n             }\n           }\n         }\n \n-        // Delete segments based on the segment lineage\n-        _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);\n-\n         // Write back to the lineage entry\n-        return SegmentLineageAccessHelper\n-            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+        if (SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion)) {\n+          // Delete segments based on the segment lineage\n+          _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);\n+          return true;\n+        } else {\n+          return false;\n+        }\n       });\n     } catch (Exception e) {\n       String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3NzY4Mw==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468077683", "bodyText": "We might want to delete segments after successfully writing back the lineage, or the segment might be deleted without updating the lineage", "author": "Jackie-Jiang", "createdAt": "2020-08-10T17:53:32Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java", "diffHunk": "@@ -177,4 +193,63 @@ private boolean shouldDeleteInProgressLLCSegment(String segmentName, IdealState\n       return states.size() == 1 && states.contains(CommonConstants.Helix.StateModel.SegmentStateModel.OFFLINE);\n     }\n   }\n+\n+  private void manageSegmentLineageCleanupForTable(String tableNameWithType) {\n+    try {\n+      DEFAULT_RETRY_POLICY.attempt(() -> {\n+        // Fetch segment lineage\n+        ZNRecord segmentLineageZNRecord = SegmentLineageAccessHelper\n+            .getSegmentLineageZNRecord(_pinotHelixResourceManager.getPropertyStore(), tableNameWithType);\n+        if (segmentLineageZNRecord == null) {\n+          return true;\n+        }\n+        SegmentLineage segmentLineage = SegmentLineage.fromZNRecord(segmentLineageZNRecord);\n+        int expectedVersion = segmentLineageZNRecord.getVersion();\n+\n+        // 1. The original segments can be deleted once the merged segments are successfully uploaded\n+        // 2. The zombie lineage entry & merged segments should be deleted if the segment replacement failed in\n+        //    the middle\n+        Set<String> segmentsForTable = new HashSet<>(_pinotHelixResourceManager.getSegmentsFor(tableNameWithType));\n+        List<String> segmentsToDelete = new ArrayList<>();\n+        for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n+          LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n+          if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n+            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n+\n+            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n+            // are all removed from the table.\n+            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n+                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              segmentLineage.deleteLineageEntry(lineageEntryId);\n+            }\n+          } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n+            // If the lineage state is 'IN_PROGRESS', we need to clean up the zombie lineage entry and its segments\n+            if (lineageEntry.getTimestamp() < System.currentTimeMillis() - LINEAGE_ENTRY_CLEANUP_RETENTION_IN_MILLIS) {\n+              segmentsToDelete.addAll(lineageEntry.getSegmentsTo());\n+\n+              // The lineage entry with 'IN_PROGRESS' state can only be safely removed when segmentTo are all removed\n+              // from the table. Deleting lineage will allow the task scheduler to re-schedule the source segments to\n+              // be merged again.\n+              if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+                segmentLineage.deleteLineageEntry(lineageEntryId);\n+              }\n+            }\n+          }\n+        }\n+\n+        // Delete segments based on the segment lineage\n+        _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);", "originalCommit": "8bf18a75012e905f379a3a292099ad6333591af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMDMzOQ==", "url": "https://github.com/apache/pinot/pull/5828#discussion_r468200339", "bodyText": "fixed", "author": "snleee", "createdAt": "2020-08-10T21:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3NzY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\nindex a9c9c89485..7b53ad6e8c 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/retention/RetentionManager.java\n\n@@ -214,36 +213,43 @@ public class RetentionManager extends ControllerPeriodicTask<Void> {\n         for (String lineageEntryId : segmentLineage.getLineageEntryIds()) {\n           LineageEntry lineageEntry = segmentLineage.getLineageEntry(lineageEntryId);\n           if (lineageEntry.getState() == LineageEntryState.COMPLETED) {\n-            // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n-            segmentsToDelete.addAll(lineageEntry.getSegmentsFrom());\n-\n-            // The lineage entry with 'COMPLETED' state can only be safely removed when both segmentFrom & segmentTo\n-            // are all removed from the table.\n-            if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsFrom()) && Collections\n-                .disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+            Set<String> sourceSegments = new HashSet<>(lineageEntry.getSegmentsFrom());\n+            sourceSegments.retainAll(segmentsForTable);\n+            if (sourceSegments.isEmpty()) {\n+              // If the lineage state is 'COMPLETED' and segmentFrom are removed, it is safe clean up\n+              // the lineage entry\n               segmentLineage.deleteLineageEntry(lineageEntryId);\n+            } else {\n+              // If the lineage state is 'COMPLETED', it is safe to delete all segments from 'segmentsFrom'\n+              segmentsToDelete.addAll(sourceSegments);\n             }\n           } else if (lineageEntry.getState() == LineageEntryState.IN_PROGRESS) {\n             // If the lineage state is 'IN_PROGRESS', we need to clean up the zombie lineage entry and its segments\n             if (lineageEntry.getTimestamp() < System.currentTimeMillis() - LINEAGE_ENTRY_CLEANUP_RETENTION_IN_MILLIS) {\n-              segmentsToDelete.addAll(lineageEntry.getSegmentsTo());\n-\n-              // The lineage entry with 'IN_PROGRESS' state can only be safely removed when segmentTo are all removed\n-              // from the table. Deleting lineage will allow the task scheduler to re-schedule the source segments to\n-              // be merged again.\n-              if (Collections.disjoint(segmentsForTable, lineageEntry.getSegmentsTo())) {\n+              Set<String> destinationSegments = new HashSet<>(lineageEntry.getSegmentsTo());\n+              destinationSegments.retainAll(segmentsForTable);\n+              if (destinationSegments.isEmpty()) {\n+                // If the lineage state is 'IN_PROGRESS' and source segments are already removed, it is safe to clean up\n+                // the lineage entry. Deleting lineage will allow the task scheduler to re-schedule the source segments\n+                // to be merged again.\n                 segmentLineage.deleteLineageEntry(lineageEntryId);\n+              } else {\n+                // If the lineage state is 'IN_PROGRESS', it is safe to delete all segments from 'segmentsTo'\n+                segmentsToDelete.addAll(destinationSegments);\n               }\n             }\n           }\n         }\n \n-        // Delete segments based on the segment lineage\n-        _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);\n-\n         // Write back to the lineage entry\n-        return SegmentLineageAccessHelper\n-            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion);\n+        if (SegmentLineageAccessHelper\n+            .writeSegmentLineage(_pinotHelixResourceManager.getPropertyStore(), segmentLineage, expectedVersion)) {\n+          // Delete segments based on the segment lineage\n+          _pinotHelixResourceManager.deleteSegments(tableNameWithType, segmentsToDelete);\n+          return true;\n+        } else {\n+          return false;\n+        }\n       });\n     } catch (Exception e) {\n       String errorMsg = String.format(\"Failed to clean up the segment lineage. (tableName = %s)\", tableNameWithType);\n"}}, {"oid": "7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "url": "https://github.com/apache/pinot/commit/7dc5b3b9cd3bae1e44dbac7a51cd5cf57d16e50d", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:21Z", "type": "forcePushed"}, {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:58Z", "type": "commit"}, {"oid": "3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "url": "https://github.com/apache/pinot/commit/3a637b9271a2177f6e70c80cf64b5f6c95e36de1", "message": "Addressing comments", "committedDate": "2020-08-10T21:38:58Z", "type": "forcePushed"}]}