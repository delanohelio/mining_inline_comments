{"pr_number": 5013, "pr_title": "For RANGE predicate queries touching offline segments, use sorted inverted index if the column is sorted", "pr_createdAt": "2020-01-24T07:25:57Z", "pr_url": "https://github.com/apache/pinot/pull/5013", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370778532", "bodyText": "This had to be fixed since DaysSinceEpoch is a sorted column and will be using sorted inverted index operator and doc id set. So the number of entries scanned in filter will be 0.", "author": "siddharthteotia", "createdAt": "2020-01-24T18:30:57Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -418,7 +418,6 @@ public void testDictionaryBasedQueries()\n     pqlQuery = \"SELECT MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME + \" where DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertTrue(response.get(\"numEntriesScannedPostFilter\").asLong() > 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDYwNA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800604", "bodyText": "Can you change it to  assertEquals(response.get(\"numEntriesScannedInFilter\").asLong(), 0)?", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4OTQ4OQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370889489", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-24T23:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODUzMg=="}], "type": "inlineReview", "revised_code": {"commit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "chunk": "diff --git a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\nindex acbdeffa7b..f8ca37f1d6 100644\n--- a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\n+++ b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\n\n@@ -418,6 +418,7 @@ public class MetadataAndDictionaryAggregationPlanClusterIntegrationTest extends\n     pqlQuery = \"SELECT MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME + \" where DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertTrue(response.get(\"numEntriesScannedPostFilter\").asLong() > 0);\n+    assertEquals(response.get(\"numEntriesScannedInFilter\").asLong(), 0);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDY3Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800673", "bodyText": "Same here", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:20:51Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java", "diffHunk": "@@ -469,7 +468,6 @@ public void testMetadataBasedQueries()\n     pqlQuery = \"SELECT COUNT(*) FROM \" + DEFAULT_TABLE_NAME + \" WHERE DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertEquals(response.get(\"numEntriesScannedPostFilter\").asLong(), 0);\n-    assertTrue(response.get(\"numEntriesScannedInFilter\").asLong() > 0);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4Mzk2OQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883969", "bodyText": "My bad -- should have actually done that instead of removing. Good catch", "author": "siddharthteotia", "createdAt": "2020-01-24T23:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "chunk": "diff --git a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\nindex acbdeffa7b..f8ca37f1d6 100644\n--- a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\n+++ b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/MetadataAndDictionaryAggregationPlanClusterIntegrationTest.java\n\n@@ -468,6 +469,7 @@ public class MetadataAndDictionaryAggregationPlanClusterIntegrationTest extends\n     pqlQuery = \"SELECT COUNT(*) FROM \" + DEFAULT_TABLE_NAME + \" WHERE DaysSinceEpoch > 16100\";\n     response = postQuery(pqlQuery);\n     assertEquals(response.get(\"numEntriesScannedPostFilter\").asLong(), 0);\n+    assertEquals(response.get(\"numEntriesScannedInFilter\").asLong(), 0);\n \n     // mixed aggregation functions in query: not answered by MetadataBasedAggregationOperator\n     pqlQuery = \"SELECT COUNT(*),MAX(ArrTime) FROM \" + DEFAULT_TABLE_NAME;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDk4MQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370800981", "bodyText": "(nit) new line", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:21:34Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {\n+  private static final int NUM_ROWS = 30000;\n+\n+  private List<GenericRow> _rows = new ArrayList<>();\n+\n+  private static final String D1 = \"STRING_COL\";\n+  private static final String M1 = \"INT_COL\"; // sorted column\n+  private static final String M2 = \"LONG_COL\";\n+\n+  private static final int INT_BASE_VALUE = 0;\n+\n+  private static final String TABLE_NAME = \"TestTable\";\n+  private static final int NUM_SEGMENTS = 1;\n+  private static final String SEGMENT_NAME_1 = TABLE_NAME + \"_100000000_200000000\";\n+  private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"SortedRangeTest\");\n+\n+  private List<IndexSegment> _indexSegments = new ArrayList<>(NUM_SEGMENTS);\n+  private final String[] stringValues = new String[NUM_ROWS];\n+  private final long[] longValues = new long[NUM_ROWS];\n+\n+  private Schema _schema;\n+\n+  @BeforeClass\n+  public void setUp() {\n+    createPinotTableSchema();\n+    createTestData();\n+  }\n+\n+  @AfterClass\n+  public void tearDown() {\n+    FileUtils.deleteQuietly(INDEX_DIR);\n+  }\n+\n+  private void createPinotTableSchema() {\n+    _schema =\n+        new Schema.SchemaBuilder().setSchemaName(TABLE_NAME).addSingleValueDimension(D1, FieldSpec.DataType.STRING)\n+            .addMetric(M1, FieldSpec.DataType.INT).addMetric(M2, FieldSpec.DataType.LONG).build();\n+  }\n+\n+  private void createTestData() {\n+    Random random = new Random();\n+    for (int rowIndex = 0; rowIndex < NUM_ROWS; rowIndex++) {\n+      GenericRow row = new GenericRow();\n+      stringValues[rowIndex] = RandomStringUtils.randomAlphanumeric(10);\n+      row.putValue(D1, stringValues[rowIndex]);\n+      row.putValue(M1, INT_BASE_VALUE + rowIndex);\n+      longValues[rowIndex] = random.nextLong();\n+      row.putValue(M2, longValues[rowIndex]);\n+      _rows.add(row);\n+    }\n+  }\n+\n+  @Override\n+  protected String getFilter() {\n+    return \"\";\n+  }\n+\n+  @Override\n+  protected IndexSegment getIndexSegment() {\n+    return _indexSegments.get(0);\n+  }\n+\n+  @Override\n+  protected List<SegmentDataManager> getSegmentDataManagers() {\n+    return null;\n+  }\n+\n+  private void createSegment(Schema schema, RecordReader recordReader, String segmentName, String tableName)\n+      throws Exception {\n+    SegmentGeneratorConfig segmentGeneratorConfig = new SegmentGeneratorConfig(schema);\n+    segmentGeneratorConfig.setTableName(tableName);\n+    segmentGeneratorConfig.setOutDir(INDEX_DIR.getAbsolutePath());\n+    segmentGeneratorConfig.setSegmentName(segmentName);\n+\n+    SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+    driver.init(segmentGeneratorConfig, recordReader);\n+    driver.build();\n+\n+    File segmentIndexDir = new File(INDEX_DIR.getAbsolutePath(), segmentName);\n+    if (!segmentIndexDir.exists()) {\n+      throw new IllegalStateException(\"Segment generation failed\");\n+    }\n+  }\n+\n+  private ImmutableSegment loadSegment(String segmentName)\n+      throws Exception {\n+    return ImmutableSegmentLoader.load(new File(INDEX_DIR, segmentName), ReadMode.heap);\n+  }\n+\n+  @Test\n+  public void testInnerSegmentQuery()\n+      throws Exception {\n+    Random random = new Random();\n+    try (RecordReader recordReader = new GenericRowRecordReader(_rows, _schema)) {\n+      createSegment(_schema, recordReader, SEGMENT_NAME_1, TABLE_NAME);\n+      final ImmutableSegment immutableSegment = loadSegment(SEGMENT_NAME_1);\n+      _indexSegments.add(immutableSegment);\n+\n+      String query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 LIMIT 100000\";\n+      Pairs.IntPair pair = new Pairs.IntPair(20000, 29999);\n+      runQuery(query, 10000, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL >= 20000 AND INT_COL <= 23666 LIMIT 100000\";\n+      pair = new Pairs.IntPair(20000, 23666);\n+      runQuery(query, 3667, Lists.newArrayList(pair), 2);\n+\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable WHERE INT_COL <= 20000 LIMIT 100000\";\n+      pair = new Pairs.IntPair(0, 20000);\n+      runQuery(query, 20001, Lists.newArrayList(pair), 2);\n+\n+      String filter = \"WHERE (INT_COL >= 15000 AND INT_COL <= 16665) OR (INT_COL >= 18000 AND INT_COL <= 19887)\";\n+      query = \"SELECT STRING_COL, INT_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      pair = new Pairs.IntPair(15000, 16665);\n+      Pairs.IntPair pair1 = new Pairs.IntPair(18000, 19987);\n+      runQuery(query, 3554, Lists.newArrayList(pair, pair1), 2);\n+\n+      // range predicate on sorted column which will use sorted inverted index based iterator\n+      // along with range predicate on unsorted column that uses scan based iterator\n+      int index = random.nextInt(NUM_ROWS + 1);\n+      long longPredicateValue = longValues[index];\n+      int count = 0;\n+      List<Pairs.IntPair> pairs = new ArrayList<>();\n+      Pairs.IntPair current = null;\n+      for (int i = 0 ; i < longValues.length; i++) {\n+        if (longValues[i] >= longPredicateValue && i >= 15000 && i <= 16665) {\n+          if (current == null) {\n+            current = new Pairs.IntPair(i, i);\n+          } else {\n+            if (i == current.getRight() + 1) {\n+              current.setRight(i);\n+            } else {\n+              if (i <= longValues.length - 2) {\n+                pairs.add(current);\n+                current = new Pairs.IntPair(i, i);\n+              }\n+            }\n+          }\n+          count++;\n+        }\n+      }\n+      pairs.add(current);\n+      filter = \"WHERE INT_COL >= 15000 AND INT_COL <= 16665 AND LONG_COL >= \" + longPredicateValue;\n+      query = \"SELECT STRING_COL, INT_COL, LONG_COL FROM TestTable \" + filter + \" LIMIT 100000\";\n+      runQuery(query, count, pairs, 3);\n+    } finally {\n+      destroySegments();\n+    }\n+  }\n+\n+  private void runQuery(String query, int count, List<Pairs.IntPair> intPairs, int numColumns) {\n+    SelectionOnlyOperator operator = getOperatorForQuery(query);\n+    IntermediateResultsBlock block = operator.nextBlock();\n+    Collection<Serializable[]> rows = block.getSelectionResult();\n+    Assert.assertNotNull(rows);\n+    Assert.assertEquals(rows.size(), count);\n+    Pairs.IntPair pair = intPairs.get(0);\n+    int startPos = pair.getLeft();\n+    int pairPos = 0;\n+    for (Serializable[] row : rows) {\n+      Assert.assertEquals(numColumns, row.length);\n+      Assert.assertEquals(row[0], stringValues[startPos]);\n+      Assert.assertEquals(row[1], startPos);\n+      if (numColumns == 3) {\n+        Assert.assertEquals(row[2], longValues[startPos]);\n+      }\n+      startPos++;\n+      if (startPos > pair.getRight() && pairPos <= intPairs.size() - 2) {\n+        pairPos++;\n+        pair = intPairs.get(pairPos);\n+        startPos = pair.getLeft();\n+      }\n+    }\n+  }\n+\n+  private void destroySegments() {\n+    for (IndexSegment indexSegment : _indexSegments) {\n+      if (indexSegment != null) {\n+        indexSegment.destroy();\n+      }\n+    }\n+    _indexSegments.clear();\n+  }\n+}", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4Mzg0NQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883845", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-24T23:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java b/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java\nindex 84b66fddda..b992f879f7 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java\n\n@@ -231,4 +231,4 @@ public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {\n     }\n     _indexSegments.clear();\n   }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNTk0NA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370805944", "bodyText": "This is not efficient. We should add getStartDictId() and getEndDictId() to OfflineDictionaryBasedRangePredicateEvaluator, and directly get the start and end dict id.", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:32:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java", "diffHunk": "@@ -78,82 +79,92 @@ protected FilterBlock getNextBlock() {\n     int[] dictIds = exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n \n     if (0 < dictIds.length) {\n-      // Sort the dictIds in ascending order, so that their respective ranges are adjacent if their dictIds are adjacent\n-      Arrays.sort(dictIds);\n+      if (_predicateEvaluator instanceof RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator) {\n+        // optimized path for RANGE predicate evaluation using sorted index.\n+        // dictIds will already be sorted since we use sorted index based evaluation\n+        // for RANGE predicates only on offline segments.\n+        // so build a pair with startDocId and endDocId\n+        IntPair pair1 = invertedIndex.getDocIds(dictIds[0]);", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MjM5NA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370882394", "bodyText": "Good suggestion. Done... no need to call getMatchingDictIds", "author": "siddharthteotia", "createdAt": "2020-01-24T23:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNTk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java\nindex cb0ce38f5c..ec3a3cfe35 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedInvertedIndexBasedFilterOperator.java\n\n@@ -75,96 +76,97 @@ public class SortedInvertedIndexBasedFilterOperator extends BaseFilterOperator {\n     // range predicate relative to the cardinality. However, as adjacent ranges get merged before returning the final\n     // list of ranges, the only drawback is that we use a lot of memory during the filter block evaluation.\n \n-    boolean exclusive = _predicateEvaluator.isExclusive();\n-    int[] dictIds = exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n-\n-    if (0 < dictIds.length) {\n-      if (_predicateEvaluator instanceof RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator) {\n+      if (_predicateEvaluator instanceof OfflineDictionaryBasedRangePredicateEvaluator) {\n         // optimized path for RANGE predicate evaluation using sorted index.\n         // dictIds will already be sorted since we use sorted index based evaluation\n         // for RANGE predicates only on offline segments.\n         // so build a pair with startDocId and endDocId\n-        IntPair pair1 = invertedIndex.getDocIds(dictIds[0]);\n-        IntPair pair2 = invertedIndex.getDocIds(dictIds[dictIds.length - 1]);\n+        OfflineDictionaryBasedRangePredicateEvaluator evaluator = (OfflineDictionaryBasedRangePredicateEvaluator)_predicateEvaluator;\n+        IntPair pair1 = invertedIndex.getDocIds(evaluator.getStartDictId());\n+        IntPair pair2 = invertedIndex.getDocIds(evaluator.getEndDictId());\n         IntPair pair = new IntPair(pair1.getLeft(), pair2.getRight());\n         pairs.add(pair);\n       } else {\n-        // Sort the dictIds in ascending order, so that their respective ranges are adjacent if their dictIds are adjacent\n-        Arrays.sort(dictIds);\n-\n-        IntPair lastPair = invertedIndex.getDocIds(dictIds[0]);\n-        IntRanges.clip(lastPair, _startDocId, _endDocId);\n-\n-        for (int i = 1; i < dictIds.length; i++) {\n-          IntPair currentPair = invertedIndex.getDocIds(dictIds[i]);\n-          IntRanges.clip(currentPair, _startDocId, _endDocId);\n+        boolean exclusive = _predicateEvaluator.isExclusive();\n+        int[] dictIds = exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n+        if (0 < dictIds.length) {\n+          // Sort the dictIds in ascending order, so that their respective ranges are adjacent if their dictIds are adjacent\n+          Arrays.sort(dictIds);\n+\n+          IntPair lastPair = invertedIndex.getDocIds(dictIds[0]);\n+          IntRanges.clip(lastPair, _startDocId, _endDocId);\n+\n+          for (int i = 1; i < dictIds.length; i++) {\n+            IntPair currentPair = invertedIndex.getDocIds(dictIds[i]);\n+            IntRanges.clip(currentPair, _startDocId, _endDocId);\n+\n+            // If the previous range is degenerate, just keep the current one\n+            if (IntRanges.isInvalid(lastPair)) {\n+              lastPair = currentPair;\n+              continue;\n+            }\n \n-          // If the previous range is degenerate, just keep the current one\n-          if (IntRanges.isInvalid(lastPair)) {\n-            lastPair = currentPair;\n-            continue;\n+            // If the current range is adjacent or overlaps with the previous range, merge it into the previous range,\n+            // otherwise add the previous range and keep the current one to be added\n+            if (IntRanges.rangesAreMergeable(lastPair, currentPair)) {\n+              IntRanges.mergeIntoFirst(lastPair, currentPair);\n+            } else {\n+              if (!IntRanges.isInvalid(lastPair)) {\n+                pairs.add(lastPair);\n+              }\n+              lastPair = currentPair;\n+            }\n           }\n \n-          // If the current range is adjacent or overlaps with the previous range, merge it into the previous range,\n-          // otherwise add the previous range and keep the current one to be added\n-          if (IntRanges.rangesAreMergeable(lastPair, currentPair)) {\n-            IntRanges.mergeIntoFirst(lastPair, currentPair);\n-          } else {\n-            if (!IntRanges.isInvalid(lastPair)) {\n-              pairs.add(lastPair);\n-            }\n-            lastPair = currentPair;\n+          // Add the last range if it's valid\n+          if (!IntRanges.isInvalid(lastPair)) {\n+            pairs.add(lastPair);\n           }\n         }\n \n-        // Add the last range if it's valid\n-        if (!IntRanges.isInvalid(lastPair)) {\n-          pairs.add(lastPair);\n-        }\n-      }\n+        if (exclusive) {\n+          // If the ranges are not additive ranges, our list of pairs is a list of \"holes\" in the [startDocId; endDocId]\n+          // range. We need to take this list of pairs and invert it. To do so, there are three cases:\n+          //\n+          // - No holes, in which case the final range is [startDocId; endDocId]\n+          // - One or more hole, in which case the final ranges are [startDocId; firstHoleStartDocId - 1] and\n+          //   [lastHoleEndDocId + 1; endDocId] and ranges in between other holes\n+          List<IntPair> newPairs = new ArrayList<>();\n+          if (pairs.isEmpty()) {\n+            newPairs.add(new IntPair(_startDocId, _endDocId));\n+          } else {\n+            // Add the first filled area (between startDocId and the first hole)\n+            IntPair firstHole = pairs.get(0);\n+            IntPair firstRange = new IntPair(_startDocId, firstHole.getLeft() - 1);\n \n-      if (exclusive) {\n-        // If the ranges are not additive ranges, our list of pairs is a list of \"holes\" in the [startDocId; endDocId]\n-        // range. We need to take this list of pairs and invert it. To do so, there are three cases:\n-        //\n-        // - No holes, in which case the final range is [startDocId; endDocId]\n-        // - One or more hole, in which case the final ranges are [startDocId; firstHoleStartDocId - 1] and\n-        //   [lastHoleEndDocId + 1; endDocId] and ranges in between other holes\n-        List<IntPair> newPairs = new ArrayList<>();\n-        if (pairs.isEmpty()) {\n-          newPairs.add(new IntPair(_startDocId, _endDocId));\n-        } else {\n-          // Add the first filled area (between startDocId and the first hole)\n-          IntPair firstHole = pairs.get(0);\n-          IntPair firstRange = new IntPair(_startDocId, firstHole.getLeft() - 1);\n-\n-          if (!IntRanges.isInvalid(firstRange)) {\n-            newPairs.add(firstRange);\n-          }\n+            if (!IntRanges.isInvalid(firstRange)) {\n+              newPairs.add(firstRange);\n+            }\n \n-          // Add the filled areas between contiguous holes\n-          int pairCount = pairs.size();\n-          for (int i = 1; i < pairCount; i++) {\n-            IntPair previousHole = pairs.get(i - 1);\n-            IntPair currentHole = pairs.get(i);\n-            IntPair range = new IntPair(previousHole.getRight() + 1, currentHole.getLeft() - 1);\n-            if (!IntRanges.isInvalid(range)) {\n-              newPairs.add(range);\n+            // Add the filled areas between contiguous holes\n+            int pairCount = pairs.size();\n+            for (int i = 1; i < pairCount; i++) {\n+              IntPair previousHole = pairs.get(i - 1);\n+              IntPair currentHole = pairs.get(i);\n+              IntPair range = new IntPair(previousHole.getRight() + 1, currentHole.getLeft() - 1);\n+              if (!IntRanges.isInvalid(range)) {\n+                newPairs.add(range);\n+              }\n             }\n-          }\n \n-          // Add the last filled area (between the last hole and endDocId)\n-          IntPair lastHole = pairs.get(pairs.size() - 1);\n-          IntPair lastRange = new IntPair(lastHole.getRight() + 1, _endDocId);\n+            // Add the last filled area (between the last hole and endDocId)\n+            IntPair lastHole = pairs.get(pairs.size() - 1);\n+            IntPair lastRange = new IntPair(lastHole.getRight() + 1, _endDocId);\n \n-          if (!IntRanges.isInvalid(lastRange)) {\n-            newPairs.add(lastRange);\n+            if (!IntRanges.isInvalid(lastRange)) {\n+              newPairs.add(lastRange);\n+            }\n           }\n-        }\n \n-        pairs = newPairs;\n+          pairs = newPairs;\n+        }\n       }\n-    }\n+\n     return new FilterBlock(new SortedDocIdSet(_dataSource.getOperatorName(), pairs));\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370807142", "bodyText": "I think checking dataSourceMetadata.isSorted() should be enough?", "author": "Jackie-Jiang", "createdAt": "2020-01-24T19:35:15Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NDI1Ng==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370864256", "bodyText": "The logic should be this right (also mentioned in the code comments)?\nwe use can sorted inverted index if:\n\ncolumn is sorted AND\npredicate is not RANGE OR predicate is RANGE but this physical plan is being built for offline segment", "author": "siddharthteotia", "createdAt": "2020-01-24T22:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTM4Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370895383", "bodyText": "If the column is sorted, we can use sorted index if there is no RANGE predicate -- we do this today.\nIf the column is sorted and there is RANGE predicate, use sorted index only for offline segments.", "author": "siddharthteotia", "createdAt": "2020-01-25T00:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDQzMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371404432", "bodyText": "Discussed offline.\ndataSourceMetadata.isSorted() is enough since dataSourceMetadata.isSorted() will always be false for realtime segments so we don't need an enhanced check.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTAxOA==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405018", "bodyText": "You mean dataSourceMetadata.isSorted() is always false for realtime right?", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxMDE2Mw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371410163", "bodyText": "Exactly. Since MutableSegmentImpl calls the constructor of ColumnDataSource with isSorted as false.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c9ff3dd50952719e07842b5de7c5816257404880", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\nindex 7265e252b6..a064991e81 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\n\n@@ -58,7 +58,7 @@ public class FilterOperatorUtils {\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n     if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n-      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {\n+      if (dataSource.getDataSourceMetadata().isSorted()) {\n         return new SortedInvertedIndexBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n       } else if (predicateType != Predicate.Type.RANGE) {\n         // TODO: add support for bitmap inverted index operator can be used for RANGE predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODcyMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370878722", "bodyText": "The condition here seems not consistent with the PR summary/title. For example, take the first part of OR in (2). It says sorted inverted index can be used if (1) column is sorted AND (2) predicate is not RANGE. This is not what the PR title means. Am I missing anything here?", "author": "chenboat", "createdAt": "2020-01-24T22:59:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java", "diffHunk": "@@ -56,16 +57,23 @@ public static BaseFilterOperator getLeafFilterOperator(PredicateEvaluator predic\n     // Use inverted index if the predicate type is not RANGE or REGEXP_LIKE for efficiency\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n-    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.RANGE) && (predicateType\n-        != Predicate.Type.REGEXP_LIKE)) {\n-      if (dataSourceMetadata.isSorted()) {\n+    if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n+      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {\n         return new SortedInvertedIndexBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n-      } else {\n+      } else if (predicateType != Predicate.Type.RANGE) {\n+        // TODO: add support for bitmap inverted index operator can be used for RANGE predicate\n         return new BitmapBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n       }\n-    } else {\n-      return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n     }\n+    return new ScanBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n+  }\n+\n+  private static boolean shouldUseSortedInvertedIndexOperator(DataSource dataSource, Predicate.Type predicateType) {\n+    boolean isSorted = dataSource.getDataSourceMetadata().isSorted();\n+    // we can sorted inverted index if:\n+    // 1. column is sorted AND\n+    // 2. predicate is not RANGE OR predicate is RANGE but this physical plan is being built for offline segment", "originalCommit": "7314a0aac3ffe6f15554b29a50f71e357c3bbdca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4MzA1Nw==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r370883057", "bodyText": "If the column is sorted, we can use sorted index if there is no RANGE predicate -- we do this today.\nIf the column is sorted and there is RANGE predicate, use sorted index only for offline segments.", "author": "siddharthteotia", "createdAt": "2020-01-24T23:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3ODcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "c9ff3dd50952719e07842b5de7c5816257404880", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\nindex 7265e252b6..a064991e81 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/FilterOperatorUtils.java\n\n@@ -58,7 +58,7 @@ public class FilterOperatorUtils {\n     DataSourceMetadata dataSourceMetadata = dataSource.getDataSourceMetadata();\n     Predicate.Type predicateType = predicateEvaluator.getPredicateType();\n     if (dataSourceMetadata.hasInvertedIndex() && (predicateType != Predicate.Type.REGEXP_LIKE)) {\n-      if (shouldUseSortedInvertedIndexOperator(dataSource, predicateType)) {\n+      if (dataSource.getDataSourceMetadata().isSorted()) {\n         return new SortedInvertedIndexBasedFilterOperator(predicateEvaluator, dataSource, startDocId, endDocId);\n       } else if (predicateType != Predicate.Type.RANGE) {\n         // TODO: add support for bitmap inverted index operator can be used for RANGE predicate\n"}}, {"oid": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "url": "https://github.com/apache/pinot/commit/754a54c17cd95ff878d6efd5c039240cfdbac8f2", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-24T23:54:13Z", "type": "forcePushed"}, {"oid": "c9ff3dd50952719e07842b5de7c5816257404880", "url": "https://github.com/apache/pinot/commit/c9ff3dd50952719e07842b5de7c5816257404880", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:24:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDUyMg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371404522", "bodyText": "Let's return _endDictId and do this -1 at the caller side with comments for readability", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:22:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java", "diffHunk": "@@ -129,6 +129,14 @@ public static BaseRawValueBasedPredicateEvaluator newRawValueBasedEvaluator(Rang\n       }\n     }\n \n+    public int getStartDictId() {\n+      return _startDictId;\n+    }\n+\n+    public int getEndDictId() {\n+      return _endDictId - 1;", "originalCommit": "754a54c17cd95ff878d6efd5c039240cfdbac8f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxNTk0Ng==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371415946", "bodyText": "Done.", "author": "siddharthteotia", "createdAt": "2020-01-27T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNDUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java\nindex dbd667fa71..08c13d12a5 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java\n\n@@ -134,7 +134,7 @@ public class RangePredicateEvaluatorFactory {\n     }\n \n     public int getEndDictId() {\n-      return _endDictId - 1;\n+      return _endDictId;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTY2NQ==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371405665", "bodyText": "Can you rename this to RangePredicateWithSortedInvertedIndexTest?", "author": "Jackie-Jiang", "createdAt": "2020-01-27T18:25:18Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.pinot.common.segment.ReadMode;\n+import org.apache.pinot.common.utils.Pairs;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.SelectionOnlyOperator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.pql.parsers.Pql2Compiler;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n+\n+\n+public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {", "originalCommit": "c9ff3dd50952719e07842b5de7c5816257404880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxNTk3Mg==", "url": "https://github.com/apache/pinot/pull/5013#discussion_r371415972", "bodyText": "Done", "author": "siddharthteotia", "createdAt": "2020-01-27T18:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQwNTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java b/pinot-core/src/test/java/org/apache/pinot/queries/RangePredicateWithSortedInvertedIndexTest.java\nsimilarity index 89%\nrename from pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java\nrename to pinot-core/src/test/java/org/apache/pinot/queries/RangePredicateWithSortedInvertedIndexTest.java\nindex b992f879f7..5c67ca978e 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/queries/TestRangePredicateWithSortedInvertedIndex.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/queries/RangePredicateWithSortedInvertedIndexTest.java\n\n@@ -49,7 +49,7 @@ import org.testng.annotations.Test;\n import org.testng.collections.Lists;\n \n \n-public class TestRangePredicateWithSortedInvertedIndex extends BaseQueriesTest {\n+public class RangePredicateWithSortedInvertedIndexTest extends BaseQueriesTest {\n   private static final int NUM_ROWS = 30000;\n \n   private List<GenericRow> _rows = new ArrayList<>();\n"}}, {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:47:24Z", "type": "commit"}, {"oid": "1728e1049d0504cf2c25a2e8252093ae90c2fd09", "url": "https://github.com/apache/pinot/commit/1728e1049d0504cf2c25a2e8252093ae90c2fd09", "message": "For RANGE predicate queries touching offline segments,\nuse sorted inverted index.", "committedDate": "2020-01-27T18:47:24Z", "type": "forcePushed"}]}