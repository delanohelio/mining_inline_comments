{"pr_number": 6208, "pr_title": "Add StrictReplicaGroupInstanceSelector", "pr_createdAt": "2020-10-29T00:34:22Z", "pr_url": "https://github.com/apache/pinot/pull/6208", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg2ODQ4OA==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513868488", "bodyText": "noinspection -> No inspection", "author": "yupeng9", "createdAt": "2020-10-29T01:45:02Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/RoutingManager.java", "diffHunk": "@@ -284,6 +278,7 @@ private static boolean isInstanceEnabled(ZNRecord instanceConfigZNRecord) {\n     if (\"true\".equals(instanceConfigZNRecord.getSimpleField(CommonConstants.Helix.IS_SHUTDOWN_IN_PROGRESS))) {\n       return false;\n     }\n+    //noinspection RedundantIfStatement", "originalCommit": "06f959d11cc3544634beb7cc0d661bc3327fd627", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwNDI3OQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514504279", "bodyText": "This is the fixed comment to disable this IDE inspection", "author": "Jackie-Jiang", "createdAt": "2020-10-29T19:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg2ODQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUyMDMxNw==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514520317", "bodyText": "ohh, i see", "author": "yupeng9", "createdAt": "2020-10-29T19:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg2ODQ4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg3MDAwMA==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513870000", "bodyText": "onlineSegments can be derived from idealState ?", "author": "yupeng9", "createdAt": "2020-10-29T01:48:59Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/BaseInstanceSelector.java", "diffHunk": "@@ -126,47 +128,28 @@ public void onInstancesChange(Set<String> enabledInstances, List<String> changed\n    * {@inheritDoc}\n    *\n    * <p>Updates the cached maps ({@code segmentToOnlineInstancesMap}, {@code segmentToOfflineInstancesMap} and\n-   * {@code instanceToSegmentsMap}) based on the given ExternalView and re-calculates\n-   * {@code segmentToEnabledInstancesMap} and {@code unavailableSegments} based on the cached states.\n+   * {@code instanceToSegmentsMap}) and re-calculates {@code segmentToEnabledInstancesMap} and\n+   * {@code unavailableSegments} based on the cached states.\n    */\n   @Override\n-  public void onExternalViewChange(ExternalView externalView, Set<String> onlineSegments) {\n-    Map<String, Map<String, String>> segmentAssignment = externalView.getRecord().getMapFields();\n-    int numSegments = segmentAssignment.size();\n-    _segmentToOnlineInstancesMap = new HashMap<>(HashUtil.getHashMapCapacity(numSegments));\n-    _segmentToOfflineInstancesMap = new HashMap<>(HashUtil.getHashMapCapacity(numSegments));\n+  public void onExternalViewChange(ExternalView externalView, IdealState idealState, Set<String> onlineSegments) {", "originalCommit": "06f959d11cc3544634beb7cc0d661bc3327fd627", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwNDk3NQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514504975", "bodyText": "onlineSegments are derived from the idealState, but also filtered by the pre-selector, so we need to pass both of them", "author": "Jackie-Jiang", "createdAt": "2020-10-29T19:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg3MDAwMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r513984804", "bodyText": "high-level comment, since this is to calculate the map based on the coarse-grained unit (i.e. replica group) instead of the segment, have you considered mapping the online segments to the replica groups first, and then use the groups for selection?", "author": "yupeng9", "createdAt": "2020-10-29T05:29:15Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,", "originalCommit": "06f959d11cc3544634beb7cc0d661bc3327fd627", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwODc3Nw==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514508777", "bodyText": "Good question. The reason why we do not pre-group the instances but use the same index to pick the instance for each segment is because the replica-group derived from the ideal state might not be the same as the replica-group from the instance assignment. If we pre-group the instances, when we shut down all instances from a replica-group, these instances might fall into multiple replica-groups derived from the ideal state, and causing multiple replica-groups down in the routing.", "author": "Jackie-Jiang", "createdAt": "2020-10-29T19:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUyMTgzMw==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514521833", "bodyText": "I see. Does this mean the grouping is neither static nor deterministic? When you mentioned the mirroring above, I thought there is a pre-group concept.", "author": "yupeng9", "createdAt": "2020-10-29T19:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNDUxMg==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514614512", "bodyText": "The grouping is not static, but is deterministic for each query. The grouping is determined by the index of the instance for each segment.", "author": "Jackie-Jiang", "createdAt": "2020-10-29T22:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNzQ3MQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r514637471", "bodyText": "Got it. Makes sense to me.", "author": "yupeng9", "createdAt": "2020-10-30T00:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk4NDgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "chunk": "diff --git a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\nindex 505c41ecab..07d62812ed 100644\n--- a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n+++ b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n\n@@ -105,7 +105,6 @@ public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSele\n       if (instancesInIdealState == null) {\n         continue;\n       }\n-      // NOTE: Instances will be sorted here because 'instanceStateMap' is a TreeMap.\n       Map<String, String> instanceStateMap = entry.getValue();\n       Set<String> tempOnlineInstances = new TreeSet<>();\n       List<String> offlineInstances = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NTQ0OQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515455449", "bodyText": "(1) Where do you utilize the fact instanceStateMap is a tree map? and why?\n(2) The ExternalView interface has the value type as a generic map. What happens if EV changes its implementation. Will it break the current impl?", "author": "chenboat", "createdAt": "2020-10-31T04:47:07Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,\n+      Map<String, List<String>> segmentToOnlineInstancesMap, Map<String, List<String>> segmentToOfflineInstancesMap,\n+      Map<String, List<String>> instanceToSegmentsMap) {\n+    // Iterate over the ideal state to fill up 'idealStateSegmentToInstancesMap' which is a map from segment to set of\n+    // instances hosting the segment in the ideal state\n+    int segmentMapCapacity = HashUtil.getHashMapCapacity(onlineSegments.size());\n+    Map<String, Set<String>> idealStateSegmentToInstancesMap = new HashMap<>(segmentMapCapacity);\n+    for (Map.Entry<String, Map<String, String>> entry : idealState.getRecord().getMapFields().entrySet()) {\n+      String segment = entry.getKey();\n+      // Only track online segments\n+      if (!onlineSegments.contains(segment)) {\n+        continue;\n+      }\n+      idealStateSegmentToInstancesMap.put(segment, entry.getValue().keySet());\n+    }\n+\n+    // Iterate over the external view to fill up 'tempSegmentToOnlineInstancesMap' and 'segmentToOfflineInstancesMap'.\n+    // 'tempSegmentToOnlineInstancesMap' is a temporary map from segment to set of instances that are in the ideal state\n+    // and also ONLINE/CONSUMING in the external view. This map does not have the strict replica-group guarantee, and\n+    // will be used to calculate the final 'segmentToOnlineInstancesMap'.\n+    Map<String, Set<String>> tempSegmentToOnlineInstancesMap = new HashMap<>(segmentMapCapacity);\n+    for (Map.Entry<String, Map<String, String>> entry : externalView.getRecord().getMapFields().entrySet()) {\n+      String segment = entry.getKey();\n+      Set<String> instancesInIdealState = idealStateSegmentToInstancesMap.get(segment);\n+      // Only track online segments\n+      if (instancesInIdealState == null) {\n+        continue;\n+      }\n+      // NOTE: Instances will be sorted here because 'instanceStateMap' is a TreeMap.", "originalCommit": "06f959d11cc3544634beb7cc0d661bc3327fd627", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3NzA0Ng==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515577046", "bodyText": "Good question. Actually it is not utilized here. The onlineInstances needs to be sorted, and it relies on the fact that tempOnlineInstances is a TreeSet. The second point is also very good.\nI moved the comments, and added an assert to guard the case of EV changing implementation.", "author": "Jackie-Jiang", "createdAt": "2020-11-01T05:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4ODAwOA==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515588008", "bodyText": "Actually the instanceStateMap is not always TreeMap, but can be LinkedHashMap as well. Explicitly sort the online instances to ensure it always work.", "author": "Jackie-Jiang", "createdAt": "2020-11-01T07:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NTQ0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "chunk": "diff --git a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\nindex 505c41ecab..07d62812ed 100644\n--- a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n+++ b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n\n@@ -105,7 +105,6 @@ public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSele\n       if (instancesInIdealState == null) {\n         continue;\n       }\n-      // NOTE: Instances will be sorted here because 'instanceStateMap' is a TreeMap.\n       Map<String, String> instanceStateMap = entry.getValue();\n       Set<String> tempOnlineInstances = new TreeSet<>();\n       List<String> offlineInstances = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2ODk0NQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515568945", "bodyText": "There is a need to introduce a new abstraction to simplify this class \u2014 note that the new abstraction can not be replicaGroup as it is now. We are talking about segment to replica group mapping. It should greatly simplify the codes in this class. At it current form, it looks correct to me but it is way too complex and hard to understand. We should refactor it in the next iteration.", "author": "chenboat", "createdAt": "2020-11-01T03:13:32Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.broker.routing.instanceselector;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.IdealState;\n+import org.apache.pinot.common.metrics.BrokerMetrics;\n+import org.apache.pinot.common.utils.CommonConstants.Helix.StateModel.SegmentStateModel;\n+import org.apache.pinot.common.utils.HashUtil;\n+\n+\n+/**\n+ * Instance selector for strict replica-group routing strategy.\n+ *\n+ * <pre>\n+ * The strict replica-group routing strategy always routes the query to the instances within the same replica-group.\n+ * (Note that the replica-group information is derived from the ideal state of the table, where the instances are sorted\n+ * alphabetically in the instance state map, so the replica-groups in the instance selector might not match the\n+ * replica-groups in the instance partitions.) The instances in a replica-group should have all the online segments\n+ * (segments with ONLINE/CONSUMING instances in the ideal state and selected by the pre-selector) available\n+ * (ONLINE/CONSUMING in the external view) in order to serve queries. If any segment is unavailable in the\n+ * replica-group, we mark the whole replica-group down and not serve queries with this replica-group.\n+ *\n+ * The selection algorithm is the same as {@link ReplicaGroupInstanceSelector}, and will always evenly distribute the\n+ * traffic to all replica-groups that have all online segments available.\n+ *\n+ * The algorithm relies on the mirror segment assignment from replica-group segment assignment strategy. With mirror\n+ * segment assignment, any server in one replica-group will always have a corresponding server in other replica-groups\n+ * that have the same segments assigned. For example, if S1 is a server in replica-group 1, and it has mirror server\n+ * S2 in replica-group 2 and S3 in replica-group 3. All segments assigned to S1 will also be assigned to S2 and S3. In\n+ * stable scenario (external view matches ideal state), all segments assigned to S1 will have the same enabled instances\n+ * of [S1, S2, S3] sorted (in alphabetical order). If we always pick the same index of enabled instances for all\n+ * segments, only one of S1, S2, S3 will be picked, and all the segments are processed by the same server. In\n+ * transitioning/error scenario (external view does not match ideal state), if a segment is down on S1, we mark all\n+ * segments with the same assignment ([S1, S2, S3]) down on S1 to ensure that we always route the segments to the same\n+ * replica-group.\n+ * </pre>\n+ */\n+public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSelector {\n+\n+  public StrictReplicaGroupInstanceSelector(String tableNameWithType, BrokerMetrics brokerMetrics) {\n+    super(tableNameWithType, brokerMetrics);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * <pre>\n+   * The maps are calculated in the following steps to meet the strict replica-group guarantee:\n+   *   1. Create a map from online segment to set of instances hosting the segment based on the ideal state\n+   *   2. Gather the online and offline instances for each online segment from the external view\n+   *   3. Compare the instances from the ideal state and the external view and gather the unavailable instances for each\n+   *      set of instances\n+   *   4. Exclude the unavailable instances from the online instances map\n+   * </pre>\n+   */\n+  @Override\n+  void updateSegmentMaps(ExternalView externalView, IdealState idealState, Set<String> onlineSegments,", "originalCommit": "06f959d11cc3544634beb7cc0d661bc3327fd627", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3NzMzOQ==", "url": "https://github.com/apache/pinot/pull/6208#discussion_r515577339", "bodyText": "I think what you mean is to introduce a new algorithm for the replica-group routing. This part is quite tricky because the routing needs to still work when we change the replica-groups and run the rebalance, and the query time computation needs to be as fast as possible. If we can come up with a simpler and better algorithm, we can definitely re-implement this class.", "author": "Jackie-Jiang", "createdAt": "2020-11-01T05:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU2ODk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "chunk": "diff --git a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\nindex 505c41ecab..07d62812ed 100644\n--- a/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n+++ b/pinot-broker/src/main/java/org/apache/pinot/broker/routing/instanceselector/StrictReplicaGroupInstanceSelector.java\n\n@@ -105,7 +105,6 @@ public class StrictReplicaGroupInstanceSelector extends ReplicaGroupInstanceSele\n       if (instancesInIdealState == null) {\n         continue;\n       }\n-      // NOTE: Instances will be sorted here because 'instanceStateMap' is a TreeMap.\n       Map<String, String> instanceStateMap = entry.getValue();\n       Set<String> tempOnlineInstances = new TreeSet<>();\n       List<String> offlineInstances = new ArrayList<>();\n"}}, {"oid": "ae8394f1781d4bc2e7194e4a6f093fe0629cefb4", "url": "https://github.com/apache/pinot/commit/ae8394f1781d4bc2e7194e4a6f093fe0629cefb4", "message": "Add StrictReplicaGroupInstanceSelector", "committedDate": "2020-11-01T05:26:39Z", "type": "commit"}, {"oid": "3635880a5ab7ca04bdbb126690e6ba8d524809cb", "url": "https://github.com/apache/pinot/commit/3635880a5ab7ca04bdbb126690e6ba8d524809cb", "message": "Address comments", "committedDate": "2020-11-01T05:26:39Z", "type": "forcePushed"}, {"oid": "e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "url": "https://github.com/apache/pinot/commit/e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "message": "Address comments", "committedDate": "2020-11-01T07:37:51Z", "type": "commit"}, {"oid": "e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "url": "https://github.com/apache/pinot/commit/e64f1964dcc3c77cbe6c2b55bc43ffada7d48f4f", "message": "Address comments", "committedDate": "2020-11-01T07:37:51Z", "type": "forcePushed"}]}