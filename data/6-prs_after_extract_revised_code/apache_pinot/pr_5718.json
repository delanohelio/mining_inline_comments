{"pr_number": 5718, "pr_title": "Feature/#5390 segment indexing reload status api", "pr_createdAt": "2020-07-20T00:59:34Z", "pr_url": "https://github.com/apache/pinot/pull/5718", "timeline": [{"oid": "e9a1c935209fd6de065deefbe03352694b43ec7e", "url": "https://github.com/apache/pinot/commit/e9a1c935209fd6de065deefbe03352694b43ec7e", "message": "- initial feature push", "committedDate": "2020-07-20T04:49:22Z", "type": "commit"}, {"oid": "e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "url": "https://github.com/apache/pinot/commit/e1aa8980d26a5e5b3d5c61b5a52f8459b68b8ea5", "message": "Segment Reload API\n- added a new API endpoint for users to query segment reload status\n\nAPI - Table metadata from Server\n- added a new endpoint to fetch segment metadata\n\n- added helper classes and methods to fetch metadata from the server\n\nTests\n- added test to server API to fetch metadata including indexing information", "committedDate": "2020-07-20T04:55:03Z", "type": "commit"}, {"oid": "422c76a7c7bc3291a41970a21825a4ef2bded208", "url": "https://github.com/apache/pinot/commit/422c76a7c7bc3291a41970a21825a4ef2bded208", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T01:49:25Z", "type": "forcePushed"}, {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T02:43:09Z", "type": "commit"}, {"oid": "7e31c1136090a48823c1a159d8608f37375a0096", "url": "https://github.com/apache/pinot/commit/7e31c1136090a48823c1a159d8608f37375a0096", "message": "Code Refactor:\n- Moved status classes to logical places\n\nLogs\n- Added logging statements\n\nTests\n- Added unit tests for Pinot Controller reload status and segment metadata API\n- Added unit tests for Pinot Server reload status and segment metadata API\n\nLicense Headers\n- Add license headers to files added to this feature", "committedDate": "2020-07-21T02:43:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTI0NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165244", "bodyText": "there seems to be some unnecessary formatting/whitespaces on all methods of this file. Could you revert those? you should be able to auto-format using the IDE\nsame comment for TablesResourceTest file", "author": "npawar", "createdAt": "2020-07-23T01:04:15Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -128,20 +137,33 @@\n @Api(tags = Constants.SEGMENT_TAG)\n @Path(\"/\")\n public class PinotSegmentRestletResource {\n-  private static Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PinotSegmentRestletResource.class);\n+\n+  @Inject\n+  ControllerConf _controllerConf;\n \n   @Inject\n   PinotHelixResourceManager _pinotHelixResourceManager;\n \n+  @Inject\n+  Executor _executor;\n+\n+  @Inject\n+  HttpConnectionManager _connectionManager;\n+\n+  @Inject\n+  ControllerMetrics _controllerMetrics;\n+\n+\n   @GET\n   @Produces(MediaType.APPLICATION_JSON)\n   @Path(\"/segments/{tableName}\")\n   @ApiOperation(value = \"List all segments\", notes = \"List all segments\")\n   public List<Map<TableType, List<String>>> getSegments(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489469", "bodyText": "Some setting on my IDE got changed for the Pinot checkstyle. Have updated it again. Should be fixed in my next commit.", "author": "guruguha", "createdAt": "2020-07-26T07:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -151,19 +149,15 @@ public class PinotSegmentRestletResource {\n   @Inject\n   HttpConnectionManager _connectionManager;\n \n-  @Inject\n-  ControllerMetrics _controllerMetrics;\n-\n-\n   @GET\n   @Produces(MediaType.APPLICATION_JSON)\n   @Path(\"/segments/{tableName}\")\n   @ApiOperation(value = \"List all segments\", notes = \"List all segments\")\n   public List<Map<TableType, List<String>>> getSegments(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n     List<String> tableNamesWithType =\n-            getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+        getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     List<Map<TableType, List<String>>> resultList = new ArrayList<>(tableNamesWithType.size());\n     for (String tableNameWithType : tableNamesWithType) {\n       TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTU5Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r459165596", "bodyText": "i could spot no change in this method vs same method moved at the bottom. can we keep it here, so that the scope of review stays limited to the actual changes?", "author": "npawar", "createdAt": "2020-07-23T01:05:48Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -246,21 +268,7 @@\n       return segmentMetadata;\n     } else {\n       throw new ControllerApplicationException(LOGGER,\n-          \"Failed to find segment: \" + segmentName + \" in table: \" + tableName, Status.NOT_FOUND);\n-    }\n-  }\n-\n-  @Nullable", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MjY2NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460492664", "bodyText": "my bad.", "author": "guruguha", "createdAt": "2020-07-26T07:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2NTU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -268,7 +262,21 @@ public class PinotSegmentRestletResource {\n       return segmentMetadata;\n     } else {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Failed to find segment: \" + segmentName + \" in table: \" + tableName, Status.NOT_FOUND);\n+          \"Failed to find segment: \" + segmentName + \" in table: \" + tableName, Status.NOT_FOUND);\n+    }\n+  }\n+\n+  @Nullable\n+  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n+    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n+    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n+      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n+          ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n+      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n+    } else {\n+      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n+          ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n+      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ2OTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460469469", "bodyText": "is there a better return code for this? NOT_FOUND suggests that the table was not found", "author": "npawar", "createdAt": "2020-07-26T02:38:29Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MzE3OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460493179", "bodyText": "since it is a propagated exception, it is better to have the message originally thrown. Updating the same.", "author": "guruguha", "createdAt": "2020-07-26T07:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ2OTQ2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTMxMg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471312", "bodyText": "nit: How about String.format for constructing these", "author": "npawar", "createdAt": "2020-07-26T03:07:07Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\nindex b8d639af43..f159901aa1 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n\n@@ -69,13 +69,13 @@ public class ServerSegmentMetadataReader {\n         URI uri = getMethod.getURI();\n         String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n         if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          LOGGER.error(\"Server {} returned error: code: {}, message: {}\", instance, getMethod.getStatusCode(),\n+              getMethod.getResponseBodyAsString());\n           continue;\n         }\n         JsonNode segmentMetadata =\n                 JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n         segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n-        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n       } catch (Exception e) {\n         // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n         // Log the number of failed servers after gathering all responses\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTM3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471375", "bodyText": "nit: for readability\ns/serversToSegmentsMap/serverToSegments\ns/endpoints/serverToEndpoint", "author": "npawar", "createdAt": "2020-07-26T03:08:17Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\nindex b8d639af43..f159901aa1 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n\n@@ -69,13 +69,13 @@ public class ServerSegmentMetadataReader {\n         URI uri = getMethod.getURI();\n         String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n         if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          LOGGER.error(\"Server {} returned error: code: {}, message: {}\", instance, getMethod.getStatusCode(),\n+              getMethod.getResponseBodyAsString());\n           continue;\n         }\n         JsonNode segmentMetadata =\n                 JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n         segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n-        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n       } catch (Exception e) {\n         // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n         // Log the number of failed servers after gathering all responses\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTYxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471610", "bodyText": "how about logging the message also here?", "author": "npawar", "createdAt": "2020-07-26T03:12:07Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (Objects.nonNull(getMethod)) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/metadata\";\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return \"http://\" + endpoint + \"/tables/\" + tableNameWithType + \"/segments/\" + segmentName + \"/reload-status\";\n+  }\n+\n+  public List<SegmentStatus> getSegmentReloadTime(String tableNameWithType,\n+                                                  Map<String, List<String>> serversToSegmentsMap,\n+                                                  BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDkxOA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460490918", "bodyText": "Would the message be formatted in anyway or will it be a full stack trace?", "author": "guruguha", "createdAt": "2020-07-26T07:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\nindex b8d639af43..f159901aa1 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n\n@@ -69,13 +69,13 @@ public class ServerSegmentMetadataReader {\n         URI uri = getMethod.getURI();\n         String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n         if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          LOGGER.error(\"Server {} returned error: code: {}, message: {}\", instance, getMethod.getStatusCode(),\n+              getMethod.getResponseBodyAsString());\n           continue;\n         }\n         JsonNode segmentMetadata =\n                 JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n         segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n-        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n       } catch (Exception e) {\n         // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n         // Log the number of failed servers after gathering all responses\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTg2Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460471862", "bodyText": "can tableReloadStatus ever be null? you'll either catch exception above, or have a non-null reload status", "author": "npawar", "createdAt": "2020-07-26T03:15:41Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NDE1Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460494153", "bodyText": "That's true! Will remove the null check.", "author": "guruguha", "createdAt": "2020-07-26T07:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MTg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjAxNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472017", "bodyText": "In the TableReloadStatus, can we also add a message telling the caller how many segments failed to report?", "author": "npawar", "createdAt": "2020-07-26T03:18:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjIxNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472217", "bodyText": "Let's specify that this metadata includes metadata from server. Was this the api name that we finally settled on? It's too similar to the other \"metadata\" endpoint and bound to cause confusion", "author": "npawar", "createdAt": "2020-07-26T03:21:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NTkxNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460495915", "bodyText": "@kishoreg had mentioned that we will discuss further into the PR on this. So, we're yet to finalize on that.", "author": "guruguha", "createdAt": "2020-07-26T08:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472369", "bodyText": "nit: wrap this in {}", "author": "npawar", "createdAt": "2020-07-26T03:23:29Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjM5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472391", "bodyText": "you already have tableType 3 lines above", "author": "npawar", "createdAt": "2020-07-26T03:24:00Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472536", "bodyText": "does this call return the CONSUMING (mutable) segments and do we need to skip them here?\nAlso how come we're supporting realtime table in reload-status, but not in metadata? I thought we're only planning to skip the CONSUMING segment in both endpoints", "author": "npawar", "createdAt": "2020-07-26T03:25:45Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NzQ4Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460497483", "bodyText": "You're right, we're skipping CONSUMING segments in both endpoints. Added the check for both endpoints.", "author": "guruguha", "createdAt": "2020-07-26T08:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3NDQ4NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460574484", "bodyText": "REALTIME tables have some CONSUMING segments (Mutable) and some ONLINE segments (Immutable). We want to still process the Immutable segments of the REALTIME table. The current implementation will skip REALTIME entirely. It's okay if you want to take that up in a follow-up. You can mention in description that this is only for OFFLINE as of now", "author": "npawar", "createdAt": "2020-07-26T21:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjYzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472637", "bodyText": "some validation to check if table was not found?\nsame for the metadata endpoint", "author": "npawar", "createdAt": "2020-07-26T03:27:45Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5Mzk4Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460493987", "bodyText": "This is taken care in the getExistingTableNamesWithType method", "author": "guruguha", "createdAt": "2020-07-26T07:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3Mjc3Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472773", "bodyText": "if table is not found, line 546 itself will throw exception.", "author": "npawar", "createdAt": "2020-07-26T03:30:02Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5NTIzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460495237", "bodyText": "That exception has been updated to the propagated exception. Also, as mentioned before, the segmentsMetadata will not be null.", "author": "guruguha", "createdAt": "2020-07-26T08:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3Mjc3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MjgwNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460472807", "bodyText": "nit: remove trace logs?", "author": "npawar", "createdAt": "2020-07-26T03:30:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473077", "bodyText": "can we move call to fetch serverToSegmentsMap inside this method, so that it's consistent with the getSegmentsMetadata Method?", "author": "npawar", "createdAt": "2020-07-26T03:34:57Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MTQ2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460491469", "bodyText": "It is outside in both methods as the \"server side\" classes don't have the resourceManager object. If it is moved to server side classes then the resourceManager object needs to be passed on - which might be overkill?", "author": "guruguha", "createdAt": "2020-07-26T07:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3MzIwNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460573206", "bodyText": "oh i meant this call\nfinal Map<String, List<String>> serverToSegments = _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n\nIt is called in the getSegmentsMetadata, but for getReloadStatus, it is being passed from caller", "author": "npawar", "createdAt": "2020-07-26T21:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMjI0MA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461312240", "bodyText": "I see, got it. updated the same.", "author": "guruguha", "createdAt": "2020-07-28T04:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzA3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\nindex 2216f1d29d..92522bd98c 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\n\n@@ -20,7 +20,6 @@ package org.apache.pinot.controller.util;\n \n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.google.common.collect.BiMap;\n import java.io.IOException;\n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzIzNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473234", "bodyText": "didnt understand why this needs to be copied to another ObjectNode. Can we get it directly from JsonNode?", "author": "npawar", "createdAt": "2020-07-26T03:36:50Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.exception.InvalidConfigException;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.controller.api.resources.ServerSegmentMetadataReader;\n+import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class TableMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TableMetadataReader.class);\n+\n+  private final Executor executor;\n+  private final HttpConnectionManager connectionManager;\n+  private final PinotHelixResourceManager pinotHelixResourceManager;\n+\n+  public TableMetadataReader(Executor executor, HttpConnectionManager connectionManager,\n+                             PinotHelixResourceManager helixResourceManager) {\n+    this.executor = executor;\n+    this.connectionManager = connectionManager;\n+    this.pinotHelixResourceManager = helixResourceManager;\n+  }\n+\n+  public TableReloadStatus getReloadStatus(String tableNameWithType, Map<String, List<String>> serverToSegmentsMap,\n+                                           int timeoutMs)\n+          throws InvalidConfigException {\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serverToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<SegmentStatus> segmentStatus = serverSegmentMetadataReader.getSegmentReloadTime(tableNameWithType, serverToSegmentsMap, endpoints, timeoutMs);\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentStatus;\n+    return tableReloadStatus;\n+  }\n+\n+  public Map<String, String> getSegmentsMetadata(String tableNameWithType, int timeoutMs) throws InvalidConfigException, IOException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    BiMap<String, String> endpoints = pinotHelixResourceManager.getDataInstanceAdminEndpoints(serversToSegmentsMap.keySet());\n+    ServerSegmentMetadataReader serverSegmentMetadataReader = new ServerSegmentMetadataReader(executor, connectionManager);\n+\n+    List<String> segmentsMetadata = serverSegmentMetadataReader.getSegmentMetadataFromServer(tableNameWithType,\n+            serversToSegmentsMap, endpoints, timeoutMs);\n+\n+    Map<String, String> response = new HashMap<>();\n+    for (String segmentMetadata : segmentsMetadata) {\n+      JsonNode responseJson = JsonUtils.stringToJsonNode(segmentMetadata);\n+      ObjectNode objectNode = responseJson.deepCopy();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MTYyMw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460491623", "bodyText": "I had it for a different logic - will remove.", "author": "guruguha", "createdAt": "2020-07-26T07:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzIzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\nindex 2216f1d29d..92522bd98c 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/TableMetadataReader.java\n\n@@ -20,7 +20,6 @@ package org.apache.pinot.controller.util;\n \n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.google.common.collect.BiMap;\n import java.io.IOException;\n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473352", "bodyText": "How about moving this also to TableReader just like TableReloadStatus? Also, if  you need the equals and hashcode, use EqualityUtils (look at Schema  class for example)", "author": "npawar", "createdAt": "2020-07-26T03:39:03Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+import java.util.Objects;\n+\n+public class SegmentStatus {", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTc0NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489744", "bodyText": "SegmentStatus is used in the server code as well. So, added a class to common for referencing.", "author": "guruguha", "createdAt": "2020-07-26T07:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3MjU1NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460572555", "bodyText": "Could you change equals and hashcode to use EqualityUtils? Look at other classes in pinot-api for reference", "author": "npawar", "createdAt": "2020-07-26T20:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwMzkwNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461303906", "bodyText": "Working on changing the equals and hashcode. Will commit the changes.", "author": "guruguha", "createdAt": "2020-07-28T04:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMDUzMQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r461310531", "bodyText": "Actually, we may not need the equality methods yet, removing them.", "author": "guruguha", "createdAt": "2020-07-28T04:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0MTA3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462441075", "bodyText": "So, you are using this same class in both Controller as well as Server APIs. That is nice but has its pit falls. Imagine a case when we add a new field to this object. We cannot upgrade controllers and servers at the same time. So, there can exist a situation where servers are sending the old object (serialized) and the controller is trying to deserialize them using the new object. Or, vice versa.\nAt the minimum:\n\nWrite a block of comment at the top of the class that this class is upgrade sensitive explaining what may happen if it is changed without regard to upgrade consideration.\nSpecifically mention that fields cannot be removed from the class (I suppose, unless there are proper defaults)\nAdd an annotation to ignore unknown fields at the class level.", "author": "mcvsubbu", "createdAt": "2020-07-29T16:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MzI1Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462453257", "bodyText": "I strongly suggest we return a different object to the user instead of returning this one. It will enable us to evolve the internal interface independent of interface exposed to the user.\nAlso, the controller returned status could include other run-time status about a segment. For example:\n\nHelix externalview of the server so we know if it is online or not.\nThe crc, size, date uploaded/refreshed, etc. from segment metadata\nOther info as wee want to add later (e.g. number of times segment was hit/searched/selected since reboot, etc.)", "author": "mcvsubbu", "createdAt": "2020-07-29T17:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDk3NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454974", "bodyText": "Please document each member in this object clearly, what it contains in various situations", "author": "mcvsubbu", "createdAt": "2020-07-29T17:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzODgwMw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463838803", "bodyText": "Thanks for the suggestions! I will think about how to refactor my code and commit again.", "author": "guruguha", "createdAt": "2020-07-31T21:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MzYwNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474093605", "bodyText": "Not all comments have been addressed. Please justify the use of the same class to return values to the user. It makes upgrades bad. Add json ignore case so that the pain is at least reduced a bit.", "author": "mcvsubbu", "createdAt": "2020-08-20T15:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTcwNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101707", "bodyText": "I think we do have that separation. We have a class TableReloadStatus in the controller that can be used to enhance any future requirements. The SegmentLoadStatus class can be then used for specific API - the loadStatus API.\nI have added JSON ignore to the SegmentLoadStatus class.", "author": "guruguha", "createdAt": "2020-08-22T15:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\nindex bdf44eaab5..14e13db5a5 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\n\n@@ -21,21 +21,23 @@ package org.apache.pinot.common.restlet.resources;\n import java.util.Objects;\n \n public class SegmentStatus {\n-  public String segmentName;\n-  public String segmentReloadTime;\n+  public String _segmentName;\n+  public String _segmentReloadTime;\n+  public String _segmentReloadStatusMessage;\n \n   public SegmentStatus() {\n   }\n \n-  public SegmentStatus(String segmentName, String segmentReloadTime) {\n-    this.segmentName = segmentName;\n-    this.segmentReloadTime = segmentReloadTime;\n+  public SegmentStatus(String segmentName, String segmentReloadTime, String segmentReloadStatusMessage) {\n+    _segmentName = segmentName;\n+    _segmentReloadTime = segmentReloadTime;\n+    _segmentReloadStatusMessage = segmentReloadStatusMessage;\n   }\n \n   @Override\n   public int hashCode() {\n-    int result = segmentName != null ? segmentName.hashCode() : 0;\n-    result = 31 * result + (segmentReloadTime != null ? segmentReloadTime.hashCode() : 0);\n+    int result = _segmentName != null ? _segmentName.hashCode() : 0;\n+    result = 31 * result + (_segmentReloadTime != null ? _segmentReloadTime.hashCode() : 0);\n     return result;\n \n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzUzOQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460473539", "bodyText": "nit: this log is misleading \"Updated metadata\"", "author": "npawar", "createdAt": "2020-07-26T03:41:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.info(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    CompletionService<GetMethod> completionService =\n+            new MultiGetRequest(_executor, _connectionManager).execute(serverURLs, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          continue;\n+        }\n+        JsonNode segmentMetadata =\n+                JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDA3NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460490074", "bodyText": "changed log message", "author": "guruguha", "createdAt": "2020-07-26T07:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3MzUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\nindex b8d639af43..f159901aa1 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n\n@@ -69,13 +69,13 @@ public class ServerSegmentMetadataReader {\n         URI uri = getMethod.getURI();\n         String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n         if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          LOGGER.error(\"Server {} returned error: code: {}, message: {}\", instance, getMethod.getStatusCode(),\n+              getMethod.getResponseBodyAsString());\n           continue;\n         }\n         JsonNode segmentMetadata =\n                 JsonUtils.inputStreamToJsonNode(getMethod.getResponseBodyAsStream());\n         segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n-        LOGGER.info(\"Updated segment metadata: {}\", segmentMetadata.size());\n       } catch (Exception e) {\n         // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n         // Log the number of failed servers after gathering all responses\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDMyNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474324", "bodyText": "remove comment", "author": "npawar", "createdAt": "2020-07-26T03:52:58Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\nindex 415a793126..8e3a70fd37 100644\n--- a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n+++ b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n\n@@ -32,6 +32,16 @@ import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n import org.apache.pinot.spi.utils.JsonUtils;\n \n public class SegmentColumnIndexesFetcher {\n+  private static final String BLOOM_FILTER = \"bloom-filter\";\n+  private static final String DICTIONARY = \"dictionary\";\n+  private static final String FORWARD_INDEX = \"forward-index\";\n+  private static final String INVERTED_INDEX = \"inverted-index\";\n+  private static final String NULL_VALUE_VECTOR_READER = \"null-value-vector-reader\";\n+  private static final String RANGE_INDEX = \"range-index\";\n+\n+  private static final String INDEX_NOT_AVAILABLE = \"NO\";\n+  private static final String INDEX_AVAILABLE = \"YES\";\n+\n   public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n     ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n     if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDUyNQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474525", "bodyText": "nit: wrap all the if else using {}\ncreate private static final constants for the keys and values that are being put in indexesNode.", "author": "npawar", "createdAt": "2020-07-26T03:55:48Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\nindex 415a793126..8e3a70fd37 100644\n--- a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n+++ b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n\n@@ -32,6 +32,16 @@ import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n import org.apache.pinot.spi.utils.JsonUtils;\n \n public class SegmentColumnIndexesFetcher {\n+  private static final String BLOOM_FILTER = \"bloom-filter\";\n+  private static final String DICTIONARY = \"dictionary\";\n+  private static final String FORWARD_INDEX = \"forward-index\";\n+  private static final String INVERTED_INDEX = \"inverted-index\";\n+  private static final String NULL_VALUE_VECTOR_READER = \"null-value-vector-reader\";\n+  private static final String RANGE_INDEX = \"range-index\";\n+\n+  private static final String INDEX_NOT_AVAILABLE = \"NO\";\n+  private static final String INDEX_AVAILABLE = \"YES\";\n+\n   public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n     ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n     if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDU1Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474556", "bodyText": "any reason you're using ObjectNode instead of Map?", "author": "npawar", "createdAt": "2020-07-26T03:56:26Z", "path": "pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.server.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.pinot.core.data.manager.SegmentDataManager;\n+import org.apache.pinot.core.data.manager.offline.ImmutableSegmentDataManager;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentImpl;\n+import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+\n+public class SegmentColumnIndexesFetcher {\n+  public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n+    ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n+    if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n+      ImmutableSegmentDataManager immutableSegmentDataManager = (ImmutableSegmentDataManager) segmentDataManager;\n+      ImmutableSegment immutableSegment = immutableSegmentDataManager.getSegment();\n+      if (immutableSegment instanceof ImmutableSegmentImpl) {\n+        ImmutableSegmentImpl immutableSegmentImpl = (ImmutableSegmentImpl) immutableSegment;\n+//        Set<String> columns = immutableSegmentImpl.getSegmentMetadata().getAllColumns();\n+        Map<String, ColumnIndexContainer> columnIndexContainerMap = immutableSegmentImpl.getIndexContainerMap();\n+        columnsIndexMetadata.add(getImmutableSegmentColumnIndexes(columnIndexContainerMap, columnSet));\n+      }\n+    }\n+    return columnsIndexMetadata;\n+  }\n+\n+  private static ObjectNode getImmutableSegmentColumnIndexes(Map<String, ColumnIndexContainer> columnIndexContainerMap,\n+                                                             Set<String> columnSet) {\n+    ObjectNode columnIndexMap = JsonUtils.newObjectNode();\n+\n+    for (Map.Entry<String, ColumnIndexContainer> e : columnIndexContainerMap.entrySet()) {\n+      if (columnSet != null && !columnSet.contains(e.getKey())) {\n+        continue;\n+      }\n+      ColumnIndexContainer columnIndexContainer = e.getValue();\n+      ObjectNode indexesNode = JsonUtils.newObjectNode();\n+      if (Objects.isNull(columnIndexContainer.getBloomFilter())) indexesNode.put(\"bloom-filter\", \"NO\");\n+      else indexesNode.put(\"bloom-filter\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getDictionary())) indexesNode.put(\"dictionary\", \"NO\");\n+      else indexesNode.put(\"dictionary\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getForwardIndex())) indexesNode.put(\"forward-index\", \"NO\");\n+      else indexesNode.put(\"forward-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getInvertedIndex())) indexesNode.put(\"inverted-index\", \"NO\");\n+      else indexesNode.put(\"inverted-index\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector()))\n+        indexesNode.put(\"null-value-vector-reader\", \"NO\");\n+      else indexesNode.put(\"null-value-vector-reader\", \"YES\");\n+\n+      if (Objects.isNull(columnIndexContainer.getNullValueVector())) indexesNode.put(\"range-index\", \"NO\");\n+      else indexesNode.put(\"range-index\", \"YES\");\n+\n+      columnIndexMap.set(e.getKey(), indexesNode);\n+    }\n+    return columnIndexMap;", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTQxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460489410", "bodyText": "The segment metadata is a JsonNode converted to a json string. I thought of using the same object conversion so that it is kept consistent.", "author": "guruguha", "createdAt": "2020-07-26T07:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\nindex 415a793126..8e3a70fd37 100644\n--- a/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n+++ b/pinot-server/src/main/java/org/apache/pinot/server/api/resources/SegmentColumnIndexesFetcher.java\n\n@@ -32,6 +32,16 @@ import org.apache.pinot.core.segment.index.column.ColumnIndexContainer;\n import org.apache.pinot.spi.utils.JsonUtils;\n \n public class SegmentColumnIndexesFetcher {\n+  private static final String BLOOM_FILTER = \"bloom-filter\";\n+  private static final String DICTIONARY = \"dictionary\";\n+  private static final String FORWARD_INDEX = \"forward-index\";\n+  private static final String INVERTED_INDEX = \"inverted-index\";\n+  private static final String NULL_VALUE_VECTOR_READER = \"null-value-vector-reader\";\n+  private static final String RANGE_INDEX = \"range-index\";\n+\n+  private static final String INDEX_NOT_AVAILABLE = \"NO\";\n+  private static final String INDEX_AVAILABLE = \"YES\";\n+\n   public static JsonNode getIndexesForSegmentColumns(SegmentDataManager segmentDataManager, Set<String> columnSet) {\n     ArrayNode columnsIndexMetadata = JsonUtils.newArrayNode();\n     if (segmentDataManager instanceof ImmutableSegmentDataManager) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ3NDgxNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r460474816", "bodyText": "remove all the unnecessary whitespace additions in this file", "author": "npawar", "createdAt": "2020-07-26T04:00:02Z", "path": "pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java", "diffHunk": "@@ -44,7 +48,7 @@\n \n   @Test\n   public void getTables()\n-      throws Exception {\n+          throws Exception {", "originalCommit": "7e31c1136090a48823c1a159d8608f37375a0096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java b/pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java\nindex 76b0f5f22a..b52a5e805f 100644\n--- a/pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java\n+++ b/pinot-server/src/test/java/org/apache/pinot/server/api/TablesResourceTest.java\n\n@@ -48,7 +48,7 @@ public class TablesResourceTest extends BaseResourceTest {\n \n   @Test\n   public void getTables()\n-          throws Exception {\n+      throws Exception {\n     String tablesPath = \"/tables\";\n \n     Response response = _webTarget.path(tablesPath).request().get(Response.class);\n"}}, {"oid": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "url": "https://github.com/apache/pinot/commit/a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "message": "Code Review Changes\n- Updating code as per PR review comments", "committedDate": "2020-07-26T08:38:36Z", "type": "commit"}, {"oid": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "url": "https://github.com/apache/pinot/commit/1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "message": "Adding comments to new classes and methods added as part of this feature\nRemoving SegmentMetadataFetcher as it seemed redundant\nRefactoring code to save failed segment reload status API calls as part of response", "committedDate": "2020-07-28T04:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDcxMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457514710", "bodyText": "Is your IDE set to pinot coding guidelines?", "author": "mcvsubbu", "createdAt": "2020-07-20T15:52:12Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -176,23 +198,23 @@\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\", notes = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\")\n   public List<Map<String, String>> getServerToSegmentsMapDeprecated1(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"MUST be null\") @QueryParam(\"state\") String stateStr,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr)\n-      throws JsonProcessingException {\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyNzY5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463827691", "bodyText": "Yes, there was some issue with my IDE itself. I updated the coding guidelines again and reformatted the files.", "author": "guruguha", "createdAt": "2020-07-31T20:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -198,23 +192,23 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\", notes = \"Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)\")\n   public List<Map<String, String>> getServerToSegmentsMapDeprecated1(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"MUST be null\") @QueryParam(\"state\") String stateStr,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr)\n-          throws JsonProcessingException {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"MUST be null\") @QueryParam(\"state\") String stateStr,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr)\n+      throws JsonProcessingException {\n     if (stateStr != null) {\n       throw new WebApplicationException(\"Cannot toggle segment state\", Status.FORBIDDEN);\n     }\n \n     List<String> tableNamesWithType =\n-            getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+        getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     List<Map<String, String>> resultList = new ArrayList<>(tableNamesWithType.size());\n     for (String tableNameWithType : tableNamesWithType) {\n       // NOTE: DO NOT change the format for backward-compatibility\n       Map<String, String> resultForTable = new LinkedHashMap<>();\n       resultForTable.put(\"tableName\", tableNameWithType);\n       resultForTable.put(\"segments\",\n-              JsonUtils.objectToString(_pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType)));\n+          JsonUtils.objectToString(_pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType)));\n       resultList.add(resultForTable);\n     }\n     return resultList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNzkzNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457517934", "bodyText": "If you are returning 404 (NOT_FOUND) then please do not use \"Failed\" in the exception message. Since the exception is invalid config, determine what is invalid and throw that exception, may be as 400 (BAD_REQUEST)", "author": "mcvsubbu", "createdAt": "2020-07-20T15:56:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5MjEzNw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463892137", "bodyText": "Updated in latest commit.", "author": "guruguha", "createdAt": "2020-08-01T00:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNzkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODc1NA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518754", "bodyText": "The exception message reads as if the table is not found. That is not the case, right?", "author": "mcvsubbu", "createdAt": "2020-07-20T15:57:08Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxODk2MA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457518960", "bodyText": "If there are no tables found, then this is the place to throw 404", "author": "mcvsubbu", "createdAt": "2020-07-20T15:57:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMTY0Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457521647", "bodyText": "remove these trace logs please", "author": "mcvsubbu", "createdAt": "2020-07-20T16:00:46Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +493,91 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n+          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      }\n+      if (Objects.isNull(tableReloadStatus))\n+        throw new ControllerApplicationException(LOGGER,\n+                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+          throws InvalidConfigException {\n+    final Map<String, List<String>> serversToSegmentsMap =\n+            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+    TableMetadataReader tableMetadataReader =\n+            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n+            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, String> segmentsMetadata = null;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+    }\n+    if (segmentsMetadata == null)\n+      throw new ControllerApplicationException(LOGGER,\n+              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n+    return segmentsMetadata;\n+  }\n+\n+  private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n+          throws InvalidConfigException, IOException {\n+    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e8ac612f31efcbe8b90ab1380f8cc072fb36ec", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 6136b1eff4..c875cd2763 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -499,85 +507,69 @@ public class PinotSegmentRestletResource {\n   @Produces(MediaType.APPLICATION_JSON)\n   @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n   public Map<String, TableMetadataReader.TableReloadStatus> getReloadStatus(\n-          @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-          @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n     List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n     Map<String, TableMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n     for (String tableNameWithType : tableNamesWithType) {\n-      TableMetadataReader.TableReloadStatus tableReloadStatus = null;\n+      TableMetadataReader.TableReloadStatus tableReloadStatus;\n       try {\n         tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n       } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n       }\n-      if (Objects.isNull(tableReloadStatus))\n-        throw new ControllerApplicationException(LOGGER,\n-                \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n       reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n     }\n     return reloadStatusMap;\n   }\n \n   private TableMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-          throws InvalidConfigException {\n+      throws InvalidConfigException {\n     final Map<String, List<String>> serversToSegmentsMap =\n-            _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n+        _pinotHelixResourceManager.getServerToSegmentsMap(tableNameWithType);\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getReloadStatus(tableNameWithType, serversToSegmentsMap,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n \n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Get the metadata for a segment\", notes = \"Get the metadata for a segment\")\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n   public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n                                                @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n     TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME)\n+    if (tableType == TableType.REALTIME) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n \n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, String> segmentsMetadata = null;\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n     try {\n-      segmentsMetadata = getSegmentsMetadataFromServer(tableNamesWithType.get(0));\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n     } catch (InvalidConfigException e) {\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Failed to load segment reload status for table: \" + tableName, Status.NOT_FOUND);\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n     } catch (IOException ioe) {\n       throw new ControllerApplicationException(LOGGER,\n-              \"Error parsing response to cluster config!\", Response.Status.BAD_REQUEST, ioe);\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);\n     }\n-    if (segmentsMetadata == null)\n-      throw new ControllerApplicationException(LOGGER,\n-              \"Table: \" + tableName + \" not found.\", Status.NOT_FOUND);\n     return segmentsMetadata;\n   }\n \n   private Map<String, String> getSegmentsMetadataFromServer(String tableNameWithType)\n-          throws InvalidConfigException, IOException {\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() entry\");\n+      throws InvalidConfigException, IOException {\n     TableMetadataReader tableMetadataReader =\n-            new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    LOGGER.trace(\"Inside getSegmentsMetadataFromServer() exit\");\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n     return tableMetadataReader.getSegmentsMetadata(tableNameWithType,\n-            _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n-  @Nullable\n-  private Map<String, String> getSegmentMetadataInternal(String tableNameWithType, String segmentName) {\n-    ZkHelixPropertyStore<ZNRecord> propertyStore = _pinotHelixResourceManager.getPropertyStore();\n-    if (TableNameBuilder.isOfflineTableResource(tableNameWithType)) {\n-      OfflineSegmentZKMetadata offlineSegmentZKMetadata =\n-              ZKMetadataProvider.getOfflineSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return offlineSegmentZKMetadata != null ? offlineSegmentZKMetadata.toMap() : null;\n-    } else {\n-      RealtimeSegmentZKMetadata realtimeSegmentZKMetadata =\n-              ZKMetadataProvider.getRealtimeSegmentZKMetadata(propertyStore, tableNameWithType, segmentName);\n-      return realtimeSegmentZKMetadata != null ? realtimeSegmentZKMetadata.toMap() : null;\n-    }\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMjkzNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r457522936", "bodyText": "thy is this class in controller/api/resources? It should be inside controller/util", "author": "mcvsubbu", "createdAt": "2020-07-20T16:02:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package org.apache.pinot.controller.api.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerSegmentMetadataReader {", "originalCommit": "6914c3249a31572d29a6f00e5b8f378aabfca3e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "422c76a7c7bc3291a41970a21825a4ef2bded208", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\nindex 9b60a042f5..b8d639af43 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerSegmentMetadataReader.java\n\n@@ -1,3 +1,21 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.apache.pinot.controller.api.resources;\n \n import com.fasterxml.jackson.databind.JsonNode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDQ2Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462454467", "bodyText": "Why is this a \"String\"? Why not 'long'?\nPlease clearly indicate the time unit in the field name. e.g. segmentReloadTimeUTCMs\nWhat is the value in this field if the segment was never reloaded, or the server restarts after the reload? Or, the reload faced an error and failed?", "author": "mcvsubbu", "createdAt": "2020-07-29T17:09:05Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ */\n+public class SegmentStatus {\n+  public String _segmentName;\n+  public String _segmentReloadTime;", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\nindex fca72b4db2..3efb5a94d3 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\n\n@@ -20,24 +20,34 @@ package org.apache.pinot.common.restlet.resources;\n \n /**\n  * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ *\n+ * NOTE: This class is being used in both the controller and the server. There is tight coupling between them.\n+ * So, the API contract cannot be changed without changing or refactoring this class.\n+ *\n+ * TODO: refactor this class to be handled better. Make sure to have an extensible design that helps add more\n  */\n public class SegmentStatus {\n+  // Name of the segment itself\n   public String _segmentName;\n-  public String _segmentReloadTime;\n+  // The last segment reload time in ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)\n+  // If the segment reload failed for a segment, then the value will be the previous segment reload was successful\n+  public String _segmentReloadTimeUTC;\n+  // If a segment load failed, then a status message is to be set - currently not done\n+  // TODO: add message description to show why call to fetch reload status has errors\n   public String _segmentReloadStatusMessage;\n \n   public SegmentStatus() {\n   }\n \n-  public SegmentStatus(String segmentName, String segmentReloadTime, String segmentReloadStatusMessage) {\n+  public SegmentStatus(String segmentName, String segmentReloadTimeUTC, String segmentReloadStatusMessage) {\n     _segmentName = segmentName;\n-    _segmentReloadTime = segmentReloadTime;\n+    _segmentReloadTimeUTC = segmentReloadTimeUTC;\n     _segmentReloadStatusMessage = segmentReloadStatusMessage;\n   }\n \n   @Override\n   public String toString() {\n-    return \"{ segmentName: \" + _segmentName + \", segmentReloadTime: \" + _segmentReloadTime +\n+    return \"{ segmentName: \" + _segmentName + \", segmentReloadTime: \" + _segmentReloadTimeUTC +\n         \", segmentReloadStatusMessage: \" + _segmentReloadStatusMessage + \" }\";\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NjAyNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462456026", "bodyText": "Let us call it \"loadStatus\" or \"runTimeStatus\" (I think all our APIs are in camel case). And change the comments/String below appropriately", "author": "mcvsubbu", "createdAt": "2020-07-29T17:11:38Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 3b4229f0ef..13a7542899 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -505,9 +506,9 @@ public class PinotSegmentRestletResource {\n   }\n \n   @GET\n-  @Path(\"segments/{tableName}/reload-status\")\n+  @Path(\"segments/{tableName}/loadStatus\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n   public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n       @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n       @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NzE4OA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457188", "bodyText": "Seems like a debug level log.", "author": "mcvsubbu", "createdAt": "2020-07-29T17:13:24Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 3b4229f0ef..13a7542899 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -505,9 +506,9 @@ public class PinotSegmentRestletResource {\n   }\n \n   @GET\n-  @Path(\"segments/{tableName}/reload-status\")\n+  @Path(\"segments/{tableName}/loadStatus\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n   public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n       @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n       @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Nzk2OQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462457969", "bodyText": "Indicate the server name here that caused the error (unless that is logged elsewhere)", "author": "mcvsubbu", "createdAt": "2020-07-29T17:14:41Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n+  }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/metadata\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Get the server metadata for all table segments\", notes = \"Get the server metadata for all table segments\")\n+  public Map<String, String> getServerMetadata(@ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+                                               @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    LOGGER.info(\"Received a request to fetch metadata for all segments for table {}\", tableName);\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    String tableNameWithType = getExistingTableNamesWithType(tableName, tableType).get(0);\n+    Map<String, String> segmentsMetadata;\n+    try {\n+      segmentsMetadata = getSegmentsMetadataFromServer(tableNameWithType);\n+    } catch (InvalidConfigException e) {\n+      throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+    } catch (IOException ioe) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Error parsing Pinot server response: \" + ioe.getMessage(), Status.INTERNAL_SERVER_ERROR, ioe);", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTc1Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895752", "bodyText": "Yes, is logged in the helper class", "author": "guruguha", "createdAt": "2020-08-01T00:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Nzk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 3b4229f0ef..13a7542899 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -505,9 +506,9 @@ public class PinotSegmentRestletResource {\n   }\n \n   @GET\n-  @Path(\"segments/{tableName}/reload-status\")\n+  @Path(\"segments/{tableName}/loadStatus\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n   public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n       @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n       @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r462460112", "bodyText": "I strongly suggest adding a verbosity level and/or a limit here. Can be added later if you wish. Imagine a table with a million segments. Do we really want to kill the servers trying to query all the segments? Or, output them only to let the client time out?\nAn example could be: limit=100 by default, verbosity=5. A level of 4, 3, 2,1 will show less information for each segment. Maybe 0 will only show how many segments that are online/offline etc.?", "author": "mcvsubbu", "createdAt": "2020-07-29T17:18:11Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +503,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/reload-status\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")", "originalCommit": "1cea905ee8f4343b2c7f50a0612a53dae6fa34b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMzc0Nw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463833747", "bodyText": "Thanks for the suggestion. Makes sense to add limit. I did think about this, but then, the issue will be knowing the status of the remaining segments. For a table with say, 1000 segments, how do we let the user know of the status of the rest of the segments?", "author": "guruguha", "createdAt": "2020-07-31T20:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTI4Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895282", "bodyText": "Add an API to get status for a range of segments, maybe? Or, add some sort of start/limit?", "author": "mcvsubbu", "createdAt": "2020-08-01T00:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTYxNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r463895616", "bodyText": "If you are adding one to get the status of one segment at a time, then the user can (if needed) iterate over the segments and get each segment. Let us evaluate the use case first. Are we talking about a full table reload or a segment reload? If full table reload, maybe we only want to return those segments that DID NOT reload properly?\nThe API definition leaves much discussion to be desired, and a PR is NOT the place to discuss API. If you have a design doc, we will discuss there.", "author": "mcvsubbu", "createdAt": "2020-08-01T00:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAwNjE0NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r469006145", "bodyText": "this can be done in another PR. Lets get this in and add the optimizations as we need them. Million segments in a table is not a common use case.", "author": "kishoreg", "createdAt": "2020-08-12T05:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MDExMg=="}], "type": "inlineReview", "revised_code": {"commit": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 3b4229f0ef..13a7542899 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -505,9 +506,9 @@ public class PinotSegmentRestletResource {\n   }\n \n   @GET\n-  @Path(\"segments/{tableName}/reload-status\")\n+  @Path(\"segments/{tableName}/loadStatus\")\n   @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Status of segment reload\", notes = \"Status of segment reload\")\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n   public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n       @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n       @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n"}}, {"oid": "d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "url": "https://github.com/apache/pinot/commit/d2d1c84dc301838be3ef8ffa6fb5b8b88056840f", "message": "Code refactor to accommodate PR comments\nPinot codestyle corrections\nMoving ServerSegmentMetadataReader to util", "committedDate": "2020-08-12T05:28:00Z", "type": "commit"}, {"oid": "d14f14300ff6053d3f2e2194a88790e636baeead", "url": "https://github.com/apache/pinot/commit/d14f14300ff6053d3f2e2194a88790e636baeead", "message": "Updating API definition for loadStatus", "committedDate": "2020-08-12T05:55:19Z", "type": "commit"}, {"oid": "b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "url": "https://github.com/apache/pinot/commit/b5b7d1c56828ea195fb0ceeb2dee0244fe2fe8d8", "message": "Code refactor to remove duplicate code", "committedDate": "2020-08-13T20:26:36Z", "type": "commit"}, {"oid": "8ee255fb4bf05af46d0006e6c2c9cb0174820905", "url": "https://github.com/apache/pinot/commit/8ee255fb4bf05af46d0006e6c2c9cb0174820905", "message": "Code refactor to remove duplicate code", "committedDate": "2020-08-13T20:30:03Z", "type": "commit"}, {"oid": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "url": "https://github.com/apache/pinot/commit/2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "message": "Merge remote-tracking branch 'origin/feature/#5390-segment-indexing-reload-status-api' into feature/#5390-segment-indexing-reload-status-api\n\n# Conflicts:\n#\tpinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java", "committedDate": "2020-08-13T20:30:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NzQ5MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474097491", "bodyText": "Add the server name to this log", "author": "mcvsubbu", "createdAt": "2020-08-20T16:03:14Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\nindex b3715a6468..98c63744c4 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\n\n@@ -76,11 +76,11 @@ public class ServerTableSizeReader {\n         serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n       } catch (IOException e) {\n         failedParses++;\n-        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+        LOGGER.error(\"Unable to parse server {} response due to an error: \", streamResponse.getKey(), e);\n       }\n     }\n     if (failedParses != 0) {\n-      LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);\n+      LOGGER.warn(\"Failed to parse {} / {} segment size info responses from servers.\", failedParses, serverUrls.size());\n     }\n     return serverToSegmentSizeInfoListMap;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTMyNg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474099326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment size info responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible, add the total number of servers to this message as well", "author": "mcvsubbu", "createdAt": "2020-08-20T16:06:00Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java", "diffHunk": "@@ -64,40 +62,25 @@ public ServerTableSizeReader(Executor executor, HttpConnectionManager connection\n       serverUrls.add(tableSizeUri);\n     }\n \n-    // TODO: use some service other than completion service so that we know which server encounters the error\n-    CompletionService<GetMethod> completionService =\n-        new MultiGetRequest(_executor, _connectionManager).execute(serverUrls, timeoutMs);\n+    // Helper service to run a httpget call to the server\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager,\n+        endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverUrls, tableNameWithType, timeoutMs);\n     Map<String, List<SegmentSizeInfo>> serverToSegmentSizeInfoListMap = new HashMap<>();\n-\n-    for (int i = 0; i < numServers; i++) {\n-      GetMethod getMethod = null;\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n       try {\n-        getMethod = completionService.take().get();\n-        URI uri = getMethod.getURI();\n-        String instance = endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n-        if (getMethod.getStatusCode() >= 300) {\n-          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n-          continue;\n-        }\n         TableSizeInfo tableSizeInfo =\n-            JsonUtils.inputStreamToObject(getMethod.getResponseBodyAsStream(), TableSizeInfo.class);\n-        serverToSegmentSizeInfoListMap.put(instance, tableSizeInfo.segments);\n-      } catch (Exception e) {\n-        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n-        // Log the number of failed servers after gathering all responses\n-      } finally {\n-        if (getMethod != null) {\n-          getMethod.releaseConnection();\n-        }\n+            JsonUtils.stringToObject(streamResponse.getValue(), TableSizeInfo.class);\n+        serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n       }\n     }\n-\n-    int numServersResponded = serverToSegmentSizeInfoListMap.size();\n-    if (numServersResponded != numServers) {\n-      LOGGER.warn(\"Finish reading segment sizes for table: {} with {}/{} servers responded\", tableNameWithType,\n-          numServersResponded, numServers);\n-    } else {\n-      LOGGER.info(\"Finish reading segment sizes for table: {}\", tableNameWithType);\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\nindex b3715a6468..98c63744c4 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/ServerTableSizeReader.java\n\n@@ -76,11 +76,11 @@ public class ServerTableSizeReader {\n         serverToSegmentSizeInfoListMap.put(streamResponse.getKey(), tableSizeInfo.segments);\n       } catch (IOException e) {\n         failedParses++;\n-        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+        LOGGER.error(\"Unable to parse server {} response due to an error: \", streamResponse.getKey(), e);\n       }\n     }\n     if (failedParses != 0) {\n-      LOGGER.warn(\"Failed to parse {} segment size info responses from server.\", failedParses);\n+      LOGGER.warn(\"Failed to parse {} / {} segment size info responses from servers.\", failedParses, serverUrls.size());\n     }\n     return serverToSegmentSizeInfoListMap;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDc5Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474100793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      numServersResponded, serverURLs);\n          \n          \n            \n                      numServersResponded, serverURLs.size());", "author": "mcvsubbu", "createdAt": "2020-08-20T16:08:21Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.controller.util;\n+\n+import com.google.common.collect.BiMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionService;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.URI;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.pinot.common.http.MultiGetRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that can be used to make HttpGet (MultiGet) calls and get the responses back.\n+ * The responses are returned as a string.\n+ *\n+ * The helper also records number of failed responses so that the caller knows if any of the calls\n+ * failed to respond. The failed instance is logged for debugging.\n+ */\n+public class CompletionServiceHelper {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompletionServiceHelper.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _httpConnectionManager;\n+  private final BiMap<String, String> _endpointsToServers;\n+\n+  public CompletionServiceHelper(Executor executor, HttpConnectionManager httpConnectionManager,\n+                                 BiMap<String, String> endpointsToServers) {\n+    _executor = executor;\n+    _httpConnectionManager = httpConnectionManager;\n+    _endpointsToServers = endpointsToServers;\n+  }\n+\n+  public CompletionServiceResponse doMultiGetRequest(List<String> serverURLs, String tableNameWithType, int timeoutMs) {\n+    CompletionServiceResponse completionServiceResponse = new CompletionServiceResponse();\n+\n+    // TODO: use some service other than completion service so that we know which server encounters the error\n+    CompletionService<GetMethod> completionService =\n+        new MultiGetRequest(_executor, _httpConnectionManager).execute(serverURLs, timeoutMs);\n+    for (int i = 0; i < serverURLs.size(); i++) {\n+      GetMethod getMethod = null;\n+      try {\n+        getMethod = completionService.take().get();\n+        URI uri = getMethod.getURI();\n+        String instance = _endpointsToServers.get(uri.getHost() + \":\" + uri.getPort());\n+        if (getMethod.getStatusCode() >= 300) {\n+          LOGGER.error(\"Server: {} returned error: {}\", instance, getMethod.getStatusCode());\n+          completionServiceResponse._failedResponseCount++;\n+          continue;\n+        }\n+        completionServiceResponse._httpResponses.put(instance, getMethod.getResponseBodyAsString());\n+      } catch (Exception e) {\n+        // Ignore individual exceptions because the exception has been logged in MultiGetRequest\n+        // Log the number of failed servers after gathering all responses\n+      } finally {\n+        if (getMethod != null) {\n+          getMethod.releaseConnection();\n+        }\n+      }\n+    }\n+\n+    int numServersResponded = completionServiceResponse._httpResponses.size();\n+    if (numServersResponded != serverURLs.size()) {\n+      LOGGER.warn(\"Finish reading information for table: {} with {}/{} server responses\", tableNameWithType,\n+          numServersResponded, serverURLs);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java\nindex 5d08e1e023..c9fd4e3453 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/CompletionServiceHelper.java\n\n@@ -83,16 +83,21 @@ public class CompletionServiceHelper {\n \n     int numServersResponded = completionServiceResponse._httpResponses.size();\n     if (numServersResponded != serverURLs.size()) {\n-      LOGGER.warn(\"Finish reading information for table: {} with {}/{} server responses\", tableNameWithType,\n-          numServersResponded, serverURLs);\n+      LOGGER.warn(\"Finished reading information for table: {} with {}/{} server responses\", tableNameWithType,\n+          numServersResponded, serverURLs.size());\n     } else {\n-      LOGGER.info(\"Finish reading information for table: {}\", tableNameWithType);\n+      LOGGER.info(\"Finished reading information for table: {}\", tableNameWithType);\n     }\n     return completionServiceResponse;\n   }\n \n+  /**\n+   * Helper class to maintain the completion service response to be sent back to the caller.\n+   */\n   static public class CompletionServiceResponse {\n+    // Map of the server instance to the response from that server\n     public Map<String, String> _httpResponses;\n+    // Number of failures encountered when requesting\n     public int _failedResponseCount;\n \n     public CompletionServiceResponse() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTU0MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474101541", "bodyText": "Add server name in the log", "author": "mcvsubbu", "createdAt": "2020-08-20T16:09:30Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjE0Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment metadata responses from {} servers.\", failedParses);\n          \n      \n    \n    \n  \n\nIf possible add total number of servers to this message as well", "author": "mcvsubbu", "createdAt": "2020-08-20T16:10:22Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMjk4MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474102981", "bodyText": "add the number of servers to this log message", "author": "mcvsubbu", "createdAt": "2020-08-20T16:11:40Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzM4Ng==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103386", "bodyText": "add server name", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:15Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzU2MQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n          \n          \n            \n                  LOGGER.warn(\"Failed to parse segment load status responses from {} servers.\", failedParses);", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:32Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzcyMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474103720", "bodyText": "nit: typo", "author": "mcvsubbu", "createdAt": "2020-08-20T16:12:47Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.controller.util;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.google.common.collect.BiMap;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.spi.utils.JsonUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a helper class that calls the server API endpoints to fetch server metadata and the segment reload status\n+ * Only the servers returning success are returned by the method. For servers returning errors (http error or otherwise),\n+ * no entry is created in the return list\n+ */\n+public class ServerSegmentMetadataReader {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ServerSegmentMetadataReader.class);\n+\n+  private final Executor _executor;\n+  private final HttpConnectionManager _connectionManager;\n+\n+  public ServerSegmentMetadataReader(Executor executor, HttpConnectionManager connectionManager) {\n+    _executor = executor;\n+    _connectionManager = connectionManager;\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * This method makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serversToSegmentsMap\n+   * @param endpoints\n+   * @param timeoutMs\n+   * @return list of segments and their metadata as a JSON string\n+   */\n+  public List<String> getSegmentMetadataFromServer(String tableNameWithType,\n+                                                   Map<String, List<String>> serversToSegmentsMap,\n+                                                   BiMap<String, String> endpoints, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment metadata from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegments : serversToSegmentsMap.entrySet()) {\n+      List<String> segments = serverToSegments.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateSegmentMetadataServerURL(tableNameWithType, segment, endpoints.get(serverToSegments.getKey())));\n+      }\n+    }\n+    BiMap<String, String> endpointsToServers = endpoints.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<String> segmentsMetadata = new ArrayList<>();\n+\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        JsonNode segmentMetadata = JsonUtils.stringToJsonNode(streamResponse.getValue());\n+        segmentsMetadata.add(JsonUtils.objectToString(segmentMetadata));\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment metadata responses from server.\", failedParses);\n+    }\n+\n+    LOGGER.debug(\"Retrieved segment metadata from servers.\");\n+    return segmentsMetadata;\n+  }\n+\n+  private String generateSegmentMetadataServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/metadata\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  private String generateReloadStatusServerURL(String tableNameWithType, String segmentName, String endpoint) {\n+    return String.format(\"http://%s/tables/%s/segments/%s/loadStatus\", endpoint, tableNameWithType, segmentName);\n+  }\n+\n+  /**\n+   * This method is called when the API request is to fetch segment metadata for all segments of the table.\n+   * It makes a MultiGet call to all servers that host their respective segments and gets the results.\n+   * @param tableNameWithType\n+   * @param serverToSegments\n+   * @param serverToEndpoint\n+   * @param timeoutMs\n+   * @return list of segments along with their last reload times\n+   */\n+  public TableReloadStatus getSegmentReloadTime(String tableNameWithType,\n+                                                Map<String, List<String>> serverToSegments,\n+                                                BiMap<String, String> serverToEndpoint, int timeoutMs) {\n+    LOGGER.debug(\"Reading segment reload status from servers for table {}.\", tableNameWithType);\n+    List<String> serverURLs = new ArrayList<>();\n+    for (Map.Entry<String, List<String>> serverToSegmentsEntry : serverToSegments.entrySet()) {\n+      List<String> segments = serverToSegmentsEntry.getValue();\n+      for (String segment : segments) {\n+        serverURLs.add(generateReloadStatusServerURL(tableNameWithType, segment, serverToEndpoint.get(serverToSegmentsEntry.getKey())));\n+      }\n+    }\n+\n+    BiMap<String, String> endpointsToServers = serverToEndpoint.inverse();\n+    CompletionServiceHelper completionServiceHelper = new CompletionServiceHelper(_executor, _connectionManager, endpointsToServers);\n+    CompletionServiceHelper.CompletionServiceResponse serviceResponse =\n+        completionServiceHelper.doMultiGetRequest(serverURLs, tableNameWithType, timeoutMs);\n+    List<SegmentStatus> segmentsStatus = new ArrayList<>();\n+    int failedParses = 0;\n+    for (Map.Entry<String, String> streamResponse : serviceResponse._httpResponses.entrySet()) {\n+      try {\n+        SegmentStatus segmentStatus = JsonUtils.stringToObject(streamResponse.getValue(), SegmentStatus.class);\n+        segmentsStatus.add(segmentStatus);\n+      } catch (IOException e) {\n+        failedParses++;\n+        LOGGER.error(\"Unable to parse server response due to an error: \", e);\n+      }\n+    }\n+    if (failedParses != 0) {\n+      LOGGER.warn(\"Failed to parse {} segment load status responses from server.\", failedParses);\n+    }\n+\n+    TableReloadStatus tableReloadStatus = new TableReloadStatus();\n+    tableReloadStatus._tableName = tableNameWithType;\n+    tableReloadStatus._segmentStatus = segmentsStatus;\n+    tableReloadStatus._numSegmentsFailed = serviceResponse._failedResponseCount;\n+    return tableReloadStatus;\n+  }\n+\n+  /**\n+   * Structure to hold the reload statsus for all segments of a given table.", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\nindex 5863ab4f45..1fbfb8886a 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/util/ServerSegmentMetadataReader.java\n\n@@ -27,7 +27,7 @@ import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executor;\n import org.apache.commons.httpclient.HttpConnectionManager;\n-import org.apache.pinot.common.restlet.resources.SegmentStatus;\n+import org.apache.pinot.common.restlet.resources.SegmentLoadStatus;\n import org.apache.pinot.spi.utils.JsonUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474104875", "bodyText": "Why is this a String and not long?", "author": "mcvsubbu", "createdAt": "2020-08-20T16:14:41Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.restlet.resources;\n+\n+/**\n+ * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n+ *\n+ * NOTE: This class is being used in both the controller and the server. There is tight coupling between them.\n+ * So, the API contract cannot be changed without changing or refactoring this class.\n+ *\n+ * TODO: refactor this class to be handled better. Make sure to have an extensible design that helps add more\n+ */\n+public class SegmentStatus {\n+  // Name of the segment itself\n+  public String _segmentName;\n+  // The last segment reload time in ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)\n+  // If the segment reload failed for a segment, then the value will be the previous segment reload was successful\n+  public String _segmentReloadTimeUTC;", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTkwNA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101904", "bodyText": "The date is in string format: ISO date format (yyyy-MM-dd HH:mm:ss:SSS UTC)", "author": "guruguha", "createdAt": "2020-08-22T15:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODc3Mg==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r479518772", "bodyText": "I have updated the API to return long instead of String", "author": "guruguha", "createdAt": "2020-08-28T20:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNDg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentLoadStatus.java\nsimilarity index 88%\nrename from pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\nrename to pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentLoadStatus.java\nindex 3efb5a94d3..cbdd76e36e 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentStatus.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/restlet/resources/SegmentLoadStatus.java\n\n@@ -18,6 +18,8 @@\n  */\n package org.apache.pinot.common.restlet.resources;\n \n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+\n /**\n  * Holds segment last reload time status along with any errors for a segment with unsuccessful call to get reload times.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTYzMA==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r474105630", "bodyText": "Ideally we should have timeout declared in milliseconds, so that we can configure sub-second values for fast responses. I suppose you are re-using a previously declared config here?", "author": "mcvsubbu", "createdAt": "2020-08-20T16:15:54Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java", "diffHunk": "@@ -485,4 +504,80 @@ private void deleteSegmentsInternal(String tableNameWithType, List<String> segme\n       throw new ControllerApplicationException(LOGGER, e.getMessage(), Response.Status.FORBIDDEN);\n     }\n   }\n+\n+  @GET\n+  @Path(\"segments/{tableName}/loadStatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n+  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n+      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n+      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n+    TableType tableType = Constants.validateTableType(tableTypeStr);\n+    if (tableType == TableType.REALTIME) {\n+      throw new ControllerApplicationException(LOGGER,\n+          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n+    }\n+\n+    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n+    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n+    for (String tableNameWithType : tableNamesWithType) {\n+      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n+      try {\n+        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n+      } catch (InvalidConfigException e) {\n+        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n+      }\n+      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n+    }\n+    return reloadStatusMap;\n+  }\n+\n+  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n+      throws InvalidConfigException {\n+    TableMetadataReader tableMetadataReader =\n+        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n+    return tableMetadataReader.getReloadStatus(tableNameWithType,\n+        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);", "originalCommit": "2198469a7609a94c8bb7f7f744fb9ecdb97f119c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwMTk5Mw==", "url": "https://github.com/apache/pinot/pull/5718#discussion_r475101993", "bodyText": "Yes, it was previously used in another code segment. Referred the same here as well.", "author": "guruguha", "createdAt": "2020-08-22T15:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTYzMA=="}], "type": "inlineReview", "revised_code": {"commit": "b36d4cf84d880efee931c8f8c4aa379311da7880", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\nindex 13a7542899..84537d648d 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/api/resources/PinotSegmentRestletResource.java\n\n@@ -505,41 +503,6 @@ public class PinotSegmentRestletResource {\n     }\n   }\n \n-  @GET\n-  @Path(\"segments/{tableName}/loadStatus\")\n-  @Produces(MediaType.APPLICATION_JSON)\n-  @ApiOperation(value = \"Load status of a table segment\", notes = \"Load status of a table segment\")\n-  public Map<String, ServerSegmentMetadataReader.TableReloadStatus> getReloadStatus(\n-      @ApiParam(value = \"Name of the table\", required = true) @PathParam(\"tableName\") String tableName,\n-      @ApiParam(value = \"OFFLINE|REALTIME\") @QueryParam(\"type\") String tableTypeStr) {\n-    TableType tableType = Constants.validateTableType(tableTypeStr);\n-    if (tableType == TableType.REALTIME) {\n-      throw new ControllerApplicationException(LOGGER,\n-          \"Table type : \" + tableTypeStr + \" not yet supported.\", Status.NOT_IMPLEMENTED);\n-    }\n-\n-    List<String> tableNamesWithType = getExistingTableNamesWithType(tableName, Constants.validateTableType(tableTypeStr));\n-    Map<String, ServerSegmentMetadataReader.TableReloadStatus> reloadStatusMap = new HashMap<>();\n-    for (String tableNameWithType : tableNamesWithType) {\n-      ServerSegmentMetadataReader.TableReloadStatus tableReloadStatus;\n-      try {\n-        tableReloadStatus = getSegmentsReloadStatus(tableNameWithType);\n-      } catch (InvalidConfigException e) {\n-        throw new ControllerApplicationException(LOGGER, e.getMessage(), Status.BAD_REQUEST);\n-      }\n-      reloadStatusMap.put(tableNameWithType, tableReloadStatus);\n-    }\n-    return reloadStatusMap;\n-  }\n-\n-  private ServerSegmentMetadataReader.TableReloadStatus getSegmentsReloadStatus(String tableNameWithType)\n-      throws InvalidConfigException {\n-    TableMetadataReader tableMetadataReader =\n-        new TableMetadataReader(_executor, _connectionManager, _pinotHelixResourceManager);\n-    return tableMetadataReader.getReloadStatus(tableNameWithType,\n-        _controllerConf.getServerAdminRequestTimeoutSeconds() * 1000);\n-  }\n-\n   @GET\n   @Path(\"segments/{tableName}/metadata\")\n   @Produces(MediaType.APPLICATION_JSON)\n"}}, {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "message": "Code refactor as per PR comments", "committedDate": "2020-08-22T15:32:50Z", "type": "commit"}, {"oid": "6e03c9b384d0eb1ab668bb01228885b26105d2a4", "url": "https://github.com/apache/pinot/commit/6e03c9b384d0eb1ab668bb01228885b26105d2a4", "message": "Code refactor as per PR comments", "committedDate": "2020-08-22T15:32:50Z", "type": "forcePushed"}, {"oid": "2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "url": "https://github.com/apache/pinot/commit/2a1cc16e2e871d8b47c71d9ba37ca38e3733037f", "message": "Updating segment loadStatus API to return long time than readable string", "committedDate": "2020-08-28T20:21:27Z", "type": "commit"}, {"oid": "563e56c9555250f2020efa016f43a069c2534d8f", "url": "https://github.com/apache/pinot/commit/563e56c9555250f2020efa016f43a069c2534d8f", "message": "- Bug fix on the server API endpoint", "committedDate": "2020-08-29T02:26:55Z", "type": "commit"}, {"oid": "d23434502cc83f96aa72f086fe936a0689c83079", "url": "https://github.com/apache/pinot/commit/d23434502cc83f96aa72f086fe936a0689c83079", "message": "Adding pretty print for server metadata response", "committedDate": "2020-08-29T02:37:16Z", "type": "commit"}, {"oid": "d13c91e180fb80a0b1770122c16a4250c7c8c36e", "url": "https://github.com/apache/pinot/commit/d13c91e180fb80a0b1770122c16a4250c7c8c36e", "message": "Reverting incorrect filename refactoring\nUpdating variable names to reflect their value type", "committedDate": "2020-09-01T02:56:41Z", "type": "commit"}, {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "message": "removing unused method variable", "committedDate": "2020-09-02T04:16:59Z", "type": "commit"}, {"oid": "ac98a410431f598e3b60f4980fc40b63f32c8e2b", "url": "https://github.com/apache/pinot/commit/ac98a410431f598e3b60f4980fc40b63f32c8e2b", "message": "removing unused method variable", "committedDate": "2020-09-02T04:16:59Z", "type": "forcePushed"}, {"oid": "2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "url": "https://github.com/apache/pinot/commit/2cf562909c7465b428df3a0a8b1d5ef5421b83d2", "message": "Enabling Pretty print of server response.\nCode refactor to clean up lines that went beyond line length", "committedDate": "2020-09-09T01:06:26Z", "type": "commit"}, {"oid": "b36d4cf84d880efee931c8f8c4aa379311da7880", "url": "https://github.com/apache/pinot/commit/b36d4cf84d880efee931c8f8c4aa379311da7880", "message": "Removing reload status API", "committedDate": "2020-09-09T03:08:00Z", "type": "commit"}, {"oid": "3f98c9949a7a280bc52b29488e6d8800f90e5852", "url": "https://github.com/apache/pinot/commit/3f98c9949a7a280bc52b29488e6d8800f90e5852", "message": "Pretty print result", "committedDate": "2020-09-11T23:33:16Z", "type": "commit"}, {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "message": "Fix test", "committedDate": "2020-09-12T00:32:15Z", "type": "commit"}, {"oid": "ec3603b051f92369402743bb48b7b8c88ce74ac7", "url": "https://github.com/apache/pinot/commit/ec3603b051f92369402743bb48b7b8c88ce74ac7", "message": "Fix test", "committedDate": "2020-09-12T00:32:15Z", "type": "forcePushed"}]}