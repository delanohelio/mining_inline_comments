{"pr_number": 6285, "pr_title": "Improve performance for distinct queries", "pr_createdAt": "2020-11-23T21:44:00Z", "pr_url": "https://github.com/apache/pinot/pull/6285", "timeline": [{"oid": "8c620e714928548ae4f095b91df626434480551a", "url": "https://github.com/apache/pinot/commit/8c620e714928548ae4f095b91df626434480551a", "message": "Improve performance for distinct queries", "committedDate": "2020-11-24T19:18:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MTczNQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533561735", "bodyText": "Common case (of aggr/group-by) should be first?", "author": "mayankshriv", "createdAt": "2020-12-01T16:45:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/CombinePlanNode.java", "diffHunk": "@@ -172,7 +173,19 @@ public CombinePlanNode(List<PlanNode> planNodes, QueryContext queryContext, Exec\n       return new StreamingSelectionOnlyCombineOperator(operators, _queryContext, _executorService, _endTimeMs,\n           _streamObserver);\n     }\n-    if (QueryContextUtils.isAggregationQuery(_queryContext)) {\n+    if (QueryContextUtils.isSelectionQuery(_queryContext)) {", "originalCommit": "8c620e714928548ae4f095b91df626434480551a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDM3OQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533654379", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-12-01T19:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/plan/CombinePlanNode.java b/pinot-core/src/main/java/org/apache/pinot/core/plan/CombinePlanNode.java\nindex f4089b4e60..c570e96645 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/plan/CombinePlanNode.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/plan/CombinePlanNode.java\n\n@@ -173,19 +173,7 @@ public class CombinePlanNode implements PlanNode {\n       return new StreamingSelectionOnlyCombineOperator(operators, _queryContext, _executorService, _endTimeMs,\n           _streamObserver);\n     }\n-    if (QueryContextUtils.isSelectionQuery(_queryContext)) {\n-      if (_queryContext.getLimit() == 0 || _queryContext.getOrderByExpressions() == null) {\n-        // Selection only\n-        return new SelectionOnlyCombineOperator(operators, _queryContext, _executorService, _endTimeMs);\n-      } else {\n-        // Selection order-by\n-        return new SelectionOrderByCombineOperator(operators, _queryContext, _executorService, _endTimeMs);\n-      }\n-    } else if (QueryContextUtils.isDistinctQuery(_queryContext)) {\n-      return new DistinctCombineOperator(operators, _queryContext, _executorService, _endTimeMs);\n-    } else {\n-      assert QueryContextUtils.isAggregationQuery(_queryContext);\n-\n+    if (QueryContextUtils.isAggregationQuery(_queryContext)) {\n       if (_queryContext.getGroupByExpressions() == null) {\n         // Aggregation only\n         return new AggregationOnlyCombineOperator(operators, _queryContext, _executorService, _endTimeMs);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MjQxMg==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533562412", "bodyText": "Same here, common case first?", "author": "mayankshriv", "createdAt": "2020-12-01T16:46:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/maker/InstancePlanMakerImplV2.java", "diffHunk": "@@ -123,8 +124,13 @@ public Plan makeInstancePlan(List<IndexSegment> indexSegments, QueryContext quer\n \n   @Override\n   public PlanNode makeSegmentPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n-    if (QueryContextUtils.isAggregationQuery(queryContext)) {\n-      // Aggregation query\n+    if (QueryContextUtils.isSelectionQuery(queryContext)) {", "originalCommit": "8c620e714928548ae4f095b91df626434480551a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDQ1NA==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533654454", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-12-01T19:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MjQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/plan/maker/InstancePlanMakerImplV2.java b/pinot-core/src/main/java/org/apache/pinot/core/plan/maker/InstancePlanMakerImplV2.java\nindex c1cc586241..0ea8f58108 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/plan/maker/InstancePlanMakerImplV2.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/plan/maker/InstancePlanMakerImplV2.java\n\n@@ -124,13 +124,7 @@ public class InstancePlanMakerImplV2 implements PlanMaker {\n \n   @Override\n   public PlanNode makeSegmentPlanNode(IndexSegment indexSegment, QueryContext queryContext) {\n-    if (QueryContextUtils.isSelectionQuery(queryContext)) {\n-      return new SelectionPlanNode(indexSegment, queryContext);\n-    } else if (QueryContextUtils.isDistinctQuery(queryContext)) {\n-      return new DistinctPlanNode(indexSegment, queryContext);\n-    } else {\n-      assert QueryContextUtils.isAggregationQuery(queryContext);\n-\n+    if (QueryContextUtils.isAggregationQuery(queryContext)) {\n       List<ExpressionContext> groupByExpressions = queryContext.getGroupByExpressions();\n       if (groupByExpressions != null) {\n         // Aggregation group-by query\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzkyNQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533563925", "bodyText": "Seems this class does not implement any of the methods?", "author": "mayankshriv", "createdAt": "2020-12-01T16:48:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -18,31 +18,25 @@\n  */\n package org.apache.pinot.core.query.aggregation.function;\n \n-import com.google.common.base.Preconditions;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.Map;\n import javax.annotation.Nullable;\n import org.apache.pinot.common.function.AggregationFunctionType;\n-import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.common.BlockValSet;\n-import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n-import org.apache.pinot.core.data.table.Record;\n import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n-import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n-import org.apache.pinot.core.query.aggregation.function.customobject.DistinctTable;\n import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n \n \n /**\n- * The DISTINCT clause in SQL is executed as the DISTINCT aggregation function.\n- * TODO: Support group-by\n+ * The DISTINCT clause in SQL is represented as the DISTINCT aggregation function. Currently it is only used to wrap the\n+ * information for the distinct queries.\n+ * TODO: Use a separate way to represent DISTINCT instead of aggregation.\n  */\n @SuppressWarnings(\"rawtypes\")\n-public class DistinctAggregationFunction implements AggregationFunction<DistinctTable, Comparable> {\n+public class DistinctAggregationFunction implements AggregationFunction<Object, Comparable> {", "originalCommit": "8c620e714928548ae4f095b91df626434480551a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjI1OA==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533656258", "bodyText": "Yes, currently DISTINCT keyword is not supported in the PinotQuery, so we use aggregation to pass the arguments. We keep it the same way for backward-compatibility, and I have added a TODO to clean it up later.", "author": "Jackie-Jiang", "createdAt": "2020-12-01T19:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTE1Mg==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533659152", "bodyText": "DISTINCT is supported in PinotQuery as a function. The CalciteSqlParser compiles Distinct specifically as a function expression.\nprivate static List<Expression> convertDistinctSelectList(SqlNodeList selectList) {\n    List<Expression> selectExpr = new ArrayList<>();\n    selectExpr.add(convertDistinctAndSelectListToFunctionExpression(selectList));\n    return selectExpr;\n  }", "author": "siddharthteotia", "createdAt": "2020-12-01T19:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzkyNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "e5440b1578895f19fe34cc5f3ae58759ba254945", "url": "https://github.com/apache/pinot/commit/e5440b1578895f19fe34cc5f3ae58759ba254945", "message": "Improve performance for distinct queries", "committedDate": "2020-12-01T19:11:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDg4NQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533664885", "bodyText": "Why not use Preconditions.checkState()? Are we moving away from them as a convention?", "author": "siddharthteotia", "createdAt": "2020-12-01T19:25:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.combine;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+\n+\n+/**\n+ * Combine operator for distinct queries.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class DistinctCombineOperator extends BaseCombineOperator {\n+  private static final String OPERATOR_NAME = \"DistinctCombineOperator\";\n+\n+  public DistinctCombineOperator(List<Operator> operators, QueryContext queryContext, ExecutorService executorService,\n+      long endTimeMs) {\n+    super(operators, queryContext, executorService, endTimeMs);\n+  }\n+\n+  @Override\n+  public String getOperatorName() {\n+    return OPERATOR_NAME;\n+  }\n+\n+  @Override\n+  protected boolean isQuerySatisfied(IntermediateResultsBlock resultsBlock) {\n+    if (_queryContext.getOrderByExpressions() == null) {\n+      List<Object> result = resultsBlock.getAggregationResult();\n+      assert result != null && result.size() == 1 && result.get(0) instanceof DistinctTable;\n+      DistinctTable distinctTable = (DistinctTable) result.get(0);\n+      return distinctTable.size() >= _queryContext.getLimit();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  protected void mergeResultsBlocks(IntermediateResultsBlock mergedBlock, IntermediateResultsBlock blockToMerge) {\n+    // TODO: Use a separate way to represent DISTINCT instead of aggregation.\n+    List<Object> mergedResults = mergedBlock.getAggregationResult();\n+    assert mergedResults != null && mergedResults.size() == 1 && mergedResults.get(0) instanceof DistinctTable;", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NjU5Ng==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533696596", "bodyText": "assert has no performance impact on production code. We don't really need to check it, this is more for readability", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\nindex 9d9e1ba3d1..e78ab4034f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\n\n@@ -34,9 +34,12 @@ import org.apache.pinot.core.query.request.context.QueryContext;\n public class DistinctCombineOperator extends BaseCombineOperator {\n   private static final String OPERATOR_NAME = \"DistinctCombineOperator\";\n \n+  private final boolean _hasOrderBy;\n+\n   public DistinctCombineOperator(List<Operator> operators, QueryContext queryContext, ExecutorService executorService,\n       long endTimeMs) {\n     super(operators, queryContext, executorService, endTimeMs);\n+    _hasOrderBy = queryContext.getOrderByExpressions() != null;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDkyMw==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533664923", "bodyText": "You can probably stash away the order by presence in a boolean instance variable and avoid the method call to getOrderByExpressions() here since I believe it will be called by each combine thread for each segment it is processing in a loop. Simply check for the instance variable", "author": "siddharthteotia", "createdAt": "2020-12-01T19:25:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.combine;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n+import org.apache.pinot.core.query.request.context.QueryContext;\n+\n+\n+/**\n+ * Combine operator for distinct queries.\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class DistinctCombineOperator extends BaseCombineOperator {\n+  private static final String OPERATOR_NAME = \"DistinctCombineOperator\";\n+\n+  public DistinctCombineOperator(List<Operator> operators, QueryContext queryContext, ExecutorService executorService,\n+      long endTimeMs) {\n+    super(operators, queryContext, executorService, endTimeMs);\n+  }\n+\n+  @Override\n+  public String getOperatorName() {\n+    return OPERATOR_NAME;\n+  }\n+\n+  @Override\n+  protected boolean isQuerySatisfied(IntermediateResultsBlock resultsBlock) {\n+    if (_queryContext.getOrderByExpressions() == null) {\n+      List<Object> result = resultsBlock.getAggregationResult();", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5OTAxOA==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533699018", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\nindex 9d9e1ba3d1..e78ab4034f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/combine/DistinctCombineOperator.java\n\n@@ -34,9 +34,12 @@ import org.apache.pinot.core.query.request.context.QueryContext;\n public class DistinctCombineOperator extends BaseCombineOperator {\n   private static final String OPERATOR_NAME = \"DistinctCombineOperator\";\n \n+  private final boolean _hasOrderBy;\n+\n   public DistinctCombineOperator(List<Operator> operators, QueryContext queryContext, ExecutorService executorService,\n       long endTimeMs) {\n     super(operators, queryContext, executorService, endTimeMs);\n+    _hasOrderBy = queryContext.getOrderByExpressions() != null;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NzcyMg==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533667722", "bodyText": "please consider separating this into multiple private methods for better readability", "author": "siddharthteotia", "createdAt": "2020-12-01T19:30:09Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/distinct/DistinctExecutorFactory.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.distinct;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.core.operator.transform.TransformOperator;\n+import org.apache.pinot.core.query.aggregation.function.DistinctAggregationFunction;\n+import org.apache.pinot.core.query.distinct.dictionary.DictionaryBasedMultiColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.dictionary.DictionaryBasedMultiColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.dictionary.DictionaryBasedSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.dictionary.DictionaryBasedSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawBytesSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawBytesSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawDoubleSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawDoubleSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawFloatSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawFloatSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawIntSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawIntSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawLongSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawLongSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawMultiColumnDistinctExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawStringSingleColumnDistinctOnlyExecutor;\n+import org.apache.pinot.core.query.distinct.raw.RawStringSingleColumnDistinctOrderByExecutor;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+\n+\n+public class DistinctExecutorFactory {\n+  private DistinctExecutorFactory() {\n+  }\n+\n+  public static DistinctExecutor getDistinctExecutor(DistinctAggregationFunction distinctAggregationFunction,\n+      TransformOperator transformOperator) {\n+    List<ExpressionContext> expressions = distinctAggregationFunction.getInputExpressions();\n+    List<OrderByExpressionContext> orderByExpressions = distinctAggregationFunction.getOrderByExpressions();\n+    int limit = distinctAggregationFunction.getLimit();\n+    if (orderByExpressions == null) {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNTEzNg==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533705136", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NzcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/DistinctExecutorFactory.java b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/DistinctExecutorFactory.java\nindex 4acaee3984..af3a9e8ee3 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/DistinctExecutorFactory.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/DistinctExecutorFactory.java\n\n@@ -45,131 +45,145 @@ import org.apache.pinot.core.segment.index.readers.Dictionary;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n \n \n+/**\n+ * Factory for {@link DistinctExecutor}.\n+ */\n public class DistinctExecutorFactory {\n   private DistinctExecutorFactory() {\n   }\n \n+  /**\n+   * Returns the {@link DistinctExecutor} for the given distinct query.\n+   */\n   public static DistinctExecutor getDistinctExecutor(DistinctAggregationFunction distinctAggregationFunction,\n       TransformOperator transformOperator) {\n     List<ExpressionContext> expressions = distinctAggregationFunction.getInputExpressions();\n     List<OrderByExpressionContext> orderByExpressions = distinctAggregationFunction.getOrderByExpressions();\n     int limit = distinctAggregationFunction.getLimit();\n     if (orderByExpressions == null) {\n-      // Distinct only\n-      if (expressions.size() == 1) {\n-        // Single column\n-        ExpressionContext expression = expressions.get(0);\n+      return getDistinctOnlyExecutor(expressions, limit, transformOperator);\n+    } else {\n+      return getDistinctOrderByExecutor(expressions, orderByExpressions, limit, transformOperator);\n+    }\n+  }\n+\n+  private static DistinctExecutor getDistinctOnlyExecutor(List<ExpressionContext> expressions, int limit,\n+      TransformOperator transformOperator) {\n+    if (expressions.size() == 1) {\n+      // Single column\n+      ExpressionContext expression = expressions.get(0);\n+      Dictionary dictionary = transformOperator.getDictionary(expression);\n+      if (dictionary != null) {\n+        // Dictionary based\n+        return new DictionaryBasedSingleColumnDistinctOnlyExecutor(expression, dictionary, limit);\n+      } else {\n+        // Raw value based\n+        DataType dataType = transformOperator.getResultMetadata(expression).getDataType();\n+        switch (dataType) {\n+          case INT:\n+            return new RawIntSingleColumnDistinctOnlyExecutor(expression, limit);\n+          case LONG:\n+            return new RawLongSingleColumnDistinctOnlyExecutor(expression, limit);\n+          case FLOAT:\n+            return new RawFloatSingleColumnDistinctOnlyExecutor(expression, limit);\n+          case DOUBLE:\n+            return new RawDoubleSingleColumnDistinctOnlyExecutor(expression, limit);\n+          case STRING:\n+            return new RawStringSingleColumnDistinctOnlyExecutor(expression, limit);\n+          case BYTES:\n+            return new RawBytesSingleColumnDistinctOnlyExecutor(expression, limit);\n+          default:\n+            throw new IllegalStateException();\n+        }\n+      }\n+    } else {\n+      // Multiple columns\n+      int numExpressions = expressions.size();\n+      List<Dictionary> dictionaries = new ArrayList<>(numExpressions);\n+      boolean dictionaryBased = true;\n+      for (ExpressionContext expression : expressions) {\n         Dictionary dictionary = transformOperator.getDictionary(expression);\n         if (dictionary != null) {\n-          // Dictionary based\n-          return new DictionaryBasedSingleColumnDistinctOnlyExecutor(expression, dictionary, limit);\n+          dictionaries.add(dictionary);\n         } else {\n-          // Raw value based\n-          DataType dataType = transformOperator.getResultMetadata(expression).getDataType();\n-          switch (dataType) {\n-            case INT:\n-              return new RawIntSingleColumnDistinctOnlyExecutor(expression, limit);\n-            case LONG:\n-              return new RawLongSingleColumnDistinctOnlyExecutor(expression, limit);\n-            case FLOAT:\n-              return new RawFloatSingleColumnDistinctOnlyExecutor(expression, limit);\n-            case DOUBLE:\n-              return new RawDoubleSingleColumnDistinctOnlyExecutor(expression, limit);\n-            case STRING:\n-              return new RawStringSingleColumnDistinctOnlyExecutor(expression, limit);\n-            case BYTES:\n-              return new RawBytesSingleColumnDistinctOnlyExecutor(expression, limit);\n-            default:\n-              throw new IllegalStateException();\n-          }\n+          dictionaryBased = false;\n+          break;\n         }\n+      }\n+      if (dictionaryBased) {\n+        // Dictionary based\n+        return new DictionaryBasedMultiColumnDistinctOnlyExecutor(expressions, dictionaries, limit);\n       } else {\n-        // Multiple columns\n-        int numExpressions = expressions.size();\n-        List<Dictionary> dictionaries = new ArrayList<>(numExpressions);\n-        boolean dictionaryBased = true;\n+        // Raw value based\n+        List<DataType> dataTypes = new ArrayList<>(numExpressions);\n         for (ExpressionContext expression : expressions) {\n-          Dictionary dictionary = transformOperator.getDictionary(expression);\n-          if (dictionary != null) {\n-            dictionaries.add(dictionary);\n-          } else {\n-            dictionaryBased = false;\n-            break;\n-          }\n+          dataTypes.add(transformOperator.getResultMetadata(expression).getDataType());\n         }\n-        if (dictionaryBased) {\n-          // Dictionary based\n-          return new DictionaryBasedMultiColumnDistinctOnlyExecutor(expressions, dictionaries, limit);\n-        } else {\n-          // Raw value based\n-          List<DataType> dataTypes = new ArrayList<>(numExpressions);\n-          for (ExpressionContext expression : expressions) {\n-            dataTypes.add(transformOperator.getResultMetadata(expression).getDataType());\n-          }\n-          return new RawMultiColumnDistinctExecutor(expressions, dataTypes, null, limit);\n+        return new RawMultiColumnDistinctExecutor(expressions, dataTypes, null, limit);\n+      }\n+    }\n+  }\n+\n+  private static DistinctExecutor getDistinctOrderByExecutor(List<ExpressionContext> expressions,\n+      List<OrderByExpressionContext> orderByExpressions, int limit, TransformOperator transformOperator) {\n+    if (expressions.size() == 1) {\n+      // Single column\n+      ExpressionContext expression = expressions.get(0);\n+      Dictionary dictionary = transformOperator.getDictionary(expression);\n+      // Note: Use raw value based when dictionary is not sorted (consuming segments).\n+      if (dictionary != null && dictionary.isSorted()) {\n+        // Dictionary based\n+        assert orderByExpressions.size() == 1;\n+        return new DictionaryBasedSingleColumnDistinctOrderByExecutor(expression, dictionary, orderByExpressions.get(0),\n+            limit);\n+      } else {\n+        // Raw value based\n+        DataType dataType = transformOperator.getResultMetadata(expression).getDataType();\n+        assert orderByExpressions.size() == 1;\n+        OrderByExpressionContext orderByExpression = orderByExpressions.get(0);\n+        switch (dataType) {\n+          case INT:\n+            return new RawIntSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          case LONG:\n+            return new RawLongSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          case FLOAT:\n+            return new RawFloatSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          case DOUBLE:\n+            return new RawDoubleSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          case STRING:\n+            return new RawStringSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          case BYTES:\n+            return new RawBytesSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n+          default:\n+            throw new IllegalStateException();\n         }\n       }\n     } else {\n-      // Distinct order-by\n-      if (expressions.size() == 1) {\n-        // Single column\n-        ExpressionContext expression = expressions.get(0);\n+      // Multiple columns\n+      int numExpressions = expressions.size();\n+      List<Dictionary> dictionaries = new ArrayList<>(numExpressions);\n+      boolean dictionaryBased = true;\n+      for (ExpressionContext expression : expressions) {\n         Dictionary dictionary = transformOperator.getDictionary(expression);\n         // Note: Use raw value based when dictionary is not sorted (consuming segments).\n         if (dictionary != null && dictionary.isSorted()) {\n-          // Dictionary based\n-          assert orderByExpressions.size() == 1;\n-          return new DictionaryBasedSingleColumnDistinctOrderByExecutor(expression, dictionary,\n-              orderByExpressions.get(0), limit);\n+          dictionaries.add(dictionary);\n         } else {\n-          // Raw value based\n-          DataType dataType = transformOperator.getResultMetadata(expression).getDataType();\n-          assert orderByExpressions.size() == 1;\n-          OrderByExpressionContext orderByExpression = orderByExpressions.get(0);\n-          switch (dataType) {\n-            case INT:\n-              return new RawIntSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            case LONG:\n-              return new RawLongSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            case FLOAT:\n-              return new RawFloatSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            case DOUBLE:\n-              return new RawDoubleSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            case STRING:\n-              return new RawStringSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            case BYTES:\n-              return new RawBytesSingleColumnDistinctOrderByExecutor(expression, orderByExpression, limit);\n-            default:\n-              throw new IllegalStateException();\n-          }\n+          dictionaryBased = false;\n+          break;\n         }\n+      }\n+      if (dictionaryBased) {\n+        // Dictionary based\n+        return new DictionaryBasedMultiColumnDistinctOrderByExecutor(expressions, dictionaries, orderByExpressions,\n+            limit);\n       } else {\n-        // Multiple columns\n-        int numExpressions = expressions.size();\n-        List<Dictionary> dictionaries = new ArrayList<>(numExpressions);\n-        boolean dictionaryBased = true;\n+        // Raw value based\n+        List<DataType> dataTypes = new ArrayList<>(numExpressions);\n         for (ExpressionContext expression : expressions) {\n-          Dictionary dictionary = transformOperator.getDictionary(expression);\n-          // Note: Use raw value based when dictionary is not sorted (consuming segments).\n-          if (dictionary != null && dictionary.isSorted()) {\n-            dictionaries.add(dictionary);\n-          } else {\n-            dictionaryBased = false;\n-            break;\n-          }\n-        }\n-        if (dictionaryBased) {\n-          // Dictionary based\n-          return new DictionaryBasedMultiColumnDistinctOrderByExecutor(expressions, dictionaries, orderByExpressions,\n-              limit);\n-        } else {\n-          // Raw value based\n-          List<DataType> dataTypes = new ArrayList<>(numExpressions);\n-          for (ExpressionContext expression : expressions) {\n-            dataTypes.add(transformOperator.getResultMetadata(expression).getDataType());\n-          }\n-          return new RawMultiColumnDistinctExecutor(expressions, dataTypes, orderByExpressions, limit);\n+          dataTypes.add(transformOperator.getResultMetadata(expression).getDataType());\n         }\n+        return new RawMultiColumnDistinctExecutor(expressions, dataTypes, orderByExpressions, limit);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MDUxOQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533680519", "bodyText": "javadoc please", "author": "siddharthteotia", "createdAt": "2020-12-01T19:52:37Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedMultiColumnDistinctExecutor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.distinct.dictionary;\n+\n+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\n+import it.unimi.dsi.fastutil.objects.ObjectSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n+import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+abstract class BaseDictionaryBasedMultiColumnDistinctExecutor implements DistinctExecutor {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedMultiColumnDistinctExecutor.java b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedMultiColumnDistinctExecutor.java\nindex b6eb29fc08..ee92d98d02 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedMultiColumnDistinctExecutor.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedMultiColumnDistinctExecutor.java\n\n@@ -26,14 +26,17 @@ import java.util.List;\n import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.data.table.Record;\n-import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.segment.index.readers.Dictionary;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.spi.utils.ByteArray;\n \n \n+/**\n+ * Base implementation of {@link DistinctExecutor} for multiple dictionary-encoded columns.\n+ */\n abstract class BaseDictionaryBasedMultiColumnDistinctExecutor implements DistinctExecutor {\n   final List<ExpressionContext> _expressions;\n   final List<Dictionary> _dictionaries;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MDYyMQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533680621", "bodyText": "javadoc please", "author": "siddharthteotia", "createdAt": "2020-12-01T19:52:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedSingleColumnDistinctExecutor.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.distinct.dictionary;\n+\n+import it.unimi.dsi.fastutil.ints.IntIterator;\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n+import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.apache.pinot.spi.utils.ByteArray;\n+\n+\n+abstract class BaseDictionaryBasedSingleColumnDistinctExecutor implements DistinctExecutor {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedSingleColumnDistinctExecutor.java b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedSingleColumnDistinctExecutor.java\nindex 89fe8bb6e7..d6a5ac6564 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedSingleColumnDistinctExecutor.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/dictionary/BaseDictionaryBasedSingleColumnDistinctExecutor.java\n\n@@ -26,14 +26,17 @@ import java.util.List;\n import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n import org.apache.pinot.core.data.table.Record;\n-import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.segment.index.readers.Dictionary;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.spi.utils.ByteArray;\n \n \n+/**\n+ * Base implementation of {@link DistinctExecutor} for single dictionary-encoded column.\n+ */\n abstract class BaseDictionaryBasedSingleColumnDistinctExecutor implements DistinctExecutor {\n   final ExpressionContext _expression;\n   final Dictionary _dictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MTc3OQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533681779", "bodyText": "Please add javadocs to all classes", "author": "siddharthteotia", "createdAt": "2020-12-01T19:54:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/distinct/raw/RawMultiColumnDistinctExecutor.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.distinct.raw;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.common.utils.DataSchema;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n+import org.apache.pinot.core.data.table.Record;\n+import org.apache.pinot.core.operator.blocks.TransformBlock;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n+import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+\n+\n+public class RawMultiColumnDistinctExecutor implements DistinctExecutor {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/raw/RawMultiColumnDistinctExecutor.java b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/raw/RawMultiColumnDistinctExecutor.java\nindex 82184d3013..1d74887396 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/raw/RawMultiColumnDistinctExecutor.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/distinct/raw/RawMultiColumnDistinctExecutor.java\n\n@@ -25,13 +25,16 @@ import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n import org.apache.pinot.core.data.table.Record;\n import org.apache.pinot.core.operator.blocks.TransformBlock;\n-import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.distinct.DistinctExecutor;\n+import org.apache.pinot.core.query.distinct.DistinctTable;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n \n \n+/**\n+ * {@link DistinctExecutor} for multiple columns where some columns are raw (non-dictionary-encoded).\n+ */\n public class RawMultiColumnDistinctExecutor implements DistinctExecutor {\n   private final List<ExpressionContext> _expressions;\n   private final DistinctTable _distinctTable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MzA2NQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533683065", "bodyText": "Can we add another 2 similar tests for single and multi column distinct on dictionary encoded columns. Here both the tests are on raw columns (and so we use DistinctTable)", "author": "siddharthteotia", "createdAt": "2020-12-01T19:56:53Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/InnerSegmentAggregationSingleValueQueriesTest.java", "diffHunk": "@@ -175,26 +178,23 @@ public void testVeryLargeAggregationGroupBy() {\n   @Test\n   public void testSingleColumnDistinct() {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNjMyNg==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533706326", "bodyText": "DistinctQueriesTest has all the scenarios covered", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4MzA2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4ODM0MA==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533688340", "bodyText": "We should separate this into multiple individual unit tests.", "author": "siddharthteotia", "createdAt": "2020-12-01T20:06:04Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java", "diffHunk": "@@ -170,163 +199,360 @@ private ImmutableSegment createSegment(int index, List<GenericRow> records)\n     return ImmutableSegmentLoader.load(new File(INDEX_DIR, segmentName), ReadMode.mmap);\n   }\n \n+  @Test\n+  public void testSingleColumnDistinctInnerSegment() {", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxMDY5Nw==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533710697", "bodyText": "Split into testSingleColumnDistinctOnlyInnerSegment and testSingleColumnDistinctOrderByInnerSegment. I don't think we need to split further because that is not as easy to manage", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4ODM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java b/pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java\nindex 7c9128bef6..6a9edfce73 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java\n\n@@ -200,8 +200,9 @@ public class DistinctQueriesTest extends BaseQueriesTest {\n   }\n \n   @Test\n-  public void testSingleColumnDistinctInnerSegment() {\n+  public void testSingleColumnDistinctOnlyInnerSegment() {\n     {\n+      // Numeric columns\n       //@formatter:off\n       List<String> queries = Arrays.asList(\n           \"SELECT DISTINCT(intColumn) FROM testTable\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MDgzMw==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533690833", "bodyText": "Unrelated to this PR - Can we please add another version of tests for SQL? Or may be just use getBrokerResponseForSqlQuery() instead of both PQL and SQL?", "author": "siddharthteotia", "createdAt": "2020-12-01T20:10:28Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/DistinctQueriesTest.java", "diffHunk": "@@ -394,285 +614,273 @@ private DistinctTable getDistinctTableInnerSegment(String query, boolean isPql)\n    *   </li>\n    * </ul>\n    */\n-  private void testDistinctInterSegmentHelper(String[] pqlQueries, String[] sqlQueries)\n-      throws Exception {\n-    ImmutableSegment segment0 = createSegment(0, generateRecords(0));\n-    ImmutableSegment segment1 = createSegment(1, generateRecords(1000));\n-    _indexSegments = Arrays.asList(segment0, segment1);\n-    try {\n-      {\n-        // Test selecting all columns\n-        String pqlQuery = pqlQueries[0];\n-        String sqlQuery = sqlQueries[0];\n-\n-        // Check data schema\n-        BrokerResponseNative pqlResponse = getBrokerResponseForPqlQuery(pqlQuery);\n-        SelectionResults selectionResults = pqlResponse.getSelectionResults();\n-        assertNotNull(selectionResults);\n-        assertEquals(selectionResults.getColumns(),\n-            Arrays.asList(\"intColumn\", \"longColumn\", \"floatColumn\", \"doubleColumn\", \"stringColumn\", \"bytesColumn\"));\n-        BrokerResponseNative sqlResponse = getBrokerResponseForSqlQuery(sqlQuery);\n-        ResultTable resultTable = sqlResponse.getResultTable();\n-        assertNotNull(resultTable);\n-        DataSchema dataSchema = resultTable.getDataSchema();\n-        assertEquals(dataSchema.getColumnNames(),\n-            new String[]{\"intColumn\", \"longColumn\", \"floatColumn\", \"doubleColumn\", \"stringColumn\", \"bytesColumn\"});\n-        assertEquals(dataSchema.getColumnDataTypes(),\n-            new ColumnDataType[]{ColumnDataType.INT, ColumnDataType.LONG, ColumnDataType.FLOAT, ColumnDataType.DOUBLE, ColumnDataType.STRING, ColumnDataType.BYTES});\n-\n-        // Check values, where all 200 unique values should be returned\n-        List<Serializable[]> pqlRows = selectionResults.getRows();\n-        assertEquals(pqlRows.size(), 2 * NUM_UNIQUE_RECORDS_PER_SEGMENT);\n-        List<Object[]> sqlRows = resultTable.getRows();\n-        assertEquals(sqlRows.size(), 2 * NUM_UNIQUE_RECORDS_PER_SEGMENT);\n-        Set<Integer> expectedValues = new HashSet<>();\n-        for (int i = 0; i < NUM_UNIQUE_RECORDS_PER_SEGMENT; i++) {\n+  private void testDistinctInterSegmentHelper(String[] pqlQueries, String[] sqlQueries) {\n+    {\n+      // Test selecting all columns\n+      String pqlQuery = pqlQueries[0];\n+      String sqlQuery = sqlQueries[0];\n+\n+      // Check data schema\n+      BrokerResponseNative pqlResponse = getBrokerResponseForPqlQuery(pqlQuery);", "originalCommit": "e5440b1578895f19fe34cc5f3ae58759ba254945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxMTQ5OQ==", "url": "https://github.com/apache/pinot/pull/6285#discussion_r533711499", "bodyText": "Why do we need that? On the server side, PQL and SQL are handled the same way, and we can use the same test logic for both", "author": "Jackie-Jiang", "createdAt": "2020-12-01T20:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MDgzMw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "url": "https://github.com/apache/pinot/commit/c42ec6c3465e6e7774f5b172068650e8dd090e91", "message": "Improve performance for distinct queries", "committedDate": "2020-12-01T21:00:49Z", "type": "commit"}, {"oid": "c42ec6c3465e6e7774f5b172068650e8dd090e91", "url": "https://github.com/apache/pinot/commit/c42ec6c3465e6e7774f5b172068650e8dd090e91", "message": "Improve performance for distinct queries", "committedDate": "2020-12-01T21:00:49Z", "type": "forcePushed"}]}