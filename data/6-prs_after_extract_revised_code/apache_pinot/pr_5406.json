{"pr_number": 5406, "pr_title": "Adding support to execute functions during query compilation", "pr_createdAt": "2020-05-18T07:35:17Z", "pr_url": "https://github.com/apache/pinot/pull/5406", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426425045", "bodyText": "this should be recursively evaluated, technically a function of function of literal should still be true here.\nE.g. format_time(now(), 'yyyy-MM-dd')", "author": "xiangfu0", "createdAt": "2020-05-18T07:39:07Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);\n+              break;\n+            default:\n+              //no change, let the expression be handled during execution phase\n+          }\n+        }\n+\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {\n+\n+    boolean compileTimeEvaluationPossible = true;\n+    Function functionCall = funcExpr.getFunctionCall();\n+    if(functionCall.getOperandsSize() > 0) {\n+      for (Expression expression : functionCall.getOperands()) {\n+        if (expression.getType() != ExpressionType.LITERAL) {", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTQ5MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426431490", "bodyText": "since logic is depth-first, it should work.\nformat_time(now(), 'yyyy-MM-dd') will first get changed to\nformat_time(123123123123, 'yyyy-MM-dd') which will be evaluated to\n2020-01-01", "author": "kishoreg", "createdAt": "2020-05-18T07:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyNTA0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\nindex f63b703c66..83b1415756 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n\n@@ -619,25 +621,21 @@ public class CalciteSqlParser {\n           }\n         }\n \n-        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n-\n-          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n-          switch (scalarFunctionType) {\n-            case NOW:\n-              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n-              break;\n-            case FORMAT_DATETIME:\n-              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n-              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n-              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n-              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n-              funcExpr = RequestUtils.getLiteralExpression(output);\n-              break;\n-            default:\n-              //no change, let the expression be handled during execution phase\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n           }\n         }\n-\n         return funcExpr;\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426428899", "bodyText": "better to implement method eval for each function which take operands list as argument which could be either literal or functions.\nThen this logic will just be\nfuncExpr = getScalarFunction(scalarFunctionType).eval(funcExpr.getFunctionCall().getOperands())", "author": "xiangfu0", "createdAt": "2020-05-18T07:46:30Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:\n+              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n+              break;\n+            case FORMAT_DATETIME:\n+              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n+              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n+              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n+              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n+              funcExpr = RequestUtils.getLiteralExpression(output);", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMjc3Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426432773", "bodyText": "Most of the functions are already available in FunctionRegistry and FunctionInvoker added by @npawar. Unfortunately, those functions are in pinot-core, we can move the scalar functions into pinot-common in another PR and remove custom implementation for now and datetime format", "author": "kishoreg", "createdAt": "2020-05-18T07:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDU1MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744550", "bodyText": "Added support for eval function of functions as long as all the recursive params are literal.", "author": "xiangfu0", "createdAt": "2020-05-20T05:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQyODg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\nindex f63b703c66..83b1415756 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n\n@@ -619,25 +621,21 @@ public class CalciteSqlParser {\n           }\n         }\n \n-        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n-\n-          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n-          switch (scalarFunctionType) {\n-            case NOW:\n-              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n-              break;\n-            case FORMAT_DATETIME:\n-              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n-              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n-              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n-              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n-              funcExpr = RequestUtils.getLiteralExpression(output);\n-              break;\n-            default:\n-              //no change, let the expression be handled during execution phase\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n           }\n         }\n-\n         return funcExpr;\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426964805", "bodyText": "What's the purpose of this? Flexibility to support variations of function names?", "author": "mayankshriv", "createdAt": "2020-05-19T00:35:45Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {\n+      String upperCaseFunctionName = value.getName().toUpperCase();\n+      _scalarFunctions.put(upperCaseFunctionName, value);\n+      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzI5NA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983294", "bodyText": "e.g. presto use _ in function names. It provides more robustness from user perspective.", "author": "xiangfu0", "createdAt": "2020-05-19T01:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NDgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\nindex c2c88a733d..9e7b5fb88f 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\n\n@@ -19,44 +19,23 @@\n package org.apache.pinot.common.function;\n \n import java.util.HashMap;\n-import java.util.HashSet;\n \n \n public enum ScalarFunctionType {\n \n   NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n \n-  private final String _name;\n-\n   static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n-\n-  static {\n-    ScalarFunctionType[] values = ScalarFunctionType.values();\n-    for (ScalarFunctionType value : values) {\n-      String upperCaseFunctionName = value.getName().toUpperCase();\n-      _scalarFunctions.put(upperCaseFunctionName, value);\n-      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);\n-    }\n-  }\n+  private final String _name;\n \n   ScalarFunctionType(String name) {\n     _name = name;\n   }\n \n-  /**\n-   * Returns the corresponding transform function type for the given function name.\n-   */\n-  public static ScalarFunctionType getScalarFunctionType(String functionName) {\n-    String upperCaseFunctionName = functionName.toUpperCase();\n-    try {\n-      return ScalarFunctionType.valueOf(upperCaseFunctionName);\n-    } catch (Exception e) {\n-      // Support function name of both datetime_format and datetime_format\n-      if (upperCaseFunctionName.contains(\"_\")) {\n-        return getScalarFunctionType(upperCaseFunctionName.replace(\"_\", \"\"));\n-      }\n-      throw new IllegalArgumentException(\"Invalid scalar function name: \" + functionName);\n-    }\n+  static void registerScalarFunction(ScalarFunctionType functionName) {\n+    String upperCaseFunctionName = functionName.getName().toUpperCase();\n+    _scalarFunctions.put(upperCaseFunctionName, functionName);\n+    _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), functionName);\n   }\n \n   public static boolean isScalarFunctionType(String functionName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965020", "bodyText": "Would it be easy to identify this based on function args, as opposed to pre-register?", "author": "mayankshriv", "createdAt": "2020-05-19T00:36:41Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.function;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+\n+public enum ScalarFunctionType {\n+\n+  NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n+\n+  private final String _name;\n+\n+  static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n+\n+  static {\n+    ScalarFunctionType[] values = ScalarFunctionType.values();\n+    for (ScalarFunctionType value : values) {", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4Mzk5Nw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983997", "bodyText": "I somehow feel, we should still pre-register those functions.", "author": "xiangfu0", "createdAt": "2020-05-19T01:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc0NDc4Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427744783", "bodyText": "Removed these code path for now.", "author": "xiangfu0", "createdAt": "2020-05-20T05:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTAyMA=="}], "type": "inlineReview", "revised_code": {"commit": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\nindex c2c88a733d..9e7b5fb88f 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/ScalarFunctionType.java\n\n@@ -19,44 +19,23 @@\n package org.apache.pinot.common.function;\n \n import java.util.HashMap;\n-import java.util.HashSet;\n \n \n public enum ScalarFunctionType {\n \n   NOW(\"now\"), FORMAT_DATETIME(\"format_datetime\");\n \n-  private final String _name;\n-\n   static HashMap<String, ScalarFunctionType> _scalarFunctions = new HashMap<>();\n-\n-  static {\n-    ScalarFunctionType[] values = ScalarFunctionType.values();\n-    for (ScalarFunctionType value : values) {\n-      String upperCaseFunctionName = value.getName().toUpperCase();\n-      _scalarFunctions.put(upperCaseFunctionName, value);\n-      _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), value);\n-    }\n-  }\n+  private final String _name;\n \n   ScalarFunctionType(String name) {\n     _name = name;\n   }\n \n-  /**\n-   * Returns the corresponding transform function type for the given function name.\n-   */\n-  public static ScalarFunctionType getScalarFunctionType(String functionName) {\n-    String upperCaseFunctionName = functionName.toUpperCase();\n-    try {\n-      return ScalarFunctionType.valueOf(upperCaseFunctionName);\n-    } catch (Exception e) {\n-      // Support function name of both datetime_format and datetime_format\n-      if (upperCaseFunctionName.contains(\"_\")) {\n-        return getScalarFunctionType(upperCaseFunctionName.replace(\"_\", \"\"));\n-      }\n-      throw new IllegalArgumentException(\"Invalid scalar function name: \" + functionName);\n-    }\n+  static void registerScalarFunction(ScalarFunctionType functionName) {\n+    String upperCaseFunctionName = functionName.getName().toUpperCase();\n+    _scalarFunctions.put(upperCaseFunctionName, functionName);\n+    _scalarFunctions.put(upperCaseFunctionName.replace(\"_\", \"\"), functionName);\n   }\n \n   public static boolean isScalarFunctionType(String functionName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426965938", "bodyText": "Will this approach scale, as number of scalar functions increase? For example, each one would need to be added here. What do you think about modelling this as a query rewrite phase that goes over all scalars and evaluates them?", "author": "mayankshriv", "createdAt": "2020-05-19T00:40:15Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +618,47 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+\n+          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n+          switch (scalarFunctionType) {\n+            case NOW:", "originalCommit": "b91b4f33292c594307fe5e7087beae7f13dc0531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk4MzU4NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r426983585", "bodyText": "I think we will need to move to function registry/invoker model", "author": "xiangfu0", "createdAt": "2020-05-19T01:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzE1Mw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597153", "bodyText": "yes, this is to just ensure that the logic of detection if a function can be evaluated at query compile time works.", "author": "kishoreg", "createdAt": "2020-05-19T21:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NTkzOA=="}], "type": "inlineReview", "revised_code": {"commit": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\nindex f63b703c66..83b1415756 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n\n@@ -619,25 +621,21 @@ public class CalciteSqlParser {\n           }\n         }\n \n-        if (FunctionDefinitionRegistry.isScalarFunc(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n-\n-          ScalarFunctionType scalarFunctionType = ScalarFunctionType.getScalarFunctionType(funcName);\n-          switch (scalarFunctionType) {\n-            case NOW:\n-              funcExpr = RequestUtils.getLiteralExpression(System.currentTimeMillis());\n-              break;\n-            case FORMAT_DATETIME:\n-              //DATETIME_FORMAT ('2020-01-01', 'yyyy-MM-dd')\n-              String input = funcExpr.getFunctionCall().getOperands().get(0).getLiteral().getStringValue();\n-              String format = funcExpr.getFunctionCall().getOperands().get(1).getLiteral().getStringValue();\n-              long output = DateTimeFormat.forPattern(format).parseMillis(input);\n-              funcExpr = RequestUtils.getLiteralExpression(output);\n-              break;\n-            default:\n-              //no change, let the expression be handled during execution phase\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n           }\n         }\n-\n         return funcExpr;\n     }\n   }\n"}}, {"oid": "6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "url": "https://github.com/apache/pinot/commit/6d95bb72ecd2be67e17bd8fa6d01190cdbb44bef", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T10:40:39Z", "type": "forcePushed"}, {"oid": "53acdfa8231d430232cefaa7cf09b75673abb90d", "url": "https://github.com/apache/pinot/commit/53acdfa8231d430232cefaa7cf09b75673abb90d", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T16:57:09Z", "type": "forcePushed"}, {"oid": "0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "url": "https://github.com/apache/pinot/commit/0e21590e08d954d73c0d28dd3ffa4b40727bdc25", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T18:19:38Z", "type": "forcePushed"}, {"oid": "5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "url": "https://github.com/apache/pinot/commit/5ef20ce5a37b5c7a9fbe98de46fc75f5ca906a8e", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T18:51:57Z", "type": "forcePushed"}, {"oid": "cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "url": "https://github.com/apache/pinot/commit/cbb6ad6dcc29ecbe7481717f6e2ff834800e44dd", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:22:03Z", "type": "forcePushed"}, {"oid": "55c9814681067386671b37db749235eca0cded56", "url": "https://github.com/apache/pinot/commit/55c9814681067386671b37db749235eca0cded56", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:25:56Z", "type": "forcePushed"}, {"oid": "1368749a6375b6c94202b59a610a75b11dcabed0", "url": "https://github.com/apache/pinot/commit/1368749a6375b6c94202b59a610a75b11dcabed0", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T19:31:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427580739", "bodyText": "Instead of this, why don't we just have a constant value function registry  where all compile time evaluated functions are registered. So this check then becomes if the function is part of the constant value function registry.", "author": "siddharthteotia", "createdAt": "2020-05-19T20:30:12Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -615,7 +620,44 @@ private static Expression toExpression(SqlNode node) {\n             funcExpr.getFunctionCall().addToOperands(toExpression(child));\n           }\n         }\n+\n+        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+          int functionOperandsLength = funcSqlNode.getOperands().length;\n+          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+          Object[] arguments = new Object[functionOperandsLength];\n+          for (int i = 0; i < functionOperandsLength; i++) {\n+            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n+            arguments[i] = argSqlNode.toValue();\n+          }\n+          try {\n+            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n+          } catch (Exception e) {\n+            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n+          }\n+        }\n         return funcExpr;\n     }\n   }\n+\n+  /**\n+   * Utility method to check if the function can be evaluated during the query compilation phae\n+   * @param funcExpr\n+   * @return true if all arguments are literals\n+   */\n+  private static boolean isCompileTimeEvaluationPossible(Expression funcExpr) {", "originalCommit": "1368749a6375b6c94202b59a610a75b11dcabed0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NjI0NQ==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427596245", "bodyText": "One thing here is that the function could be used in transform functions in query/ingestion field conversion. Ideally we should be able to evaluate any transform function with literal here.", "author": "xiangfu0", "createdAt": "2020-05-19T20:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NzM0MA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r427597340", "bodyText": "+1", "author": "kishoreg", "createdAt": "2020-05-19T21:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\nindex 83b1415756..a672fc8177 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java\n\n@@ -598,48 +596,59 @@ public class CalciteSqlParser {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n-        }\n-        if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)\n-            && funcSqlNode.getFunctionQuantifier().toValue()\n-            .equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n-          funcName = AggregationFunctionType.DISTINCTCOUNT.getName();\n-        }\n-        Expression funcExpr = RequestUtils.getFunctionExpression(funcName);\n-        for (SqlNode child : funcSqlNode.getOperands()) {\n-          if (child instanceof SqlNodeList) {\n-            final Iterator<SqlNode> iterator = ((SqlNodeList) child).iterator();\n-            while (iterator.hasNext()) {\n-              final SqlNode next = iterator.next();\n-              funcExpr.getFunctionCall().addToOperands(toExpression(next));\n-            }\n-          } else {\n-            funcExpr.getFunctionCall().addToOperands(toExpression(child));\n-          }\n-        }\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n \n-        if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n-          int functionOperandsLength = funcSqlNode.getOperands().length;\n-          FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n-          Object[] arguments = new Object[functionOperandsLength];\n-          for (int i = 0; i < functionOperandsLength; i++) {\n-            SqlLiteral argSqlNode = (SqlLiteral) funcSqlNode.getOperands()[i];\n-            arguments[i] = argSqlNode.toValue();\n-          }\n-          try {\n-            FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n-            funcExpr = RequestUtils.getLiteralExpression(invoker.process(arguments).toString());\n-          } catch (Exception e) {\n-            throw new SqlCompilationException(\"Unsupported Scalar function - \" + funcName);\n-          }\n-        }\n-        return funcExpr;\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n     }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)\n+        && funcSqlNode.getFunctionQuantifier().toValue()\n+        .equalsIgnoreCase(AggregationFunctionType.DISTINCT.getName())) {\n+      funcName = AggregationFunctionType.DISTINCTCOUNT.getName();\n+    }\n+    return funcName;\n   }\n \n+  private static Expression evaluateFunctionExpression(SqlBasicCall funcSqlNode) {\n+    String funcName = extractFunctionName(funcSqlNode);\n+    Expression funcExpr = RequestUtils.getFunctionExpression(funcName);\n+    if (FunctionRegistry.containsFunctionByName(funcName) && isCompileTimeEvaluationPossible(funcExpr)) {\n+      int functionOperandsLength = funcSqlNode.getOperands().length;\n+      FunctionInfo functionInfo = FunctionRegistry.getFunctionByName(funcName);\n+      Object[] arguments = new Object[functionOperandsLength];\n+      for (int i = 0; i < functionOperandsLength; i++) {\n+        if (funcSqlNode.getOperands()[i] instanceof SqlLiteral) {\n+          arguments[i] = ((SqlLiteral) funcSqlNode.getOperands()[i]).toValue();\n+        } else {\n+          // Evaluate function call (SqlBasicCall) recursively.\n+          arguments[i] = evaluateFunctionExpression((SqlBasicCall) funcSqlNode.getOperands()[i]).getLiteral().getFieldValue();\n+        }\n+      }\n+      try {\n+        FunctionInvoker invoker = new FunctionInvoker(functionInfo);\n+        Object result = invoker.process(arguments);\n+        return RequestUtils.getLiteralExpression(result);\n+      } catch (Exception e) {\n+        throw new SqlCompilationException(new IllegalArgumentException(\"Unsupported function - \" + funcName, e));\n+      }\n+    }\n+    for (SqlNode child : funcSqlNode.getOperands()) {\n+      if (child instanceof SqlNodeList) {\n+        final Iterator<SqlNode> iterator = ((SqlNodeList) child).iterator();\n+        while (iterator.hasNext()) {\n+          final SqlNode next = iterator.next();\n+          funcExpr.getFunctionCall().addToOperands(toExpression(next));\n+        }\n+      } else {\n+        funcExpr.getFunctionCall().addToOperands(toExpression(child));\n+      }\n+    }\n+    return funcExpr;\n+  }\n   /**\n    * Utility method to check if the function can be evaluated during the query compilation phae\n    * @param funcExpr\n"}}, {"oid": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "url": "https://github.com/apache/pinot/commit/9a4e8ca5e5343246c7f2c312c9826819426f5c42", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-19T23:09:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429500477", "bodyText": "this function is the same as fromDateTime on line 217. Do we need both?", "author": "npawar", "createdAt": "2020-05-23T01:09:13Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java", "diffHunk": "@@ -216,4 +217,18 @@ static String toDateTime(Long millis, String pattern) {\n   static Long fromDateTime(String dateTimeString, String pattern) {\n     return DateTimePatternHandler.parseDateTimeStringToEpochMillis(dateTimeString, pattern);\n   }\n+\n+  /**\n+   * Return current time as epoch millis\n+   */\n+  static Long now() {\n+    return System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Return epoch millis value based on a given date time string and it's corresponding format.\n+   */\n+  public static Long formatDatetime(String input, String format) {", "originalCommit": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTEwMg==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511102", "bodyText": "will delete", "author": "xiangfu0", "createdAt": "2020-05-23T03:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java b/pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java\nindex 3a026487b0..c0ebe1bd87 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/DateTimeFunctions.java\n\n@@ -224,11 +224,4 @@ public class DateTimeFunctions {\n   static Long now() {\n     return System.currentTimeMillis();\n   }\n-\n-  /**\n-   * Return epoch millis value based on a given date time string and it's corresponding format.\n-   */\n-  public static Long formatDatetime(String input, String format) {\n-    return DateTimeFormat.forPattern(format).parseMillis(input);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429501906", "bodyText": "i didn't quite follow why there is special casing for  DISTINCTCOUNT ?", "author": "npawar", "createdAt": "2020-05-23T01:26:44Z", "path": "pinot-common/src/main/java/org/apache/pinot/sql/parsers/CalciteSqlParser.java", "diffHunk": "@@ -593,29 +596,77 @@ private static Expression toExpression(SqlNode node) {\n           // Move on to process default logic.\n         }\n       default:\n-        SqlBasicCall funcSqlNode = (SqlBasicCall) node;\n-        String funcName = funcSqlNode.getOperator().getKind().name();\n-        if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n-          funcName = funcSqlNode.getOperator().getName();\n+        return evaluateFunctionExpression((SqlBasicCall) node);\n+    }\n+  }\n+\n+  private static String extractFunctionName(SqlBasicCall funcSqlNode) {\n+    String funcName = funcSqlNode.getOperator().getKind().name();\n+    if (funcSqlNode.getOperator().getKind() == SqlKind.OTHER_FUNCTION) {\n+      funcName = funcSqlNode.getOperator().getName();\n+    }\n+    if (funcName.equalsIgnoreCase(SqlKind.COUNT.toString()) && (funcSqlNode.getFunctionQuantifier() != null)", "originalCommit": "9a4e8ca5e5343246c7f2c312c9826819426f5c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxMTM2OA==", "url": "https://github.com/apache/pinot/pull/5406#discussion_r429511368", "bodyText": "this is a special handling for the case of COUNT(DISTINCT A).", "author": "xiangfu0", "createdAt": "2020-05-23T03:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTkwNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "8d84161496a68ff55916d2b4bb8fed401a65418b", "url": "https://github.com/apache/pinot/commit/8d84161496a68ff55916d2b4bb8fed401a65418b", "message": "Adding support to execute functions during query compilation", "committedDate": "2020-05-23T03:57:53Z", "type": "commit"}, {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "message": "Remove function formatDatetime", "committedDate": "2020-05-23T03:57:53Z", "type": "commit"}, {"oid": "cc89fe3aba61f035864cd1bda86e2c62642c4131", "url": "https://github.com/apache/pinot/commit/cc89fe3aba61f035864cd1bda86e2c62642c4131", "message": "Remove function formatDatetime", "committedDate": "2020-05-23T03:57:53Z", "type": "forcePushed"}]}