{"pr_number": 6165, "pr_title": "Add table level lock for segment upload", "pr_createdAt": "2020-10-20T21:44:09Z", "pr_url": "https://github.com/apache/pinot/pull/6165", "timeline": [{"oid": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91", "url": "https://github.com/apache/pinot/commit/9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91", "message": "Add table level lock for segment upload", "committedDate": "2020-10-20T21:45:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508867945", "bodyText": "This will increase the number of tables in the map forever. Can you do a similar approach as is done in PinotLLCRealtimeSegmentManager? Maybe you can use the same config, or a hard-coded number of locks for now.", "author": "mcvsubbu", "createdAt": "2020-10-20T22:04:12Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1643,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());", "originalCommit": "9ba9f4e59e9cb0bde3fc7fe4f68a9ae06868fd91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMTk1MA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508901950", "bodyText": "It will be one per table, I feel it should be ok. The purpose of adding  this lock is to ensure we only update one segment per table at a time and we can still support multiple tables to be updated simultaneously.", "author": "xiangfu0", "createdAt": "2020-10-20T23:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0ODM3Ng==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508948376", "bodyText": "Is this for offline segments? If so, how can this prevent other controllers from updating the idealstate?\nFor realtime, a lock makes sense since there is one leader for each table that handles idealstate update. Other controllers will handle different tables. This is not the case with offline segments.", "author": "mcvsubbu", "createdAt": "2020-10-21T02:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MDgzOQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r508990839", "bodyText": "This won't prevent from other controller, just to improve on the single controller update. In practice, it will help a lot on idealstate update as well, as we have only 3 parallel writes to update idealstates instead of segment push job parallelism.\nFrom client side, we can also try to push to one single controller to avoid the race condition.", "author": "xiangfu0", "createdAt": "2020-10-21T05:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNTMxNQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509405315", "bodyText": "Also, we hold the lock while backing off, so a single cross-controller contention will start building a queue? I think a better solution may to simply reduce the backoff time and try more often?\nAlso, we have clusters with 1000s of tables, and in this case, the hash table will contain all of them.", "author": "mcvsubbu", "createdAt": "2020-10-21T15:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU4NzI0Ng==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509587246", "bodyText": "@mcvsubbu A map with less than 10000 entries should be tiny (less than 1MB). Actually the _segmentCrcMap and _lastKnownSegmentMetadataVersionMap might cause problem because it stores an entry per segment, but that is out of the scope of this PR", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNTYwNQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509705605", "bodyText": "Discussing offline, I gather this:\n\n\nThis helps in case of thousands of segments being pushed. For metadata push, we still need to generate the metadata from segment tar file, which takes time. In order to improve that, if we increase parallelism, then metadata generation improves. However, parallel push in segments start taking longer due to retries. If we reduce parallelism, the metadata generation slows down as well.\n\n\nWith this PR, we can still keep high parallelism for metadata generation, but also reduce longer update time (or even failures), by reducing the probability of retries.\n\n\nThe Map size should be small, and the synchronization is only for IS update. So this can be thought of as a bug fix, which is reducing number of retries, without penalizing on push time with parallelism.\n\n\nWe also discussed the following:\n\nWe can also reduce number of IS updates (and hence retries) by having bulk updates to IS. For example, metadata push can pack multiple segment metadatas in one POST call.\n\n@siddharthteotia please add anything I missed.", "author": "mayankshriv", "createdAt": "2020-10-21T21:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2Nzk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex 7cce5b57e3..e104f1ab99 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -1643,14 +1648,7 @@ public class PinotHelixResourceManager {\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n-        synchronized (_tableUpdaterLockMap) {\n-          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n-            _tableUpdaterLockMap.put(offlineTableName, new Object());\n-          }\n-        }\n-      }\n-      synchronized (_tableUpdaterLockMap.get(offlineTableName)) {\n+      synchronized (getTableUpdaterLock(offlineTableName)) {\n         HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n           assert idealState != null;\n           Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n"}}, {"oid": "2d95abdef78f73e20b97edef2a2a4265ba526162", "url": "https://github.com/apache/pinot/commit/2d95abdef78f73e20b97edef2a2a4265ba526162", "message": "Add table level lock for segment upload", "committedDate": "2020-10-20T23:42:30Z", "type": "forcePushed"}, {"oid": "8a02f09431cfad092badb0fbf48dd3a2a0429e1a", "url": "https://github.com/apache/pinot/commit/8a02f09431cfad092badb0fbf48dd3a2a0429e1a", "message": "Add table level lock for segment upload", "committedDate": "2020-10-20T23:48:09Z", "type": "forcePushed"}, {"oid": "145a314b7b4209c472c12e5875a6d5a13547b04f", "url": "https://github.com/apache/pinot/commit/145a314b7b4209c472c12e5875a6d5a13547b04f", "message": "Add table level lock for segment upload", "committedDate": "2020-10-20T23:48:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2NzEwOQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509567109", "bodyText": "(nit) we don't use final for local variable", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:41:26Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1505,10 +1507,19 @@ public void deleteOfflineTable(String tableName) {\n     LOGGER.info(\"Deleting table {}: Removed table config\", offlineTableName);\n \n     // Remove instance partitions\n+    final String rawTableName = TableNameBuilder.extractRawTableName(tableName);", "originalCommit": "145a314b7b4209c472c12e5875a6d5a13547b04f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex f7b007c371..e104f1ab99 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -1511,15 +1516,6 @@ public class PinotHelixResourceManager {\n     InstancePartitionsUtils.removeInstancePartitions(_propertyStore,\n         InstancePartitionsType.OFFLINE.getInstancePartitionsName(rawTableName));\n     LOGGER.info(\"Deleting table {}: Removed instance partitions\", offlineTableName);\n-\n-    // Remove table locker if there\n-    if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n-      synchronized (_tableUpdaterLockMap) {\n-        if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n-          _tableUpdaterLockMap.remove(rawTableName);\n-        }\n-      }\n-    }\n     LOGGER.info(\"Deleting table {}: Finish\", offlineTableName);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3MjQ1Ng==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509572456", "bodyText": "The key is offlineTableName instead of rawTableName.\nAlso, no need to do check and remove here, directly remove should be good enough\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n          \n          \n            \n                _tableUpdaterLockMap.remove(offlineTableName);", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:47:18Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1505,10 +1507,19 @@ public void deleteOfflineTable(String tableName) {\n     LOGGER.info(\"Deleting table {}: Removed table config\", offlineTableName);\n \n     // Remove instance partitions\n+    final String rawTableName = TableNameBuilder.extractRawTableName(tableName);\n     InstancePartitionsUtils.removeInstancePartitions(_propertyStore,\n-        InstancePartitionsType.OFFLINE.getInstancePartitionsName(TableNameBuilder.extractRawTableName(tableName)));\n+        InstancePartitionsType.OFFLINE.getInstancePartitionsName(rawTableName));\n     LOGGER.info(\"Deleting table {}: Removed instance partitions\", offlineTableName);\n \n+    // Remove table locker if there\n+    if (_tableUpdaterLockMap.containsKey(rawTableName)) {", "originalCommit": "145a314b7b4209c472c12e5875a6d5a13547b04f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex f7b007c371..e104f1ab99 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -1511,15 +1516,6 @@ public class PinotHelixResourceManager {\n     InstancePartitionsUtils.removeInstancePartitions(_propertyStore,\n         InstancePartitionsType.OFFLINE.getInstancePartitionsName(rawTableName));\n     LOGGER.info(\"Deleting table {}: Removed instance partitions\", offlineTableName);\n-\n-    // Remove table locker if there\n-    if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n-      synchronized (_tableUpdaterLockMap) {\n-        if (_tableUpdaterLockMap.containsKey(rawTableName)) {\n-          _tableUpdaterLockMap.remove(rawTableName);\n-        }\n-      }\n-    }\n     LOGGER.info(\"Deleting table {}: Finish\", offlineTableName);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3NDc3NA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509574774", "bodyText": "Use ConcurrentHashMap", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:49:15Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -140,6 +140,8 @@\n \n   private final Map<String, Map<String, Long>> _segmentCrcMap = new HashMap<>();\n   private final Map<String, Map<String, Integer>> _lastKnownSegmentMetadataVersionMap = new HashMap<>();\n+  private final Map<String, Object> _tableUpdaterLockMap = new HashMap<>();", "originalCommit": "145a314b7b4209c472c12e5875a6d5a13547b04f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex f7b007c371..e104f1ab99 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -133,6 +133,7 @@ public class PinotHelixResourceManager {\n   private static final long CACHE_ENTRY_EXPIRE_TIME_HOURS = 6L;\n   private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n   public static final String APPEND = \"APPEND\";\n+  private static final int DEFAULT_TABLE_UPDATER_LOCKER_SIZE = 100;\n \n   // TODO: make this configurable\n   public static final long EXTERNAL_VIEW_ONLINE_SEGMENTS_MAX_WAIT_MS = 10 * 60_000L; // 10 minutes\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3OTM2OA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r509579368", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  synchronized (_tableUpdaterLockMap.get(offlineTableName)) {\n          \n          \n            \n                  synchronized (_tableUpdaterLockMap.computeIfAbsent(offlineTableName, k -> new Object())) {", "author": "Jackie-Jiang", "createdAt": "2020-10-21T18:52:46Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1641,23 +1652,30 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n-        assert idealState != null;\n-        Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n-        if (currentAssignment.containsKey(segmentName)) {\n-          LOGGER.warn(\"Segment: {} already exists in the IdealState for table: {}, do not update\", segmentName,\n-              offlineTableName);\n-        } else {\n-          List<String> assignedInstances =\n-              segmentAssignment.assignSegment(segmentName, currentAssignment, instancePartitionsMap);\n-          LOGGER.info(\"Assigning segment: {} to instances: {} for table: {}\", segmentName, assignedInstances,\n-              offlineTableName);\n-          currentAssignment.put(segmentName,\n-              SegmentAssignmentUtils.getInstanceStateMap(assignedInstances, SegmentStateModel.ONLINE));\n+      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+        synchronized (_tableUpdaterLockMap) {\n+          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n+            _tableUpdaterLockMap.put(offlineTableName, new Object());\n+          }\n         }\n-        return idealState;\n-      });\n-      LOGGER.info(\"Added segment: {} to IdealState for table: {}\", segmentName, offlineTableName);\n+      }\n+      synchronized (_tableUpdaterLockMap.get(offlineTableName)) {", "originalCommit": "145a314b7b4209c472c12e5875a6d5a13547b04f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex f7b007c371..e104f1ab99 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -1652,14 +1648,7 @@ public class PinotHelixResourceManager {\n       Map<InstancePartitionsType, InstancePartitions> instancePartitionsMap = Collections\n           .singletonMap(InstancePartitionsType.OFFLINE, InstancePartitionsUtils\n               .fetchOrComputeInstancePartitions(_helixZkManager, offlineTableConfig, InstancePartitionsType.OFFLINE));\n-      if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n-        synchronized (_tableUpdaterLockMap) {\n-          if (_tableUpdaterLockMap.get(offlineTableName) == null) {\n-            _tableUpdaterLockMap.put(offlineTableName, new Object());\n-          }\n-        }\n-      }\n-      synchronized (_tableUpdaterLockMap.get(offlineTableName)) {\n+      synchronized (getTableUpdaterLock(offlineTableName)) {\n         HelixHelper.updateIdealState(_helixZkManager, offlineTableName, idealState -> {\n           assert idealState != null;\n           Map<String, Map<String, String>> currentAssignment = idealState.getRecord().getMapFields();\n"}}, {"oid": "23e9e7efdfbd334dd02e907746bb277e5140ba44", "url": "https://github.com/apache/pinot/commit/23e9e7efdfbd334dd02e907746bb277e5140ba44", "message": "Add table level lock for segment upload", "committedDate": "2020-10-22T20:55:38Z", "type": "commit"}, {"oid": "ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "url": "https://github.com/apache/pinot/commit/ebf3a6cf3f9342d21bf1ec47f6fd31e6b403e073", "message": "Address comments", "committedDate": "2020-10-22T21:51:07Z", "type": "forcePushed"}, {"oid": "1b9d2de0bffee2747d1b17e02be82c84cb9d6762", "url": "https://github.com/apache/pinot/commit/1b9d2de0bffee2747d1b17e02be82c84cb9d6762", "message": "Address comments", "committedDate": "2020-10-22T22:00:07Z", "type": "forcePushed"}, {"oid": "a17ea4ca9be9419961cf6d25059847879cd533a5", "url": "https://github.com/apache/pinot/commit/a17ea4ca9be9419961cf6d25059847879cd533a5", "message": "Address comments", "committedDate": "2020-10-22T22:07:01Z", "type": "forcePushed"}, {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331", "url": "https://github.com/apache/pinot/commit/7a1012671337c8c2ae9457152e8792bb969e9331", "message": "Address comments", "committedDate": "2020-10-22T22:11:46Z", "type": "commit"}, {"oid": "7a1012671337c8c2ae9457152e8792bb969e9331", "url": "https://github.com/apache/pinot/commit/7a1012671337c8c2ae9457152e8792bb969e9331", "message": "Address comments", "committedDate": "2020-10-22T22:11:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NjU0NQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510496545", "bodyText": "I would use a random delay policy instead of fixed. Otherwise, you can have the same controllers coming back to update the IS at the same time.\nI don't think we have the policy, so you can create one.", "author": "mcvsubbu", "createdAt": "2020-10-22T22:36:21Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java", "diffHunk": "@@ -55,6 +55,7 @@\n   private static final String ENABLE_COMPRESSIONS_KEY = \"enableCompression\";\n \n   private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n+  private static final RetryPolicy DEFAULT_TABLE_IDEALSTATES_UPDATE_RETRY_POLICY = RetryPolicies.fixedDelayRetryPolicy(20, 100L);", "originalCommit": "7a1012671337c8c2ae9457152e8792bb969e9331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYwODM4OQ==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510608389", "bodyText": "added.", "author": "xiangfu0", "createdAt": "2020-10-23T05:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ5NjU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java b/pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java\nindex 17cf23f838..d39ca4178d 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/utils/helix/HelixHelper.java\n\n@@ -55,7 +55,7 @@ public class HelixHelper {\n   private static final String ENABLE_COMPRESSIONS_KEY = \"enableCompression\";\n \n   private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n-  private static final RetryPolicy DEFAULT_TABLE_IDEALSTATES_UPDATE_RETRY_POLICY = RetryPolicies.fixedDelayRetryPolicy(20, 100L);\n+  private static final RetryPolicy DEFAULT_TABLE_IDEALSTATES_UPDATE_RETRY_POLICY = RetryPolicies.randomDelayRetryPolicy(20, 100L, 200L);\n   private static final Logger LOGGER = LoggerFactory.getLogger(HelixHelper.class);\n   private static final ZNRecordSerializer ZN_RECORD_SERIALIZER = new ZNRecordSerializer();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTQxOA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510501418", "bodyText": "hash code can be negative. use & INTEGER_MAX to get a positive. I fell into the same trap in the realtime part :-)", "author": "mcvsubbu", "createdAt": "2020-10-22T22:51:06Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java", "diffHunk": "@@ -1672,6 +1679,10 @@ public void addNewSegment(String tableName, SegmentMetadata segmentMetadata, Str\n     }\n   }\n \n+  private Object getTableUpdaterLock(String offlineTableName) {\n+    return _tableUpdaterLocks[offlineTableName.hashCode() % _tableUpdaterLocks.length];", "originalCommit": "7a1012671337c8c2ae9457152e8792bb969e9331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYwODU5NA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510608594", "bodyText": "good catch :)", "author": "xiangfu0", "createdAt": "2020-10-23T05:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUwMTQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\nindex 211663a8a5..26c2dac40f 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/PinotHelixResourceManager.java\n\n@@ -1680,7 +1680,7 @@ public class PinotHelixResourceManager {\n   }\n \n   private Object getTableUpdaterLock(String offlineTableName) {\n-    return _tableUpdaterLocks[offlineTableName.hashCode() % _tableUpdaterLocks.length];\n+    return _tableUpdaterLocks[(offlineTableName.hashCode() & Integer.MAX_VALUE) % _tableUpdaterLocks.length];\n   }\n \n   @Nullable\n"}}, {"oid": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "url": "https://github.com/apache/pinot/commit/6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "message": "Using random delay policy", "committedDate": "2020-10-22T23:14:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjIyMw==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510996223", "bodyText": "isn't it simpler to just do:\nreturn _minDelayMs + (long)((_maxDelayMs - _minDelayMs) * RANDOM.nextDouble())?", "author": "mcvsubbu", "createdAt": "2020-10-23T16:19:16Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.utils.retry;\n+\n+import java.util.Random;\n+\n+\n+/**\n+ * Delay policy with random delay between attempts.\n+ */\n+public class RandomDelayRetryPolicy extends BaseRetryPolicy {\n+  private final static Random RANDOM = new Random(System.currentTimeMillis());\n+  private final long _minDelayMs;\n+  private final int _rangeUpper;\n+  private final int _rangeLower;\n+\n+  public RandomDelayRetryPolicy(int maxNumAttempts, long minDelayMs, long maxDelayMs) {\n+    super(maxNumAttempts);\n+    _minDelayMs = minDelayMs;\n+    _rangeUpper = (int) ((maxDelayMs - minDelayMs) / Integer.MAX_VALUE + 1);\n+    _rangeLower = (int) ((maxDelayMs - minDelayMs) % Integer.MAX_VALUE);\n+  }\n+\n+  @Override\n+  protected long getDelayMs(int currentAttempt) {\n+    return RANDOM.nextInt(_rangeUpper) * Integer.MAX_VALUE + RANDOM.nextInt(_rangeLower) + _minDelayMs;", "originalCommit": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwMjQ5Nw==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r511102497", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-10-23T19:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "27f84c4babdceedd594a6e79c821af90c05fa659", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java b/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\nindex 7327f647ed..f8e703a3a2 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\n\n@@ -18,6 +18,7 @@\n  */\n package org.apache.pinot.spi.utils.retry;\n \n+import com.google.common.base.Preconditions;\n import java.util.Random;\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjQ1MA==", "url": "https://github.com/apache/pinot/pull/6165#discussion_r510996450", "bodyText": "Thanks for adding this. This will be useful in other places as well.", "author": "mcvsubbu", "createdAt": "2020-10-23T16:19:38Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.utils.retry;\n+\n+import java.util.Random;\n+\n+\n+/**\n+ * Delay policy with random delay between attempts.\n+ */\n+public class RandomDelayRetryPolicy extends BaseRetryPolicy {", "originalCommit": "6d910f9d4c32ddae7a64c1b83655ca1684a73c42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27f84c4babdceedd594a6e79c821af90c05fa659", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java b/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\nindex 7327f647ed..f8e703a3a2 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/utils/retry/RandomDelayRetryPolicy.java\n\n@@ -18,6 +18,7 @@\n  */\n package org.apache.pinot.spi.utils.retry;\n \n+import com.google.common.base.Preconditions;\n import java.util.Random;\n \n \n"}}, {"oid": "27f84c4babdceedd594a6e79c821af90c05fa659", "url": "https://github.com/apache/pinot/commit/27f84c4babdceedd594a6e79c821af90c05fa659", "message": "update random policy", "committedDate": "2020-10-23T18:40:03Z", "type": "commit"}]}