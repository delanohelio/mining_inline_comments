{"pr_number": 5872, "pr_title": "Support for exact distinct count for non int data types", "pr_createdAt": "2020-08-16T09:31:41Z", "pr_url": "https://github.com/apache/pinot/pull/5872", "timeline": [{"oid": "ef30e07e696bb80f5fb31f6557676768cf4ad457", "url": "https://github.com/apache/pinot/commit/ef30e07e696bb80f5fb31f6557676768cf4ad457", "message": "Fixing serde for  bytesset", "committedDate": "2020-08-17T05:55:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2Mzc1OQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471263759", "bodyText": "Float.BYTES", "author": "xiangfu0", "createdAt": "2020-08-17T06:49:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -452,6 +478,142 @@ public IntSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<LongSet> LONG_SET_SER_DE = new ObjectSerDe<LongSet>() {\n+\n+    @Override\n+    public byte[] serialize(LongSet longSet) {\n+      int size = longSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      LongIterator iterator = longSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putLong(iterator.nextLong());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public LongSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public LongSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      LongSet longSet = new LongOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        longSet.add(byteBuffer.getLong());\n+      }\n+      return longSet;\n+    }\n+  };\n+\n+  public static final ObjectSerDe<FloatSet> FLOAT_SET_SER_DE = new ObjectSerDe<FloatSet>() {\n+\n+    @Override\n+    public byte[] serialize(FloatSet floatSet) {\n+      int size = floatSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];", "originalCommit": "ef30e07e696bb80f5fb31f6557676768cf4ad457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex 81f90d8ef8..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -463,14 +470,14 @@ public class ObjectSerDeUtils {\n     }\n \n     @Override\n-    public IntSet deserialize(byte[] bytes) {\n+    public IntOpenHashSet deserialize(byte[] bytes) {\n       return deserialize(ByteBuffer.wrap(bytes));\n     }\n \n     @Override\n-    public IntSet deserialize(ByteBuffer byteBuffer) {\n+    public IntOpenHashSet deserialize(ByteBuffer byteBuffer) {\n       int size = byteBuffer.getInt();\n-      IntSet intSet = new IntOpenHashSet(size);\n+      IntOpenHashSet intSet = new IntOpenHashSet(size);\n       for (int i = 0; i < size; i++) {\n         intSet.add(byteBuffer.getInt());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MzkyNA==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471263924", "bodyText": "byteBuffer.getFloat()", "author": "xiangfu0", "createdAt": "2020-08-17T06:50:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -452,6 +478,142 @@ public IntSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<LongSet> LONG_SET_SER_DE = new ObjectSerDe<LongSet>() {\n+\n+    @Override\n+    public byte[] serialize(LongSet longSet) {\n+      int size = longSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      LongIterator iterator = longSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putLong(iterator.nextLong());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public LongSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public LongSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      LongSet longSet = new LongOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        longSet.add(byteBuffer.getLong());\n+      }\n+      return longSet;\n+    }\n+  };\n+\n+  public static final ObjectSerDe<FloatSet> FLOAT_SET_SER_DE = new ObjectSerDe<FloatSet>() {\n+\n+    @Override\n+    public byte[] serialize(FloatSet floatSet) {\n+      int size = floatSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      FloatIterator iterator = floatSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putFloat(iterator.nextFloat());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public FloatSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public FloatSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      FloatSet floatSet = new FloatOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        floatSet.add(byteBuffer.getLong());", "originalCommit": "ef30e07e696bb80f5fb31f6557676768cf4ad457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex 81f90d8ef8..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -463,14 +470,14 @@ public class ObjectSerDeUtils {\n     }\n \n     @Override\n-    public IntSet deserialize(byte[] bytes) {\n+    public IntOpenHashSet deserialize(byte[] bytes) {\n       return deserialize(ByteBuffer.wrap(bytes));\n     }\n \n     @Override\n-    public IntSet deserialize(ByteBuffer byteBuffer) {\n+    public IntOpenHashSet deserialize(ByteBuffer byteBuffer) {\n       int size = byteBuffer.getInt();\n-      IntSet intSet = new IntOpenHashSet(size);\n+      IntOpenHashSet intSet = new IntOpenHashSet(size);\n       for (int i = 0; i < size; i++) {\n         intSet.add(byteBuffer.getInt());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2Mzk5NQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471263995", "bodyText": "Double.BYTES", "author": "xiangfu0", "createdAt": "2020-08-17T06:50:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -452,6 +478,142 @@ public IntSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<LongSet> LONG_SET_SER_DE = new ObjectSerDe<LongSet>() {\n+\n+    @Override\n+    public byte[] serialize(LongSet longSet) {\n+      int size = longSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      LongIterator iterator = longSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putLong(iterator.nextLong());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public LongSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public LongSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      LongSet longSet = new LongOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        longSet.add(byteBuffer.getLong());\n+      }\n+      return longSet;\n+    }\n+  };\n+\n+  public static final ObjectSerDe<FloatSet> FLOAT_SET_SER_DE = new ObjectSerDe<FloatSet>() {\n+\n+    @Override\n+    public byte[] serialize(FloatSet floatSet) {\n+      int size = floatSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      FloatIterator iterator = floatSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putFloat(iterator.nextFloat());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public FloatSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public FloatSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      FloatSet floatSet = new FloatOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        floatSet.add(byteBuffer.getLong());\n+      }\n+      return floatSet;\n+    }\n+  };\n+\n+  public static final ObjectSerDe<DoubleSet> DOUBLE_SET_SER_DE = new ObjectSerDe<DoubleSet>() {\n+\n+    @Override\n+    public byte[] serialize(DoubleSet doubleSet) {\n+      int size = doubleSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];", "originalCommit": "ef30e07e696bb80f5fb31f6557676768cf4ad457", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex 81f90d8ef8..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -463,14 +470,14 @@ public class ObjectSerDeUtils {\n     }\n \n     @Override\n-    public IntSet deserialize(byte[] bytes) {\n+    public IntOpenHashSet deserialize(byte[] bytes) {\n       return deserialize(ByteBuffer.wrap(bytes));\n     }\n \n     @Override\n-    public IntSet deserialize(ByteBuffer byteBuffer) {\n+    public IntOpenHashSet deserialize(ByteBuffer byteBuffer) {\n       int size = byteBuffer.getInt();\n-      IntSet intSet = new IntOpenHashSet(size);\n+      IntOpenHashSet intSet = new IntOpenHashSet(size);\n       for (int i = 0; i < size; i++) {\n         intSet.add(byteBuffer.getInt());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MTIzNg==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471661236", "bodyText": "What is this for?", "author": "Jackie-Jiang", "createdAt": "2020-08-17T17:53:33Z", "path": "pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java", "diffHunk": "@@ -61,7 +61,8 @@\n   PERCENTILEMV(\"percentileMV\"),\n   PERCENTILEESTMV(\"percentileEstMV\"),\n   PERCENTILETDIGESTMV(\"percentileTDigestMV\"),\n-  DISTINCT(\"distinct\");\n+  DISTINCT(\"distinct\"),\n+  DISTINCTRAWBLOOMFILTER(\"distinctRawBloomFilter\");", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczNjQxMg==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471736412", "bodyText": "removed it", "author": "kishoreg", "createdAt": "2020-08-17T19:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java b/pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java\nindex b0db043f50..fc60ea65d6 100644\n--- a/pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java\n+++ b/pinot-common/src/main/java/org/apache/pinot/common/function/AggregationFunctionType.java\n\n@@ -61,8 +61,7 @@ public enum AggregationFunctionType {\n   PERCENTILEMV(\"percentileMV\"),\n   PERCENTILEESTMV(\"percentileEstMV\"),\n   PERCENTILETDIGESTMV(\"percentileTDigestMV\"),\n-  DISTINCT(\"distinct\"),\n-  DISTINCTRAWBLOOMFILTER(\"distinctRawBloomFilter\");\n+  DISTINCT(\"distinct\");\n \n   private final String _name;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2Mzk0NA==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471663944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } else if (value instanceof it.unimi.dsi.fastutil.floats.FloatSet) {\n          \n          \n            \n                  } else if (value instanceof FloatSet) {", "author": "Jackie-Jiang", "createdAt": "2020-08-17T17:58:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -111,6 +127,14 @@ public static ObjectType getObjectType(Object value) {\n         return ObjectType.Geometry;\n       } else if (value instanceof RoaringBitmap) {\n         return ObjectType.RoaringBitmap;\n+      } else if (value instanceof LongSet) {\n+        return ObjectType.LongSet;\n+      } else if (value instanceof it.unimi.dsi.fastutil.floats.FloatSet) {", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex a389fc12e0..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -129,12 +133,17 @@ public class ObjectSerDeUtils {\n         return ObjectType.RoaringBitmap;\n       } else if (value instanceof LongSet) {\n         return ObjectType.LongSet;\n-      } else if (value instanceof it.unimi.dsi.fastutil.floats.FloatSet) {\n+      } else if (value instanceof FloatSet) {\n         return ObjectType.FloatSet;\n-      } else if (value instanceof it.unimi.dsi.fastutil.doubles.DoubleSet) {\n+      } else if (value instanceof DoubleSet) {\n         return ObjectType.DoubleSet;\n       } else if (value instanceof ObjectSet) {\n-        return ObjectType.BytesSet;\n+        ObjectSet objectSet = (ObjectSet) value;\n+        if (objectSet.isEmpty() || objectSet.iterator().next() instanceof String) {\n+          return ObjectType.StringSet;\n+        } else {\n+          return ObjectType.BytesSet;\n+        }\n       } else {\n         throw new IllegalArgumentException(\"Unsupported type of value: \" + value.getClass().getSimpleName());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NDAyNw==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471664027", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } else if (value instanceof it.unimi.dsi.fastutil.doubles.DoubleSet) {\n          \n          \n            \n                  } else if (value instanceof DoubleSet) {", "author": "Jackie-Jiang", "createdAt": "2020-08-17T17:58:29Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -111,6 +127,14 @@ public static ObjectType getObjectType(Object value) {\n         return ObjectType.Geometry;\n       } else if (value instanceof RoaringBitmap) {\n         return ObjectType.RoaringBitmap;\n+      } else if (value instanceof LongSet) {\n+        return ObjectType.LongSet;\n+      } else if (value instanceof it.unimi.dsi.fastutil.floats.FloatSet) {\n+        return ObjectType.FloatSet;\n+      } else if (value instanceof it.unimi.dsi.fastutil.doubles.DoubleSet) {", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex a389fc12e0..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -129,12 +133,17 @@ public class ObjectSerDeUtils {\n         return ObjectType.RoaringBitmap;\n       } else if (value instanceof LongSet) {\n         return ObjectType.LongSet;\n-      } else if (value instanceof it.unimi.dsi.fastutil.floats.FloatSet) {\n+      } else if (value instanceof FloatSet) {\n         return ObjectType.FloatSet;\n-      } else if (value instanceof it.unimi.dsi.fastutil.doubles.DoubleSet) {\n+      } else if (value instanceof DoubleSet) {\n         return ObjectType.DoubleSet;\n       } else if (value instanceof ObjectSet) {\n-        return ObjectType.BytesSet;\n+        ObjectSet objectSet = (ObjectSet) value;\n+        if (objectSet.isEmpty() || objectSet.iterator().next() instanceof String) {\n+          return ObjectType.StringSet;\n+        } else {\n+          return ObjectType.BytesSet;\n+        }\n       } else {\n         throw new IllegalArgumentException(\"Unsupported type of value: \" + value.getClass().getSimpleName());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NDk3MQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471664971", "bodyText": "Revert this reformat (you may want to enable formatter markers in comments in your IDE)", "author": "Jackie-Jiang", "createdAt": "2020-08-17T18:00:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -538,23 +695,8 @@ public RoaringBitmap deserialize(ByteBuffer byteBuffer) {\n \n   // NOTE: DO NOT change the order, it has to be the same order as the ObjectType\n   //@formatter:off\n-  private static final ObjectSerDe[] SER_DES = {\n-      STRING_SER_DE,\n-      LONG_SER_DE,\n-      DOUBLE_SER_DE,\n-      DOUBLE_ARRAY_LIST_SER_DE,\n-      AVG_PAIR_SER_DE,\n-      MIN_MAX_RANGE_PAIR_SER_DE,\n-      HYPER_LOG_LOG_SER_DE,\n-      QUANTILE_DIGEST_SER_DE,\n-      MAP_SER_DE,\n-      INT_SET_SER_DE,\n-      TDIGEST_SER_DE,\n-      DISTINCT_TABLE_SER_DE,\n-      DATA_SKETCH_SER_DE,\n-      GEOMETRY_SER_DE,\n-      ROARING_BITMAP_SER_DE\n-  };\n+  private static final ObjectSerDe[] SER_DES =", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex a389fc12e0..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -695,8 +744,28 @@ public class ObjectSerDeUtils {\n \n   // NOTE: DO NOT change the order, it has to be the same order as the ObjectType\n   //@formatter:off\n-  private static final ObjectSerDe[] SER_DES =\n-      {STRING_SER_DE, LONG_SER_DE, DOUBLE_SER_DE, DOUBLE_ARRAY_LIST_SER_DE, AVG_PAIR_SER_DE, MIN_MAX_RANGE_PAIR_SER_DE, HYPER_LOG_LOG_SER_DE, QUANTILE_DIGEST_SER_DE, MAP_SER_DE, INT_SET_SER_DE, TDIGEST_SER_DE, DISTINCT_TABLE_SER_DE, DATA_SKETCH_SER_DE, GEOMETRY_SER_DE, ROARING_BITMAP_SER_DE, LONG_SET_SER_DE, FLOAT_SET_SER_DE, DOUBLE_SET_SER_DE, BYTES_SET_SER_DE};\n+  private static final ObjectSerDe[] SER_DES = {\n+      STRING_SER_DE,\n+      LONG_SER_DE,\n+      DOUBLE_SER_DE,\n+      DOUBLE_ARRAY_LIST_SER_DE,\n+      AVG_PAIR_SER_DE,\n+      MIN_MAX_RANGE_PAIR_SER_DE,\n+      HYPER_LOG_LOG_SER_DE,\n+      QUANTILE_DIGEST_SER_DE,\n+      MAP_SER_DE,\n+      INT_SET_SER_DE,\n+      TDIGEST_SER_DE,\n+      DISTINCT_TABLE_SER_DE,\n+      DATA_SKETCH_SER_DE,\n+      GEOMETRY_SER_DE,\n+      ROARING_BITMAP_SER_DE,\n+      LONG_SET_SER_DE,\n+      FLOAT_SET_SER_DE,\n+      DOUBLE_SET_SER_DE,\n+      STRING_SET_SER_DE,\n+      BYTES_SET_SER_DE\n+  };\n   //@formatter:on\n \n   public static byte[] serialize(Object value) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NTc1NQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471665755", "bodyText": "Suggest using ByteArray instead of ByteBuffer to store bytes", "author": "Jackie-Jiang", "createdAt": "2020-08-17T18:01:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java", "diffHunk": "@@ -77,36 +83,42 @@ protected IntermediateResultsBlock getNextBlock() {\n               .add(new MinMaxRangePair(dictionary.getDoubleValue(0), dictionary.getDoubleValue(dictionarySize - 1)));\n           break;\n         case DISTINCTCOUNT:\n-          IntOpenHashSet set = new IntOpenHashSet(dictionarySize);\n+          AbstractCollection set;\n           switch (dictionary.getValueType()) {\n             case INT:\n+              set = new IntOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n                 set.add(dictionary.getIntValue(dictId));\n               }\n               break;\n             case LONG:\n+              set = new LongOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Long.hashCode(dictionary.getLongValue(dictId)));\n+                set.add(dictionary.getLongValue(dictId));\n               }\n               break;\n             case FLOAT:\n+              set = new FloatOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Float.hashCode(dictionary.getFloatValue(dictId)));\n+                set.add(dictionary.getFloatValue(dictId));\n               }\n               break;\n             case DOUBLE:\n+              set = new DoubleOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Double.hashCode(dictionary.getDoubleValue(dictId)));\n+                set.add(dictionary.getDoubleValue(dictId));\n               }\n               break;\n             case STRING:\n+              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getStringValue(dictId).hashCode());\n+                set.add(ByteBuffer.wrap(dictionary.getStringValue(dictId).getBytes(Charsets.UTF_8)));", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NjIwMQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471666201", "bodyText": "Use StringUtils.encodeUtf8() to encode string for better performance", "author": "Jackie-Jiang", "createdAt": "2020-08-17T18:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NTc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\nindex a5dfc389de..8dacb841f6 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\n\n@@ -83,48 +81,52 @@ public class DictionaryBasedAggregationOperator extends BaseOperator<Intermediat\n               .add(new MinMaxRangePair(dictionary.getDoubleValue(0), dictionary.getDoubleValue(dictionarySize - 1)));\n           break;\n         case DISTINCTCOUNT:\n-          AbstractCollection set;\n           switch (dictionary.getValueType()) {\n             case INT:\n-              set = new IntOpenHashSet(dictionarySize);\n+              IntOpenHashSet intSet = new IntOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getIntValue(dictId));\n+                intSet.add(dictionary.getIntValue(dictId));\n               }\n+              aggregationResults.add(intSet);\n               break;\n             case LONG:\n-              set = new LongOpenHashSet(dictionarySize);\n+              LongOpenHashSet longSet = new LongOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getLongValue(dictId));\n+                longSet.add(dictionary.getLongValue(dictId));\n               }\n+              aggregationResults.add(longSet);\n               break;\n             case FLOAT:\n-              set = new FloatOpenHashSet(dictionarySize);\n+              FloatOpenHashSet floatSet = new FloatOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getFloatValue(dictId));\n+                floatSet.add(dictionary.getFloatValue(dictId));\n               }\n+              aggregationResults.add(floatSet);\n               break;\n             case DOUBLE:\n-              set = new DoubleOpenHashSet(dictionarySize);\n+              DoubleOpenHashSet doubleSet = new DoubleOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getDoubleValue(dictId));\n+                doubleSet.add(dictionary.getDoubleValue(dictId));\n               }\n+              aggregationResults.add(doubleSet);\n               break;\n             case STRING:\n-              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);\n+              ObjectOpenHashSet<String> stringSet = new ObjectOpenHashSet<>(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(ByteBuffer.wrap(dictionary.getStringValue(dictId).getBytes(Charsets.UTF_8)));\n+                stringSet.add(dictionary.getStringValue(dictId));\n               }\n+              aggregationResults.add(stringSet);\n               break;\n             case BYTES:\n-              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);\n+              ObjectOpenHashSet<ByteArray> bytesSet = new ObjectOpenHashSet<>(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(ByteBuffer.wrap(dictionary.getBytesValue(dictId)));\n+                bytesSet.add(new ByteArray(dictionary.getBytesValue(dictId)));\n               }\n+              aggregationResults.add(bytesSet);\n               break;\n             default:\n               throw new IllegalStateException();\n           }\n-          aggregationResults.add(set);\n           break;\n         case SEGMENTPARTITIONEDDISTINCTCOUNT:\n           aggregationResults.add((long) dictionarySize);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2ODkzOA==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471668938", "bodyText": "I don't think this works for ser/de. You need to construct a type specific set based on the data type", "author": "Jackie-Jiang", "createdAt": "2020-08-17T18:07:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountAggregationFunction.java", "diffHunk": "@@ -233,41 +241,103 @@ public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResult\n   }\n \n   @Override\n-  public IntOpenHashSet extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+  public AbstractCollection extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n     Object result = aggregationResultHolder.getResult();\n     if (result == null) {\n-      return new IntOpenHashSet();\n+      return emptyCollection();\n     }\n \n     if (result instanceof DictIdsWrapper) {\n       // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n       return convertToValueSet((DictIdsWrapper) result);\n     } else {\n       // For non-dictionary-encoded expression, directly return the value set\n-      return (IntOpenHashSet) result;\n+      return (AbstractCollection) result;\n     }\n   }\n \n+  private AbstractCollection emptyCollection() {\n+    return new AbstractCollection() {", "originalCommit": "3c531f32b734be6004add1f3e138f42bf9e7c1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountAggregationFunction.java\nindex f81ae0d256..368e587917 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountAggregationFunction.java\n\n@@ -241,102 +249,87 @@ public class DistinctCountAggregationFunction extends BaseSingleInputAggregation\n   }\n \n   @Override\n-  public AbstractCollection extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+  public Set extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n     Object result = aggregationResultHolder.getResult();\n     if (result == null) {\n-      return emptyCollection();\n+      // Use empty IntOpenHashSet as a place holder for empty result\n+      return new IntOpenHashSet();\n     }\n \n     if (result instanceof DictIdsWrapper) {\n-      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      // For dictionary-encoded expression, convert dictionary ids to values\n       return convertToValueSet((DictIdsWrapper) result);\n     } else {\n       // For non-dictionary-encoded expression, directly return the value set\n-      return (AbstractCollection) result;\n+      return (Set) result;\n     }\n   }\n \n-  private AbstractCollection emptyCollection() {\n-    return new AbstractCollection() {\n-      @Override\n-      public Iterator iterator() {\n-        return new Iterator() {\n-          @Override\n-          public boolean hasNext() {\n-            return false;\n-          }\n-\n-          @Override\n-          public Object next() {\n-            return null;\n-          }\n-        };\n-      }\n-\n-      @Override\n-      public int size() {\n-        return 0;\n-      }\n-    };\n-  }\n-\n   @Override\n-  public AbstractCollection extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+  public Set extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n     Object result = groupByResultHolder.getResult(groupKey);\n     if (result == null) {\n-      return emptyCollection();\n+      // NOTE: Return an empty IntOpenHashSet for empty result.\n+      return new IntOpenHashSet();\n     }\n \n     if (result instanceof DictIdsWrapper) {\n-      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      // For dictionary-encoded expression, convert dictionary ids to values\n       return convertToValueSet((DictIdsWrapper) result);\n     } else {\n       // For non-dictionary-encoded expression, directly return the value set\n-      return (AbstractCollection) result;\n+      return (Set) result;\n     }\n   }\n \n   @Override\n-  public AbstractCollection merge(AbstractCollection intermediateResult1, AbstractCollection intermediateResult2) {\n-    if (intermediateResult1.getClass().isAssignableFrom(intermediateResult2.getClass())) {\n+  public Set merge(Set intermediateResult1, Set intermediateResult2) {\n+    if (intermediateResult1.isEmpty()) {\n+      return intermediateResult2;\n+    }\n+    if (intermediateResult2.isEmpty()) {\n+      return intermediateResult1;\n+    }\n+    if (intermediateResult1.getClass() == intermediateResult2.getClass()) {\n+      // Both results are of the same type, directly merge\n       intermediateResult1.addAll(intermediateResult2);\n       return intermediateResult1;\n     } else {\n-      //handle backwards compatibility, we used to use IntHashSet for all datatypes earlier\n-      //so we try to convert other types into int using hashcode\n-      //Note this code path is executed only while brokers and servers are getting upgraded.\n-      //When both are on the same version, they will satisfy the intermediateResult1.getClass().isAssignableFrom(intermediateResult2.getClass() condition\n-      IntOpenHashSet intOpenHashSet;\n-      AbstractCollection toMerge;\n+      // TODO: Remove this part after releasing 0.5.0\n+      // The results are not of the same type. This can happen when servers are getting upgraded, and some servers are\n+      // still running the old code and store hash codes in the set. For backward-compatibility, we convert the values\n+      // into hash codes and insert them into the hash code set.\n+      IntOpenHashSet hashCodeSet;\n+      Set valueSet;\n       if (intermediateResult1 instanceof IntOpenHashSet) {\n-        intOpenHashSet = (IntOpenHashSet) intermediateResult1;\n-        toMerge = intermediateResult2;\n+        hashCodeSet = (IntOpenHashSet) intermediateResult1;\n+        valueSet = intermediateResult2;\n       } else {\n-        intOpenHashSet = (IntOpenHashSet) intermediateResult2;\n-        toMerge = intermediateResult1;\n+        hashCodeSet = (IntOpenHashSet) intermediateResult2;\n+        valueSet = intermediateResult1;\n       }\n-      if (toMerge instanceof LongOpenHashSet) {\n-        LongOpenHashSet longOpenHashSet = (LongOpenHashSet) toMerge;\n-        for (long e : longOpenHashSet) {\n-          intOpenHashSet.add(Long.hashCode(e));\n+      if (valueSet instanceof LongOpenHashSet) {\n+        LongOpenHashSet longSet = (LongOpenHashSet) valueSet;\n+        for (long value : longSet) {\n+          hashCodeSet.add(Long.hashCode(value));\n         }\n-      } else if (toMerge instanceof FloatOpenHashSet) {\n-        FloatOpenHashSet floatOpenHashSet = (FloatOpenHashSet) toMerge;\n-        for (float e : floatOpenHashSet) {\n-          intOpenHashSet.add(Float.hashCode(e));\n+      } else if (valueSet instanceof FloatOpenHashSet) {\n+        FloatOpenHashSet floatSet = (FloatOpenHashSet) valueSet;\n+        for (float value : floatSet) {\n+          hashCodeSet.add(Float.hashCode(value));\n         }\n-      } else if (toMerge instanceof DoubleOpenHashSet) {\n-        DoubleOpenHashSet doubleOpenHashSet = (DoubleOpenHashSet) toMerge;\n-        for (double e : doubleOpenHashSet) {\n-          intOpenHashSet.add(Double.hashCode(e));\n+      } else if (valueSet instanceof DoubleOpenHashSet) {\n+        DoubleOpenHashSet doubleSet = (DoubleOpenHashSet) valueSet;\n+        for (double value : doubleSet) {\n+          hashCodeSet.add(Double.hashCode(value));\n         }\n-      } else if (toMerge instanceof ObjectOpenHashSet) {\n-        ObjectOpenHashSet objectOpenHashSet = (ObjectOpenHashSet) toMerge;\n-        for (Object e : objectOpenHashSet) {\n-          intOpenHashSet.add(e.hashCode());\n+      } else {\n+        // STRING and BYTES\n+        for (Object value : valueSet) {\n+          hashCodeSet.add(value.hashCode());\n         }\n       }\n-      return intOpenHashSet;\n+      return hashCodeSet;\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5NjkzOQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471796939", "bodyText": "Wondering if we should have a single ser/de for different data types, by writing the data type as part of header. Not sure if the iterators share the same interface to be able to share the same serialize().", "author": "mayankshriv", "createdAt": "2020-08-17T21:56:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -452,6 +476,139 @@ public IntSet deserialize(ByteBuffer byteBuffer) {\n     }\n   };\n \n+  public static final ObjectSerDe<LongSet> LONG_SET_SER_DE = new ObjectSerDe<LongSet>() {\n+\n+    @Override\n+    public byte[] serialize(LongSet longSet) {\n+      int size = longSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Long.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);\n+      LongIterator iterator = longSet.iterator();\n+      while (iterator.hasNext()) {\n+        byteBuffer.putLong(iterator.nextLong());\n+      }\n+      return bytes;\n+    }\n+\n+    @Override\n+    public LongSet deserialize(byte[] bytes) {\n+      return deserialize(ByteBuffer.wrap(bytes));\n+    }\n+\n+    @Override\n+    public LongSet deserialize(ByteBuffer byteBuffer) {\n+      int size = byteBuffer.getInt();\n+      LongSet longSet = new LongOpenHashSet(size);\n+      for (int i = 0; i < size; i++) {\n+        longSet.add(byteBuffer.getLong());\n+      }\n+      return longSet;\n+    }\n+  };\n+\n+  public static final ObjectSerDe<FloatSet> FLOAT_SET_SER_DE = new ObjectSerDe<FloatSet>() {\n+\n+    @Override\n+    public byte[] serialize(FloatSet floatSet) {\n+      int size = floatSet.size();\n+      byte[] bytes = new byte[Integer.BYTES + size * Float.BYTES];\n+      ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n+      byteBuffer.putInt(size);", "originalCommit": "e5fd3a07afc50ea06daf3b379b534be3e28cdb8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ1MzQ1Ng==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r473453456", "bodyText": "We are using fastutil Sets for better performance, and each Set has its own iterator class. Keeping them separate is more readable IMO. The ObjectType info is already maintained in the header, no need to introduce another level of type info.", "author": "Jackie-Jiang", "createdAt": "2020-08-20T00:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5NjkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\nindex a389fc12e0..52d4c67635 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java\n\n@@ -461,14 +470,14 @@ public class ObjectSerDeUtils {\n     }\n \n     @Override\n-    public IntSet deserialize(byte[] bytes) {\n+    public IntOpenHashSet deserialize(byte[] bytes) {\n       return deserialize(ByteBuffer.wrap(bytes));\n     }\n \n     @Override\n-    public IntSet deserialize(ByteBuffer byteBuffer) {\n+    public IntOpenHashSet deserialize(ByteBuffer byteBuffer) {\n       int size = byteBuffer.getInt();\n-      IntSet intSet = new IntOpenHashSet(size);\n+      IntOpenHashSet intSet = new IntOpenHashSet(size);\n       for (int i = 0; i < size; i++) {\n         intSet.add(byteBuffer.getInt());\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5ODE1Mw==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r471798153", "bodyText": "why not byte[]?", "author": "mayankshriv", "createdAt": "2020-08-17T21:59:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java", "diffHunk": "@@ -77,36 +83,42 @@ protected IntermediateResultsBlock getNextBlock() {\n               .add(new MinMaxRangePair(dictionary.getDoubleValue(0), dictionary.getDoubleValue(dictionarySize - 1)));\n           break;\n         case DISTINCTCOUNT:\n-          IntOpenHashSet set = new IntOpenHashSet(dictionarySize);\n+          AbstractCollection set;\n           switch (dictionary.getValueType()) {\n             case INT:\n+              set = new IntOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n                 set.add(dictionary.getIntValue(dictId));\n               }\n               break;\n             case LONG:\n+              set = new LongOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Long.hashCode(dictionary.getLongValue(dictId)));\n+                set.add(dictionary.getLongValue(dictId));\n               }\n               break;\n             case FLOAT:\n+              set = new FloatOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Float.hashCode(dictionary.getFloatValue(dictId)));\n+                set.add(dictionary.getFloatValue(dictId));\n               }\n               break;\n             case DOUBLE:\n+              set = new DoubleOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(Double.hashCode(dictionary.getDoubleValue(dictId)));\n+                set.add(dictionary.getDoubleValue(dictId));\n               }\n               break;\n             case STRING:\n+              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);", "originalCommit": "e5fd3a07afc50ea06daf3b379b534be3e28cdb8d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18105504b22008b45a585cd592b4e10cd4bf337a", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\nindex a5dfc389de..8dacb841f6 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/DictionaryBasedAggregationOperator.java\n\n@@ -83,48 +81,52 @@ public class DictionaryBasedAggregationOperator extends BaseOperator<Intermediat\n               .add(new MinMaxRangePair(dictionary.getDoubleValue(0), dictionary.getDoubleValue(dictionarySize - 1)));\n           break;\n         case DISTINCTCOUNT:\n-          AbstractCollection set;\n           switch (dictionary.getValueType()) {\n             case INT:\n-              set = new IntOpenHashSet(dictionarySize);\n+              IntOpenHashSet intSet = new IntOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getIntValue(dictId));\n+                intSet.add(dictionary.getIntValue(dictId));\n               }\n+              aggregationResults.add(intSet);\n               break;\n             case LONG:\n-              set = new LongOpenHashSet(dictionarySize);\n+              LongOpenHashSet longSet = new LongOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getLongValue(dictId));\n+                longSet.add(dictionary.getLongValue(dictId));\n               }\n+              aggregationResults.add(longSet);\n               break;\n             case FLOAT:\n-              set = new FloatOpenHashSet(dictionarySize);\n+              FloatOpenHashSet floatSet = new FloatOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getFloatValue(dictId));\n+                floatSet.add(dictionary.getFloatValue(dictId));\n               }\n+              aggregationResults.add(floatSet);\n               break;\n             case DOUBLE:\n-              set = new DoubleOpenHashSet(dictionarySize);\n+              DoubleOpenHashSet doubleSet = new DoubleOpenHashSet(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(dictionary.getDoubleValue(dictId));\n+                doubleSet.add(dictionary.getDoubleValue(dictId));\n               }\n+              aggregationResults.add(doubleSet);\n               break;\n             case STRING:\n-              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);\n+              ObjectOpenHashSet<String> stringSet = new ObjectOpenHashSet<>(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(ByteBuffer.wrap(dictionary.getStringValue(dictId).getBytes(Charsets.UTF_8)));\n+                stringSet.add(dictionary.getStringValue(dictId));\n               }\n+              aggregationResults.add(stringSet);\n               break;\n             case BYTES:\n-              set = new ObjectOpenHashSet<ByteBuffer>(dictionarySize);\n+              ObjectOpenHashSet<ByteArray> bytesSet = new ObjectOpenHashSet<>(dictionarySize);\n               for (int dictId = 0; dictId < dictionarySize; dictId++) {\n-                set.add(ByteBuffer.wrap(dictionary.getBytesValue(dictId)));\n+                bytesSet.add(new ByteArray(dictionary.getBytesValue(dictId)));\n               }\n+              aggregationResults.add(bytesSet);\n               break;\n             default:\n               throw new IllegalStateException();\n           }\n-          aggregationResults.add(set);\n           break;\n         case SEGMENTPARTITIONEDDISTINCTCOUNT:\n           aggregationResults.add((long) dictionarySize);\n"}}, {"oid": "18105504b22008b45a585cd592b4e10cd4bf337a", "url": "https://github.com/apache/pinot/commit/18105504b22008b45a585cd592b4e10cd4bf337a", "message": "Support exact distinct count", "committedDate": "2020-08-19T23:45:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MzcwNQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r473493705", "bodyText": "will this be a problem as we always return StringSet for empty value?", "author": "xiangfu0", "createdAt": "2020-08-20T01:02:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/ObjectSerDeUtils.java", "diffHunk": "@@ -111,6 +131,19 @@ public static ObjectType getObjectType(Object value) {\n         return ObjectType.Geometry;\n       } else if (value instanceof RoaringBitmap) {\n         return ObjectType.RoaringBitmap;\n+      } else if (value instanceof LongSet) {\n+        return ObjectType.LongSet;\n+      } else if (value instanceof FloatSet) {\n+        return ObjectType.FloatSet;\n+      } else if (value instanceof DoubleSet) {\n+        return ObjectType.DoubleSet;\n+      } else if (value instanceof ObjectSet) {\n+        ObjectSet objectSet = (ObjectSet) value;\n+        if (objectSet.isEmpty() || objectSet.iterator().next() instanceof String) {", "originalCommit": "18105504b22008b45a585cd592b4e10cd4bf337a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU0ODEyMQ==", "url": "https://github.com/apache/pinot/pull/5872#discussion_r473548121", "bodyText": "It is fine for empty set as empty string set and empty bytes set are the same (both are empty ObjectOpenHashSet)", "author": "Jackie-Jiang", "createdAt": "2020-08-20T02:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MzcwNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "1159f79a88b6727e50db9cc50e3a71f400d9d3cc", "url": "https://github.com/apache/pinot/commit/1159f79a88b6727e50db9cc50e3a71f400d9d3cc", "message": "Support exact distinct count", "committedDate": "2020-08-20T18:28:02Z", "type": "commit"}, {"oid": "a6836284047eb98f4c4c8aa2832310945f31efeb", "url": "https://github.com/apache/pinot/commit/a6836284047eb98f4c4c8aa2832310945f31efeb", "message": "Add DistinctCountBitmap query override", "committedDate": "2020-08-20T18:28:02Z", "type": "forcePushed"}, {"oid": "4fdf4cdbb24c468cb4d4ecf465551b485df38f4c", "url": "https://github.com/apache/pinot/commit/4fdf4cdbb24c468cb4d4ecf465551b485df38f4c", "message": "Add DistinctCountBitmap query override", "committedDate": "2020-08-20T18:32:22Z", "type": "commit"}, {"oid": "4fdf4cdbb24c468cb4d4ecf465551b485df38f4c", "url": "https://github.com/apache/pinot/commit/4fdf4cdbb24c468cb4d4ecf465551b485df38f4c", "message": "Add DistinctCountBitmap query override", "committedDate": "2020-08-20T18:32:22Z", "type": "forcePushed"}]}