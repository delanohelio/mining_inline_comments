{"pr_number": 5661, "pr_title": "Optimize selection order-by when not all selected expressions are ordered", "pr_createdAt": "2020-07-07T01:44:21Z", "pr_url": "https://github.com/apache/pinot/pull/5661", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDI2NQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590265", "bodyText": "not sure if this a valid check. what if the expressions are functions?", "author": "kishoreg", "createdAt": "2020-07-07T03:23:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1MjU1Mg==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451152552", "bodyText": "Both order-by and selected expressions can be identifiers or functions. Expressions here are order-by expressions followed by non-order-by expressions (deduplicated, see SelectionOperatorUtils.extractExpressions() for more details.", "author": "Jackie-Jiang", "createdAt": "2020-07-07T21:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\nindex 9f3b417559..6479b4f08a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n\n@@ -167,134 +168,145 @@ public class SelectionOrderByOperator extends BaseOperator<IntermediateResultsBl\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    int numExpressions = _expressions.size();\n-    int numOrderByExpressions = _orderByExpressions.size();\n-\n-    if (numExpressions == numOrderByExpressions) {\n-      // All selected expressions are ordered\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n \n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n-      TransformBlock transformBlock;\n-      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numExpressions; i++) {\n-          ExpressionContext expression = _expressions.get(i);\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        _numDocsScanned += numDocsFetched;\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n-        }\n-      }\n-      _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n \n-      String[] columnNames = new String[numExpressions];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n       for (int i = 0; i < numExpressions; i++) {\n-        columnNames[i] = _expressions.get(i).toString();\n-        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n-        columnDataTypes[i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+        ExpressionContext expression = _expressions.get(i);\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n-      return new IntermediateResultsBlock(new DataSchema(columnNames, columnDataTypes), _rows);\n-    } else {\n-      // Not all the selected expressions are ordered\n-\n-      // Insert the order-by expressions and docId into the priority queue\n-      BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n-      TransformBlock transformBlock;\n-      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numOrderByExpressions; i++) {\n-          ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        _numDocsScanned += numDocsFetched;\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n-        }\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n+    }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-      // Copy the order-by expression values to the final complete rows and store the document ids into a bitmap\n-      // NOTE: Here we also temporary copy the docId into the complete rows so that we can use it to sort the rows.\n-      int numRows = _rows.size();\n-      List<Object[]> completeRows = new ArrayList<>(numRows);\n-      MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n-      for (Object[] row : _rows) {\n-        Object[] completeRow = new Object[numExpressions];\n-        System.arraycopy(row, 0, completeRow, 0, numOrderByExpressions + 1);\n-        completeRows.add(completeRow);\n-        docIds.add((int) row[numOrderByExpressions]);\n-      }\n-      _rows.clear();\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n \n-      // Sort the rows so that the docId is in ascending order\n-      completeRows.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n \n-      // Construct a new TransformOperator to fetch the non-order-by expressions for the documents in the result\n-      List<ExpressionContext> nonOrderByExpressions = _expressions.subList(numOrderByExpressions, numExpressions);\n-      Set<String> columns = new HashSet<>();\n-      for (ExpressionContext expressionContext : nonOrderByExpressions) {\n-        expressionContext.getColumns(columns);\n-      }\n-      Map<String, DataSource> dataSourceMap = new HashMap<>();\n-      for (String column : columns) {\n-        dataSourceMap.put(column, _indexSegment.getDataSource(column));\n-      }\n-      ProjectionOperator projectionOperator =\n-          new ProjectionOperator(dataSourceMap, new BitmapDocIdSetOperator(docIds, numRows));\n-      TransformOperator transformOperator = new TransformOperator(projectionOperator, nonOrderByExpressions);\n-\n-      // Copy the non-order-by expression values to the final complete rows\n-      int numNonOrderByExpressions = nonOrderByExpressions.size();\n-      blockValSets = new BlockValSet[numNonOrderByExpressions];\n-      int rowBaseId = 0;\n-      while ((transformBlock = transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numNonOrderByExpressions; i++) {\n-          ExpressionContext expression = nonOrderByExpressions.get(i);\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          Object[] row = blockValueFetcher.getRow(i);\n-          Object[] completeRow = completeRows.get(rowBaseId + i);\n-          System.arraycopy(row, 0, completeRow, numOrderByExpressions, numNonOrderByExpressions);\n-        }\n-        rowBaseId += numDocsFetched;\n-      }\n-      _numEntriesScannedPostFilter =\n-          (long) _numDocsScanned * _transformOperator.getNumColumnsProjected() + (long) numRows * transformOperator\n-              .getNumColumnsProjected();\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n \n-      // Create the data schema\n-      String[] columnNames = new String[numExpressions];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n-      for (int i = 0; i < numExpressions; i++) {\n-        columnNames[i] = _expressions.get(i).toString();\n-      }\n+    // Fetch the order-by expressions and docIds and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n       for (int i = 0; i < numOrderByExpressions; i++) {\n-        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n-        columnDataTypes[i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+        ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n-      for (int i = 0; i < numNonOrderByExpressions; i++) {\n-        TransformResultMetadata expressionMetadata = transformOperator.getResultMetadata(nonOrderByExpressions.get(i));\n-        columnDataTypes[numOrderByExpressions + i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+      blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        // NOTE: We pre-allocate the complete row so that we can fill up the non-order-by output expression values later\n+        //       without creating extra rows or re-constructing the priority queue. We can change the values in-place\n+        //       because the comparator only compare the values for the order-by expressions.\n+        Object[] row = new Object[numExpressions];\n+        blockValueFetcher.getRow(i, row, 0);\n+        SelectionOperatorUtils.addToPriorityQueue(row, _rows, _numRowsToKeep);\n       }\n-      DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+    }\n+\n+    // Copy the rows (shallow copy so that any modification will also be reflected to the priority queue) into a list,\n+    // and store the document ids into a bitmap\n+    int numRows = _rows.size();\n+    List<Object[]> rowList = new ArrayList<>(numRows);\n+    MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n+    for (Object[] row : _rows) {\n+      rowList.add(row);\n+      docIds.add((int) row[numOrderByExpressions]);\n+    }\n+\n+    // Sort the rows so that the docIds are in ascending order (bitmap always returns values in ascending order)\n+    rowList.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n \n-      // Dump the compete rows into the priority queue\n-      for (Object[] completeRow : completeRows) {\n-        _rows.offer(completeRow);\n+    // Construct a new TransformOperator to fetch the non-order-by expressions for the top rows\n+    List<ExpressionContext> nonOrderByExpressions = _expressions.subList(numOrderByExpressions, numExpressions);\n+    Set<String> columns = new HashSet<>();\n+    for (ExpressionContext expressionContext : nonOrderByExpressions) {\n+      expressionContext.getColumns(columns);\n+    }\n+    Map<String, DataSource> dataSourceMap = new HashMap<>();\n+    for (String column : columns) {\n+      dataSourceMap.put(column, _indexSegment.getDataSource(column));\n+    }\n+    ProjectionOperator projectionOperator =\n+        new ProjectionOperator(dataSourceMap, new BitmapDocIdSetOperator(docIds, numRows));\n+    TransformOperator transformOperator = new TransformOperator(projectionOperator, nonOrderByExpressions);\n+\n+    // Fill the non-order-by expression values\n+    int numNonOrderByExpressions = nonOrderByExpressions.size();\n+    blockValSets = new BlockValSet[numNonOrderByExpressions];\n+    int rowBaseId = 0;\n+    while ((transformBlock = transformOperator.nextBlock()) != null) {\n+      for (int i = 0; i < numNonOrderByExpressions; i++) {\n+        ExpressionContext expression = nonOrderByExpressions.get(i);\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+      }\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        blockValueFetcher.getRow(i, rowList.get(rowBaseId + i), numOrderByExpressions);\n       }\n+      rowBaseId += numDocsFetched;\n+    }\n+    _numEntriesScannedPostFilter =\n+        (long) _numDocsScanned * _transformOperator.getNumColumnsProjected() + (long) numRows * transformOperator\n+            .getNumColumnsProjected();\n \n-      return new IntermediateResultsBlock(dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+    }\n+    for (int i = 0; i < numOrderByExpressions; i++) {\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n     }\n+    for (int i = 0; i < numNonOrderByExpressions; i++) {\n+      TransformResultMetadata expressionMetadata = transformOperator.getResultMetadata(nonOrderByExpressions.get(i));\n+      columnDataTypes[numOrderByExpressions + i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDM2Nw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450590367", "bodyText": "can we extract the if and else into separate methods for readability", "author": "kishoreg", "createdAt": "2020-07-07T03:23:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +167,134 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    TransformBlock transformBlock;\n-    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    if (numExpressions == numOrderByExpressions) {\n+      // All selected expressions are ordered\n+\n       BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+      TransformBlock transformBlock;\n+      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+        for (int i = 0; i < numExpressions; i++) {\n+          ExpressionContext expression = _expressions.get(i);\n+          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        }\n+        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+        int numDocsFetched = transformBlock.getNumDocs();\n+        _numDocsScanned += numDocsFetched;\n+        for (int i = 0; i < numDocsFetched; i++) {\n+          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n+        }\n+      }\n+      _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n+\n+      String[] columnNames = new String[numExpressions];\n+      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n-        ExpressionContext expression = _expressions.get(i);\n-        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+        columnNames[i] = _expressions.get(i).toString();\n+        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+        columnDataTypes[i] = DataSchema.ColumnDataType\n+            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n       }\n-      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      return new IntermediateResultsBlock(new DataSchema(columnNames, columnDataTypes), _rows);\n+    } else {", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\nindex 9f3b417559..6479b4f08a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n\n@@ -167,134 +168,145 @@ public class SelectionOrderByOperator extends BaseOperator<IntermediateResultsBl\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n-    int numExpressions = _expressions.size();\n-    int numOrderByExpressions = _orderByExpressions.size();\n-\n-    if (numExpressions == numOrderByExpressions) {\n-      // All selected expressions are ordered\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n \n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n-      TransformBlock transformBlock;\n-      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numExpressions; i++) {\n-          ExpressionContext expression = _expressions.get(i);\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        _numDocsScanned += numDocsFetched;\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n-        }\n-      }\n-      _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n \n-      String[] columnNames = new String[numExpressions];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n       for (int i = 0; i < numExpressions; i++) {\n-        columnNames[i] = _expressions.get(i).toString();\n-        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n-        columnDataTypes[i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+        ExpressionContext expression = _expressions.get(i);\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n-      return new IntermediateResultsBlock(new DataSchema(columnNames, columnDataTypes), _rows);\n-    } else {\n-      // Not all the selected expressions are ordered\n-\n-      // Insert the order-by expressions and docId into the priority queue\n-      BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n-      TransformBlock transformBlock;\n-      while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numOrderByExpressions; i++) {\n-          ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        _numDocsScanned += numDocsFetched;\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n-        }\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n+    }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-      // Copy the order-by expression values to the final complete rows and store the document ids into a bitmap\n-      // NOTE: Here we also temporary copy the docId into the complete rows so that we can use it to sort the rows.\n-      int numRows = _rows.size();\n-      List<Object[]> completeRows = new ArrayList<>(numRows);\n-      MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n-      for (Object[] row : _rows) {\n-        Object[] completeRow = new Object[numExpressions];\n-        System.arraycopy(row, 0, completeRow, 0, numOrderByExpressions + 1);\n-        completeRows.add(completeRow);\n-        docIds.add((int) row[numOrderByExpressions]);\n-      }\n-      _rows.clear();\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n \n-      // Sort the rows so that the docId is in ascending order\n-      completeRows.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n \n-      // Construct a new TransformOperator to fetch the non-order-by expressions for the documents in the result\n-      List<ExpressionContext> nonOrderByExpressions = _expressions.subList(numOrderByExpressions, numExpressions);\n-      Set<String> columns = new HashSet<>();\n-      for (ExpressionContext expressionContext : nonOrderByExpressions) {\n-        expressionContext.getColumns(columns);\n-      }\n-      Map<String, DataSource> dataSourceMap = new HashMap<>();\n-      for (String column : columns) {\n-        dataSourceMap.put(column, _indexSegment.getDataSource(column));\n-      }\n-      ProjectionOperator projectionOperator =\n-          new ProjectionOperator(dataSourceMap, new BitmapDocIdSetOperator(docIds, numRows));\n-      TransformOperator transformOperator = new TransformOperator(projectionOperator, nonOrderByExpressions);\n-\n-      // Copy the non-order-by expression values to the final complete rows\n-      int numNonOrderByExpressions = nonOrderByExpressions.size();\n-      blockValSets = new BlockValSet[numNonOrderByExpressions];\n-      int rowBaseId = 0;\n-      while ((transformBlock = transformOperator.nextBlock()) != null) {\n-        for (int i = 0; i < numNonOrderByExpressions; i++) {\n-          ExpressionContext expression = nonOrderByExpressions.get(i);\n-          blockValSets[i] = transformBlock.getBlockValueSet(expression);\n-        }\n-        RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-        int numDocsFetched = transformBlock.getNumDocs();\n-        for (int i = 0; i < numDocsFetched; i++) {\n-          Object[] row = blockValueFetcher.getRow(i);\n-          Object[] completeRow = completeRows.get(rowBaseId + i);\n-          System.arraycopy(row, 0, completeRow, numOrderByExpressions, numNonOrderByExpressions);\n-        }\n-        rowBaseId += numDocsFetched;\n-      }\n-      _numEntriesScannedPostFilter =\n-          (long) _numDocsScanned * _transformOperator.getNumColumnsProjected() + (long) numRows * transformOperator\n-              .getNumColumnsProjected();\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n \n-      // Create the data schema\n-      String[] columnNames = new String[numExpressions];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n-      for (int i = 0; i < numExpressions; i++) {\n-        columnNames[i] = _expressions.get(i).toString();\n-      }\n+    // Fetch the order-by expressions and docIds and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n       for (int i = 0; i < numOrderByExpressions; i++) {\n-        TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n-        columnDataTypes[i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+        ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n-      for (int i = 0; i < numNonOrderByExpressions; i++) {\n-        TransformResultMetadata expressionMetadata = transformOperator.getResultMetadata(nonOrderByExpressions.get(i));\n-        columnDataTypes[numOrderByExpressions + i] = DataSchema.ColumnDataType\n-            .fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+      blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        // NOTE: We pre-allocate the complete row so that we can fill up the non-order-by output expression values later\n+        //       without creating extra rows or re-constructing the priority queue. We can change the values in-place\n+        //       because the comparator only compare the values for the order-by expressions.\n+        Object[] row = new Object[numExpressions];\n+        blockValueFetcher.getRow(i, row, 0);\n+        SelectionOperatorUtils.addToPriorityQueue(row, _rows, _numRowsToKeep);\n       }\n-      DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+    }\n+\n+    // Copy the rows (shallow copy so that any modification will also be reflected to the priority queue) into a list,\n+    // and store the document ids into a bitmap\n+    int numRows = _rows.size();\n+    List<Object[]> rowList = new ArrayList<>(numRows);\n+    MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n+    for (Object[] row : _rows) {\n+      rowList.add(row);\n+      docIds.add((int) row[numOrderByExpressions]);\n+    }\n+\n+    // Sort the rows so that the docIds are in ascending order (bitmap always returns values in ascending order)\n+    rowList.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n \n-      // Dump the compete rows into the priority queue\n-      for (Object[] completeRow : completeRows) {\n-        _rows.offer(completeRow);\n+    // Construct a new TransformOperator to fetch the non-order-by expressions for the top rows\n+    List<ExpressionContext> nonOrderByExpressions = _expressions.subList(numOrderByExpressions, numExpressions);\n+    Set<String> columns = new HashSet<>();\n+    for (ExpressionContext expressionContext : nonOrderByExpressions) {\n+      expressionContext.getColumns(columns);\n+    }\n+    Map<String, DataSource> dataSourceMap = new HashMap<>();\n+    for (String column : columns) {\n+      dataSourceMap.put(column, _indexSegment.getDataSource(column));\n+    }\n+    ProjectionOperator projectionOperator =\n+        new ProjectionOperator(dataSourceMap, new BitmapDocIdSetOperator(docIds, numRows));\n+    TransformOperator transformOperator = new TransformOperator(projectionOperator, nonOrderByExpressions);\n+\n+    // Fill the non-order-by expression values\n+    int numNonOrderByExpressions = nonOrderByExpressions.size();\n+    blockValSets = new BlockValSet[numNonOrderByExpressions];\n+    int rowBaseId = 0;\n+    while ((transformBlock = transformOperator.nextBlock()) != null) {\n+      for (int i = 0; i < numNonOrderByExpressions; i++) {\n+        ExpressionContext expression = nonOrderByExpressions.get(i);\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+      }\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        blockValueFetcher.getRow(i, rowList.get(rowBaseId + i), numOrderByExpressions);\n       }\n+      rowBaseId += numDocsFetched;\n+    }\n+    _numEntriesScannedPostFilter =\n+        (long) _numDocsScanned * _transformOperator.getNumColumnsProjected() + (long) numRows * transformOperator\n+            .getNumColumnsProjected();\n \n-      return new IntermediateResultsBlock(dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+    }\n+    for (int i = 0; i < numOrderByExpressions; i++) {\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n     }\n+    for (int i = 0; i < numNonOrderByExpressions; i++) {\n+      TransformResultMetadata expressionMetadata = transformOperator.getResultMetadata(nonOrderByExpressions.get(i));\n+      columnDataTypes[numOrderByExpressions + i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MTc0Mw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r450591743", "bodyText": "can we refer to them as output expressions and orderBy expressions?\nthe two cases output expressions == orderby expressions\norderby expression is small part of output expressions", "author": "kishoreg", "createdAt": "2020-07-07T03:29:43Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -20,72 +20,96 @@\n \n import java.util.ArrayList;\n import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.PriorityQueue;\n+import java.util.Set;\n+import org.apache.pinot.common.utils.CommonConstants.Segment.BuiltInVirtualColumn;\n import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.DataSource;\n import org.apache.pinot.core.common.RowBasedBlockValueFetcher;\n import org.apache.pinot.core.indexsegment.IndexSegment;\n import org.apache.pinot.core.operator.BaseOperator;\n import org.apache.pinot.core.operator.ExecutionStatistics;\n+import org.apache.pinot.core.operator.ProjectionOperator;\n+import org.apache.pinot.core.operator.blocks.DocIdSetBlock;\n import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n import org.apache.pinot.core.operator.blocks.TransformBlock;\n import org.apache.pinot.core.operator.transform.TransformOperator;\n import org.apache.pinot.core.operator.transform.TransformResultMetadata;\n+import org.apache.pinot.core.plan.DocIdSetPlanNode;\n import org.apache.pinot.core.query.request.context.ExpressionContext;\n import org.apache.pinot.core.query.request.context.OrderByExpressionContext;\n import org.apache.pinot.core.query.request.context.QueryContext;\n import org.apache.pinot.core.query.selection.SelectionOperatorUtils;\n import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.apache.pinot.spi.utils.ByteArray;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+/**\n+ * Operator for selection order-by queries.\n+ * <p>The operator uses a priority queue to sort the rows and return the top rows based on the order-by expressions.\n+ * <p>It is optimized to fetch only the values needed for the ordering purpose and the final result:\n+ * <ul>\n+ *   <li>\n+ *     When all the selected expressions are ordered, the operator fetches all the expressions and insert them into the", "originalCommit": "b76a63b21899d1099651484edf07e44047f5baaa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\nindex 9f3b417559..6479b4f08a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n\n@@ -58,15 +58,15 @@ import org.roaringbitmap.buffer.MutableRoaringBitmap;\n  * <p>It is optimized to fetch only the values needed for the ordering purpose and the final result:\n  * <ul>\n  *   <li>\n- *     When all the selected expressions are ordered, the operator fetches all the expressions and insert them into the\n- *     priority queue because all the values are needed for ordering.\n+ *     When all the output expressions are ordered, the operator fetches all the output expressions and insert them into\n+ *     the priority queue because all the values are needed for ordering.\n  *   </li>\n  *   <li>\n- *     When there are some selected expressions not ordered, the operator fetches only the order-by expressions and the\n- *     virtual document id column and insert them into the priority queue. After getting the top documents, the operator\n- *     does a second round scan only on the top documents for the non-order-by selected expressions. This optimization\n- *     can significantly reduce the scanning and improve the query performance when a lot of expressions are selected\n- *     but very few are ordered (e.g. SELECT * FROM table ORDER BY col).\n+ *     Otherwise, the operator fetches only the order-by expressions and the virtual document id column and insert them\n+ *     into the priority queue. After getting the top rows, the operator does a second round scan only on the document\n+ *     ids for the top rows for the non-order-by output expressions. This optimization can significantly reduce the\n+ *     scanning and improve the query performance when most/all of the output expressions are not ordered (e.g. SELECT *\n+ *     FROM table ORDER BY col).\n  *   </li>\n  * </ul>\n  */\n"}}, {"oid": "44f30443a1d45fa61b6d371278da4ef1027a6341", "url": "https://github.com/apache/pinot/commit/44f30443a1d45fa61b6d371278da4ef1027a6341", "message": "Optimize selection order-by when not all selected expressions are ordered", "committedDate": "2020-07-07T22:20:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDI5MQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451270291", "bodyText": "Nit for readability: either add a variable, or a comment to indicate row[numOrderByExpressions] has the docId.", "author": "mayankshriv", "createdAt": "2020-07-08T04:05:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {\n+    int numExpressions = _expressions.size();\n+    int numOrderByExpressions = _orderByExpressions.size();\n+\n+    // Fetch the order-by expressions and docIds and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numOrderByExpressions + 1];\n+    TransformBlock transformBlock;\n+    while ((transformBlock = _transformOperator.nextBlock()) != null) {\n+      for (int i = 0; i < numOrderByExpressions; i++) {\n+        ExpressionContext expression = _orderByExpressions.get(i).getExpression();\n+        blockValSets[i] = transformBlock.getBlockValueSet(expression);\n+      }\n+      blockValSets[numOrderByExpressions] = transformBlock.getBlockValueSet(BuiltInVirtualColumn.DOCID);\n+      RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n+      int numDocsFetched = transformBlock.getNumDocs();\n+      _numDocsScanned += numDocsFetched;\n+      for (int i = 0; i < numDocsFetched; i++) {\n+        // NOTE: We pre-allocate the complete row so that we can fill up the non-order-by output expression values later\n+        //       without creating extra rows or re-constructing the priority queue. We can change the values in-place\n+        //       because the comparator only compare the values for the order-by expressions.\n+        Object[] row = new Object[numExpressions];\n+        blockValueFetcher.getRow(i, row, 0);\n+        SelectionOperatorUtils.addToPriorityQueue(row, _rows, _numRowsToKeep);\n+      }\n+    }\n+\n+    // Copy the rows (shallow copy so that any modification will also be reflected to the priority queue) into a list,\n+    // and store the document ids into a bitmap\n+    int numRows = _rows.size();\n+    List<Object[]> rowList = new ArrayList<>(numRows);\n+    MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n+    for (Object[] row : _rows) {\n+      rowList.add(row);\n+      docIds.add((int) row[numOrderByExpressions]);", "originalCommit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3ODc1NQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451278755", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-07-08T04:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDI5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\nindex 6479b4f08a..e13ef48c20 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n\n@@ -248,10 +248,11 @@ public class SelectionOrderByOperator extends BaseOperator<IntermediateResultsBl\n     MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n     for (Object[] row : _rows) {\n       rowList.add(row);\n-      docIds.add((int) row[numOrderByExpressions]);\n+      int docId = (int) row[numOrderByExpressions];\n+      docIds.add(docId);\n     }\n \n-    // Sort the rows so that the docIds are in ascending order (bitmap always returns values in ascending order)\n+    // Sort the rows with docIds to match the order of the bitmap (bitmap always returns values in ascending order)\n     rowList.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n \n     // Construct a new TransformOperator to fetch the non-order-by expressions for the top rows\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTkwOQ==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451271909", "bodyText": "Not required for this PR, but does it help if we completely defer the fetching of non-orderby expressions until combine phase? I think that might actually improve further quite a bit? We might need to have a segmentId+docId as a virtual column.", "author": "mayankshriv", "createdAt": "2020-07-08T04:12:51Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java", "diffHunk": "@@ -143,24 +168,145 @@ public SelectionOrderByOperator(IndexSegment indexSegment, QueryContext queryCon\n \n   @Override\n   protected IntermediateResultsBlock getNextBlock() {\n+    if (_expressions.size() == _orderByExpressions.size()) {\n+      return computeAllOrdered();\n+    } else {\n+      return computePartiallyOrdered();\n+    }\n+  }\n+\n+  /**\n+   * Helper method to compute the result when all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computeAllOrdered() {\n+    int numExpressions = _expressions.size();\n+\n+    // Fetch all the expressions and insert them into the priority queue\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n     TransformBlock transformBlock;\n     while ((transformBlock = _transformOperator.nextBlock()) != null) {\n-      int numExpressions = _expressions.size();\n-      BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n       for (int i = 0; i < numExpressions; i++) {\n         ExpressionContext expression = _expressions.get(i);\n         blockValSets[i] = transformBlock.getBlockValueSet(expression);\n       }\n       RowBasedBlockValueFetcher blockValueFetcher = new RowBasedBlockValueFetcher(blockValSets);\n-\n       int numDocsFetched = transformBlock.getNumDocs();\n       _numDocsScanned += numDocsFetched;\n       for (int i = 0; i < numDocsFetched; i++) {\n         SelectionOperatorUtils.addToPriorityQueue(blockValueFetcher.getRow(i), _rows, _numRowsToKeep);\n       }\n     }\n+    _numEntriesScannedPostFilter = (long) _numDocsScanned * _transformOperator.getNumColumnsProjected();\n \n-    return new IntermediateResultsBlock(_dataSchema, _rows);\n+    // Create the data schema\n+    String[] columnNames = new String[numExpressions];\n+    DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      columnNames[i] = _expressions.get(i).toString();\n+      TransformResultMetadata expressionMetadata = _orderByExpressionMetadata[i];\n+      columnDataTypes[i] =\n+          DataSchema.ColumnDataType.fromDataType(expressionMetadata.getDataType(), expressionMetadata.isSingleValue());\n+    }\n+    DataSchema dataSchema = new DataSchema(columnNames, columnDataTypes);\n+\n+    return new IntermediateResultsBlock(dataSchema, _rows);\n+  }\n+\n+  /**\n+   * Helper method to compute the result when not all the output expressions are ordered.\n+   */\n+  private IntermediateResultsBlock computePartiallyOrdered() {", "originalCommit": "44f30443a1d45fa61b6d371278da4ef1027a6341", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI4MjM4Nw==", "url": "https://github.com/apache/pinot/pull/5661#discussion_r451282387", "bodyText": "That is possible, and could save some read for high LIMIT queries (which are always expensive), but requires quite big change because that breaks the assumption of one operator only process one segment. After combining the order-by expressions we need to reopen the segments to read the values. For the second round scan, we might also need multi-threading similar to the first round. Not sure if the optimization is worth the overhead.", "author": "Jackie-Jiang", "createdAt": "2020-07-08T04:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\nindex 6479b4f08a..e13ef48c20 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/query/SelectionOrderByOperator.java\n\n@@ -248,10 +248,11 @@ public class SelectionOrderByOperator extends BaseOperator<IntermediateResultsBl\n     MutableRoaringBitmap docIds = new MutableRoaringBitmap();\n     for (Object[] row : _rows) {\n       rowList.add(row);\n-      docIds.add((int) row[numOrderByExpressions]);\n+      int docId = (int) row[numOrderByExpressions];\n+      docIds.add(docId);\n     }\n \n-    // Sort the rows so that the docIds are in ascending order (bitmap always returns values in ascending order)\n+    // Sort the rows with docIds to match the order of the bitmap (bitmap always returns values in ascending order)\n     rowList.sort(Comparator.comparingInt(o -> (int) o[numOrderByExpressions]));\n \n     // Construct a new TransformOperator to fetch the non-order-by expressions for the top rows\n"}}, {"oid": "2e0c32b1605764aec30ea609d079e04c4456f7c5", "url": "https://github.com/apache/pinot/commit/2e0c32b1605764aec30ea609d079e04c4456f7c5", "message": "Optimize selection order-by when not all selected expressions are ordered", "committedDate": "2020-07-08T04:38:37Z", "type": "commit"}, {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "message": "Address comments", "committedDate": "2020-07-08T04:55:29Z", "type": "commit"}, {"oid": "9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "url": "https://github.com/apache/pinot/commit/9f2c3d8a20355dbcde3bd3dc8cece2d54ab1a1a2", "message": "Address comments", "committedDate": "2020-07-08T04:55:29Z", "type": "forcePushed"}]}