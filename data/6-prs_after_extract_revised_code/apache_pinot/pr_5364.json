{"pr_number": 5364, "pr_title": "Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions", "pr_createdAt": "2020-05-11T19:36:11Z", "pr_url": "https://github.com/apache/pinot/pull/5364", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMDA3OQ==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423300079", "bodyText": "Seems like AggregationFunctionUtils.getArguments first creates List, then converts to String[], and here we are doing the reverse, creating [] from List. Is that not redundant? Or is it because of more callers of getArguments() benefit if it returns String[]?", "author": "mayankshriv", "createdAt": "2020-05-11T20:29:16Z", "path": "pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java", "diffHunk": "@@ -456,9 +457,9 @@ private void handleCaseSensitivity(BrokerRequest brokerRequest) {\n       for (AggregationInfo info : brokerRequest.getAggregationsInfo()) {\n         if (!info.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n           // Always read from backward compatible api in AggregationFunctionUtils.\n-          List<String> expressions = AggregationFunctionUtils.getAggregationExpressions(info);\n+          String[] expressions = AggregationFunctionUtils.getArguments(info);", "originalCommit": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MzQ4Ng==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423363486", "bodyText": "Changed it back to List. For the new format, no conversion is required. For the old backward-compatible format, there will be an array to list conversion, which is fine.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T22:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMDA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "chunk": "diff --git a/pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java b/pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java\nindex 54e9ba6933..c612cdcbad 100644\n--- a/pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java\n+++ b/pinot-broker/src/main/java/org/apache/pinot/broker/requesthandler/BaseBrokerRequestHandler.java\n\n@@ -457,13 +457,9 @@ public abstract class BaseBrokerRequestHandler implements BrokerRequestHandler {\n       for (AggregationInfo info : brokerRequest.getAggregationsInfo()) {\n         if (!info.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n           // Always read from backward compatible api in AggregationFunctionUtils.\n-          String[] expressions = AggregationFunctionUtils.getArguments(info);\n-\n-          List<String> newExpressions = new ArrayList<>(expressions.length);\n-          for (String expression : expressions) {\n-            newExpressions.add(fixColumnNameCase(actualTableName, expression));\n-          }\n-          info.setExpressions(newExpressions);\n+          List<String> arguments = AggregationFunctionUtils.getArguments(info);\n+          arguments.replaceAll(e -> fixColumnNameCase(actualTableName, e));\n+          info.setExpressions(arguments);\n         }\n       }\n       if (brokerRequest.isSetGroupBy()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMjc1Mg==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423312752", "bodyText": "Are there other callers of this api, other than Star tree? If not, then may be better to throw exception?", "author": "mayankshriv", "createdAt": "2020-05-11T20:53:02Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -128,6 +79,29 @@ public static AggregationFunctionContext getAggregationFunctionContext(Aggregati\n     return aggregationFunctions;\n   }\n \n+  /**\n+   * Creates an {@link AggregationFunctionColumnPair} from the {@link AggregationFunction}. Returns {@code null} if\n+   * the {@link AggregationFunction} cannot be represented as an {@link AggregationFunctionColumnPair} (e.g. has\n+   * multiple arguments, argument is not column etc.).\n+   */\n+  @Nullable\n+  public static AggregationFunctionColumnPair getAggregationFunctionColumnPair(\n+      AggregationFunction aggregationFunction) {\n+    AggregationFunctionType aggregationFunctionType = aggregationFunction.getType();\n+    if (aggregationFunctionType == AggregationFunctionType.COUNT) {\n+      return AggregationFunctionColumnPair.COUNT_STAR;\n+    }\n+    //noinspection unchecked\n+    List<TransformExpressionTree> inputExpressions = aggregationFunction.getInputExpressions();\n+    if (inputExpressions.size() == 1) {\n+      TransformExpressionTree inputExpression = inputExpressions.get(0);\n+      if (inputExpression.isColumn()) {\n+        return new AggregationFunctionColumnPair(aggregationFunctionType, inputExpression.getValue());\n+      }\n+    }\n+    return null;", "originalCommit": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NDA5Ng==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423364096", "bodyText": "This is for star-tree only, but we use it to check whether the query can be solved by star-tree. We use null to notify the caller that the function cannot be solved by star-tree.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T22:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxMjc1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "309416f40fa350166a6e2bbcec6156e31aec4c76", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\nindex 19b91d14eb..8b7574087a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n\n@@ -80,9 +80,9 @@ public class AggregationFunctionUtils {\n   }\n \n   /**\n-   * Creates an {@link AggregationFunctionColumnPair} from the {@link AggregationFunction}. Returns {@code null} if\n-   * the {@link AggregationFunction} cannot be represented as an {@link AggregationFunctionColumnPair} (e.g. has\n-   * multiple arguments, argument is not column etc.).\n+   * (For Star-Tree) Creates an {@link AggregationFunctionColumnPair} from the {@link AggregationFunction}. Returns\n+   * {@code null} if the {@link AggregationFunction} cannot be represented as an {@link AggregationFunctionColumnPair}\n+   * (e.g. has multiple arguments, argument is not column etc.).\n    */\n   @Nullable\n   public static AggregationFunctionColumnPair getAggregationFunctionColumnPair(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDI0Ng==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423314246", "bodyText": "SingleInput instead?", "author": "mayankshriv", "createdAt": "2020-05-11T20:55:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.pinot.common.request.transform.TransformExpressionTree;\n+\n+\n+/**\n+ * Base implementation of {@link AggregationFunction} with single expression.\n+ */\n+public abstract class BaseSingleExpressionAggregationFunction<I, F extends Comparable> implements AggregationFunction<I, F> {", "originalCommit": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NDY0Mw==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423364643", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-05-11T22:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNDI0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleInputAggregationFunction.java\nsimilarity index 89%\nrename from pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java\nrename to pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleInputAggregationFunction.java\nindex 96d1fabe5b..43641b2f05 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleExpressionAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/BaseSingleInputAggregationFunction.java\n\n@@ -24,9 +24,9 @@ import org.apache.pinot.common.request.transform.TransformExpressionTree;\n \n \n /**\n- * Base implementation of {@link AggregationFunction} with single expression.\n+ * Base implementation of {@link AggregationFunction} with single input expression.\n  */\n-public abstract class BaseSingleExpressionAggregationFunction<I, F extends Comparable> implements AggregationFunction<I, F> {\n+public abstract class BaseSingleInputAggregationFunction<I, F extends Comparable> implements AggregationFunction<I, F> {\n   protected final String _column;\n   protected final TransformExpressionTree _expression;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTgwMw==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423315803", "bodyText": "Most aggregations today take single input. Converting them into expression trees may penalize the common case?", "author": "mayankshriv", "createdAt": "2020-05-11T20:58:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -188,13 +186,13 @@ public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int ma\n \n   @Override\n   public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {", "originalCommit": "e6d8aa54d083f3ad409dcf54d113a46a1ef24bde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2NTEyMw==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423365123", "bodyText": "We get the expressions from AggregationFunction.getInputExpressions(), which is already compiled. We only compile the expression once.", "author": "Jackie-Jiang", "createdAt": "2020-05-11T22:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTgwMw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "url": "https://github.com/apache/pinot/commit/27dbef6b45d0d9d60483d619d10c05b41d5b2595", "message": "Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n\n- Clean up all the usage of AggregationFunctionContext to directly use AggregationFunction\n- Construct the AggregationFunctions and Group-by Expressions at planning phase and pass them to Operator and Executor to save the extra expression compilation\n- Use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n  - The benefit of this is to save the redundant string conversion, and more efficient hashCode() and equals()\n  - The keys of the blockValSetMap should be the same as AggregationFunction.getInputExpressions()\n  - The only exception is CountAggregationFunction with Star-Tree where there is a single entry in blockValSetMap (column \"*\")\n- Add base implementation of AggregationFunction: BaseSingleExpressionAggregationFunction for aggregation functions on single expressions\n- For PERCENTILE group aggregation functions, support using the second arguments to pass in percentile (e.g. PERCENTILE(column, 99), PERCENTILETDIGEST(column, 90))\n- Enhance Star-Tree Aggregation/Group-by Executor to handle the column name conversion so that AggregationFunctionColumnPair is transparent to the AggregationFunction\n\nBACKWARD-INCOMPATIBLE CHANGE:\nThe following APIs are changed in AggregationFunction (use TransformExpressionTree instead of String as the key of blockValSetMap):\nvoid aggregate(int length, AggregationResultHolder aggregationResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);", "committedDate": "2020-05-12T01:26:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzU0OA==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423853548", "bodyText": "Do we agree that there will be some (may be marginal only) overhead in terms of computing equals() on TransformExpressionTree (which will compare the expression type and the expression value which is column name for the general case)? Earlier it was being done directly on String identifier. Same goes for hashcode.", "author": "siddharthteotia", "createdAt": "2020-05-12T16:04:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctAggregationFunction.java", "diffHunk": "@@ -104,23 +104,23 @@ public AggregationResultHolder createAggregationResultHolder() {\n \n   @Override\n   public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n-      Map<String, BlockValSet> blockValSetMap) {\n-    int numColumns = _columns.length;\n+      Map<TransformExpressionTree, BlockValSet> blockValSetMap) {\n     int numBlockValSets = blockValSetMap.size();\n-    Preconditions.checkState(numBlockValSets == numColumns, \"Size mismatch: numBlockValSets = %s, numColumns = %s\",\n-        numBlockValSets, numColumns);\n-\n-    DistinctTable distinctTable = aggregationResultHolder.getResult();\n-    BlockValSet[] blockValSets = new BlockValSet[numColumns];\n-\n-    for (int i = 0; i < numColumns; i++) {\n-      blockValSets[i] = blockValSetMap.get(_columns[i]);\n+    int numExpressions = _inputExpressions.size();\n+    Preconditions\n+        .checkState(numBlockValSets == numExpressions, \"Size mismatch: numBlockValSets = %s, numExpressions = %s\",\n+            numBlockValSets, numExpressions);\n+\n+    BlockValSet[] blockValSets = new BlockValSet[numExpressions];\n+    for (int i = 0; i < numExpressions; i++) {\n+      blockValSets[i] = blockValSetMap.get(_inputExpressions.get(i));", "originalCommit": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NzA5Mg==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423947092", "bodyText": "For column (not function expression), there might be minimal overhead (overhead should be much smaller comparing to creating the map). For function expression, IMO comparing TransformExpressionTree should be cheaper comparing to the expression string.\nAlso, here we saved the overhead of converting expression to string, so directly using expression should give better performance.", "author": "Jackie-Jiang", "createdAt": "2020-05-12T18:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1MzU0OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423858568", "bodyText": "Why do we need these special checks for 0 and 1?\nIIUC, instead of executing the for loop once for numExpressions == 1, you are using a branch. Can we just have the loop? It will be much cleaner unless I am missing the performance benefit of doing it this way. Loop will take care of returning the empty map, map with 1 KV pair or more", "author": "siddharthteotia", "createdAt": "2020-05-12T16:11:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();", "originalCommit": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0OTQ3Ng==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423949476", "bodyText": "We can use loop, but that will always create a HashMap, where all the operations are much more expensive than EmptyMap and SingletonMap. Because most of the functions are zero (COUNT(*)) or single input expression, this should give better performance.", "author": "Jackie-Jiang", "createdAt": "2020-05-12T18:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMTQ0NA==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r424021444", "bodyText": "Got it. Thanks", "author": "siddharthteotia", "createdAt": "2020-05-12T20:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1ODU2OA=="}], "type": "inlineReview", "revised_code": {"commit": "309416f40fa350166a6e2bbcec6156e31aec4c76", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\nindex 0215595676..8b7574087a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n\n@@ -209,8 +209,8 @@ public class AggregationFunctionUtils {\n   }\n \n   /**\n-   * Creates a map from expression required by the {@link AggregationFunctionColumnPair} to {@link BlockValSet} fetched\n-   * from the {@link TransformBlock} (for star-tree).\n+   * (For Star-Tree) Creates a map from expression required by the {@link AggregationFunctionColumnPair} to\n+   * {@link BlockValSet} fetched from the {@link TransformBlock}.\n    * <p>NOTE: We construct the map with original column name as the key but fetch BlockValSet with the aggregation\n    *          function pair so that the aggregation result column name is consistent with or without star-tree.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1OTE5OA==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423859198", "bodyText": "(nit) - For better readability, consider putting \"for star tree\" at the beginning something like This function is used in start tree code path only", "author": "siddharthteotia", "createdAt": "2020-05-12T16:12:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java", "diffHunk": "@@ -181,37 +162,63 @@ public static int parsePercentile(String percentileString) {\n    * @param arguments Arguments to concatenate\n    * @return Concatenated String of arguments\n    */\n-  public static String concatArgs(List<String> arguments) {\n-    return (arguments.size() > 1) ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n-        : arguments.get(0);\n+  public static String concatArgs(String[] arguments) {\n+    return arguments.length > 1 ? String.join(CompilerConstants.AGGREGATION_FUNCTION_ARG_SEPARATOR, arguments)\n+        : arguments[0];\n   }\n \n   /**\n-   * Compiles and returns all transform expressions required for computing the aggregation, group-by\n-   * and order-by\n-   *\n-   * @param brokerRequest Broker Request\n-   * @param functionContexts Aggregation Function contexts\n-   * @return Set of compiled expressions in the aggregation, group-by and order-by clauses\n+   * Collects all transform expressions required for aggregation/group-by queries.\n+   * <p>NOTE: We don't need to consider order-by columns here as the ordering is only allowed for aggregation functions\n+   *          or group-by expressions.\n    */\n-  public static Set<TransformExpressionTree> collectExpressionsToTransform(BrokerRequest brokerRequest,\n-      AggregationFunctionContext[] functionContexts) {\n-\n-    Set<TransformExpressionTree> expressionTrees = new LinkedHashSet<>();\n-    for (AggregationFunctionContext functionContext : functionContexts) {\n-      AggregationFunction function = functionContext.getAggregationFunction();\n-      expressionTrees.addAll(function.getInputExpressions());\n+  public static Set<TransformExpressionTree> collectExpressionsToTransform(AggregationFunction[] aggregationFunctions,\n+      @Nullable TransformExpressionTree[] groupByExpressions) {\n+    Set<TransformExpressionTree> expressions = new HashSet<>();\n+    for (AggregationFunction aggregationFunction : aggregationFunctions) {\n+      //noinspection unchecked\n+      expressions.addAll(aggregationFunction.getInputExpressions());\n+    }\n+    if (groupByExpressions != null) {\n+      expressions.addAll(Arrays.asList(groupByExpressions));\n     }\n+    return expressions;\n+  }\n \n-    // Extract group-by expressions\n-    if (brokerRequest.isSetGroupBy()) {\n-      for (String expression : brokerRequest.getGroupBy().getExpressions()) {\n-        expressionTrees.add(TransformExpressionTree.compileToExpressionTree(expression));\n-      }\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunction} to {@link BlockValSet} fetched from the\n+   * {@link TransformBlock}.\n+   */\n+  public static Map<TransformExpressionTree, BlockValSet> getBlockValSetMap(AggregationFunction aggregationFunction,\n+      TransformBlock transformBlock) {\n+    //noinspection unchecked\n+    List<TransformExpressionTree> expressions = aggregationFunction.getInputExpressions();\n+    int numExpressions = expressions.size();\n+    if (numExpressions == 0) {\n+      return Collections.emptyMap();\n     }\n+    if (numExpressions == 1) {\n+      TransformExpressionTree expression = expressions.get(0);\n+      return Collections.singletonMap(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    Map<TransformExpressionTree, BlockValSet> blockValSetMap = new HashMap<>();\n+    for (TransformExpressionTree expression : expressions) {\n+      blockValSetMap.put(expression, transformBlock.getBlockValueSet(expression));\n+    }\n+    return blockValSetMap;\n+  }\n \n-    // TODO: Add order-by expressions when available in brokerRequest for aggregation queries.\n-    // The current order-by implementation assumes that ordering will be on aggregation/group-by columns.\n-    return expressionTrees;\n+  /**\n+   * Creates a map from expression required by the {@link AggregationFunctionColumnPair} to {@link BlockValSet} fetched\n+   * from the {@link TransformBlock} (for star-tree).", "originalCommit": "27dbef6b45d0d9d60483d619d10c05b41d5b2595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MDY1NA==", "url": "https://github.com/apache/pinot/pull/5364#discussion_r423950654", "bodyText": "Done", "author": "Jackie-Jiang", "createdAt": "2020-05-12T18:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1OTE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "309416f40fa350166a6e2bbcec6156e31aec4c76", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\nindex 0215595676..8b7574087a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/AggregationFunctionUtils.java\n\n@@ -209,8 +209,8 @@ public class AggregationFunctionUtils {\n   }\n \n   /**\n-   * Creates a map from expression required by the {@link AggregationFunctionColumnPair} to {@link BlockValSet} fetched\n-   * from the {@link TransformBlock} (for star-tree).\n+   * (For Star-Tree) Creates a map from expression required by the {@link AggregationFunctionColumnPair} to\n+   * {@link BlockValSet} fetched from the {@link TransformBlock}.\n    * <p>NOTE: We construct the map with original column name as the key but fetch BlockValSet with the aggregation\n    *          function pair so that the aggregation result column name is consistent with or without star-tree.\n    */\n"}}, {"oid": "309416f40fa350166a6e2bbcec6156e31aec4c76", "url": "https://github.com/apache/pinot/commit/309416f40fa350166a6e2bbcec6156e31aec4c76", "message": "Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n\n- Clean up all the usage of AggregationFunctionContext to directly use AggregationFunction\n- Construct the AggregationFunctions and Group-by Expressions at planning phase and pass them to Operator and Executor to save the extra expression compilation\n- Use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n  - The benefit of this is to save the redundant string conversion, and more efficient hashCode() and equals()\n  - The keys of the blockValSetMap should be the same as AggregationFunction.getInputExpressions()\n  - The only exception is CountAggregationFunction with Star-Tree where there is a single entry in blockValSetMap (column \"*\")\n- Add base implementation of AggregationFunction: BaseSingleExpressionAggregationFunction for aggregation functions on single expressions\n- For PERCENTILE group aggregation functions, support using the second arguments to pass in percentile (e.g. PERCENTILE(column, 99), PERCENTILETDIGEST(column, 90))\n- Enhance Star-Tree Aggregation/Group-by Executor to handle the column name conversion so that AggregationFunctionColumnPair is transparent to the AggregationFunction\n\nBACKWARD-INCOMPATIBLE CHANGE:\nThe following APIs are changed in AggregationFunction (use TransformExpressionTree instead of String as the key of blockValSetMap):\nvoid aggregate(int length, AggregationResultHolder aggregationResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);", "committedDate": "2020-05-12T19:41:10Z", "type": "forcePushed"}, {"oid": "e2b366deae0788d0c43f2d988391f63ad92f4e47", "url": "https://github.com/apache/pinot/commit/e2b366deae0788d0c43f2d988391f63ad92f4e47", "message": "Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n\n- Clean up all the usage of AggregationFunctionContext to directly use AggregationFunction\n- Construct the AggregationFunctions and Group-by Expressions at planning phase and pass them to Operator and Executor to save the extra expression compilation\n- Use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n  - The benefit of this is to save the redundant string conversion, and more efficient hashCode() and equals()\n  - The keys of the blockValSetMap should be the same as AggregationFunction.getInputExpressions()\n  - The only exception is CountAggregationFunction with Star-Tree where there is a single entry in blockValSetMap (column \"*\")\n- Add base implementation of AggregationFunction: BaseSingleExpressionAggregationFunction for aggregation functions on single expressions\n- For PERCENTILE group aggregation functions, support using the second arguments to pass in percentile (e.g. PERCENTILE(column, 99), PERCENTILETDIGEST(column, 90))\n- Enhance Star-Tree Aggregation/Group-by Executor to handle the column name conversion so that AggregationFunctionColumnPair is transparent to the AggregationFunction\n\nBACKWARD-INCOMPATIBLE CHANGE:\nThe following APIs are changed in AggregationFunction (use TransformExpressionTree instead of String as the key of blockValSetMap):\nvoid aggregate(int length, AggregationResultHolder aggregationResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);", "committedDate": "2020-05-12T19:51:44Z", "type": "commit"}, {"oid": "e2b366deae0788d0c43f2d988391f63ad92f4e47", "url": "https://github.com/apache/pinot/commit/e2b366deae0788d0c43f2d988391f63ad92f4e47", "message": "Clean up AggregationFunctionContext and use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n\n- Clean up all the usage of AggregationFunctionContext to directly use AggregationFunction\n- Construct the AggregationFunctions and Group-by Expressions at planning phase and pass them to Operator and Executor to save the extra expression compilation\n- Use TransformExpressionTree as the key in the blockValSetMap passed to the AggregationFunctions\n  - The benefit of this is to save the redundant string conversion, and more efficient hashCode() and equals()\n  - The keys of the blockValSetMap should be the same as AggregationFunction.getInputExpressions()\n  - The only exception is CountAggregationFunction with Star-Tree where there is a single entry in blockValSetMap (column \"*\")\n- Add base implementation of AggregationFunction: BaseSingleExpressionAggregationFunction for aggregation functions on single expressions\n- For PERCENTILE group aggregation functions, support using the second arguments to pass in percentile (e.g. PERCENTILE(column, 99), PERCENTILETDIGEST(column, 90))\n- Enhance Star-Tree Aggregation/Group-by Executor to handle the column name conversion so that AggregationFunctionColumnPair is transparent to the AggregationFunction\n\nBACKWARD-INCOMPATIBLE CHANGE:\nThe following APIs are changed in AggregationFunction (use TransformExpressionTree instead of String as the key of blockValSetMap):\nvoid aggregate(int length, AggregationResultHolder aggregationResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);\nvoid aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder, Map<TransformExpressionTree, BlockValSet> blockValSetMap);", "committedDate": "2020-05-12T19:51:44Z", "type": "forcePushed"}, {"oid": "406f93862efa44e0ddc6143e55a1ccc5ec8b72c9", "url": "https://github.com/apache/pinot/commit/406f93862efa44e0ddc6143e55a1ccc5ec8b72c9", "message": "minor change", "committedDate": "2020-05-12T21:01:29Z", "type": "commit"}]}