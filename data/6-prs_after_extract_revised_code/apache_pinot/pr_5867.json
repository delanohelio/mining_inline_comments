{"pr_number": 5867, "pr_title": "[Post-Aggregation] Support post-aggregation in SELECT", "pr_createdAt": "2020-08-14T22:53:32Z", "pr_url": "https://github.com/apache/pinot/pull/5867", "timeline": [{"oid": "fad58fccabc4d6e26d1b528d20cb5343107e4fac", "url": "https://github.com/apache/pinot/commit/fad58fccabc4d6e26d1b528d20cb5343107e4fac", "message": "Support post-aggregation in SELECT", "committedDate": "2020-08-14T23:58:08Z", "type": "forcePushed"}, {"oid": "edc41780701dbce192e799d3aaffe334a9851f17", "url": "https://github.com/apache/pinot/commit/edc41780701dbce192e799d3aaffe334a9851f17", "message": "Support post-aggregation in SELECT", "committedDate": "2020-08-17T19:26:42Z", "type": "forcePushed"}, {"oid": "597705967ed172f0a08e6a7f46bbbbd49d7651c2", "url": "https://github.com/apache/pinot/commit/597705967ed172f0a08e6a7f46bbbbd49d7651c2", "message": "Support post-aggregation in SELECT", "committedDate": "2020-08-17T19:34:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1ODI2Mw==", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472358263", "bodyText": "how about adding a query with literals", "author": "npawar", "createdAt": "2020-08-18T17:20:12Z", "path": "pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java", "diffHunk": "@@ -231,6 +231,13 @@ public void testHardcodedSqlQueries()\n     testSqlQuery(query, Collections.singletonList(query));\n     query = \"SELECT MAX(ArrDelay), Month FROM mytable GROUP BY Month ORDER BY ABS(Month - 6) + MAX(ArrDelay)\";\n     testSqlQuery(query, Collections.singletonList(query));\n+\n+    // Post-aggregation in SELECT", "originalCommit": "597705967ed172f0a08e6a7f46bbbbd49d7651c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQwMzE4Mw==", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472403183", "bodyText": "Sounds good, added", "author": "Jackie-Jiang", "createdAt": "2020-08-18T18:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1ODI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a361c9f4bf449da42f165caf5558c3d400cf883d", "chunk": "diff --git a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java\nindex a7d75ca2ef..53e85ceba2 100644\n--- a/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java\n+++ b/pinot-integration-tests/src/test/java/org/apache/pinot/integration/tests/BaseClusterIntegrationTestSet.java\n\n@@ -238,6 +238,9 @@ public abstract class BaseClusterIntegrationTestSet extends BaseClusterIntegrati\n     query =\n         \"SELECT MAX(ArrDelay) - MAX(AirTime), DaysSinceEpoch FROM mytable GROUP BY DaysSinceEpoch ORDER BY MAX(ArrDelay) - MIN(AirTime) DESC\";\n     testSqlQuery(query, Collections.singletonList(query));\n+    query =\n+        \"SELECT DaysSinceEpoch, MAX(ArrDelay) * 2 - MAX(AirTime) - 3 FROM mytable GROUP BY DaysSinceEpoch ORDER BY MAX(ArrDelay) - MIN(AirTime) DESC\";\n+    testSqlQuery(query, Collections.singletonList(query));\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4MTgyNA==", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472381824", "bodyText": "looks like the reordering logic happens within postAggregationHandler, whether we have post aggregations functions or not? Can we add a comment either here or inside postAggregationHandler, that reordering is handled as one of the post aggregation operations?", "author": "npawar", "createdAt": "2020-08-18T17:59:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -160,103 +160,49 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n+    DataSchema prePostAggregationDataSchema = getPrePostAggregationDataSchema(dataSchema);\n     int limit = _queryContext.getLimit();\n     List<Object[]> rows = new ArrayList<>(limit);\n+    for (int i = 0; i < limit && sortedIterator.hasNext(); i++) {\n+      Object[] row = sortedIterator.next().getValues();\n+      for (int j = 0; j < _numAggregationFunctions; j++) {\n+        int valueIndex = j + _numGroupByExpressions;\n+        row[valueIndex] =\n+            AggregationFunctionUtils.getSerializableValue(_aggregationFunctions[j].extractFinalResult(row[valueIndex]));\n+      }\n+      rows.add(row);\n+    }\n \n     if (_sqlQuery) {\n       // SQL query with SQL group-by mode and response format\n-      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n-\n-      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n-      int numSelectExpressions = selectExpressionIndexMap.length;\n-      String[] columnNames = resultTableSchema.getColumnNames();\n-      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n-      String[] reorderedColumnNames = new String[numSelectExpressions];\n-      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n-      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n-      for (int i = 0; i < numSelectExpressions; i++) {\n-        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n-        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n-      }\n-      while (rows.size() < limit && sortedIterator.hasNext()) {\n-        Record nextRecord = sortedIterator.next();\n-        Object[] values = nextRecord.getValues();\n-        for (int i = 0; i < _numAggregationFunctions; i++) {\n-          int valueIndex = i + _numGroupByExpressions;\n-          values[valueIndex] = AggregationFunctionUtils\n-              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n-        }\n \n-        Object[] reorderedValues = new Object[numSelectExpressions];", "originalCommit": "597705967ed172f0a08e6a7f46bbbbd49d7651c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQwOTUwNQ==", "url": "https://github.com/apache/pinot/pull/5867#discussion_r472409505", "bodyText": "Good point. Added comment inside PostAggregationHandler stating that the column re-ordering is handled inside.", "author": "Jackie-Jiang", "createdAt": "2020-08-18T18:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4MTgyNA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "a361c9f4bf449da42f165caf5558c3d400cf883d", "url": "https://github.com/apache/pinot/commit/a361c9f4bf449da42f165caf5558c3d400cf883d", "message": "Support post-aggregation in SELECT", "committedDate": "2020-08-18T18:50:46Z", "type": "commit"}, {"oid": "a361c9f4bf449da42f165caf5558c3d400cf883d", "url": "https://github.com/apache/pinot/commit/a361c9f4bf449da42f165caf5558c3d400cf883d", "message": "Support post-aggregation in SELECT", "committedDate": "2020-08-18T18:50:46Z", "type": "forcePushed"}]}