{"pr_number": 5382, "pr_title": "Temporary work-around to bypass function arguments being treated as expressions with columns.", "pr_createdAt": "2020-05-14T01:42:04Z", "pr_url": "https://github.com/apache/pinot/pull/5382", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyNDYzMA==", "url": "https://github.com/apache/pinot/pull/5382#discussion_r424824630", "bodyText": "I would recommend specialize THETA_SKETCHES, so that it won't affect DISTINCT", "author": "Jackie-Jiang", "createdAt": "2020-05-14T01:44:19Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/request/ServerQueryRequest.java", "diffHunk": "@@ -94,10 +94,12 @@ public ServerQueryRequest(InstanceRequest instanceRequest, ServerMetrics serverM\n     if (aggregationsInfo != null) {\n       _aggregationExpressions = new HashSet<>();\n       for (AggregationInfo aggregationInfo : aggregationsInfo) {\n-        if (!aggregationInfo.getAggregationType().equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-          for (String expressions : AggregationFunctionUtils.getArguments(aggregationInfo)) {\n-            _aggregationExpressions.add(TransformExpressionTree.compileToExpressionTree(expressions));\n-          }\n+        String aggregationType = aggregationInfo.getAggregationType();", "originalCommit": "f93182326448f475873f15c94a043cda2e820a92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyNjkxNA==", "url": "https://github.com/apache/pinot/pull/5382#discussion_r424826914", "bodyText": "Yeah, I was debating between the two approaches. I missed that we could support expressions in distinct. Will update to special case theta-sketch.", "author": "mayankshriv", "createdAt": "2020-05-14T01:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgyNDYzMA=="}], "type": "inlineReview", "revised_code": {"commit": "6f7a8d212b3e983bfec9a692cd762dfce4614ce4", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/request/ServerQueryRequest.java b/pinot-core/src/main/java/org/apache/pinot/core/query/request/ServerQueryRequest.java\nindex 9fdc51ddd7..65b77997af 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/request/ServerQueryRequest.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/request/ServerQueryRequest.java\n\n@@ -95,11 +95,17 @@ public class ServerQueryRequest {\n       _aggregationExpressions = new HashSet<>();\n       for (AggregationInfo aggregationInfo : aggregationsInfo) {\n         String aggregationType = aggregationInfo.getAggregationType();\n-        if (!aggregationType.equalsIgnoreCase(AggregationFunctionType.COUNT.getName())) {\n-          // TODO: Argument expressions need to be interpreted by AggregationFunction (as not all may have columns).\n-          // For now, assume the first argument has the expression to fetch columns.\n-          String expression = AggregationFunctionUtils.getArguments(aggregationInfo).get(0);\n-          _aggregationExpressions.add(TransformExpressionTree.compileToExpressionTree(expression));\n+\n+        // TODO: Remove special casing of theta-sketch.\n+        // This is needed as a work-around because only aggregation functions know how to interpret the expressions.\n+        // The code below assumes that all expressions have columns in them, which may not be true. But only Aggregation\n+        // functions have that knowledge, and have not been instantiated yet. A clean fix would be to instantiate\n+        // aggregation functions upfront to interpret the expressions.\n+        if (!aggregationType.equalsIgnoreCase(AggregationFunctionType.COUNT.getName()) || !aggregationType\n+            .equalsIgnoreCase(AggregationFunctionType.DISTINCTCOUNTTHETASKETCH.getName())) {\n+          for (String expressions : AggregationFunctionUtils.getArguments(aggregationInfo)) {\n+            _aggregationExpressions.add(TransformExpressionTree.compileToExpressionTree(expressions));\n+          }\n         }\n       }\n       _aggregationColumns = RequestUtils.extractColumnsFromExpressions(_aggregationExpressions);\n"}}, {"oid": "6f7a8d212b3e983bfec9a692cd762dfce4614ce4", "url": "https://github.com/apache/pinot/commit/6f7a8d212b3e983bfec9a692cd762dfce4614ce4", "message": "Temporary work-around to bypass function arguments being treated as expressions with columns.\n\nOnly aggregation functions have the knowledge on how to interpret their arguments.\nHowever, the assumption within ServerQueryRequest is that all expression arguments will contain\ncolumns to be collected. A clean fix would be to create aggregation functions upfront and let\nthem interpret the arguments. However, until that happens, working-around by assuming that first\nargument contains all the columns (to be used by DataSchemaPruner), which is true for all functions.\n\nA side effect would be that DataSchemaPruner won't work for DistinctCountThetaSketchAggregatinoFunction.\nBut since this pruner is only for schema mis-matches, and not for performance, there should not be\nan impact.", "committedDate": "2020-05-14T01:58:56Z", "type": "forcePushed"}, {"oid": "364956757d9e284cdeaccde3091b1dd51c5deda7", "url": "https://github.com/apache/pinot/commit/364956757d9e284cdeaccde3091b1dd51c5deda7", "message": "Temporary work-around to bypass function arguments being treated as expressions with columns.\n\nOnly aggregation functions have the knowledge on how to interpret their arguments.\nHowever, the assumption within ServerQueryRequest is that all expression arguments will contain\ncolumns to be collected. A clean fix would be to create aggregation functions upfront and let\nthem interpret the arguments. However, until that happens, working-around by assuming that first\nargument contains all the columns (to be used by DataSchemaPruner), which is true for all functions.\n\nA side effect would be that DataSchemaPruner won't work for DistinctCountThetaSketchAggregatinoFunction.\nBut since this pruner is only for schema mis-matches, and not for performance, there should not be\nan impact.", "committedDate": "2020-05-14T01:59:43Z", "type": "commit"}, {"oid": "364956757d9e284cdeaccde3091b1dd51c5deda7", "url": "https://github.com/apache/pinot/commit/364956757d9e284cdeaccde3091b1dd51c5deda7", "message": "Temporary work-around to bypass function arguments being treated as expressions with columns.\n\nOnly aggregation functions have the knowledge on how to interpret their arguments.\nHowever, the assumption within ServerQueryRequest is that all expression arguments will contain\ncolumns to be collected. A clean fix would be to create aggregation functions upfront and let\nthem interpret the arguments. However, until that happens, working-around by assuming that first\nargument contains all the columns (to be used by DataSchemaPruner), which is true for all functions.\n\nA side effect would be that DataSchemaPruner won't work for DistinctCountThetaSketchAggregatinoFunction.\nBut since this pruner is only for schema mis-matches, and not for performance, there should not be\nan impact.", "committedDate": "2020-05-14T01:59:43Z", "type": "forcePushed"}]}