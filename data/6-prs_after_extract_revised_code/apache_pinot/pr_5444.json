{"pr_number": 5444, "pr_title": "Enhance and simplify the filtering", "pr_createdAt": "2020-05-26T03:01:37Z", "pr_url": "https://github.com/apache/pinot/pull/5444", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMTk4MQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430711981", "bodyText": "this is awesome", "author": "kishoreg", "createdAt": "2020-05-26T21:15:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -21,6 +21,4 @@\n public interface BlockDocIdSet {\n \n   BlockDocIdIterator iterator();\n-", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\nindex 99440eb9a1..685a83425e 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n\n@@ -18,7 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n+/**\n+ * The interface <code>BlockDocIdSet</code> represents all the matching document ids for a predicate.\n+ * TODO: Redesign the filtering to skip the BlockDocIdSet and directly use BlockDocIdIterator\n+ */\n public interface BlockDocIdSet {\n \n+  /**\n+   * Returns a {@code BlockDocIdIterator} for the matching document ids. The document ids returned from the iterator\n+   * should be in ascending order.\n+   */\n   BlockDocIdIterator iterator();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMjgwMQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430712801", "bodyText": "why is blockValIterator returning getNextDocId ?", "author": "kishoreg", "createdAt": "2020-05-26T21:16:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java", "diffHunk": "@@ -22,6 +22,8 @@\n \n   boolean hasNext();\n \n+  int getNextDocId();", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDQ3Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430790472", "bodyText": "This iterator is not only iterator but supports skipTo(docId) and reset(). It is easier to track the docId here comparing to tracking it on the caller side. I'll add some javadoc to explain this", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMjgwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\nindex bb10ab6f02..9d083878d3 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\n\n@@ -20,11 +20,23 @@ package org.apache.pinot.core.common;\n \n public interface BlockValIterator {\n \n+  /**\n+   * Returns {@code true} if there are more values in the iterator, {@code false} otherwise.\n+   */\n   boolean hasNext();\n \n+  /**\n+   * Returns the next document id to be read.\n+   */\n   int getNextDocId();\n \n+  /**\n+   * Sets the next document id to the given document id.\n+   */\n   void skipTo(int docId);\n \n+  /**\n+   * Resets the iterator so that the next document id is 0.\n+   */\n   void reset();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDI3NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430714275", "bodyText": "why are we removing these methods, dont we need them for no-dictionary?", "author": "kishoreg", "createdAt": "2020-05-26T21:20:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java", "diffHunk": "@@ -277,42 +260,6 @@ public void setStringArray(int row, String[] stringArray) {\n     }\n   }\n \n-  @Override", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4OTA2Mw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430789063", "bodyText": "No, I only removed the ones that does not apply to Pinot types (we don't support MV BYTES).", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java b/pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java\nindex e5c67a38be..b47cfb7de5 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/io/readerwriter/impl/FixedByteSingleColumnMultiValueReaderWriter.java\n\n@@ -260,6 +277,42 @@ public class FixedByteSingleColumnMultiValueReaderWriter extends BaseSingleColum\n     }\n   }\n \n+  @Override\n+  public void setBytesArray(int row, byte[][] bytesArray) {\n+    int newStartIndex = updateHeader(row, bytesArray.length);\n+    for (int i = 0; i < bytesArray.length; i++) {\n+      _currentDataWriter.setBytes(newStartIndex + i, 0, bytesArray[i]);\n+    }\n+  }\n+\n+  @Override\n+  public int getCharArray(int row, char[] charArray) {\n+    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);\n+    int rowInCurrentHeader = getRowInCurrentHeader(row);\n+    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);\n+    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);\n+    int length = headerReader.getInt(rowInCurrentHeader, 2);\n+    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);\n+    for (int i = 0; i < length; i++) {\n+      charArray[i] = dataReader.getChar(startIndex + i, 0);\n+    }\n+    return length;\n+  }\n+\n+  @Override\n+  public int getShortArray(int row, short[] shortsArray) {\n+    FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);\n+    int rowInCurrentHeader = getRowInCurrentHeader(row);\n+    int bufferIndex = headerReader.getInt(rowInCurrentHeader, 0);\n+    int startIndex = headerReader.getInt(rowInCurrentHeader, 1);\n+    int length = headerReader.getInt(rowInCurrentHeader, 2);\n+    FixedByteSingleValueMultiColReader dataReader = _dataReaders.get(bufferIndex);\n+    for (int i = 0; i < length; i++) {\n+      shortsArray[i] = dataReader.getShort(startIndex + i, 0);\n+    }\n+    return length;\n+  }\n+\n   @Override\n   public int getIntArray(int row, int[] intArray) {\n     FixedByteSingleValueMultiColReader headerReader = getCurrentReader(row);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzIxNA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430777214", "bodyText": "we don't want to remove these. There are usecases where we will support no-dictionary modes", "author": "kishoreg", "createdAt": "2020-05-27T00:20:54Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java", "diffHunk": "@@ -19,60 +19,14 @@\n package org.apache.pinot.core.io.writer;\n \n public interface SingleColumnMultiValueWriter extends DataFileWriter {\n-  /**", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4OTUyMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430789523", "bodyText": "Same here. I only removed the ones that does not apply to Pinot data types.", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java b/pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java\nindex f5968202ef..7edac926f7 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/io/writer/SingleColumnMultiValueWriter.java\n\n@@ -19,14 +19,60 @@\n package org.apache.pinot.core.io.writer;\n \n public interface SingleColumnMultiValueWriter extends DataFileWriter {\n+  /**\n+   * Read the multiple values for a column at a specific row.\n+   *\n+   * @param row\n+   * @param charArray\n+   */\n+  void setCharArray(int row, char[] charArray);\n \n+  /**\n+   *\n+   * @param row\n+   * @param shortsArray\n+   */\n+  void setShortArray(int row, short[] shortsArray);\n+\n+  /**\n+   *\n+   * @param row\n+   * @param intArray\n+   */\n   void setIntArray(int row, int[] intArray);\n \n+  /**\n+   *\n+   * @param row\n+   * @param longArray\n+   */\n   void setLongArray(int row, long[] longArray);\n \n+  /**\n+   *\n+   * @param row\n+   * @param floatArray\n+   */\n   void setFloatArray(int row, float[] floatArray);\n \n+  /**\n+   *\n+   * @param row\n+   * @param doubleArray\n+   */\n   void setDoubleArray(int row, double[] doubleArray);\n \n+  /**\n+   *\n+   * @param row\n+   * @param stringArray\n+   */\n   void setStringArray(int row, String[] stringArray);\n+\n+  /**\n+   *\n+   * @param row\n+   * @param bytesArray\n+   */\n+  void setBytesArray(int row, byte[][] bytesArray);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430783521", "bodyText": "Java doc over this method and/or the interface? Since we are refactoring this interface, it is a good time to add javadoc for a public interface as well.", "author": "chenboat", "createdAt": "2020-05-27T00:43:25Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -21,6 +21,4 @@\n public interface BlockDocIdSet {\n \n   BlockDocIdIterator iterator();", "originalCommit": "8dbbaa576b37449fc2e85813380ad84ba60f9bd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDU4Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r430790582", "bodyText": "Good point, will add javadoc", "author": "Jackie-Jiang", "createdAt": "2020-05-27T01:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDc5OQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604799", "bodyText": "can you also explain why it is called block*?", "author": "chenboat", "createdAt": "2020-05-28T06:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MzAxNA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432043014", "bodyText": "The result from the Operator is called Block, and BlockDocIdSet is the document ids from a Block. It is not structured very well, but it is out of the scope of this PR. We have plan to clean that up later.", "author": "Jackie-Jiang", "createdAt": "2020-05-28T18:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\nindex 99440eb9a1..685a83425e 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n\n@@ -18,7 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n+/**\n+ * The interface <code>BlockDocIdSet</code> represents all the matching document ids for a predicate.\n+ * TODO: Redesign the filtering to skip the BlockDocIdSet and directly use BlockDocIdIterator\n+ */\n public interface BlockDocIdSet {\n \n+  /**\n+   * Returns a {@code BlockDocIdIterator} for the matching document ids. The document ids returned from the iterator\n+   * should be in ascending order.\n+   */\n   BlockDocIdIterator iterator();\n }\n"}}, {"oid": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "url": "https://github.com/apache/pinot/commit/721e572ec55d488dc0f094e3b413b732ed0ae52b", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-27T04:04:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDQ4NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604484", "bodyText": "javadoc?", "author": "chenboat", "createdAt": "2020-05-28T06:17:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java", "diffHunk": "@@ -18,33 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- *\n- */\n-public abstract class BlockMultiValIterator implements BlockValIterator {\n-\n-  public int nextCharVal(char[] charArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockMultiValIterator extends BlockValIterator {", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\nindex 35a087daaa..68c0fc516f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\n\n@@ -18,15 +18,33 @@\n  */\n package org.apache.pinot.core.common;\n \n-public interface BlockMultiValIterator extends BlockValIterator {\n+/**\n+ *\n+ *\n+ */\n+public abstract class BlockMultiValIterator implements BlockValIterator {\n+\n+  public int nextCharVal(char[] charArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextIntVal(int[] intArray);\n+  public int nextIntVal(int[] intArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextLongVal(long[] longArray);\n+  public int nextLongVal(long[] longArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextFloatVal(float[] floatArray);\n+  public int nextFloatVal(float[] floatArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextDoubleVal(double[] doubleArray);\n+  public int nextDoubleVal(double[] doubleArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextStringVal(String[] stringArray);\n+  public int nextBytesArrayVal(byte[][] bytesArrays) {\n+    throw new UnsupportedOperationException();\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNDk3Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431604976", "bodyText": "javadoc", "author": "chenboat", "createdAt": "2020-05-28T06:19:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java", "diffHunk": "@@ -18,37 +18,17 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- * TODO: Split into two classes, one for iterator over data, another over dictionary id's.\n- */\n-public abstract class BlockSingleValIterator implements BlockValIterator {\n-\n-  char nextCharVal() {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockSingleValIterator extends BlockValIterator {", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java\nindex af4b9f282c..5222189a43 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockSingleValIterator.java\n\n@@ -18,17 +18,37 @@\n  */\n package org.apache.pinot.core.common;\n \n-public interface BlockSingleValIterator extends BlockValIterator {\n+/**\n+ *\n+ * TODO: Split into two classes, one for iterator over data, another over dictionary id's.\n+ */\n+public abstract class BlockSingleValIterator implements BlockValIterator {\n+\n+  char nextCharVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextIntVal();\n+  public int nextIntVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  long nextLongVal();\n+  public float nextFloatVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  float nextFloatVal();\n+  public long nextLongVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  double nextDoubleVal();\n+  public double nextDoubleVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  String nextStringVal();\n+  public byte[] nextBytesVal() {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  byte[] nextBytesVal();\n+  public String nextStringVal() {\n+    throw new UnsupportedOperationException();\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjUwNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431606505", "bodyText": "what is the behavior if the input doc id does not exist?", "author": "chenboat", "createdAt": "2020-05-28T06:23:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java", "diffHunk": "@@ -20,9 +20,23 @@\n \n public interface BlockValIterator {\n \n+  /**\n+   * Returns {@code true} if there are more values in the iterator, {@code false} otherwise.\n+   */\n   boolean hasNext();\n \n+  /**\n+   * Returns the next document id to be read.\n+   */\n+  int getNextDocId();\n+\n+  /**\n+   * Sets the next document id to the given document id.", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\nindex 9d083878d3..776f42525f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockValIterator.java\n\n@@ -20,23 +20,9 @@ package org.apache.pinot.core.common;\n \n public interface BlockValIterator {\n \n-  /**\n-   * Returns {@code true} if there are more values in the iterator, {@code false} otherwise.\n-   */\n   boolean hasNext();\n \n-  /**\n-   * Returns the next document id to be read.\n-   */\n-  int getNextDocId();\n-\n-  /**\n-   * Sets the next document id to the given document id.\n-   */\n   void skipTo(int docId);\n \n-  /**\n-   * Resets the iterator so that the next document id is 0.\n-   */\n   void reset();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjk3MQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431606971", "bodyText": "it is worthwhile to explain how to use this method? what is the input array?", "author": "chenboat", "createdAt": "2020-05-28T06:25:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java", "diffHunk": "@@ -18,33 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n-/**\n- *\n- *\n- */\n-public abstract class BlockMultiValIterator implements BlockValIterator {\n-\n-  public int nextCharVal(char[] charArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+public interface BlockMultiValIterator extends BlockValIterator {\n \n-  public int nextIntVal(int[] intArray) {\n-    throw new UnsupportedOperationException();\n-  }\n+  int nextIntVal(int[] intArray);", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d048549b900fd79c8559349310ab88c276e9a66b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\nindex 35a087daaa..68c0fc516f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockMultiValIterator.java\n\n@@ -18,15 +18,33 @@\n  */\n package org.apache.pinot.core.common;\n \n-public interface BlockMultiValIterator extends BlockValIterator {\n+/**\n+ *\n+ *\n+ */\n+public abstract class BlockMultiValIterator implements BlockValIterator {\n+\n+  public int nextCharVal(char[] charArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextIntVal(int[] intArray);\n+  public int nextIntVal(int[] intArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextLongVal(long[] longArray);\n+  public int nextLongVal(long[] longArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextFloatVal(float[] floatArray);\n+  public int nextFloatVal(float[] floatArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextDoubleVal(double[] doubleArray);\n+  public int nextDoubleVal(double[] doubleArray) {\n+    throw new UnsupportedOperationException();\n+  }\n \n-  int nextStringVal(String[] stringArray);\n+  public int nextBytesArrayVal(byte[][] bytesArrays) {\n+    throw new UnsupportedOperationException();\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTA3Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r431615072", "bodyText": "does it mean the class performs binary merge of 2 child BlockDocIdSets each time?", "author": "chenboat", "createdAt": "2020-05-28T06:45:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docidsets;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.AndDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.BitmapBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.RangelessBitmapDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.ScanBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SortedDocIdIterator;\n+import org.apache.pinot.core.util.SortedRangeIntersection;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+/**\n+ * The FilterBlockDocIdSet to perform AND on all child FilterBlockDocIdSets.\n+ * <p>The AndBlockDocIdSet will construct the BlockDocIdIterator based on the BlockDocIdIterators from the child\n+ * FilterBlockDocIdSets:\n+ * <ul>\n+ *   <li>\n+ *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and", "originalCommit": "721e572ec55d488dc0f094e3b413b732ed0ae52b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MDEwMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432060103", "bodyText": "It uses a bitmap to perform AND for all index-based BlockDocIdIterators, and use ScanBasedDocIdIterator.applyAnd(docIds) to resolve the scan-based BlockDocIdIterators. After all, there will be one RangelessBitmapDocIdIterator on top of the result bitmap.", "author": "Jackie-Jiang", "createdAt": "2020-05-28T19:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\nindex 815a407501..7fbffa8ed0 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\n\n@@ -38,9 +38,9 @@ import org.roaringbitmap.buffer.MutableRoaringBitmap;\n  * FilterBlockDocIdSets:\n  * <ul>\n  *   <li>\n- *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n- *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterators, merge them and construct a\n- *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterators, directly\n+ *     When there are at least one index-base BlockDocIdIterator (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n+ *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterator, merge them and construct a\n+ *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterator, directly\n  *     return the merged RangelessBitmapDocIdIterator; otherwise, construct and return an AndDocIdIterator with the\n  *     merged RangelessBitmapDocIdIterator and the remaining BlockDocIdIterators.\n  *   </li>\n"}}, {"oid": "d048549b900fd79c8559349310ab88c276e9a66b", "url": "https://github.com/apache/pinot/commit/d048549b900fd79c8559349310ab88c276e9a66b", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-28T22:42:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMTYzNw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432211637", "bodyText": "It will be useful to add some comments here as to how we make sure that index never overruns. It took me a couple of iterations to get the test cases to test this.\nOn that topic, will be useful to add a unit test for this class.", "author": "mcvsubbu", "createdAt": "2020-05-29T01:39:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {\n-  public final BlockDocIdIterator[] docIdIterators;\n-  public ScanBasedDocIdIterator[] scanBasedDocIdIterators;\n-  public final int[] docIdPointers;\n-  public boolean reachedEnd = false;\n-  public int currentDocId = -1;\n-  int currentMax = -1;\n-  private boolean hasScanBasedIterators;\n+  public final BlockDocIdIterator[] _docIdIterators;\n \n-  public AndDocIdIterator(BlockDocIdIterator[] blockDocIdIterators) {\n-    int numIndexBasedIterators = 0;\n-    int numScanBasedIterators = 0;\n-    for (int i = 0; i < blockDocIdIterators.length; i++) {\n-      if (blockDocIdIterators[i] instanceof IndexBasedDocIdIterator) {\n-        numIndexBasedIterators = numIndexBasedIterators + 1;\n-      } else if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-        numScanBasedIterators = numScanBasedIterators + 1;\n-      }\n-    }\n-    // if we have at least one index based then do intersection based on index based only, and then\n-    // check if matching docs apply on scan based iterator\n-    if (numIndexBasedIterators > 0 && numScanBasedIterators > 0) {\n-      hasScanBasedIterators = true;\n-      int nonScanIteratorsSize = blockDocIdIterators.length - numScanBasedIterators;\n-      this.docIdIterators = new BlockDocIdIterator[nonScanIteratorsSize];\n-      this.scanBasedDocIdIterators = new ScanBasedDocIdIterator[numScanBasedIterators];\n-      int nonScanBasedIndex = 0;\n-      int scanBasedIndex = 0;\n-      for (int i = 0; i < blockDocIdIterators.length; i++) {\n-        if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-          this.scanBasedDocIdIterators[scanBasedIndex++] = (ScanBasedDocIdIterator) blockDocIdIterators[i];\n-        } else {\n-          this.docIdIterators[nonScanBasedIndex++] = blockDocIdIterators[i];\n-        }\n-      }\n-    } else {\n-      hasScanBasedIterators = false;\n-      this.docIdIterators = blockDocIdIterators;\n-    }\n-    this.docIdPointers = new int[docIdIterators.length];\n-    Arrays.fill(docIdPointers, -1);\n-  }\n+  private int _nextDocId = 0;\n \n-  @Override\n-  public int advance(int targetDocId) {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    if (currentDocId >= targetDocId) {\n-      return currentDocId;\n-    }\n-    // next() method will always increment currentMax by 1.\n-    currentMax = targetDocId - 1;\n-    return next();\n+  public AndDocIdIterator(BlockDocIdIterator[] docIdIterators) {\n+    _docIdIterators = docIdIterators;\n   }\n \n   @Override\n   public int next() {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    currentMax = currentMax + 1;\n-    // always increment the pointer to current max, when this is called first time, every one will\n-    // be set to start of posting list.\n-    for (int i = 0; i < docIdIterators.length; i++) {\n-      docIdPointers[i] = docIdIterators[i].advance(currentMax);\n-      if (docIdPointers[i] == Constants.EOF) {\n-        reachedEnd = true;\n-        currentMax = Constants.EOF;\n-        break;\n-      }\n-      if (docIdPointers[i] > currentMax) {\n-        currentMax = docIdPointers[i];\n-        if (i > 0) {\n-          // we need to advance all pointer since we found a new max\n-          i = -1;\n-        }\n-      }\n-      if (hasScanBasedIterators && i == docIdIterators.length - 1) {\n-        // this means we found the docId common to all nonScanBased iterators, now we need to ensure\n-        // that its also found in scanBasedIterator, if not matched, we restart the intersection\n-        for (ScanBasedDocIdIterator iterator : scanBasedDocIdIterators) {\n-          if (!iterator.isMatch(currentMax)) {\n-            i = -1;\n-            currentMax = currentMax + 1;\n-            break;\n+    int maxDocId = _nextDocId;\n+    int maxDocIdIndex = -1;\n+    int numDocIdIterators = _docIdIterators.length;\n+    int index = 0;\n+    while (index < numDocIdIterators) {\n+      if (index == maxDocIdIndex) {\n+        // Skip the index with the max document id\n+        index++;", "originalCommit": "d048549b900fd79c8559349310ab88c276e9a66b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDc5NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432244794", "bodyText": "Changed the code a little bit so that it is more clear how index is kept in bound.\nAdded AndDocIdIteratorTest and OrDocIdIteratorTest.\nI have run all the queries before submitting the PR. Will run them again before merging.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T04:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMTYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "d22ac5ce9e049c020ee8b9cb7b440591bd7f5176", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\nindex 84d7a63cab..7395880f2d 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n\n@@ -41,20 +41,20 @@ public final class AndDocIdIterator implements BlockDocIdIterator {\n       if (index == maxDocIdIndex) {\n         // Skip the index with the max document id\n         index++;\n-      } else {\n-        int docId = _docIdIterators[index].advance(maxDocId);\n-        if (docId != Constants.EOF) {\n-          if (docId == maxDocId) {\n-            index++;\n-          } else {\n-            // The current iterator does not contain the maxDocId, update maxDocId and advance all other iterators\n-            maxDocId = docId;\n-            maxDocIdIndex = index;\n-            index = 0;\n-          }\n+        continue;\n+      }\n+      int docId = _docIdIterators[index].advance(maxDocId);\n+      if (docId != Constants.EOF) {\n+        if (docId == maxDocId) {\n+          index++;\n         } else {\n-          return Constants.EOF;\n+          // The current iterator does not contain the maxDocId, update maxDocId and advance all other iterators\n+          maxDocId = docId;\n+          maxDocIdIndex = index;\n+          index = 0;\n         }\n+      } else {\n+        return Constants.EOF;\n       }\n     }\n     _nextDocId = maxDocId;\n"}}, {"oid": "d22ac5ce9e049c020ee8b9cb7b440591bd7f5176", "url": "https://github.com/apache/pinot/commit/d22ac5ce9e049c020ee8b9cb7b440591bd7f5176", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T04:04:13Z", "type": "forcePushed"}, {"oid": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "url": "https://github.com/apache/pinot/commit/02f8fc7c0e73853ad6637e3b18539df462cc57cd", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T04:19:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMTg0Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432321846", "bodyText": "(nit): should just be cardinality of the column (since size of dictionary is equal to cardinality)", "author": "siddharthteotia", "createdAt": "2020-05-29T08:05:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.DataSource;\n+import org.apache.pinot.core.io.reader.impl.v1.SortedIndexReader;\n+import org.apache.pinot.core.operator.blocks.FilterBlock;\n+import org.apache.pinot.core.operator.docidsets.SortedDocIdSet;\n+import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n+import org.apache.pinot.core.operator.filter.predicate.RangePredicateEvaluatorFactory.OfflineDictionaryBasedRangePredicateEvaluator;\n+\n+\n+@SuppressWarnings(\"rawtypes\")\n+public class SortedIndexBasedFilterOperator extends BaseFilterOperator {\n+  private static final String OPERATOR_NAME = \"SortedIndexBasedFilterOperator\";\n+\n+  private final PredicateEvaluator _predicateEvaluator;\n+  private final SortedIndexReader _sortedIndexReader;\n+  private final int _numDocs;\n+\n+  SortedIndexBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int numDocs) {\n+    _predicateEvaluator = predicateEvaluator;\n+    _sortedIndexReader = (SortedIndexReader) dataSource.getInvertedIndex();\n+    _numDocs = numDocs;\n+  }\n+\n+  @Override\n+  protected FilterBlock getNextBlock() {\n+    // At this point, we need to create a list of matching docId ranges. There are two kinds of operators:\n+    //\n+    // - \"Additive\" operators, such as EQ, IN and RANGE build up a list of ranges and merge overlapping/adjacent ones,\n+    //   clipping the ranges to [startDocId; endDocId]\n+    //\n+    // - \"Subtractive\" operators, such as NEQ and NOT IN build up a list of ranges that do not match and build a list of\n+    //   matching intervals by subtracting a list of non-matching intervals from the given range of\n+    //   [startDocId; endDocId]\n+    //\n+    // For now, we don't look at the cardinality of the column's dictionary, although we should do that if someone", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODk5Nw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432678997", "bodyText": "I didn't change this block of comments, but seems it identifies it as a new class. Let me update it.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMTg0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java\nindex 131a45ed15..2fa417c307 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/SortedIndexBasedFilterOperator.java\n\n@@ -48,19 +48,12 @@ public class SortedIndexBasedFilterOperator extends BaseFilterOperator {\n \n   @Override\n   protected FilterBlock getNextBlock() {\n-    // At this point, we need to create a list of matching docId ranges. There are two kinds of operators:\n+    // At this point, we need to create a list of matching docIdRanges.\n     //\n-    // - \"Additive\" operators, such as EQ, IN and RANGE build up a list of ranges and merge overlapping/adjacent ones,\n-    //   clipping the ranges to [startDocId; endDocId]\n-    //\n-    // - \"Subtractive\" operators, such as NEQ and NOT IN build up a list of ranges that do not match and build a list of\n-    //   matching intervals by subtracting a list of non-matching intervals from the given range of\n-    //   [startDocId; endDocId]\n-    //\n-    // For now, we don't look at the cardinality of the column's dictionary, although we should do that if someone\n-    // specifies a very large list of IN/NOT IN predicates relative to the column's cardinality or a very large/small\n-    // range predicate relative to the cardinality. However, as adjacent ranges get merged before returning the final\n-    // list of ranges, the only drawback is that we use a lot of memory during the filter block evaluation.\n+    // There are two kinds of operators:\n+    // - \"Additive\" operators (EQ, IN, RANGE): Build up a list of matching docIdRanges with adjacent ones merged.\n+    // - \"Subtractive\" operators (NEQ, NOT IN): Build up a list of non-matching docIdRanges with adjacent ones merged,\n+    //   then subtract them from the range of [0, numDocs) to get a list of matching docIdRanges.\n \n     if (_predicateEvaluator instanceof OfflineDictionaryBasedRangePredicateEvaluator) {\n       // For RANGE predicate, use start/end document id to construct a new document id range\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMjA5NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432322094", "bodyText": "Is is possible to handle NOT_IN, NEQ exactly once?\nWe checked for _exclusive and accordingly get non matching dictIds or matching dictIds based on whether it is true or false. So the predicate is already evaluated correctly. Now why can't we can just work on the docIds for these dictIds.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:06:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/BitmapBasedFilterOperator.java", "diffHunk": "@@ -25,62 +25,73 @@\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n import org.apache.pinot.core.segment.index.readers.InvertedIndexReader;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+@SuppressWarnings(\"rawtypes\")\n public class BitmapBasedFilterOperator extends BaseFilterOperator {\n   private static final String OPERATOR_NAME = \"BitmapBasedFilterOperator\";\n \n   private final PredicateEvaluator _predicateEvaluator;\n-  private final DataSource _dataSource;\n-  private final ImmutableRoaringBitmap[] _bitmaps;\n-  private final int _startDocId;\n-  // TODO: change it to exclusive\n-  // Inclusive\n-  private final int _endDocId;\n+  private final InvertedIndexReader _invertedIndexReader;\n+  private final ImmutableRoaringBitmap _docIds;\n   private final boolean _exclusive;\n+  private final int _numDocs;\n \n-  BitmapBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int startDocId,\n-      int endDocId) {\n-    // NOTE:\n-    // Predicate that is always evaluated as true or false should not be passed into the BitmapBasedFilterOperator for\n-    // performance concern.\n-    // If predicate is always evaluated as true, use MatchAllFilterOperator; if predicate is always evaluated as false,\n-    // use EmptyFilterOperator.\n-    Preconditions.checkArgument(!predicateEvaluator.isAlwaysTrue() && !predicateEvaluator.isAlwaysFalse());\n-\n+  BitmapBasedFilterOperator(PredicateEvaluator predicateEvaluator, DataSource dataSource, int numDocs) {\n     _predicateEvaluator = predicateEvaluator;\n-    _dataSource = dataSource;\n-    _bitmaps = null;\n-    _startDocId = startDocId;\n-    _endDocId = endDocId;\n+    _invertedIndexReader = dataSource.getInvertedIndex();\n+    _docIds = null;\n     _exclusive = predicateEvaluator.isExclusive();\n+    _numDocs = numDocs;\n   }\n \n-  public BitmapBasedFilterOperator(ImmutableRoaringBitmap[] bitmaps, int startDocId, int endDocId, boolean exclusive) {\n+  public BitmapBasedFilterOperator(ImmutableRoaringBitmap docIds, boolean exclusive, int numDocs) {\n     _predicateEvaluator = null;\n-    _dataSource = null;\n-    _bitmaps = bitmaps;\n-    _startDocId = startDocId;\n-    _endDocId = endDocId;\n+    _invertedIndexReader = null;\n+    _docIds = docIds;\n     _exclusive = exclusive;\n+    _numDocs = numDocs;\n   }\n \n   @Override\n   protected FilterBlock getNextBlock() {\n-    if (_bitmaps != null) {\n-      return new FilterBlock(new BitmapDocIdSet(_bitmaps, _startDocId, _endDocId, _exclusive));\n+    if (_docIds != null) {\n+      if (_exclusive) {\n+        return new FilterBlock(new BitmapDocIdSet(ImmutableRoaringBitmap.flip(_docIds, 0L, _numDocs), _numDocs));\n+      } else {\n+        return new FilterBlock(new BitmapDocIdSet(_docIds, _numDocs));\n+      }\n     }\n \n     int[] dictIds = _exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MTQ4Mg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432681482", "bodyText": "For exclusive predicate, we need to flip (inverse) the bitmap so that the result bitmap can reflect the matching docIds.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMjA5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzI2Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323266", "bodyText": "This is good piece of information. Why delete it? That's how the filtering will work right if we do\nWHERE col1 = 200 AND col2 = 10 -- if there is an inverted index on col1 and no index on col2", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:12Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java", "diffHunk": "@@ -24,22 +24,18 @@\n \n \n /**\n- * All scan based filter iterators must implement this interface. This allows intersection to be\n- * optimized.\n- * For example, if the we have two iterators one index based and another scan based, instead of", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjYwOQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432692609", "bodyText": "This part is explained in the AndDocIdSet. Updated the javadoc so that it is more clear here as well.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzI2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java\nindex 56c52204fd..5a5b9d3099 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ScanBasedDocIdIterator.java\n\n@@ -24,12 +24,18 @@ import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n /**\n- * All scan-based filter iterators should implement this interface to allow intersection to be optimized.\n+ * All scan-based filter iterators should implement this interface to allow intersection (AND operation) to be\n+ * optimized.\n+ * <p>When there are at least one index-base BlockDocIdIterator (SortedDocIdIterator or BitmapBasedDocIdIterator) and at\n+ * least one ScanBasedDocIdIterator, instead of iterating on each BlockDocIdIterator (we should avoid iterating on\n+ * ScanBasedDocIdIterator because that requires a lot of document scans), it can be optimized by first constructing a\n+ * bitmap of matching document ids from the index-based BlockDocIdIterators, and let ScanBasedDocIdIterator only scan\n+ * the matching document ids from the index-base BlockDocIdIterators.\n  */\n public interface ScanBasedDocIdIterator extends BlockDocIdIterator {\n \n   /**\n-   * Applies AND operation to the given bitmap of document ids, returns a bitmap of the matched document ids.\n+   * Applies AND operation to the given bitmap of document ids, returns a bitmap of the matching document ids.\n    */\n   MutableRoaringBitmap applyAnd(ImmutableRoaringBitmap docIds);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323335", "bodyText": "I think generally hasNext() should be called before next() like it is done here. But I think our next() implementations (at least in some of the cases), have hasNext() called internally from next() as well.\nSo may be we should simply do (nextDocId = docIdIterator.next()) < _numDocs", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:21Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java", "diffHunk": "@@ -18,238 +18,138 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import org.apache.pinot.core.common.BlockMetadata;\n import org.apache.pinot.core.common.BlockSingleValIterator;\n-import org.apache.pinot.core.common.BlockValSet;\n import org.apache.pinot.core.common.Constants;\n import org.apache.pinot.core.operator.filter.predicate.PredicateEvaluator;\n-import org.apache.pinot.spi.data.FieldSpec;\n import org.roaringbitmap.IntIterator;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n-public class SVScanDocIdIterator implements ScanBasedDocIdIterator {\n-  private int _currentDocId = -1;\n+public final class SVScanDocIdIterator implements ScanBasedDocIdIterator {\n+  private final PredicateEvaluator _predicateEvaluator;\n   private final BlockSingleValIterator _valueIterator;\n-  private int _startDocId;\n-  private int _endDocId;\n-  private PredicateEvaluator _evaluator;\n-  private String _operatorName;\n-  private int _numEntriesScanned = 0;\n+  private final int _numDocs;\n   private final ValueMatcher _valueMatcher;\n \n-  public SVScanDocIdIterator(String operatorName, BlockValSet blockValSet, BlockMetadata blockMetadata,\n-      PredicateEvaluator evaluator) {\n-    _operatorName = operatorName;\n-    _evaluator = evaluator;\n-    _valueIterator = (BlockSingleValIterator) blockValSet.iterator();\n-\n-    if (evaluator.isAlwaysFalse()) {\n-      _currentDocId = Constants.EOF;\n-      setStartDocId(Constants.EOF);\n-      setEndDocId(Constants.EOF);\n-    } else {\n-      setStartDocId(blockMetadata.getStartDocId());\n-      setEndDocId(blockMetadata.getEndDocId());\n-    }\n+  private int _nextDocId = 0;\n+  private long _numEntriesScanned = 0L;\n \n-    if (evaluator.isDictionaryBased()) {\n-      _valueMatcher = new IntMatcher(); // Match using dictionary id's that are integers.\n-    } else {\n-      _valueMatcher = getValueMatcherForType(blockMetadata.getDataType());\n-    }\n-    _valueMatcher.setEvaluator(evaluator);\n-  }\n-\n-  /**\n-   * After setting the startDocId, next calls will always return from &gt;=startDocId\n-   *\n-   * @param startDocId Start doc id\n-   */\n-  public void setStartDocId(int startDocId) {\n-    _currentDocId = startDocId - 1;\n-    _valueIterator.skipTo(startDocId);\n-    _startDocId = startDocId;\n-  }\n-\n-  /**\n-   * After setting the endDocId, next call will return Constants.EOF after currentDocId exceeds\n-   * endDocId\n-   *\n-   * @param endDocId End doc id\n-   */\n-  public void setEndDocId(int endDocId) {\n-    _endDocId = endDocId;\n-  }\n-\n-  @Override\n-  public boolean isMatch(int docId) {\n-    if (_currentDocId == Constants.EOF) {\n-      return false;\n-    }\n-    _valueIterator.skipTo(docId);\n-    _numEntriesScanned++;\n-    return _valueMatcher.doesCurrentEntryMatch(_valueIterator);\n-  }\n-\n-  @Override\n-  public int advance(int targetDocId) {\n-    if (_currentDocId == Constants.EOF) {\n-      return _currentDocId;\n-    }\n-    if (targetDocId < _startDocId) {\n-      targetDocId = _startDocId;\n-    } else if (targetDocId > _endDocId) {\n-      _currentDocId = Constants.EOF;\n-    }\n-    if (_currentDocId >= targetDocId) {\n-      return _currentDocId;\n-    } else {\n-      _currentDocId = targetDocId - 1;\n-      _valueIterator.skipTo(targetDocId);\n-      return next();\n-    }\n+  public SVScanDocIdIterator(PredicateEvaluator predicateEvaluator, BlockSingleValIterator valueIterator, int numDocs) {\n+    _predicateEvaluator = predicateEvaluator;\n+    _valueIterator = valueIterator;\n+    _numDocs = numDocs;\n+    _valueMatcher = getValueMatcher();\n   }\n \n   @Override\n   public int next() {\n-    if (_currentDocId == Constants.EOF) {\n-      return Constants.EOF;\n-    }\n-    while (_valueIterator.hasNext() && _currentDocId < _endDocId) {\n-      _currentDocId = _currentDocId + 1;\n+    while (_nextDocId < _numDocs) {\n+      int nextDocId = _nextDocId++;\n       _numEntriesScanned++;\n-      if (_valueMatcher.doesCurrentEntryMatch(_valueIterator)) {\n-        return _currentDocId;\n+      if (_valueMatcher.doesNextValueMatch()) {\n+        return nextDocId;\n       }\n     }\n-    _currentDocId = Constants.EOF;\n     return Constants.EOF;\n   }\n \n   @Override\n-  public int currentDocId() {\n-    return _currentDocId;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return SVScanDocIdIterator.class.getSimpleName() + \"[\" + _operatorName + \"]\";\n+  public int advance(int targetDocId) {\n+    _nextDocId = targetDocId;\n+    _valueIterator.skipTo(targetDocId);\n+    return next();\n   }\n \n   @Override\n   public MutableRoaringBitmap applyAnd(ImmutableRoaringBitmap docIds) {\n     MutableRoaringBitmap result = new MutableRoaringBitmap();\n-    if (_evaluator.isAlwaysFalse()) {\n-      return result;\n-    }\n-    IntIterator intIterator = docIds.getIntIterator();\n-    int docId = -1;\n-    while (intIterator.hasNext() && docId < _endDocId) {\n-      docId = intIterator.next();\n-      if (docId >= _startDocId) {\n-        _valueIterator.skipTo(docId);\n-        _numEntriesScanned++;\n-        if (_valueMatcher.doesCurrentEntryMatch(_valueIterator)) {\n-          result.add(docId);\n-        }\n+    IntIterator docIdIterator = docIds.getIntIterator();\n+    int nextDocId;\n+    while (docIdIterator.hasNext() && (nextDocId = docIdIterator.next()) < _numDocs) {", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTY1NA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432695654", "bodyText": "This IntIterator is from ImmutableRoaringBitmap.getIntIterator() where docIdIterator.next() does not check hasNext().\nOur BlockDocIdIterator does not have hasNext() and always use Constants.EOF to notify the end of the iteration.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5OTI4NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432699285", "bodyText": "its ok to drop hasNext if it simplifies the implementation", "author": "kishoreg", "createdAt": "2020-05-29T19:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java\nindex ced6d9580f..5f1fc9ec9d 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/SVScanDocIdIterator.java\n\n@@ -26,6 +26,10 @@ import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n+/**\n+ * The {@code SVScanDocIdIterator} is the scan-based iterator for SVScanDocIdSet to scan a single-value column for the\n+ * matching document ids.\n+ */\n public final class SVScanDocIdIterator implements ScanBasedDocIdIterator {\n   private final PredicateEvaluator _predicateEvaluator;\n   private final BlockSingleValIterator _valueIterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYwNg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323606", "bodyText": "+1000 on removing this.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java", "diffHunk": "@@ -18,9 +18,15 @@\n  */\n package org.apache.pinot.core.common;\n \n+/**\n+ * The interface <code>BlockDocIdSet</code> represents all the matching document ids for a predicate.", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed42e1cbe87bdc580cea52106506547a0d0bc997", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\nindex 685a83425e..bedff54d83 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdSet.java\n\n@@ -19,14 +19,14 @@\n package org.apache.pinot.core.common;\n \n /**\n- * The interface <code>BlockDocIdSet</code> represents all the matching document ids for a predicate.\n+ * The interface {@code BlockDocIdSet} represents all the matching document ids for a predicate.\n  * TODO: Redesign the filtering to skip the BlockDocIdSet and directly use BlockDocIdIterator\n  */\n public interface BlockDocIdSet {\n \n   /**\n-   * Returns a {@code BlockDocIdIterator} for the matching document ids. The document ids returned from the iterator\n-   * should be in ascending order.\n+   * Returns an iterator of the matching document ids. The document ids returned from the iterator should be in\n+   * ascending order.\n    */\n   BlockDocIdIterator iterator();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYzMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432323633", "bodyText": "What happens from an API point of view if the target is same as last returned matching docId?\nWe won't throw error and return the target as is. So, the comment should state greater than or equal to.", "author": "siddharthteotia", "createdAt": "2020-05-29T08:08:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java", "diffHunk": "@@ -25,25 +25,16 @@\n public interface BlockDocIdIterator {\n \n   /**\n-   * Get the next document id.\n-   *\n-   * @return Next document id or EOF if there is no more documents\n+   * Returns the next matched document id, or {@link Constants#EOF} if there is no more matched document.\n+   * <p>NOTE: There should be no more call to this method after it returns {@link Constants#EOF}.\n    */\n   int next();\n \n   /**\n-   * Advance to the first document whose id is equal or greater than the given target document id.\n-   * <p>If the given target document id is smaller or equal to the current document id, then return the current one.\n-   *\n-   * @param targetDocId The target document id\n-   * @return First document id that is equal or greater than target or EOF if no document matches\n+   * Returns the first matched document whose id is equal to or greater than the given target document id, or\n+   * {@link Constants#EOF} if there is no such document.\n+   * <p>NOTE: The target document id should be greater than the document id previous returned.", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMDg3Ng==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432700876", "bodyText": "No, the advance(targetDocId) here is equivalent to skipTo(targetDocId) and next() where you already iterate over the targetDocId. From an iterator's perspective, it should not return the same value twice. With this assumption, we can save one if check inside the advance(targetDocId).\nUpdated the javadoc to make it more clear.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzYzMw=="}], "type": "inlineReview", "revised_code": {"commit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java\nindex 0c8a6c6bcf..9fa29b877e 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/common/BlockDocIdIterator.java\n\n@@ -33,7 +33,8 @@ public interface BlockDocIdIterator {\n   /**\n    * Returns the first matched document whose id is equal to or greater than the given target document id, or\n    * {@link Constants#EOF} if there is no such document.\n-   * <p>NOTE: The target document id should be greater than the document id previous returned.\n+   * <p>NOTE: The target document id should be GREATER THAN the document id previous returned because the iterator\n+   *          should not return the same value twice.\n    * <p>NOTE: There should be no more call to this method after it returns {@link Constants#EOF}.\n    */\n   int advance(int targetDocId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTMxMw==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432331313", "bodyText": "These 3 (sorted, inv index, and scan) are basically for left or right leaf operators of AND. The remainingDocIdIterators is for non-leaves (child AND/OR) right?\nOn that note, for any sub-tree rooted at AND, there can be at-most one child with sorted iterator. Right?", "author": "siddharthteotia", "createdAt": "2020-05-29T08:23:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.docidsets;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.pinot.common.utils.Pairs.IntPair;\n+import org.apache.pinot.core.common.BlockDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.AndDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.BitmapBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.RangelessBitmapDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.ScanBasedDocIdIterator;\n+import org.apache.pinot.core.operator.dociditerators.SortedDocIdIterator;\n+import org.apache.pinot.core.util.SortedRangeIntersection;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+\n+\n+/**\n+ * The FilterBlockDocIdSet to perform AND on all child FilterBlockDocIdSets.\n+ * <p>The AndBlockDocIdSet will construct the BlockDocIdIterator based on the BlockDocIdIterators from the child\n+ * FilterBlockDocIdSets:\n+ * <ul>\n+ *   <li>\n+ *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n+ *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterators, merge them and construct a\n+ *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterators, directly\n+ *     return the merged RangelessBitmapDocIdIterator; otherwise, construct and return an AndDocIdIterator with the\n+ *     merged RangelessBitmapDocIdIterator and the remaining BlockDocIdIterators.\n+ *   </li>\n+ *   <li>\n+ *     Otherwise, construct and return an AndDocIdIterator with all BlockDocIdIterators.\n+ *   </li>\n+ * </ul>\n+ */\n+public final class AndDocIdSet implements FilterBlockDocIdSet {\n+  private final List<FilterBlockDocIdSet> _docIdSets;\n+\n+  public AndDocIdSet(List<FilterBlockDocIdSet> docIdSets) {\n+    _docIdSets = docIdSets;\n+  }\n+\n+  @Override\n+  public BlockDocIdIterator iterator() {\n+    int numDocIdSets = _docIdSets.size();\n+    // NOTE: Keep the order of FilterBlockDocIdSets to preserve the order decided within FilterOperatorUtils.\n+    // TODO: Consider deciding the order based on the stats of BlockDocIdIterators\n+    BlockDocIdIterator[] allDocIdIterators = new BlockDocIdIterator[numDocIdSets];\n+    List<SortedDocIdIterator> sortedDocIdIterators = new ArrayList<>();", "originalCommit": "02f8fc7c0e73853ad6637e3b18539df462cc57cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNDA5MA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r432704090", "bodyText": "For the current supported iterators, yes remainingDocIdIterators can only be AND/OR.\nThere could be multiple sorted iterators if there are multiple predicates on the same sorted column or there are multiple sorted columns.", "author": "Jackie-Jiang", "createdAt": "2020-05-29T19:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\nindex 815a407501..7fbffa8ed0 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/docidsets/AndDocIdSet.java\n\n@@ -38,9 +38,9 @@ import org.roaringbitmap.buffer.MutableRoaringBitmap;\n  * FilterBlockDocIdSets:\n  * <ul>\n  *   <li>\n- *     When there are at least one index-base BlockDocIdIterators (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n- *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterators, merge them and construct a\n- *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterators, directly\n+ *     When there are at least one index-base BlockDocIdIterator (SortedDocIdIterator or BitmapBasedDocIdIterator) and\n+ *     at least one ScanBasedDocIdIterator, or more than one index-based BlockDocIdIterator, merge them and construct a\n+ *     RangelessBitmapDocIdIterator from the merged document ids. If there is no remaining BlockDocIdIterator, directly\n  *     return the merged RangelessBitmapDocIdIterator; otherwise, construct and return an AndDocIdIterator with the\n  *     merged RangelessBitmapDocIdIterator and the remaining BlockDocIdIterators.\n  *   </li>\n"}}, {"oid": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "url": "https://github.com/apache/pinot/commit/13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-05-29T19:53:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MTAzMg==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433641032", "bodyText": "i think a better name could be candidateDocId because the while loop() is searching for the next doc Id exists in all iterators. maxDocId to many ppl mean the maximum doc id in the iterator.", "author": "chenboat", "createdAt": "2020-06-02T06:10:35Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {\n-  public final BlockDocIdIterator[] docIdIterators;\n-  public ScanBasedDocIdIterator[] scanBasedDocIdIterators;\n-  public final int[] docIdPointers;\n-  public boolean reachedEnd = false;\n-  public int currentDocId = -1;\n-  int currentMax = -1;\n-  private boolean hasScanBasedIterators;\n+  public final BlockDocIdIterator[] _docIdIterators;\n \n-  public AndDocIdIterator(BlockDocIdIterator[] blockDocIdIterators) {\n-    int numIndexBasedIterators = 0;\n-    int numScanBasedIterators = 0;\n-    for (int i = 0; i < blockDocIdIterators.length; i++) {\n-      if (blockDocIdIterators[i] instanceof IndexBasedDocIdIterator) {\n-        numIndexBasedIterators = numIndexBasedIterators + 1;\n-      } else if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-        numScanBasedIterators = numScanBasedIterators + 1;\n-      }\n-    }\n-    // if we have at least one index based then do intersection based on index based only, and then\n-    // check if matching docs apply on scan based iterator\n-    if (numIndexBasedIterators > 0 && numScanBasedIterators > 0) {\n-      hasScanBasedIterators = true;\n-      int nonScanIteratorsSize = blockDocIdIterators.length - numScanBasedIterators;\n-      this.docIdIterators = new BlockDocIdIterator[nonScanIteratorsSize];\n-      this.scanBasedDocIdIterators = new ScanBasedDocIdIterator[numScanBasedIterators];\n-      int nonScanBasedIndex = 0;\n-      int scanBasedIndex = 0;\n-      for (int i = 0; i < blockDocIdIterators.length; i++) {\n-        if (blockDocIdIterators[i] instanceof ScanBasedDocIdIterator) {\n-          this.scanBasedDocIdIterators[scanBasedIndex++] = (ScanBasedDocIdIterator) blockDocIdIterators[i];\n-        } else {\n-          this.docIdIterators[nonScanBasedIndex++] = blockDocIdIterators[i];\n-        }\n-      }\n-    } else {\n-      hasScanBasedIterators = false;\n-      this.docIdIterators = blockDocIdIterators;\n-    }\n-    this.docIdPointers = new int[docIdIterators.length];\n-    Arrays.fill(docIdPointers, -1);\n-  }\n+  private int _nextDocId = 0;\n \n-  @Override\n-  public int advance(int targetDocId) {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    if (currentDocId >= targetDocId) {\n-      return currentDocId;\n-    }\n-    // next() method will always increment currentMax by 1.\n-    currentMax = targetDocId - 1;\n-    return next();\n+  public AndDocIdIterator(BlockDocIdIterator[] docIdIterators) {\n+    _docIdIterators = docIdIterators;\n   }\n \n   @Override\n   public int next() {\n-    if (currentDocId == Constants.EOF) {\n-      return currentDocId;\n-    }\n-    currentMax = currentMax + 1;\n-    // always increment the pointer to current max, when this is called first time, every one will\n-    // be set to start of posting list.\n-    for (int i = 0; i < docIdIterators.length; i++) {\n-      docIdPointers[i] = docIdIterators[i].advance(currentMax);\n-      if (docIdPointers[i] == Constants.EOF) {\n-        reachedEnd = true;\n-        currentMax = Constants.EOF;\n-        break;\n-      }\n-      if (docIdPointers[i] > currentMax) {\n-        currentMax = docIdPointers[i];\n-        if (i > 0) {\n-          // we need to advance all pointer since we found a new max\n-          i = -1;\n-        }\n+    int maxDocId = _nextDocId;", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2NDUxNQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434064515", "bodyText": "I prefer AndDocIdIterator because it performs an AND (intersection) operation on all the iterators, and also it is the BlockDocIdIterator for AndDocIdSet. Will add some javadoc showing the relation between them.", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MTAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\nindex 7395880f2d..690bff0250 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n\n@@ -22,6 +22,11 @@ import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n+/**\n+ * The {@code AndDocIdIterator} is the iterator for AndDocIdSet to perform AND on all child BlockDocIdIterators.\n+ * <p>It keeps calling {@link BlockDocIdIterator#advance(int)} to gather the common matching document id from all child\n+ * BlockDocIdIterators until one of them hits the end.\n+ */\n public final class AndDocIdIterator implements BlockDocIdIterator {\n   public final BlockDocIdIterator[] _docIdIterators;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0Mjc3OA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433642778", "bodyText": "what happens if _nextIndex >= docIds.length? should we have a array length check?", "author": "chenboat", "createdAt": "2020-06-02T06:15:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/ArrayBasedDocIdIterator.java", "diffHunk": "@@ -36,37 +35,15 @@ public ArrayBasedDocIdIterator(int[] docIds, int searchableLength) {\n \n   @Override\n   public int next() {\n-    if (_currentDocId == Constants.EOF) {\n-      return Constants.EOF;\n-    }\n-    if (++_currentIndex == _searchableLength) {\n-      _currentDocId = Constants.EOF;\n+    if (_nextIndex < _searchableLength) {\n+      return _docIds[_nextIndex++];", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2MzU2NQ==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434063565", "bodyText": "Caller should ensure _searchableLength <= _docIds.length. If caller passes in wrong parameters, it is okay to through IndexOutOfBoundException. Similarly, we don't perform null check everywhere for simplicity and performance reason.", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0Mjc3OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NzI3OA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r433647278", "bodyText": "1.javadoc?\n2. comments about thread safety. is it safe/advisable to use this iterator in more than one thread?", "author": "chenboat", "createdAt": "2020-06-02T06:27:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java", "diffHunk": "@@ -18,112 +18,52 @@\n  */\n package org.apache.pinot.core.operator.dociditerators;\n \n-import java.util.Arrays;\n import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n-// TODO: Optimize this\n public final class AndDocIdIterator implements BlockDocIdIterator {", "originalCommit": "13ba3d7d5acf77f3612373aa3ce76b4cd1c50436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA2Njg3MA==", "url": "https://github.com/apache/pinot/pull/5444#discussion_r434066870", "bodyText": "It is not thread safety (the whole filtering layer does not involve thread safety because it is happening under one segment which is always processed by one thread). Also, I don't think multiple threads using one iterator make sense..", "author": "Jackie-Jiang", "createdAt": "2020-06-02T17:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NzI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\nindex 7395880f2d..690bff0250 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/dociditerators/AndDocIdIterator.java\n\n@@ -22,6 +22,11 @@ import org.apache.pinot.core.common.BlockDocIdIterator;\n import org.apache.pinot.core.common.Constants;\n \n \n+/**\n+ * The {@code AndDocIdIterator} is the iterator for AndDocIdSet to perform AND on all child BlockDocIdIterators.\n+ * <p>It keeps calling {@link BlockDocIdIterator#advance(int)} to gather the common matching document id from all child\n+ * BlockDocIdIterators until one of them hits the end.\n+ */\n public final class AndDocIdIterator implements BlockDocIdIterator {\n   public final BlockDocIdIterator[] _docIdIterators;\n \n"}}, {"oid": "5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "url": "https://github.com/apache/pinot/commit/5ec6a24740809eda740e3c1a7e692b71bb57cdc8", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-02T18:30:58Z", "type": "forcePushed"}, {"oid": "ed42e1cbe87bdc580cea52106506547a0d0bc997", "url": "https://github.com/apache/pinot/commit/ed42e1cbe87bdc580cea52106506547a0d0bc997", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-05T22:50:19Z", "type": "commit"}, {"oid": "ed42e1cbe87bdc580cea52106506547a0d0bc997", "url": "https://github.com/apache/pinot/commit/ed42e1cbe87bdc580cea52106506547a0d0bc997", "message": "Enhance and simplify the filtering\n\nRemoved the methods that complicate the code but provide no value:\n- BlockDocIdSet\n  - getRaw\n- FilterBlockDocIdSet\n  - getMinDocId\n  - getMaxDocId\n  - setStartDocId\n  - setEndDocId\n- BlockDocIdIterator\n  - currentDocId\n- ScanBasedDocIdIterator\n  - isMatch\n\nUniformed the behavior of all filter-related classes to bound the return docIds with numDocs\nSimplified the logic of AND/OR handling\nPushed down the AND smart handling logic to BlockDocIdIterator to ensure the best performance:\n- AndDocIdSet might return RangelessBitmapDocIdIterator which can be merged with other iterators\n- OrDocIdSet might return BitmapDocIdIterator which can be merged with other iterators\n\nTested all the queries (10K PQL, 10K SQL) within the query file using HybridClusterIntegrationTest", "committedDate": "2020-06-05T22:50:19Z", "type": "forcePushed"}]}