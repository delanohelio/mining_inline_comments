{"pr_number": 5667, "pr_title": "Support text index on dictionary encoded columns", "pr_createdAt": "2020-07-08T07:56:38Z", "pr_url": "https://github.com/apache/pinot/pull/5667", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMTUzNw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451711537", "bodyText": "Will this cause multiple text document map to the same pinot document? How do you maintain the map? We need to figure out the semantic of text index on MV columns", "author": "Jackie-Jiang", "createdAt": "2020-07-08T17:30:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java", "diffHunk": "@@ -115,14 +115,31 @@ public IndexWriter getIndexWriter() {\n \n   @Override\n   public void addDoc(Object document, int docIdCounter) {\n-    Document docToIndex = new Document();\n-    docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n-    docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n-    try {\n-      _indexWriter.addDocument(docToIndex);\n-    } catch (Exception e) {\n-      LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n-      throw new RuntimeException(e);\n+    if (!(document instanceof Object[])) {\n+      // text index on SV column\n+      Document docToIndex = new Document();\n+      docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n+      docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n+      try {\n+        _indexWriter.addDocument(docToIndex);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n+        throw new RuntimeException(e);\n+      }\n+    } else {\n+      // text index on MV column\n+      Object[] values = (Object[])document;\n+      for (Object value : values) {\n+        Document docToIndex = new Document();", "originalCommit": "9df8a5a7d7c6554ab7d845897708e66ec108e9f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4NDM5NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451884394", "bodyText": "In order to fix this issue #5666 sooner, I am only relaxing the constraint of text index on raw columns in this PR. The constraint of text index on SV columns is still there and will address in a follow-up. Need to do some digging into Lucene as well to see how arrays can be stored in a single document etc.", "author": "siddharthteotia", "createdAt": "2020-07-08T23:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMTUzNw=="}], "type": "inlineReview", "revised_code": {"commit": "8e1e9af32c5f5c32afea20000048690471737c90", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java\nindex c47f39d71c..4c19cc27fa 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneTextIndexCreator.java\n\n@@ -115,31 +115,15 @@ public class LuceneTextIndexCreator implements InvertedIndexCreator {\n \n   @Override\n   public void addDoc(Object document, int docIdCounter) {\n-    if (!(document instanceof Object[])) {\n-      // text index on SV column\n-      Document docToIndex = new Document();\n-      docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n-      docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n-      try {\n-        _indexWriter.addDocument(docToIndex);\n-      } catch (Exception e) {\n-        LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n-        throw new RuntimeException(e);\n-      }\n-    } else {\n-      // text index on MV column\n-      Object[] values = (Object[])document;\n-      for (Object value : values) {\n-        Document docToIndex = new Document();\n-        docToIndex.add(new TextField(_textColumn, value.toString(), Field.Store.NO));\n-        docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n-        try {\n-          _indexWriter.addDocument(docToIndex);\n-        } catch (Exception e) {\n-          LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n-          throw new RuntimeException(e);\n-        }\n-      }\n+    // text index on SV column\n+    Document docToIndex = new Document();\n+    docToIndex.add(new TextField(_textColumn, document.toString(), Field.Store.NO));\n+    docToIndex.add(new StoredField(LUCENE_INDEX_DOC_ID_COLUMN_NAME, docIdCounter));\n+    try {\n+      _indexWriter.addDocument(docToIndex);\n+    } catch (Exception e) {\n+      LOGGER.error(\"Failure while adding a new document to index for column {}, exception {}\", _textColumn, e.getMessage());\n+      throw new RuntimeException(e);\n     }\n   }\n \n"}}, {"oid": "8e1e9af32c5f5c32afea20000048690471737c90", "url": "https://github.com/apache/pinot/commit/8e1e9af32c5f5c32afea20000048690471737c90", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-08T23:40:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDQxMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451904412", "bodyText": "Move this into the branch of single value column", "author": "Jackie-Jiang", "createdAt": "2020-07-09T00:57:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -379,6 +370,13 @@ public void indexRow(GenericRow row) {\n           _nullValueVectorCreatorMap.get(columnName).setNull(docIdCounter);\n         }\n       }\n+\n+      // text-search enabled column", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTY2Mw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315663", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex f1da2dd9bd..bc44492933 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -370,13 +378,6 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n           _nullValueVectorCreatorMap.get(columnName).setNull(docIdCounter);\n         }\n       }\n-\n-      // text-search enabled column\n-      if (_textIndexColumns.contains(columnName)) {\n-        InvertedIndexCreator textInvertedIndexCreator = _textIndexCreatorMap.get(columnName);\n-        // add the column value to lucene index\n-        textInvertedIndexCreator.addDoc(columnValueToIndex, docIdCounter);\n-      }\n     }\n     docIdCounter++;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM0NQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451907345", "bodyText": "Also check that column is STRING type?", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:09:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -199,16 +200,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n         _forwardIndexCreatorMap.put(columnName,\n             getRawIndexCreatorForColumn(_indexDir, compressionType, columnName, fieldSpec.getDataType(), totalDocs,\n                 indexCreationInfo.getLengthOfLongestEntry(), deriveNumDocsPerChunk, writerVersion));\n+      }\n \n+      if (_textIndexColumns.contains(columnName)) {\n         // Initialize text index creator\n-        if (_textIndexColumns.contains(columnName)) {\n-          _invertedIndexCreatorMap\n-              .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n-        }\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTY4MA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315680", "bodyText": "Yeah, missed that earlier", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex f1da2dd9bd..bc44492933 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -205,7 +205,9 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n       if (_textIndexColumns.contains(columnName)) {\n         // Initialize text index creator\n         Preconditions.checkState(fieldSpec.isSingleValueField(),\n-            \"Text index is currently not supported on multi-value columns\");\n+            \"Text index is currently only supported on single-value columns\");\n+        Preconditions.checkState(fieldSpec.getDataType() == DataType.STRING,\n+            \"Text index is currently only supported on STRING type columns\");\n         _textIndexCreatorMap\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451909729", "bodyText": "I think you can just remove this method and always use the default one. We should always create dictionary-encoded index for default column because it is much more efficient.", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:18:42Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded\n    * single-value STRING columns. Eventually we will relax the constraints\n    * step by step.\n    * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * a MV column\n    * @param column column name\n    * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n   private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n       FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n     if (!fieldSpec.isSingleValueField()) {\n       throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value column: \" + column);\n     }\n-\n     if (fieldSpec.getDataType() != DataType.STRING) {\n       throw new UnsupportedOperationException(\"Text index is currently only supported on STRING column:\" + column);\n     }\n   }\n \n   void createV1ForwardIndexForTextIndex(String column, IndexLoadingConfig indexLoadingConfig)", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNjQxNg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455326416", "bodyText": "It seems to me that existing function createColumnV1Indices() has a bug which I want to investigate further and fix before I reuse that method for text index. Meanwhile, this PR is complete and I can refactor this portion next.\nConsider that case a new column gets added with inverted index. Two things happen:\n(1) First, default column handler creates dictionary and forward index. Note that it doesn't create bit encoded forward index. It creates sorted forward index.\n(2) Later during segment load, InvertedIndexHandler reads the forward index to create inverted index. This code when trying to create inverted index first gets a forward index reader. It gets the forward index buffer and creates the bit encoded forward index reader. This seems wrong to me since for newly added column, the forward index buffer had sorted index format and wasn't bit encoded.\nI will look into this in detail and as part of that cleanup the existing code first before reusing it for text.", "author": "siddharthteotia", "createdAt": "2020-07-15T20:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNTczNQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455335735", "bodyText": "Never mind. This particular code handles the problem I was talking about\n// Only create inverted index on dictionary-encoded unsorted columns for (String column : indexLoadingConfig.getInvertedIndexColumns()) { ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column); if (columnMetadata != null && !columnMetadata.isSorted() && columnMetadata.hasDictionary()) { _invertedIndexColumns.add(columnMetadata); } }", "author": "siddharthteotia", "createdAt": "2020-07-15T20:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM2MDk0MA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455360940", "bodyText": "So why do we still need to keep this method? We should decouple the default column logic from the text index logic. For default column, always use dictionary-encoded + sorted index.", "author": "Jackie-Jiang", "createdAt": "2020-07-15T21:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4MzY3NQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455983675", "bodyText": "Cleaned up the code to reuse existing", "author": "siddharthteotia", "createdAt": "2020-07-16T18:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwOTcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\nindex 3de5915215..0ef4f53617 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n\n@@ -324,10 +322,8 @@ public abstract class BaseDefaultColumnHandler implements DefaultColumnHandler {\n \n   /**\n    * Right now the text index is supported on RAW and dictionary encoded\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a MV column\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param column column name\n    * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMDIzNg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r451910236", "bodyText": "Since text column supports both raw & dictionary-encoded index, remove the branch for text column", "author": "Jackie-Jiang", "createdAt": "2020-07-09T01:20:28Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java", "diffHunk": "@@ -67,10 +67,19 @@ protected void updateDefaultColumn(String column, DefaultColumnAction action, In\n     Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4MzU2Nw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455983567", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-16T18:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkxMDIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "cdd757223f33faac42815feaaa3bed4814ab118b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java\nindex b8f2f56801..62853bda70 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/V3DefaultColumnHandler.java\n\n@@ -63,36 +63,17 @@ public class V3DefaultColumnHandler extends BaseDefaultColumnHandler {\n     FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n     Preconditions.checkNotNull(fieldSpec);\n     boolean isSingleValue = fieldSpec.isSingleValueField();\n-\n-    Set<String> textIndexColumns = indexLoadingConfig.getTextIndexColumns();\n-    if (textIndexColumns.contains(column)) {\n-      // create forward index for this text index enabled column\n-      // if the column is dictionary encoded, it will also create dictionary\n-      createV1ForwardIndexForTextIndex(column, indexLoadingConfig);\n-      if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-        // Write forward index and dictionary to V3 format\n-        File forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.UNSORTED_SV_FORWARD_INDEX_FILE_EXTENSION);\n-        LoaderUtils.writeIndexToV3Format(_segmentWriter, column, forwardIndexFile, ColumnIndexType.FORWARD_INDEX);\n-        File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);\n-        LoaderUtils.writeIndexToV3Format(_segmentWriter, column, dictionaryFile, ColumnIndexType.DICTIONARY);\n-      } else {\n-        // Write raw forward index to V3 format\n-        File forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.RAW_SV_FORWARD_INDEX_FILE_EXTENSION);\n-        LoaderUtils.writeIndexToV3Format(_segmentWriter, column, forwardIndexFile, ColumnIndexType.FORWARD_INDEX);\n-      }\n+    // Create new dictionary and forward index, and update column metadata\n+    createColumnV1Indices(column, indexLoadingConfig);\n+    // Write index to V3 format.\n+    File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);\n+    File forwardIndexFile;\n+    if (isSingleValue) {\n+      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.SORTED_SV_FORWARD_INDEX_FILE_EXTENSION);\n     } else {\n-      // Create new dictionary and forward index, and update column metadata\n-      createColumnV1Indices(column);\n-      // Write index to V3 format.\n-      File dictionaryFile = new File(_indexDir, column + V1Constants.Dict.FILE_EXTENSION);\n-      File forwardIndexFile;\n-      if (isSingleValue) {\n-        forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.SORTED_SV_FORWARD_INDEX_FILE_EXTENSION);\n-      } else {\n-        forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.UNSORTED_MV_FORWARD_INDEX_FILE_EXTENSION);\n-      }\n-      LoaderUtils.writeIndexToV3Format(_segmentWriter, column, dictionaryFile, ColumnIndexType.DICTIONARY);\n-      LoaderUtils.writeIndexToV3Format(_segmentWriter, column, forwardIndexFile, ColumnIndexType.FORWARD_INDEX);\n+      forwardIndexFile = new File(_indexDir, column + V1Constants.Indexes.UNSORTED_MV_FORWARD_INDEX_FILE_EXTENSION);\n     }\n+    LoaderUtils.writeIndexToV3Format(_segmentWriter, column, dictionaryFile, ColumnIndexType.DICTIONARY);\n+    LoaderUtils.writeIndexToV3Format(_segmentWriter, column, forwardIndexFile, ColumnIndexType.FORWARD_INDEX);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTM4NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453821384", "bodyText": "Are there any more constraints to relax? If not, we can modify this comment?", "author": "mcvsubbu", "createdAt": "2020-07-13T17:44:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -325,77 +323,92 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTcwMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315702", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTM4NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\nindex 3de5915215..0ef4f53617 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n\n@@ -324,10 +322,8 @@ public abstract class BaseDefaultColumnHandler implements DefaultColumnHandler {\n \n   /**\n    * Right now the text index is supported on RAW and dictionary encoded\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a MV column\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param column column name\n    * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMzAyNw==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453823027", "bodyText": "same here. capture the constraints correctly in comments", "author": "mcvsubbu", "createdAt": "2020-07-13T17:47:13Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -111,35 +117,22 @@ public void createTextIndexesOnSegmentLoad()\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n+   * Right now the text index is supported on RAW and dictionary encoded", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTcyMg==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315722", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-07-15T20:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMzAyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\nindex e836ef7e43..792644b3bf 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n\n@@ -118,10 +118,8 @@ public class TextIndexHandler {\n \n   /**\n    * Right now the text index is supported on RAW and dictionary encoded\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a MV column\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param columnMetadata metadata for column\n    */\n   private void checkUnsupportedOperationsForTextIndex(ColumnMetadata columnMetadata) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNDk1OQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r453824959", "bodyText": "Should it be ColumnIndexType.DICTIONARY?", "author": "mcvsubbu", "createdAt": "2020-07-13T17:50:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +144,68 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {\n+            for (int docId = 0; docId < numDocs; docId++) {\n+              int dictId = forwardIndexReader.getDictId(docId, readerContext);\n+              String value = dictionary.getStringValue(dictId);\n+              textIndexCreator.addDoc(value, docId);\n+            }\n+          }\n+        }\n       }\n       textIndexCreator.seal();\n     }\n+\n     LOGGER.info(\"Created text index for column: {} in segment: {}\", column, _segmentName);\n     PropertiesConfiguration properties = SegmentMetadataImpl.getPropertiesConfiguration(_indexDir);\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), TextIndexType.LUCENE.name());\n     properties.save();\n   }\n \n-  private VarByteChunkSVForwardIndexReader getForwardIndexReader(ColumnMetadata columnMetadata)\n+  private ForwardIndexReader<?> getForwardIndexReader(ColumnMetadata columnMetadata)\n+      throws IOException {\n+    if (!columnMetadata.hasDictionary()) {\n+      // raw index\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);\n+      return new VarByteChunkSVForwardIndexReader(buffer, DataType.STRING);\n+    } else {\n+      PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);", "originalCommit": "8e1e9af32c5f5c32afea20000048690471737c90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTc0NA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r455315744", "bodyText": "No", "author": "siddharthteotia", "createdAt": "2020-07-15T20:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNDk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "cdd757223f33faac42815feaaa3bed4814ab118b", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\nindex e836ef7e43..eafedffc03 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n\n@@ -188,16 +187,24 @@ public class TextIndexHandler {\n   private ForwardIndexReader<?> getForwardIndexReader(ColumnMetadata columnMetadata)\n       throws IOException {\n     if (!columnMetadata.hasDictionary()) {\n-      // raw index\n+      // text index on raw column\n       PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);\n       return new VarByteChunkSVForwardIndexReader(buffer, DataType.STRING);\n     } else {\n+      // text index on dictionary encoded column\n+      // two cases:\n+      // 1. column is sorted\n+      // 2. column is unsorted\n       PinotDataBuffer buffer = _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.FORWARD_INDEX);\n       int numRows = columnMetadata.getTotalDocs();\n       int numBitsPerValue = columnMetadata.getBitsPerElement();\n-      // dictionary encoded index for SV column since currently text index\n-      // is not supported on MV columns\n-      return new FixedBitSVForwardIndexReader(buffer, numRows, numBitsPerValue);\n+      if (columnMetadata.isSorted()) {\n+        // created sorted dictionary based forward index reader\n+        return new SortedIndexReaderImpl(buffer, columnMetadata.getCardinality());\n+      } else {\n+        // create bit-encoded dictionary based forward index reader\n+        return new FixedBitSVForwardIndexReader(buffer, numRows, numBitsPerValue);\n+      }\n     }\n   }\n \n"}}, {"oid": "ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "url": "https://github.com/apache/pinot/commit/ea2c70f84f4c0aafe95cae560a73cdfbb1c52922", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-15T20:15:02Z", "type": "forcePushed"}, {"oid": "216b6cf99d0119e1514c396389d62a3deb8f348b", "url": "https://github.com/apache/pinot/commit/216b6cf99d0119e1514c396389d62a3deb8f348b", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-15T20:57:36Z", "type": "forcePushed"}, {"oid": "cdd757223f33faac42815feaaa3bed4814ab118b", "url": "https://github.com/apache/pinot/commit/cdd757223f33faac42815feaaa3bed4814ab118b", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-16T17:20:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMTU0MQ==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456001541", "bodyText": "Let's remove this check as it will be checked in TextIndexHandler. Try not to couple different modules together.", "author": "Jackie-Jiang", "createdAt": "2020-07-16T18:52:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -321,88 +321,33 @@ protected void removeColumnV1Indices(String column)\n   }\n \n   /**\n-   * Right now the text index is supported on RAW (non-dictionary encoded)\n-   * single-value STRING columns. Eventually we will relax the constraints\n-   * step by step.\n-   * For example, later on user should be able to create text index on\n-   * a dictionary encoded STRING column that also has native Pinot's inverted\n-   * index. We can also support it on BYTE columns later.\n+   * Right now the text index is supported on RAW and dictionary encoded\n+   * single-value STRING columns. Later we can add support for text index\n+   * on multi-value columns and BYTE type columns\n    * @param column column name\n-   * @param indexLoadingConfig index loading config\n    * @param fieldSpec field spec\n    */\n-  private void checkUnsupportedOperationsForTextIndex(String column, IndexLoadingConfig indexLoadingConfig,\n-      FieldSpec fieldSpec) {\n-    if (!indexLoadingConfig.getNoDictionaryColumns().contains(column)) {\n-      throw new UnsupportedOperationException(\n-          \"Text index is currently not supported on dictionary encoded column: \" + column);\n-    }\n-\n-    Set<String> sortedColumns = new HashSet<>(indexLoadingConfig.getSortedColumns());\n-    if (sortedColumns.contains(column)) {\n-      // since Pinot's current implementation doesn't support raw sorted columns,\n-      // we need to check for this too\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on sorted column: \" + column);\n-    }\n-\n+  private void checkUnsupportedOperationsForTextIndex(String column, FieldSpec fieldSpec) {", "originalCommit": "cdd757223f33faac42815feaaa3bed4814ab118b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7afda3f00cfaabcf966098ec3847993ee8063344", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\nindex 8fb92b9a64..0cf5c4e301 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java\n\n@@ -320,34 +320,15 @@ public abstract class BaseDefaultColumnHandler implements DefaultColumnHandler {\n     SegmentColumnarIndexCreator.removeColumnMetadataInfo(_segmentProperties, column);\n   }\n \n-  /**\n-   * Right now the text index is supported on RAW and dictionary encoded\n-   * single-value STRING columns. Later we can add support for text index\n-   * on multi-value columns and BYTE type columns\n-   * @param column column name\n-   * @param fieldSpec field spec\n-   */\n-  private void checkUnsupportedOperationsForTextIndex(String column, FieldSpec fieldSpec) {\n-    if (!fieldSpec.isSingleValueField()) {\n-      throw new UnsupportedOperationException(\"Text index is currently not supported on multi-value column: \" + column);\n-    }\n-    if (fieldSpec.getDataType() != DataType.STRING) {\n-      throw new UnsupportedOperationException(\"Text index is currently only supported on STRING column:\" + column);\n-    }\n-  }\n-\n   /**\n    * Helper method to create the V1 indices (dictionary and forward index) for a column.\n    *\n    * @param column column name.\n    */\n-  protected void createColumnV1Indices(String column, IndexLoadingConfig indexLoadingConfig)\n+  protected void createColumnV1Indices(String column)\n       throws Exception {\n     final FieldSpec fieldSpec = _schema.getFieldSpecFor(column);\n     Preconditions.checkNotNull(fieldSpec);\n-    if (indexLoadingConfig.getTextIndexColumns().contains(column)) {\n-      checkUnsupportedOperationsForTextIndex(column, fieldSpec);\n-    }\n \n     // Generate column index creation information.\n     final int totalDocs = _segmentMetadata.getTotalDocs();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMjkwMA==", "url": "https://github.com/apache/pinot/pull/5667#discussion_r456002900", "bodyText": "Remove this check (or replace with checkState)", "author": "Jackie-Jiang", "createdAt": "2020-07-16T18:54:34Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java", "diffHunk": "@@ -151,30 +143,76 @@ private void createTextIndexForColumn(ColumnMetadata columnMetadata)\n       return;\n     }\n     int numDocs = columnMetadata.getTotalDocs();\n-    LOGGER.info(\"Creating new text index for column: {} in segment: {}\", column, _segmentName);\n+    boolean hasDictionary = columnMetadata.hasDictionary();\n+    LOGGER.info(\"Creating new text index for column: {} in segment: {}, hasDictionary: {}\", column, _segmentName, hasDictionary);\n     File segmentDirectory = SegmentDirectoryPaths.segmentDirectoryFor(_indexDir, _segmentVersion);\n     // The handlers are always invoked by the preprocessor. Before this ImmutableSegmentLoader would have already\n     // up-converted the segment from v1/v2 -> v3 (if needed). So based on the segmentVersion, whatever segment\n     // segmentDirectory is indicated to us by SegmentDirectoryPaths, we create lucene index there. There is no\n     // further need to move around the lucene index directory since it is created with correct directory structure\n     // based on segmentVersion.\n-    try (LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true);\n-        VarByteChunkSVForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n-        ChunkReaderContext readerContext = forwardIndexReader.createContext()) {\n-      for (int docId = 0; docId < numDocs; docId++) {\n-        textIndexCreator.addDoc(forwardIndexReader.getString(docId, readerContext), docId);\n+    try (ForwardIndexReader forwardIndexReader = getForwardIndexReader(columnMetadata);\n+        ForwardIndexReaderContext readerContext = forwardIndexReader.createContext();\n+        LuceneTextIndexCreator textIndexCreator = new LuceneTextIndexCreator(column, segmentDirectory, true)) {\n+      if (!hasDictionary) {\n+        // text index on raw column, just read the raw forward index\n+        VarByteChunkSVForwardIndexReader rawIndexReader = (VarByteChunkSVForwardIndexReader)forwardIndexReader;\n+        ChunkReaderContext chunkReaderContext = (ChunkReaderContext)readerContext;\n+        for (int docId = 0; docId < numDocs; docId++) {\n+          textIndexCreator.addDoc(rawIndexReader.getString(docId, chunkReaderContext), docId);\n+        }\n+      } else {\n+        // text index on dictionary encoded SV column\n+        // read forward index to get dictId\n+        // read the raw value from dictionary using dictId\n+        try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n+          if (columnMetadata.isSingleValue()) {", "originalCommit": "cdd757223f33faac42815feaaa3bed4814ab118b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7afda3f00cfaabcf966098ec3847993ee8063344", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\nindex eafedffc03..d42f06a671 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/TextIndexHandler.java\n\n@@ -166,12 +166,10 @@ public class TextIndexHandler {\n         // read forward index to get dictId\n         // read the raw value from dictionary using dictId\n         try (BaseImmutableDictionary dictionary = getDictionaryReader(columnMetadata)) {\n-          if (columnMetadata.isSingleValue()) {\n-            for (int docId = 0; docId < numDocs; docId++) {\n-              int dictId = forwardIndexReader.getDictId(docId, readerContext);\n-              String value = dictionary.getStringValue(dictId);\n-              textIndexCreator.addDoc(value, docId);\n-            }\n+          for (int docId = 0; docId < numDocs; docId++) {\n+            int dictId = forwardIndexReader.getDictId(docId, readerContext);\n+            String value = dictionary.getStringValue(dictId);\n+            textIndexCreator.addDoc(value, docId);\n           }\n         }\n       }\n"}}, {"oid": "7afda3f00cfaabcf966098ec3847993ee8063344", "url": "https://github.com/apache/pinot/commit/7afda3f00cfaabcf966098ec3847993ee8063344", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T01:33:22Z", "type": "forcePushed"}, {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T03:32:29Z", "type": "commit"}, {"oid": "7fb7f358d5fb0a4b6510a900fadd95a08def674c", "url": "https://github.com/apache/pinot/commit/7fb7f358d5fb0a4b6510a900fadd95a08def674c", "message": "Support text index on dictionary encoded columns.\nWith these changes, we can essentially have both text and native\nPinot inverted index on the same column.", "committedDate": "2020-07-17T03:32:29Z", "type": "forcePushed"}]}