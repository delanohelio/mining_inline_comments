{"pr_number": 5926, "pr_title": "Introduce IdSet and add IdSetAggregationFunction", "pr_createdAt": "2020-08-26T04:53:47Z", "pr_url": "https://github.com/apache/pinot/pull/5926", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzNjUwNQ==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r477036505", "bodyText": "Do you think this constructor is the only thing we need? If not, We should make this private and add static builders", "author": "kishoreg", "createdAt": "2020-08-26T05:06:52Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.utils;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Base64;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+\n+/**\n+ * The {@code IdSet} represents a collection of ids. It can be used to optimize the query with huge IN clause.\n+ */\n+public class IdSet implements Comparable<IdSet> {\n+  public static final IdSet EMPTY_ID_SET = new IdSet(Type.EMPTY, null, null);\n+\n+  // Throw exception when the serialized IdSet is exceeding this threshold (32MB)\n+  private static final int MAX_SIZE_IN_BYTES = 32 * 1024 * 1024;\n+\n+  private enum Type {\n+    // DO NOT change the index of the types as the ser/de relies on them\n+    EMPTY(0), ROARING_BITMAP(1), ROARING_64_NAVIGABLE_MAP(2);\n+\n+    private final int _index;\n+\n+    Type(int index) {\n+      _index = index;\n+    }\n+  }\n+\n+  private final Type _type;\n+  private final RoaringBitmap _bitmap;\n+  private final Roaring64NavigableMap _longBitmap;\n+", "originalCommit": "de6eee3535d9aac026f3cd3f64465c68bac740a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "456de3419a4d24e73887c47c7a918a42fce3ade5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java\ndeleted file mode 100644\nindex 3b0db48b8b..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java\n+++ /dev/null\n\n@@ -1,326 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.query.utils;\n-\n-import com.google.common.base.Preconditions;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Base64;\n-import java.util.Objects;\n-import javax.annotation.Nullable;\n-import org.apache.pinot.spi.data.FieldSpec.DataType;\n-import org.roaringbitmap.RoaringBitmap;\n-import org.roaringbitmap.longlong.Roaring64NavigableMap;\n-\n-\n-/**\n- * The {@code IdSet} represents a collection of ids. It can be used to optimize the query with huge IN clause.\n- */\n-public class IdSet implements Comparable<IdSet> {\n-  public static final IdSet EMPTY_ID_SET = new IdSet(Type.EMPTY, null, null);\n-\n-  // Throw exception when the serialized IdSet is exceeding this threshold (32MB)\n-  private static final int MAX_SIZE_IN_BYTES = 32 * 1024 * 1024;\n-\n-  private enum Type {\n-    // DO NOT change the index of the types as the ser/de relies on them\n-    EMPTY(0), ROARING_BITMAP(1), ROARING_64_NAVIGABLE_MAP(2);\n-\n-    private final int _index;\n-\n-    Type(int index) {\n-      _index = index;\n-    }\n-  }\n-\n-  private final Type _type;\n-  private final RoaringBitmap _bitmap;\n-  private final Roaring64NavigableMap _longBitmap;\n-\n-  public IdSet(DataType dataType) {\n-    switch (dataType) {\n-      case INT:\n-        _type = Type.ROARING_BITMAP;\n-        _bitmap = new RoaringBitmap();\n-        _longBitmap = null;\n-        break;\n-      case LONG:\n-        _type = Type.ROARING_64_NAVIGABLE_MAP;\n-        _bitmap = null;\n-        _longBitmap = new Roaring64NavigableMap();\n-        break;\n-      default:\n-        throw new IllegalStateException(\"Unsupported data type: \" + dataType);\n-    }\n-  }\n-\n-  private IdSet(Type type, @Nullable RoaringBitmap bitmap, @Nullable Roaring64NavigableMap longBitmap) {\n-    _type = type;\n-    _bitmap = bitmap;\n-    _longBitmap = longBitmap;\n-  }\n-\n-  /**\n-   * Adds an INT id into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(int id) {\n-    assert _bitmap != null;\n-    _bitmap.add(id);\n-  }\n-\n-  /**\n-   * Adds an array of INT ids into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(int[] ids, int length) {\n-    assert _bitmap != null;\n-    _bitmap.addN(ids, 0, length);\n-  }\n-\n-  /**\n-   * Adds a LONG id into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(long id) {\n-    assert _longBitmap != null;\n-    _longBitmap.addLong(id);\n-  }\n-\n-  /**\n-   * Adds an array of LONG ids into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(long[] ids, int length) {\n-    assert _longBitmap != null;\n-    for (int i = 0; i < length; i++) {\n-      _longBitmap.addLong(ids[i]);\n-    }\n-  }\n-\n-  /**\n-   * Merges 2 IdSets. If both IdSets are not empty, they must be of the same type.\n-   */\n-  public static IdSet merge(IdSet idSet1, IdSet idSet2) {\n-    if (idSet2._type == Type.EMPTY) {\n-      return idSet1;\n-    }\n-    switch (idSet1._type) {\n-      case EMPTY:\n-        return idSet2;\n-      case ROARING_BITMAP:\n-        idSet1._bitmap.or(idSet2._bitmap);\n-        return idSet1;\n-      case ROARING_64_NAVIGABLE_MAP:\n-        idSet2._longBitmap.or(idSet2._longBitmap);\n-        return idSet1;\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Returns {@code true} if the IdSet contains the given id, {@code false} otherwise. Should only be called for INT\n-   * type ids.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   * Check cardinality before calling this method to prevent calling this method on the EMPTY IdSet.\n-   */\n-  public boolean contains(int id) {\n-    assert _bitmap != null;\n-    return _bitmap.contains(id);\n-  }\n-\n-  /**\n-   * Returns {@code true} if the IdSet contains the given id, {@code false} otherwise. Should only be called for LONG\n-   * type ids.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   * Check cardinality before calling this method to prevent calling this method on the EMPTY IdSet.\n-   */\n-  public boolean contains(long id) {\n-    assert _longBitmap != null;\n-    return _longBitmap.contains(id);\n-  }\n-\n-  /**\n-   * Returns the cardinality of the IdSet.\n-   */\n-  public long getCardinality() {\n-    switch (_type) {\n-      case EMPTY:\n-        return 0;\n-      case ROARING_BITMAP:\n-        assert _bitmap != null;\n-        return _bitmap.getLongCardinality();\n-      case ROARING_64_NAVIGABLE_MAP:\n-        assert _longBitmap != null;\n-        return _longBitmap.getLongCardinality();\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Returns all the ids within the IdSet. Should only be called for INT type ids.\n-   */\n-  public int[] getIntIds() {\n-    if (_type == Type.ROARING_BITMAP) {\n-      assert _bitmap != null;\n-      return _bitmap.toArray();\n-    } else {\n-      return new int[0];\n-    }\n-  }\n-\n-  /**\n-   * Returns all the ids within the IdSet. Should only be called for LONG type ids.\n-   */\n-  public long[] getLongIds() {\n-    if (_type == Type.ROARING_64_NAVIGABLE_MAP) {\n-      assert _longBitmap != null;\n-      return _longBitmap.toArray();\n-    } else {\n-      return new long[0];\n-    }\n-  }\n-\n-  /**\n-   * Serializes the IdSet into a byte array.\n-   */\n-  public byte[] toBytes()\n-      throws IOException {\n-    switch (_type) {\n-      case EMPTY:\n-        return new byte[Integer.BYTES];\n-      case ROARING_BITMAP: {\n-        assert _bitmap != null;\n-        int numBytes = Integer.BYTES + _bitmap.serializedSizeInBytes();\n-        Preconditions.checkState(numBytes <= MAX_SIZE_IN_BYTES, \"IdSet size: %s has exceeded the limit: %s \", numBytes,\n-            MAX_SIZE_IN_BYTES);\n-        byte[] bytes = new byte[numBytes];\n-        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-        byteBuffer.putInt(Type.ROARING_BITMAP._index);\n-        _bitmap.serialize(byteBuffer);\n-        return bytes;\n-      }\n-      case ROARING_64_NAVIGABLE_MAP: {\n-        assert _longBitmap != null;\n-        long numBytes = Integer.BYTES + _longBitmap.serializedSizeInBytes();\n-        Preconditions.checkState(numBytes <= MAX_SIZE_IN_BYTES, \"IdSet size: %s has exceeded the limit: %s \", numBytes,\n-            MAX_SIZE_IN_BYTES);\n-        // NOTE: No need to close these streams.\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream((int) numBytes);\n-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-        dataOutputStream.writeInt(Type.ROARING_64_NAVIGABLE_MAP._index);\n-        _longBitmap.serialize(dataOutputStream);\n-        return byteArrayOutputStream.toByteArray();\n-      }\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a byte array.\n-   */\n-  public static IdSet fromBytes(byte[] bytes)\n-      throws IOException {\n-    return fromByteBuffer(ByteBuffer.wrap(bytes));\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a ByteBuffer.\n-   */\n-  public static IdSet fromByteBuffer(ByteBuffer byteBuffer)\n-      throws IOException {\n-    int index = byteBuffer.getInt();\n-    switch (index) {\n-      case 0:\n-        return EMPTY_ID_SET;\n-      case 1:\n-        RoaringBitmap bitmap = new RoaringBitmap();\n-        bitmap.deserialize(byteBuffer);\n-        return new IdSet(Type.ROARING_BITMAP, bitmap, null);\n-      case 2:\n-        Preconditions.checkArgument(byteBuffer.hasArray(),\n-            \"Cannot deserialize Roaring64NavigableMap from ByteBuffer not backed by an accessible byte array\");\n-        Roaring64NavigableMap longBitmap = new Roaring64NavigableMap();\n-        // NOTE: No need to close these streams.\n-        longBitmap.deserialize(new DataInputStream(\n-            new ByteArrayInputStream(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(),\n-                byteBuffer.remaining())));\n-        return new IdSet(Type.ROARING_64_NAVIGABLE_MAP, null, longBitmap);\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Serializes the IdSet into a Base64 string.\n-   * <p>Use Base64 instead of Hex encoding for better compression.\n-   */\n-  public String toBase64String()\n-      throws IOException {\n-    return Base64.getEncoder().encodeToString(toBytes());\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a Base64 string.\n-   * <p>Use Base64 instead of Hex encoding for better compression.\n-   */\n-  public static IdSet fromBase64String(String base64String)\n-      throws IOException {\n-    return fromBytes(Base64.getDecoder().decode(base64String));\n-  }\n-\n-  @Override\n-  public int compareTo(IdSet idSet) {\n-    return Long.compare(getCardinality(), idSet.getCardinality());\n-  }\n-\n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof IdSet)) {\n-      return false;\n-    }\n-    IdSet idSet = (IdSet) o;\n-    return _type == idSet._type && Objects.equals(_bitmap, idSet._bitmap) && Objects\n-        .equals(_longBitmap, idSet._longBitmap);\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return Objects.hash(_type, _bitmap, _longBitmap);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    try {\n-      return toBase64String();\n-    } catch (IOException e) {\n-      throw new RuntimeException(\"Caught exception while serializing IdSet\", e);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAzNzg0OQ==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r477037849", "bodyText": "Let\u2019s make this an interface with multiple implementations?", "author": "kishoreg", "createdAt": "2020-08-26T05:11:58Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.utils;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Base64;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+\n+/**\n+ * The {@code IdSet} represents a collection of ids. It can be used to optimize the query with huge IN clause.\n+ */\n+public class IdSet implements Comparable<IdSet> {", "originalCommit": "de6eee3535d9aac026f3cd3f64465c68bac740a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "456de3419a4d24e73887c47c7a918a42fce3ade5", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java b/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java\ndeleted file mode 100644\nindex 3b0db48b8b..0000000000\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/utils/IdSet.java\n+++ /dev/null\n\n@@ -1,326 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.pinot.core.query.utils;\n-\n-import com.google.common.base.Preconditions;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.util.Base64;\n-import java.util.Objects;\n-import javax.annotation.Nullable;\n-import org.apache.pinot.spi.data.FieldSpec.DataType;\n-import org.roaringbitmap.RoaringBitmap;\n-import org.roaringbitmap.longlong.Roaring64NavigableMap;\n-\n-\n-/**\n- * The {@code IdSet} represents a collection of ids. It can be used to optimize the query with huge IN clause.\n- */\n-public class IdSet implements Comparable<IdSet> {\n-  public static final IdSet EMPTY_ID_SET = new IdSet(Type.EMPTY, null, null);\n-\n-  // Throw exception when the serialized IdSet is exceeding this threshold (32MB)\n-  private static final int MAX_SIZE_IN_BYTES = 32 * 1024 * 1024;\n-\n-  private enum Type {\n-    // DO NOT change the index of the types as the ser/de relies on them\n-    EMPTY(0), ROARING_BITMAP(1), ROARING_64_NAVIGABLE_MAP(2);\n-\n-    private final int _index;\n-\n-    Type(int index) {\n-      _index = index;\n-    }\n-  }\n-\n-  private final Type _type;\n-  private final RoaringBitmap _bitmap;\n-  private final Roaring64NavigableMap _longBitmap;\n-\n-  public IdSet(DataType dataType) {\n-    switch (dataType) {\n-      case INT:\n-        _type = Type.ROARING_BITMAP;\n-        _bitmap = new RoaringBitmap();\n-        _longBitmap = null;\n-        break;\n-      case LONG:\n-        _type = Type.ROARING_64_NAVIGABLE_MAP;\n-        _bitmap = null;\n-        _longBitmap = new Roaring64NavigableMap();\n-        break;\n-      default:\n-        throw new IllegalStateException(\"Unsupported data type: \" + dataType);\n-    }\n-  }\n-\n-  private IdSet(Type type, @Nullable RoaringBitmap bitmap, @Nullable Roaring64NavigableMap longBitmap) {\n-    _type = type;\n-    _bitmap = bitmap;\n-    _longBitmap = longBitmap;\n-  }\n-\n-  /**\n-   * Adds an INT id into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(int id) {\n-    assert _bitmap != null;\n-    _bitmap.add(id);\n-  }\n-\n-  /**\n-   * Adds an array of INT ids into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(int[] ids, int length) {\n-    assert _bitmap != null;\n-    _bitmap.addN(ids, 0, length);\n-  }\n-\n-  /**\n-   * Adds a LONG id into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(long id) {\n-    assert _longBitmap != null;\n-    _longBitmap.addLong(id);\n-  }\n-\n-  /**\n-   * Adds an array of LONG ids into the IdSet.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   */\n-  public void add(long[] ids, int length) {\n-    assert _longBitmap != null;\n-    for (int i = 0; i < length; i++) {\n-      _longBitmap.addLong(ids[i]);\n-    }\n-  }\n-\n-  /**\n-   * Merges 2 IdSets. If both IdSets are not empty, they must be of the same type.\n-   */\n-  public static IdSet merge(IdSet idSet1, IdSet idSet2) {\n-    if (idSet2._type == Type.EMPTY) {\n-      return idSet1;\n-    }\n-    switch (idSet1._type) {\n-      case EMPTY:\n-        return idSet2;\n-      case ROARING_BITMAP:\n-        idSet1._bitmap.or(idSet2._bitmap);\n-        return idSet1;\n-      case ROARING_64_NAVIGABLE_MAP:\n-        idSet2._longBitmap.or(idSet2._longBitmap);\n-        return idSet1;\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Returns {@code true} if the IdSet contains the given id, {@code false} otherwise. Should only be called for INT\n-   * type ids.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   * Check cardinality before calling this method to prevent calling this method on the EMPTY IdSet.\n-   */\n-  public boolean contains(int id) {\n-    assert _bitmap != null;\n-    return _bitmap.contains(id);\n-  }\n-\n-  /**\n-   * Returns {@code true} if the IdSet contains the given id, {@code false} otherwise. Should only be called for LONG\n-   * type ids.\n-   * <p>For performance concern, this method does not check the IdSet type and assume the IdSet is of the correct type.\n-   * Check cardinality before calling this method to prevent calling this method on the EMPTY IdSet.\n-   */\n-  public boolean contains(long id) {\n-    assert _longBitmap != null;\n-    return _longBitmap.contains(id);\n-  }\n-\n-  /**\n-   * Returns the cardinality of the IdSet.\n-   */\n-  public long getCardinality() {\n-    switch (_type) {\n-      case EMPTY:\n-        return 0;\n-      case ROARING_BITMAP:\n-        assert _bitmap != null;\n-        return _bitmap.getLongCardinality();\n-      case ROARING_64_NAVIGABLE_MAP:\n-        assert _longBitmap != null;\n-        return _longBitmap.getLongCardinality();\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Returns all the ids within the IdSet. Should only be called for INT type ids.\n-   */\n-  public int[] getIntIds() {\n-    if (_type == Type.ROARING_BITMAP) {\n-      assert _bitmap != null;\n-      return _bitmap.toArray();\n-    } else {\n-      return new int[0];\n-    }\n-  }\n-\n-  /**\n-   * Returns all the ids within the IdSet. Should only be called for LONG type ids.\n-   */\n-  public long[] getLongIds() {\n-    if (_type == Type.ROARING_64_NAVIGABLE_MAP) {\n-      assert _longBitmap != null;\n-      return _longBitmap.toArray();\n-    } else {\n-      return new long[0];\n-    }\n-  }\n-\n-  /**\n-   * Serializes the IdSet into a byte array.\n-   */\n-  public byte[] toBytes()\n-      throws IOException {\n-    switch (_type) {\n-      case EMPTY:\n-        return new byte[Integer.BYTES];\n-      case ROARING_BITMAP: {\n-        assert _bitmap != null;\n-        int numBytes = Integer.BYTES + _bitmap.serializedSizeInBytes();\n-        Preconditions.checkState(numBytes <= MAX_SIZE_IN_BYTES, \"IdSet size: %s has exceeded the limit: %s \", numBytes,\n-            MAX_SIZE_IN_BYTES);\n-        byte[] bytes = new byte[numBytes];\n-        ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n-        byteBuffer.putInt(Type.ROARING_BITMAP._index);\n-        _bitmap.serialize(byteBuffer);\n-        return bytes;\n-      }\n-      case ROARING_64_NAVIGABLE_MAP: {\n-        assert _longBitmap != null;\n-        long numBytes = Integer.BYTES + _longBitmap.serializedSizeInBytes();\n-        Preconditions.checkState(numBytes <= MAX_SIZE_IN_BYTES, \"IdSet size: %s has exceeded the limit: %s \", numBytes,\n-            MAX_SIZE_IN_BYTES);\n-        // NOTE: No need to close these streams.\n-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream((int) numBytes);\n-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-        dataOutputStream.writeInt(Type.ROARING_64_NAVIGABLE_MAP._index);\n-        _longBitmap.serialize(dataOutputStream);\n-        return byteArrayOutputStream.toByteArray();\n-      }\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a byte array.\n-   */\n-  public static IdSet fromBytes(byte[] bytes)\n-      throws IOException {\n-    return fromByteBuffer(ByteBuffer.wrap(bytes));\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a ByteBuffer.\n-   */\n-  public static IdSet fromByteBuffer(ByteBuffer byteBuffer)\n-      throws IOException {\n-    int index = byteBuffer.getInt();\n-    switch (index) {\n-      case 0:\n-        return EMPTY_ID_SET;\n-      case 1:\n-        RoaringBitmap bitmap = new RoaringBitmap();\n-        bitmap.deserialize(byteBuffer);\n-        return new IdSet(Type.ROARING_BITMAP, bitmap, null);\n-      case 2:\n-        Preconditions.checkArgument(byteBuffer.hasArray(),\n-            \"Cannot deserialize Roaring64NavigableMap from ByteBuffer not backed by an accessible byte array\");\n-        Roaring64NavigableMap longBitmap = new Roaring64NavigableMap();\n-        // NOTE: No need to close these streams.\n-        longBitmap.deserialize(new DataInputStream(\n-            new ByteArrayInputStream(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(),\n-                byteBuffer.remaining())));\n-        return new IdSet(Type.ROARING_64_NAVIGABLE_MAP, null, longBitmap);\n-      default:\n-        throw new IllegalStateException();\n-    }\n-  }\n-\n-  /**\n-   * Serializes the IdSet into a Base64 string.\n-   * <p>Use Base64 instead of Hex encoding for better compression.\n-   */\n-  public String toBase64String()\n-      throws IOException {\n-    return Base64.getEncoder().encodeToString(toBytes());\n-  }\n-\n-  /**\n-   * Deserializes the IdSet from a Base64 string.\n-   * <p>Use Base64 instead of Hex encoding for better compression.\n-   */\n-  public static IdSet fromBase64String(String base64String)\n-      throws IOException {\n-    return fromBytes(Base64.getDecoder().decode(base64String));\n-  }\n-\n-  @Override\n-  public int compareTo(IdSet idSet) {\n-    return Long.compare(getCardinality(), idSet.getCardinality());\n-  }\n-\n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof IdSet)) {\n-      return false;\n-    }\n-    IdSet idSet = (IdSet) o;\n-    return _type == idSet._type && Objects.equals(_bitmap, idSet._bitmap) && Objects\n-        .equals(_longBitmap, idSet._longBitmap);\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return Objects.hash(_type, _bitmap, _longBitmap);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    try {\n-      return toBase64String();\n-    } catch (IOException e) {\n-      throw new RuntimeException(\"Caught exception while serializing IdSet\", e);\n-    }\n-  }\n-}\n"}}, {"oid": "456de3419a4d24e73887c47c7a918a42fce3ade5", "url": "https://github.com/apache/pinot/commit/456de3419a4d24e73887c47c7a918a42fce3ade5", "message": "Add IdSet and IdSetAggregationFunction", "committedDate": "2020-08-28T02:32:05Z", "type": "forcePushed"}, {"oid": "fab464fcfa250f92bee4e897c62b69976a5bc0db", "url": "https://github.com/apache/pinot/commit/fab464fcfa250f92bee4e897c62b69976a5bc0db", "message": "Add IdSet and IdSetAggregationFunction", "committedDate": "2020-08-28T02:39:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzNjkzNw==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r478836937", "bodyText": "add a sample call", "author": "kishoreg", "createdAt": "2020-08-28T05:24:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.utils.idset.IdSet;\n+import org.apache.pinot.core.query.utils.idset.IdSets;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+\n+\n+/**\n+ * The {@code IdSetAggregationFunction} collects the values for a given single-value expression into an IdSet, which can\n+ * be used in the second query to optimize the query with huge IN clause generated from another query.\n+ */\n+public class IdSetAggregationFunction extends BaseSingleInputAggregationFunction<IdSet, String> {\n+  public static final char PARAMETER_DELIMITER = ';';\n+  public static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n+  public static final String SIZE_THRESHOLD_IN_BYTES_KEY = \"SIZETHRESHOLDINBYTES\";\n+  public static final String EXPECTED_INSERTIONS_KEY = \"EXPECTEDINSERTIONS\";\n+  public static final String FPP_KEY = \"FPP\";\n+\n+  private final int _sizeThresholdInBytes;\n+  private final int _expectedInsertions;\n+  private final double _fpp;\n+\n+  /**", "originalCommit": "fab464fcfa250f92bee4e897c62b69976a5bc0db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzI2Ng==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r479457266", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-08-28T18:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzNjkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "178e4797ef0bbab652eeddaa58f382782aacecf7", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\nindex cc7697327c..6b5d3411c1 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\n\n@@ -39,22 +39,35 @@ import org.apache.pinot.spi.data.FieldSpec.DataType;\n /**\n  * The {@code IdSetAggregationFunction} collects the values for a given single-value expression into an IdSet, which can\n  * be used in the second query to optimize the query with huge IN clause generated from another query.\n+ * <p>The generated IdSet can be backed by RoaringBitmap, Roaring64NavigableMap or BloomFilter based on type of the ids\n+ * and the function parameters.\n+ * <p>The function takes an optional second argument as the parameters for the function. There are 3 parameters for the\n+ * function:\n+ * <ul>\n+ *   <li>\n+ *     sizeThresholdInBytes: When the size of the IdSet exceeds this threshold, convert the IdSet to BloomFilterIdSet to\n+ *     reduce the size of the IdSet. Directly create BloomFilterIdSet if it is smaller or equal to 0. (Default 8MB)\n+ *   </li>\n+ *   <li>\n+ *     expectedInsertions: Number of expected insertions for the BloomFilter, must be positive. (Default 5M)\n+ *   </li>\n+ *   <li>\n+ *     fpp: Desired false positive probability for the BloomFilter, must be positive and less than 1.0. (Default 0.03)\n+ *   </li>\n+ * </ul>\n+ * <p>Example: IDSET(col, 'sizeThresholdInBytes=1000;expectedInsertions=10000;fpp=0.03')\n  */\n public class IdSetAggregationFunction extends BaseSingleInputAggregationFunction<IdSet, String> {\n-  public static final char PARAMETER_DELIMITER = ';';\n-  public static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n-  public static final String SIZE_THRESHOLD_IN_BYTES_KEY = \"SIZETHRESHOLDINBYTES\";\n-  public static final String EXPECTED_INSERTIONS_KEY = \"EXPECTEDINSERTIONS\";\n-  public static final String FPP_KEY = \"FPP\";\n+  private static final char PARAMETER_DELIMITER = ';';\n+  private static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n+  private static final String UPPER_CASE_SIZE_THRESHOLD_IN_BYTES = \"SIZETHRESHOLDINBYTES\";\n+  private static final String UPPER_CASE_EXPECTED_INSERTIONS = \"EXPECTEDINSERTIONS\";\n+  private static final String UPPER_CASE_FPP = \"FPP\";\n \n   private final int _sizeThresholdInBytes;\n   private final int _expectedInsertions;\n   private final double _fpp;\n \n-  /**\n-   * NOTE: First argument is the id expression, optional second argument is a JSON string of the parameters for the\n-   *       function.\n-   */\n   public IdSetAggregationFunction(List<ExpressionContext> arguments) {\n     super(arguments.get(0));\n     if (arguments.size() == 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzNzMxMg==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r478837312", "bodyText": "what are these? java docs", "author": "kishoreg", "createdAt": "2020-08-28T05:25:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.query.utils.idset.IdSet;\n+import org.apache.pinot.core.query.utils.idset.IdSets;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+\n+\n+/**\n+ * The {@code IdSetAggregationFunction} collects the values for a given single-value expression into an IdSet, which can\n+ * be used in the second query to optimize the query with huge IN clause generated from another query.\n+ */\n+public class IdSetAggregationFunction extends BaseSingleInputAggregationFunction<IdSet, String> {\n+  public static final char PARAMETER_DELIMITER = ';';\n+  public static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n+  public static final String SIZE_THRESHOLD_IN_BYTES_KEY = \"SIZETHRESHOLDINBYTES\";", "originalCommit": "fab464fcfa250f92bee4e897c62b69976a5bc0db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzI5MA==", "url": "https://github.com/apache/pinot/pull/5926#discussion_r479457290", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-08-28T18:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzNzMxMg=="}], "type": "inlineReview", "revised_code": {"commit": "178e4797ef0bbab652eeddaa58f382782aacecf7", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\nindex cc7697327c..6b5d3411c1 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/IdSetAggregationFunction.java\n\n@@ -39,22 +39,35 @@ import org.apache.pinot.spi.data.FieldSpec.DataType;\n /**\n  * The {@code IdSetAggregationFunction} collects the values for a given single-value expression into an IdSet, which can\n  * be used in the second query to optimize the query with huge IN clause generated from another query.\n+ * <p>The generated IdSet can be backed by RoaringBitmap, Roaring64NavigableMap or BloomFilter based on type of the ids\n+ * and the function parameters.\n+ * <p>The function takes an optional second argument as the parameters for the function. There are 3 parameters for the\n+ * function:\n+ * <ul>\n+ *   <li>\n+ *     sizeThresholdInBytes: When the size of the IdSet exceeds this threshold, convert the IdSet to BloomFilterIdSet to\n+ *     reduce the size of the IdSet. Directly create BloomFilterIdSet if it is smaller or equal to 0. (Default 8MB)\n+ *   </li>\n+ *   <li>\n+ *     expectedInsertions: Number of expected insertions for the BloomFilter, must be positive. (Default 5M)\n+ *   </li>\n+ *   <li>\n+ *     fpp: Desired false positive probability for the BloomFilter, must be positive and less than 1.0. (Default 0.03)\n+ *   </li>\n+ * </ul>\n+ * <p>Example: IDSET(col, 'sizeThresholdInBytes=1000;expectedInsertions=10000;fpp=0.03')\n  */\n public class IdSetAggregationFunction extends BaseSingleInputAggregationFunction<IdSet, String> {\n-  public static final char PARAMETER_DELIMITER = ';';\n-  public static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n-  public static final String SIZE_THRESHOLD_IN_BYTES_KEY = \"SIZETHRESHOLDINBYTES\";\n-  public static final String EXPECTED_INSERTIONS_KEY = \"EXPECTEDINSERTIONS\";\n-  public static final String FPP_KEY = \"FPP\";\n+  private static final char PARAMETER_DELIMITER = ';';\n+  private static final char PARAMETER_KEY_VALUE_SEPARATOR = '=';\n+  private static final String UPPER_CASE_SIZE_THRESHOLD_IN_BYTES = \"SIZETHRESHOLDINBYTES\";\n+  private static final String UPPER_CASE_EXPECTED_INSERTIONS = \"EXPECTEDINSERTIONS\";\n+  private static final String UPPER_CASE_FPP = \"FPP\";\n \n   private final int _sizeThresholdInBytes;\n   private final int _expectedInsertions;\n   private final double _fpp;\n \n-  /**\n-   * NOTE: First argument is the id expression, optional second argument is a JSON string of the parameters for the\n-   *       function.\n-   */\n   public IdSetAggregationFunction(List<ExpressionContext> arguments) {\n     super(arguments.get(0));\n     if (arguments.size() == 1) {\n"}}, {"oid": "178e4797ef0bbab652eeddaa58f382782aacecf7", "url": "https://github.com/apache/pinot/commit/178e4797ef0bbab652eeddaa58f382782aacecf7", "message": "Add more javadoc", "committedDate": "2020-08-28T18:02:58Z", "type": "forcePushed"}, {"oid": "9aa4070bb86dc79e920f70cdff0eb5ea32e07e53", "url": "https://github.com/apache/pinot/commit/9aa4070bb86dc79e920f70cdff0eb5ea32e07e53", "message": "Add IdSet and IdSetAggregationFunction", "committedDate": "2020-08-28T19:49:10Z", "type": "commit"}, {"oid": "9aa4070bb86dc79e920f70cdff0eb5ea32e07e53", "url": "https://github.com/apache/pinot/commit/9aa4070bb86dc79e920f70cdff0eb5ea32e07e53", "message": "Add IdSet and IdSetAggregationFunction", "committedDate": "2020-08-28T19:49:10Z", "type": "forcePushed"}]}