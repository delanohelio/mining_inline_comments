{"pr_number": 4990, "pr_title": "Enhance TableRebalancer to be able to rebalance table under any condition", "pr_createdAt": "2020-01-15T20:42:28Z", "pr_url": "https://github.com/apache/pinot/pull/4990", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMTg1NQ==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r367121855", "bodyText": "I think this should be error level.", "author": "siddharthteotia", "createdAt": "2020-01-15T21:41:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -420,10 +463,19 @@ static boolean isExternalViewConverged(Map<String, Map<String, String>> external\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n-        String state = instanceStateEntry.getValue();\n-        if (!state.equals(SegmentOnlineOfflineStateModel.OFFLINE) && !state\n-            .equals(externalViewInstanceStateMap.get(instanceStateEntry.getKey()))) {\n-          return false;\n+        String idealStateInstanceState = instanceStateEntry.getValue();\n+        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n+          continue;\n+        }\n+        String instanceName = instanceStateEntry.getKey();\n+        String externalViewInstanceState = externalViewInstanceStateMap.get(instanceName);\n+        if (!idealStateInstanceState.equals(externalViewInstanceState)) {\n+          if (RealtimeSegmentOnlineOfflineStateModel.ERROR.equals(externalViewInstanceState)) {\n+            LOGGER.warn(\"Found ERROR instance: {} for segment: {}, table: {}\", instanceName, segmentName,", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzgwMA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333800", "bodyText": "I think  a warning is better. The server instance, when it transitioned into ERROR state, would have logged an error anyway. It is not an error in the controller if it discovers that a server was malfunctioning.\nOn another (but related) note, I would avoid logging strings that have \"ERROR\". It is quite irritating to see these come up when we see some problem, and want to get all the error logs (as in, logs that have been logged with LOGGER.error() statement). I am not sure we can do much here, but something to note.", "author": "mcvsubbu", "createdAt": "2020-01-19T23:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMTg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -457,19 +473,25 @@ public class TableRebalancer {\n     for (Map.Entry<String, Map<String, String>> entry : idealStateSegmentStates.entrySet()) {\n       String segmentName = entry.getKey();\n       Map<String, String> externalViewInstanceStateMap = externalViewSegmentStates.get(segmentName);\n-      if (externalViewInstanceStateMap == null) {\n-        return false;\n-      }\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n+\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n         String idealStateInstanceState = instanceStateEntry.getValue();\n-        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n+        if (idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n           continue;\n         }\n+\n+        // ExternalView should contain the segment\n+        if (externalViewInstanceStateMap == null) {\n+          return false;\n+        }\n+\n+        // Check whether the instance state in ExternalView matches the IdealState\n         String instanceName = instanceStateEntry.getKey();\n         String externalViewInstanceState = externalViewInstanceStateMap.get(instanceName);\n         if (!idealStateInstanceState.equals(externalViewInstanceState)) {\n+          // For ERROR instance, log a warning but treat it as good state so that it won't block the rebalance\n           if (RealtimeSegmentOnlineOfflineStateModel.ERROR.equals(externalViewInstanceState)) {\n             LOGGER.warn(\"Found ERROR instance: {} for segment: {}, table: {}\", instanceName, segmentName,\n                 tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTY3MA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368331670", "bodyText": "Can you elaborate on what instance re-assignment means? Maybe best to add it in the comments on RebalanceConfigConstants. We need to also doc it in along with the rebalance command. Let me know if there is a doc already, and I can read it.", "author": "mcvsubbu", "createdAt": "2020-01-19T23:17:55Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1MDE4Nw==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369250187", "bodyText": "More comments can be found in the instance assignment related classes. The doc for instance assignment has not been added yet, will do in the following pr.", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -205,9 +214,11 @@ public class TableRebalancer {\n           Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n               .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n                   AccessOption.PERSISTENT), \"Failed to update IdealState\");\n-          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+          LOGGER.info(\"Finished rebalancing table: {} with downtime in {}ms.\", tableNameWithType,\n               System.currentTimeMillis() - startTimeMs);\n-          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Success with downtime (replaced IdealState with the target segment assignment, ExternalView might not reach the target segment assignment yet)\",\n+              instancePartitionsMap, targetAssignment);\n         } catch (ZkBadVersionException e) {\n           LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n               tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTc3NA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368331774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n          \n          \n            \n                  LOGGER.info(\"Rebalancing table {} in dry-run mode, returning the target assignment\", tableNameWithType);", "author": "mcvsubbu", "createdAt": "2020-01-19T23:19:24Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0NzAwOA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369247008", "bodyText": "I prefer having a : before the variables so it is easier to locate the variables", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMTc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -205,9 +214,11 @@ public class TableRebalancer {\n           Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n               .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n                   AccessOption.PERSISTENT), \"Failed to update IdealState\");\n-          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+          LOGGER.info(\"Finished rebalancing table: {} with downtime in {}ms.\", tableNameWithType,\n               System.currentTimeMillis() - startTimeMs);\n-          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Success with downtime (replaced IdealState with the target segment assignment, ExternalView might not reach the target segment assignment yet)\",\n+              instancePartitionsMap, targetAssignment);\n         } catch (ZkBadVersionException e) {\n           LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n               tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjAwNw==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332007", "bodyText": "(1) If the table is disabled, it is already down, so maybe just say that we are moving segment assignment?\n(2) Why is this a warning? it can be an info.\n(3) We should return this information in the status as well.", "author": "mcvsubbu", "createdAt": "2020-01-19T23:22:50Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2MTI1Mw==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369261253", "bodyText": "(1) rebalance with downtime is the same as moving segment assignment (added javadoc)\n(2) It is a warning because we log it only when downtime is set to false\n(3) Added downtime info into the response", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -205,9 +214,11 @@ public class TableRebalancer {\n           Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n               .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n                   AccessOption.PERSISTENT), \"Failed to update IdealState\");\n-          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+          LOGGER.info(\"Finished rebalancing table: {} with downtime in {}ms.\", tableNameWithType,\n               System.currentTimeMillis() - startTimeMs);\n-          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Success with downtime (replaced IdealState with the target segment assignment, ExternalView might not reach the target segment assignment yet)\",\n+              instancePartitionsMap, targetAssignment);\n         } catch (ZkBadVersionException e) {\n           LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n               tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjEzMw==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332133", "bodyText": "Is is useful to extract this part into a method (provided it has reasonable number of arguments. Similarly the else part.", "author": "mcvsubbu", "createdAt": "2020-01-19T23:24:27Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);\n+      downtime = true;\n+    }\n+\n+    if (downtime) {\n       LOGGER.info(\"Rebalancing table: {} with downtime\", tableNameWithType);\n-    } else {\n-      minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n-          RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n-      int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n-      int numTargetReplicas = targetAssignment.values().iterator().next().size();\n-      // Use the smaller one to determine the min available replicas\n-      int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n-      if (minAvailableReplicas > 0) {\n-        if (minAvailableReplicas >= numReplicas) {\n-          LOGGER.warn(\n-              \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n-              minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n-          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+\n+      while (true) {", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2MTUxMQ==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369261511", "bodyText": "Too many arguments need to be passed, and it is called only once, so prefer keeping it inline for now", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -205,9 +214,11 @@ public class TableRebalancer {\n           Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n               .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n                   AccessOption.PERSISTENT), \"Failed to update IdealState\");\n-          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+          LOGGER.info(\"Finished rebalancing table: {} with downtime in {}ms.\", tableNameWithType,\n               System.currentTimeMillis() - startTimeMs);\n-          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Success with downtime (replaced IdealState with the target segment assignment, ExternalView might not reach the target segment assignment yet)\",\n+              instancePartitionsMap, targetAssignment);\n         } catch (ZkBadVersionException e) {\n           LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n               tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjcyOQ==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368332729", "bodyText": "Should we be passing the expected version into waitForExternalViewToConverge so that if the idealstate changes due to some other factor, we don't wait for convergence. Instead, we should execute the logic below.", "author": "mcvsubbu", "createdAt": "2020-01-19T23:33:11Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -175,67 +166,127 @@ public RebalanceResult rebalance(TableConfig tableConfig, Configuration rebalanc\n     if (currentAssignment.equals(targetAssignment)) {\n       LOGGER.info(\"Table: {} is already balanced\", tableNameWithType);\n       if (reassignInstances) {\n-        return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n-            instancePartitionsMap, targetAssignment);\n+        if (dryRun) {\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Instance reassigned in dry-run mode, table is already balanced\", instancePartitionsMap,\n+              targetAssignment);\n+        } else {\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Instance reassigned, table is already balanced\",\n+              instancePartitionsMap, targetAssignment);\n+        }\n       } else {\n         return new RebalanceResult(RebalanceResult.Status.NO_OP, \"Table is already balanced\", instancePartitionsMap,\n             targetAssignment);\n       }\n     }\n \n     if (dryRun) {\n-      LOGGER.info(\"Rebalance table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n+      LOGGER.info(\"Rebalancing table: {} in dry-run mode, returning the target assignment\", tableNameWithType);\n       return new RebalanceResult(RebalanceResult.Status.DONE, \"Dry-run mode\", instancePartitionsMap, targetAssignment);\n     }\n \n-    int minAvailableReplicas;\n-    if (rebalanceConfig.getBoolean(RebalanceConfigConstants.DOWNTIME, RebalanceConfigConstants.DEFAULT_DOWNTIME)) {\n-      minAvailableReplicas = 0;\n+    if (!downtime && !currentIdealState.isEnabled()) {\n+      LOGGER.warn(\"Table: {} is disabled, rebalancing it with downtime\", tableNameWithType);\n+      downtime = true;\n+    }\n+\n+    if (downtime) {\n       LOGGER.info(\"Rebalancing table: {} with downtime\", tableNameWithType);\n-    } else {\n-      minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n-          RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n-      int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n-      int numTargetReplicas = targetAssignment.values().iterator().next().size();\n-      // Use the smaller one to determine the min available replicas\n-      int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n-      if (minAvailableReplicas > 0) {\n-        if (minAvailableReplicas >= numReplicas) {\n-          LOGGER.warn(\n-              \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n-              minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n-          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+\n+      while (true) {\n+        // Reuse current IdealState to update the IdealState in cluster\n+        ZNRecord idealStateRecord = currentIdealState.getRecord();\n+        idealStateRecord.setMapFields(targetAssignment);\n+        currentIdealState.setNumPartitions(targetAssignment.size());\n+        currentIdealState.setReplicas(Integer.toString(targetAssignment.values().iterator().next().size()));\n+\n+        // Check version and update IdealState\n+        try {\n+          Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n+              .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n+                  AccessOption.PERSISTENT), \"Failed to update IdealState\");\n+          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+              System.currentTimeMillis() - startTimeMs);\n+          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+        } catch (ZkBadVersionException e) {\n+          LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n+              tableNameWithType);\n+          try {\n+            IdealState idealState = _helixDataAccessor.getProperty(idealStatePropertyKey);\n+            // IdealState might be null if table got deleted, throwing exception to abort the rebalance\n+            Preconditions.checkState(idealState != null, \"Failed to find the IdealState\");\n+            currentIdealState = idealState;\n+            currentAssignment = currentIdealState.getRecord().getMapFields();\n+            targetAssignment =\n+                segmentAssignment.rebalanceTable(currentAssignment, instancePartitionsMap, rebalanceConfig);\n+          } catch (Exception e1) {\n+            LOGGER.error(\"Caught exception while re-calculating the target assignment for table: {}\", tableNameWithType,\n+                e1);\n+            return new RebalanceResult(RebalanceResult.Status.FAILED,\n+                \"Caught exception while re-calculating the target assignment: \" + e1, instancePartitionsMap,\n+                targetAssignment);\n+          }\n+        } catch (Exception e) {\n+          LOGGER.error(\"Caught exception while updating IdealState for table: {}\", tableNameWithType, e);\n+          return new RebalanceResult(RebalanceResult.Status.FAILED, \"Caught exception while updating IdealState: \" + e,\n               instancePartitionsMap, targetAssignment);\n         }\n       }\n-      // If min available replicas is negative, treat it as max unavailable replicas\n-      if (minAvailableReplicas < 0) {\n-        minAvailableReplicas = Math.max(numReplicas + minAvailableReplicas, 0);\n+    }\n+\n+    // Calculate the min available replicas for no-downtime rebalance\n+    int minAvailableReplicas = rebalanceConfig.getInt(RebalanceConfigConstants.MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME,\n+        RebalanceConfigConstants.DEFAULT_MIN_REPLICAS_TO_KEEP_UP_FOR_NO_DOWNTIME);\n+    int numCurrentReplicas = currentAssignment.values().iterator().next().size();\n+    int numTargetReplicas = targetAssignment.values().iterator().next().size();\n+    // Use the smaller one to determine the min available replicas\n+    int numReplicas = Math.min(numCurrentReplicas, numTargetReplicas);\n+    if (minAvailableReplicas > 0) {\n+      if (minAvailableReplicas >= numReplicas) {\n+        LOGGER.warn(\n+            \"Illegal config for min available replicas: {} for table: {}, must be less than number of replicas (current: {}, target: {})\",\n+            minAvailableReplicas, tableNameWithType, numCurrentReplicas, numTargetReplicas);\n+        return new RebalanceResult(RebalanceResult.Status.FAILED, \"Illegal min available replicas config\",\n+            instancePartitionsMap, targetAssignment);\n       }\n-      LOGGER.info(\"Rebalancing table: {} with min available replicas: {}\", tableNameWithType, minAvailableReplicas);\n     }\n+    // If min available replicas is negative, treat it as max unavailable replicas\n+    if (minAvailableReplicas < 0) {\n+      minAvailableReplicas = Math.max(numReplicas + minAvailableReplicas, 0);\n+    }\n+    LOGGER.info(\"Rebalancing table: {} with min available replicas: {}\", tableNameWithType, minAvailableReplicas);\n \n     int expectedVersion = currentIdealState.getRecord().getVersion();\n     while (true) {\n       // Wait for ExternalView to converge before updating the next IdealState\n+      IdealState idealState;\n       try {\n-        IdealState idealState = waitForExternalViewToConverge(tableNameWithType);\n-        LOGGER.info(\"ExternalView converged for table: {}\", tableNameWithType);\n-        if (idealState.getRecord().getVersion() != expectedVersion) {\n-          LOGGER.info(\n-              \"IdealState version changed while waiting for ExternalView to converge for table: {}, re-calculating the target assignment\",\n-              tableNameWithType);\n+        idealState = waitForExternalViewToConverge(tableNameWithType);", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2Mjk4MQ==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369262981", "bodyText": "We still need to wait for convergence when ideal state changes to guarantee the available replicas", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMjcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -205,9 +214,11 @@ public class TableRebalancer {\n           Preconditions.checkState(_helixDataAccessor.getBaseDataAccessor()\n               .set(idealStatePropertyKey.getPath(), idealStateRecord, idealStateRecord.getVersion(),\n                   AccessOption.PERSISTENT), \"Failed to update IdealState\");\n-          LOGGER.info(\"Finished rebalancing table: {} in {}ms.\", tableNameWithType,\n+          LOGGER.info(\"Finished rebalancing table: {} with downtime in {}ms.\", tableNameWithType,\n               System.currentTimeMillis() - startTimeMs);\n-          return new RebalanceResult(RebalanceResult.Status.DONE, \"Success\", instancePartitionsMap, targetAssignment);\n+          return new RebalanceResult(RebalanceResult.Status.DONE,\n+              \"Success with downtime (replaced IdealState with the target segment assignment, ExternalView might not reach the target segment assignment yet)\",\n+              instancePartitionsMap, targetAssignment);\n         } catch (ZkBadVersionException e) {\n           LOGGER.info(\"IdealState version changed for table: {}, re-calculating the target assignment\",\n               tableNameWithType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzIzNw==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                LOGGER.warn(\"ExternalView haven't converged within: {}ms for table: {}, continuing the rebalance\",\n          \n          \n            \n                LOGGER.warn(\"ExternalView has not converged within: {}ms for table: {}, continuing the rebalance\",", "author": "mcvsubbu", "createdAt": "2020-01-19T23:40:33Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -307,32 +358,32 @@ private InstancePartitions getInstancePartitions(TableConfig tableConfig,\n   }\n \n   private IdealState waitForExternalViewToConverge(String tableNameWithType)\n-      throws InterruptedException, TimeoutException {\n+      throws InterruptedException {\n     long endTimeMs = System.currentTimeMillis() + EXTERNAL_VIEW_STABILIZATION_MAX_WAIT_MS;\n \n-    while (System.currentTimeMillis() < endTimeMs) {\n-      IdealState idealState =\n-          _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().idealStates(tableNameWithType));\n+    IdealState idealState;\n+    do {\n+      idealState = _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().idealStates(tableNameWithType));\n       // IdealState might be null if table got deleted, throwing exception to abort the rebalance\n       Preconditions.checkState(idealState != null, \"Failed to find the IdealState\");\n \n       ExternalView externalView =\n           _helixDataAccessor.getProperty(_helixDataAccessor.keyBuilder().externalView(tableNameWithType));\n       // ExternalView might be null when table is just created, skipping check for this iteration\n       if (externalView != null) {\n-        Map<String, Map<String, String>> externalViewSegmentStates = externalView.getRecord().getMapFields();\n-        if (isExternalViewConverged(externalViewSegmentStates, idealState.getRecord().getMapFields())) {\n+        if (isExternalViewConverged(tableNameWithType, externalView.getRecord().getMapFields(),\n+            idealState.getRecord().getMapFields())) {\n+          LOGGER.info(\"ExternalView converged for table: {}\", tableNameWithType);\n           return idealState;\n         }\n-        if (hasSegmentInErrorState(externalViewSegmentStates)) {\n-          throw new IllegalStateException(\"Found segments in ERROR state\");\n-        }\n       }\n \n       Thread.sleep(EXTERNAL_VIEW_CHECK_INTERVAL_MS);\n-    }\n+    } while (System.currentTimeMillis() < endTimeMs);\n \n-    throw new TimeoutException(\"Timeout while waiting for ExternalView to converge\");\n+    LOGGER.warn(\"ExternalView haven't converged within: {}ms for table: {}, continuing the rebalance\",", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2MzA0OA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369263048", "bodyText": "Fixed", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -381,7 +397,7 @@ public class TableRebalancer {\n       Thread.sleep(EXTERNAL_VIEW_CHECK_INTERVAL_MS);\n     } while (System.currentTimeMillis() < endTimeMs);\n \n-    LOGGER.warn(\"ExternalView haven't converged within: {}ms for table: {}, continuing the rebalance\",\n+    LOGGER.warn(\"ExternalView has not converged within: {}ms for table: {}, continuing the rebalance\",\n         EXTERNAL_VIEW_STABILIZATION_MAX_WAIT_MS, tableNameWithType);\n     return idealState;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzQxNA==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r368333414", "bodyText": "Is the condition inverted?", "author": "mcvsubbu", "createdAt": "2020-01-19T23:42:54Z", "path": "pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java", "diffHunk": "@@ -420,10 +463,19 @@ static boolean isExternalViewConverged(Map<String, Map<String, String>> external\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n-        String state = instanceStateEntry.getValue();\n-        if (!state.equals(SegmentOnlineOfflineStateModel.OFFLINE) && !state\n-            .equals(externalViewInstanceStateMap.get(instanceStateEntry.getKey()))) {\n-          return false;\n+        String idealStateInstanceState = instanceStateEntry.getValue();\n+        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {", "originalCommit": "83a32918c257be3d400e32aefcaa037871c8c367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2MzQ4OQ==", "url": "https://github.com/apache/pinot/pull/4990#discussion_r369263489", "bodyText": "Yes, good catch", "author": "Jackie-Jiang", "createdAt": "2020-01-21T21:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMzMzQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "chunk": "diff --git a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\nindex a541d0f9a3..d014c43d93 100644\n--- a/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n+++ b/pinot-controller/src/main/java/org/apache/pinot/controller/helix/core/rebalance/TableRebalancer.java\n\n@@ -457,19 +473,25 @@ public class TableRebalancer {\n     for (Map.Entry<String, Map<String, String>> entry : idealStateSegmentStates.entrySet()) {\n       String segmentName = entry.getKey();\n       Map<String, String> externalViewInstanceStateMap = externalViewSegmentStates.get(segmentName);\n-      if (externalViewInstanceStateMap == null) {\n-        return false;\n-      }\n       Map<String, String> idealStateInstanceStateMap = entry.getValue();\n+\n       for (Map.Entry<String, String> instanceStateEntry : idealStateInstanceStateMap.entrySet()) {\n         // Ignore OFFLINE state in IdealState\n         String idealStateInstanceState = instanceStateEntry.getValue();\n-        if (!idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n+        if (idealStateInstanceState.equals(RealtimeSegmentOnlineOfflineStateModel.OFFLINE)) {\n           continue;\n         }\n+\n+        // ExternalView should contain the segment\n+        if (externalViewInstanceStateMap == null) {\n+          return false;\n+        }\n+\n+        // Check whether the instance state in ExternalView matches the IdealState\n         String instanceName = instanceStateEntry.getKey();\n         String externalViewInstanceState = externalViewInstanceStateMap.get(instanceName);\n         if (!idealStateInstanceState.equals(externalViewInstanceState)) {\n+          // For ERROR instance, log a warning but treat it as good state so that it won't block the rebalance\n           if (RealtimeSegmentOnlineOfflineStateModel.ERROR.equals(externalViewInstanceState)) {\n             LOGGER.warn(\"Found ERROR instance: {} for segment: {}, table: {}\", instanceName, segmentName,\n                 tableNameWithType);\n"}}, {"oid": "ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "url": "https://github.com/apache/pinot/commit/ffdfa02388d3b8fab8e3d1523ce4d033646638c8", "message": "Address comments, add more tests", "committedDate": "2020-01-22T00:50:02Z", "type": "forcePushed"}, {"oid": "0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "url": "https://github.com/apache/pinot/commit/0ad78b7887bf1a9059742f00eb5b03c9174a9f10", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime", "committedDate": "2020-01-22T05:38:36Z", "type": "forcePushed"}, {"oid": "f84d46a9856e55aa2854adea8e94dfc0440fad8d", "url": "https://github.com/apache/pinot/commit/f84d46a9856e55aa2854adea8e94dfc0440fad8d", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime", "committedDate": "2020-01-22T06:13:00Z", "type": "commit"}, {"oid": "f84d46a9856e55aa2854adea8e94dfc0440fad8d", "url": "https://github.com/apache/pinot/commit/f84d46a9856e55aa2854adea8e94dfc0440fad8d", "message": "Enhance TableRebalancer to be able to rebalance table under any condition\n\nAdd a new option: \"bestEfforts\" to allow rebalance in the following scenario (min available replicas won't be guaranteed)\n- Table with segments in ERROR state\n- ExternalView not converged within the max wait time\n\nAlso add support for rebalancing Helix disabled table with downtime", "committedDate": "2020-01-22T06:13:00Z", "type": "forcePushed"}]}