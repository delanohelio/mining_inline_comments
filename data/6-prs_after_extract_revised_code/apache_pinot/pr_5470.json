{"pr_number": 5470, "pr_title": "Derive numDocsPerChunk for var byte raw index from metadata only if config is enabled.", "pr_createdAt": "2020-05-30T23:13:28Z", "pr_url": "https://github.com/apache/pinot/pull/5470", "timeline": [{"oid": "cadfcaee026d53bc603dea0b6806922e1eaafb19", "url": "https://github.com/apache/pinot/commit/cadfcaee026d53bc603dea0b6806922e1eaafb19", "message": "Two changes:\n\n(1) PR https://github.com/apache/incubator-pinot/pull/5256\nadded support for deriving num docs per chunk for var byte\nraw index create from column length. This was specifically\ndone as part of supporting text blobs. For use cases that\ndon't want this feature and are high QPS, see a negative\nimpact since size of chunk increases (earlier value\nof numDocsPerChunk was hardcoded to 1000) and based on the\naccess pattern we might end up uncompressing a bigger chunk to get values\nfor a set of docIds. We have made this change configurable.\nSo the default behaviour is same as old (1000 docs per chunk)\n\n(2) PR https://github.com/apache/incubator-pinot/pull/4791\nadded support for noDict for STRING/BYTES in consuming segments.\nThere is a particular impact of this change on the use cases\nthat have set noDict on their STRING dimension columns for other performance\nreasons and also want metricsAggregation. These use cases don't get to\naggregateMetrics because the new implementation was able to honor their\ntable config setting of noDict on STRING/BYTES. Without metrics aggregation,\nmemory pressure increases. So to continue aggregating metrics for such cases,\nwe will create dictionary even if the column is part of noDictionary set\nfrom table config.", "committedDate": "2020-05-30T23:25:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTMxNw==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432895317", "bodyText": "deriveNumDocsPerChunk sounds more accurate? (applicable to all related config & variable names)", "author": "snleee", "createdAt": "2020-05-30T23:26:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -193,9 +194,10 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             getColumnCompressionType(segmentCreationSpec, fieldSpec);\n \n         // Initialize forward index creator\n+        boolean deriveNumChunksForVarByteRawIndex = shouldDeriveNumChunksForRawIndex(columnName, segmentCreationSpec.getColumnProperties());", "originalCommit": "cadfcaee026d53bc603dea0b6806922e1eaafb19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQyMg==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896422", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-05-30T23:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "af9bc3077ae4869aa02757a706cc89e0ebf4d953", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex 6441931352..9ff286437a 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -194,10 +194,10 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n             getColumnCompressionType(segmentCreationSpec, fieldSpec);\n \n         // Initialize forward index creator\n-        boolean deriveNumChunksForVarByteRawIndex = shouldDeriveNumChunksForRawIndex(columnName, segmentCreationSpec.getColumnProperties());\n+        boolean deriveNumDocsPerChunk = shouldDeriveNumDocsPerChunk(columnName, segmentCreationSpec.getColumnProperties());\n         _forwardIndexCreatorMap.put(columnName,\n             getRawIndexCreatorForColumn(_indexDir, compressionType, columnName, fieldSpec.getDataType(), totalDocs,\n-                indexCreationInfo.getLengthOfLongestEntry(), deriveNumChunksForVarByteRawIndex));\n+                indexCreationInfo.getLengthOfLongestEntry(), deriveNumDocsPerChunk));\n \n         // Initialize text index creator\n         if (_textIndexColumns.contains(columnName)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432895436", "bodyText": "What was the original behavior before your recent change? Did we explicitly check STRING and BYTES types also?", "author": "snleee", "createdAt": "2020-05-30T23:28:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {\n+      // text column is no dictionary currently\n+      return true;\n+    }\n+    FieldSpec.DataType dataType = fieldSpec.getDataType();\n+    if (noDictionaryColumns.contains(column)) {\n+      // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n+      // So even if the user had the column in noDictionaryColumns set in table config, we still\n+      // created dictionary in consuming segments.\n+      // Later on we added this support. There is a particular impact of this change on the use cases\n+      // that have set noDict on their STRING dimension columns for other performance\n+      // reasons and also want metricsAggregation. These use cases don't get to\n+      // aggregateMetrics because the new implementation is able to honor their table config setting\n+      // of noDict on STRING/BYTES. Without metrics aggregation, memory pressure increases.\n+      // So to continue aggregating metrics for such cases, we will create dictionary even\n+      // if the column is part of noDictionary set from table config\n+      if (fieldSpec instanceof DimensionFieldSpec && _aggregateMetrics && (dataType == FieldSpec.DataType.STRING ||", "originalCommit": "cadfcaee026d53bc603dea0b6806922e1eaafb19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQxNg==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896416", "bodyText": "Yes we checked for STRING. See here #4791\nNote that there is a method  enableMetricsAggregationIfPossible that decides whether metrics can be aggregated or not and that checks whether all dimensions have dictionary, all metrics should not have dictionary and should be SV etc. That method is still intact.\nJust that during initialization of MutableSegmentImpl, we used to check for STRING and remove it from noDictionaryColumns set since raw index wasn't supported. This was actually the reason why the use cases were able to specify it as noDict in config and still able to aggregate metrics.", "author": "siddharthteotia", "createdAt": "2020-05-30T23:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjU3NQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896575", "bodyText": "Sounds good to me \ud83d\udc4d", "author": "snleee", "createdAt": "2020-05-30T23:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjY2MA==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896660", "bodyText": "Log message for this?", "author": "mayankshriv", "createdAt": "2020-05-30T23:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzM2Mg==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897362", "bodyText": "should the name of the method be changed to shouldCreateDictionaryForColumn()?", "author": "mcvsubbu", "createdAt": "2020-05-31T00:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NTQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "af9bc3077ae4869aa02757a706cc89e0ebf4d953", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\nindex e770beac48..0e24664a2b 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n\n@@ -329,11 +329,7 @@ public class MutableSegmentImpl implements MutableSegment {\n    * @return true if column is no-dictionary, false if dictionary encoded\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n-      Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    if (textIndexColumns.contains(column)) {\n-      // text column is no dictionary currently\n-      return true;\n-    }\n+      FieldSpec fieldSpec, String column) {\n     FieldSpec.DataType dataType = fieldSpec.getDataType();\n     if (noDictionaryColumns.contains(column)) {\n       // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896019", "bodyText": "The description of textIndexColumns is missing in this method.", "author": "jackjlli", "createdAt": "2020-05-30T23:41:23Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -330,8 +330,32 @@ public long getLatestIngestionTimestamp() {\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n       Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    return textIndexColumns.contains(column) || (noDictionaryColumns.contains(column) && fieldSpec.isSingleValueField()\n-        && !invertedIndexColumns.contains(column));\n+    if (textIndexColumns.contains(column)) {", "originalCommit": "cadfcaee026d53bc603dea0b6806922e1eaafb19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjQxOQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896419", "bodyText": "done", "author": "siddharthteotia", "createdAt": "2020-05-30T23:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzE5NQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897195", "bodyText": "This check here seems a little dangerous to me. We do have column level settings, it is better to throw an exception if a column has both text index as well as dictionary. If we somehow add a dictionary for text column later, we will have to remember to come back to change this place.", "author": "mcvsubbu", "createdAt": "2020-05-31T00:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODIzMQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432898231", "bodyText": "Actually it is not needed anymore. I already do the validation upfront in TableConfig (already in master). So we can remove it. Per column config is enough", "author": "siddharthteotia", "createdAt": "2020-05-31T00:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTg4NQ==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432905885", "bodyText": "Excellent. I think we still rename the method as something along the lines if shouldCreateDictionaryForColumn(), since it has some logic and is not just checking the table config for noDictionary setting,", "author": "mcvsubbu", "createdAt": "2020-05-31T03:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NjAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "af9bc3077ae4869aa02757a706cc89e0ebf4d953", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\nindex e770beac48..0e24664a2b 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n\n@@ -329,11 +329,7 @@ public class MutableSegmentImpl implements MutableSegment {\n    * @return true if column is no-dictionary, false if dictionary encoded\n    */\n   private boolean isNoDictionaryColumn(Set<String> noDictionaryColumns, Set<String> invertedIndexColumns,\n-      Set<String> textIndexColumns, FieldSpec fieldSpec, String column) {\n-    if (textIndexColumns.contains(column)) {\n-      // text column is no dictionary currently\n-      return true;\n-    }\n+      FieldSpec fieldSpec, String column) {\n     FieldSpec.DataType dataType = fieldSpec.getDataType();\n     if (noDictionaryColumns.contains(column)) {\n       // Earlier we didn't support noDict in consuming segments for STRING and BYTES columns.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432896846", "bodyText": "Defaults to false, right?", "author": "mayankshriv", "createdAt": "2020-05-31T00:00:08Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -213,6 +215,14 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n     }\n   }\n \n+  public static boolean shouldDeriveNumDocsPerChunk(String columnName, Map<String, Map<String, String>> columnProperties) {\n+    if (columnProperties != null) {\n+      Map<String, String> properties = columnProperties.get(columnName);\n+      return properties != null && Boolean.parseBoolean(properties.get(FieldConfig.DERIVE_NUM_DOCS_PER_CHUNK_RAW_INDEX_KEY));", "originalCommit": "1b7c94560dad927561df2161edd085f6f8066dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzQyMg==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432897422", "bodyText": "Can we derive it automatically? (e.g. if column is text index then we derive it from metadata) Or, do you see this being usefiul in other cases as well?", "author": "mcvsubbu", "createdAt": "2020-05-31T00:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODQ1Mw==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432898453", "bodyText": "Defaults to false, right?\n\nYes\n\nCan we derive it automatically? (e.g. if column is text index then we derive it from metadata) Or, do you see this being usefiul in other cases as well?\n\nWe could. Even for columns with text indexes, I don't think we should use it by default (since now that we have seen the potential -ve impact related to access pattern). Yes, most likely this will be used for columns with text index but only if the average column value size is very large (around 1-2MB) since that is the case which takes the chunk size and compressed chunk size (2 * raw) > 2GB and deriving the numDocsPerChunk becomes useful.", "author": "siddharthteotia", "createdAt": "2020-05-31T00:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTgzNw==", "url": "https://github.com/apache/pinot/pull/5470#discussion_r432905837", "bodyText": "The reason I ask is that if we introduce a config it is hard to remove/deprecate, etc. if we make it a default for text column, we can always introduce a config later to adjust. In both offline and realtime cases, we know the average column size (or, can compute easily) at the segment generation time, so it seems to me that this can be done automatically without introducing a configuration. I would propose to NOT introduce a config at this time", "author": "mcvsubbu", "createdAt": "2020-05-31T03:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Njg0Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "af9bc3077ae4869aa02757a706cc89e0ebf4d953", "url": "https://github.com/apache/pinot/commit/af9bc3077ae4869aa02757a706cc89e0ebf4d953", "message": "Two changes:\n\n(1) PR https://github.com/apache/incubator-pinot/pull/5256\nadded support for deriving num docs per chunk for var byte\nraw index create from column length. This was specifically\ndone as part of supporting text blobs. For use cases that\ndon't want this feature and are high QPS, see a negative\nimpact since size of chunk increases (earlier value\nof numDocsPerChunk was hardcoded to 1000) and based on the\naccess pattern we might end up uncompressing a bigger chunk to get values\nfor a set of docIds. We have made this change configurable.\nSo the default behaviour is same as old (1000 docs per chunk)\n\n(2) PR https://github.com/apache/incubator-pinot/pull/4791\nadded support for noDict for STRING/BYTES in consuming segments.\nThere is a particular impact of this change on the use cases\nthat have set noDict on their STRING dimension columns for other performance\nreasons and also want metricsAggregation. These use cases don't get to\naggregateMetrics because the new implementation was able to honor their\ntable config setting of noDict on STRING/BYTES. Without metrics aggregation,\nmemory pressure increases. So to continue aggregating metrics for such cases,\nwe will create dictionary even if the column is part of noDictionary set\nfrom table config.", "committedDate": "2020-05-31T00:48:30Z", "type": "commit"}, {"oid": "af9bc3077ae4869aa02757a706cc89e0ebf4d953", "url": "https://github.com/apache/pinot/commit/af9bc3077ae4869aa02757a706cc89e0ebf4d953", "message": "Two changes:\n\n(1) PR https://github.com/apache/incubator-pinot/pull/5256\nadded support for deriving num docs per chunk for var byte\nraw index create from column length. This was specifically\ndone as part of supporting text blobs. For use cases that\ndon't want this feature and are high QPS, see a negative\nimpact since size of chunk increases (earlier value\nof numDocsPerChunk was hardcoded to 1000) and based on the\naccess pattern we might end up uncompressing a bigger chunk to get values\nfor a set of docIds. We have made this change configurable.\nSo the default behaviour is same as old (1000 docs per chunk)\n\n(2) PR https://github.com/apache/incubator-pinot/pull/4791\nadded support for noDict for STRING/BYTES in consuming segments.\nThere is a particular impact of this change on the use cases\nthat have set noDict on their STRING dimension columns for other performance\nreasons and also want metricsAggregation. These use cases don't get to\naggregateMetrics because the new implementation was able to honor their\ntable config setting of noDict on STRING/BYTES. Without metrics aggregation,\nmemory pressure increases. So to continue aggregating metrics for such cases,\nwe will create dictionary even if the column is part of noDictionary set\nfrom table config.", "committedDate": "2020-05-31T00:48:30Z", "type": "forcePushed"}]}