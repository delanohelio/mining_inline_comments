{"pr_number": 5331, "pr_title": "Optimize RealtimeDictionaryBasedRangePredicateEvaluator by not scanning the dictionary when cardinality is high", "pr_createdAt": "2020-05-05T04:44:47Z", "pr_url": "https://github.com/apache/pinot/pull/5331", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDEwMQ==", "url": "https://github.com/apache/pinot/pull/5331#discussion_r419894101", "bodyText": "Not related to this PR, just shall we start thinking of how to simplify those switch cases code blocks?", "author": "xiangfu0", "createdAt": "2020-05-05T06:41:32Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/RangePredicateEvaluatorFactory.java", "diffHunk": "@@ -169,19 +171,59 @@ public int getNumMatchingDictIds() {\n   }\n \n   private static final class RealtimeDictionaryBasedRangePredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {\n+    // When the cardinality of the column is lower than this threshold, pre-calculate the matching dictionary ids;\n+    // otherwise, fetch the value when evaluating each dictionary id.\n+    // TODO: Tune this threshold\n+    private static final int DICT_ID_SET_BASED_CARDINALITY_THRESHOLD = 1000;\n+\n+    final BaseMutableDictionary _dictionary;\n+    final DataType _dataType;\n+    final boolean _dictIdSetBased;\n     final IntSet _matchingDictIdSet;\n-    final int _numMatchingDictIds;\n-    int[] _matchingDictIds;\n-\n-    RealtimeDictionaryBasedRangePredicateEvaluator(RangePredicate rangePredicate, BaseMutableDictionary dictionary) {\n-      _matchingDictIdSet = dictionary\n-          .getDictIdsInRange(rangePredicate.getLowerBoundary(), rangePredicate.getUpperBoundary(),\n-              rangePredicate.includeLowerBoundary(), rangePredicate.includeUpperBoundary());\n-      _numMatchingDictIds = _matchingDictIdSet.size();\n-      if (_numMatchingDictIds == 0) {\n-        _alwaysFalse = true;\n-      } else if (_numMatchingDictIds == dictionary.length()) {\n-        _alwaysTrue = true;\n+    final BaseRawValueBasedPredicateEvaluator _rawValueBasedEvaluator;\n+\n+    RealtimeDictionaryBasedRangePredicateEvaluator(RangePredicate rangePredicate, BaseMutableDictionary dictionary,\n+        DataType dataType) {\n+      _dictionary = dictionary;\n+      _dataType = dataType;\n+      int cardinality = dictionary.length();\n+      if (cardinality < DICT_ID_SET_BASED_CARDINALITY_THRESHOLD) {\n+        _dictIdSetBased = true;\n+        _rawValueBasedEvaluator = null;\n+        _matchingDictIdSet = dictionary\n+            .getDictIdsInRange(rangePredicate.getLowerBoundary(), rangePredicate.getUpperBoundary(),\n+                rangePredicate.includeLowerBoundary(), rangePredicate.includeUpperBoundary());\n+        int numMatchingDictIds = _matchingDictIdSet.size();\n+        if (numMatchingDictIds == 0) {\n+          _alwaysFalse = true;\n+        } else if (numMatchingDictIds == cardinality) {\n+          _alwaysTrue = true;\n+        }\n+      } else {\n+        _dictIdSetBased = false;\n+        _matchingDictIdSet = null;\n+        switch (dataType) {", "originalCommit": "ec03154343df4831e33092a247505ef0af3d9daf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "021e062e454391a0aec9ca2d89285f52fcc2da38", "url": "https://github.com/apache/pinot/commit/021e062e454391a0aec9ca2d89285f52fcc2da38", "message": "Optimize RealtimeDictionaryBasedRangePredicateEvaluator by not scanning the dictionary when cardinality is high\n\nFor real-time range predicate, because the dictionary is not sorted, in order to get the matching dictionary ids, we have to scan the whole dictionary.\nThis will cause performance issue when the cardinality is high for the column.\nOptimize it by adding a cardinality threshold (1000 for now) to decide whether to pre-calculate all the matching dictionary ids.", "committedDate": "2020-05-05T18:37:32Z", "type": "commit"}, {"oid": "021e062e454391a0aec9ca2d89285f52fcc2da38", "url": "https://github.com/apache/pinot/commit/021e062e454391a0aec9ca2d89285f52fcc2da38", "message": "Optimize RealtimeDictionaryBasedRangePredicateEvaluator by not scanning the dictionary when cardinality is high\n\nFor real-time range predicate, because the dictionary is not sorted, in order to get the matching dictionary ids, we have to scan the whole dictionary.\nThis will cause performance issue when the cardinality is high for the column.\nOptimize it by adding a cardinality threshold (1000 for now) to decide whether to pre-calculate all the matching dictionary ids.", "committedDate": "2020-05-05T18:37:32Z", "type": "forcePushed"}]}