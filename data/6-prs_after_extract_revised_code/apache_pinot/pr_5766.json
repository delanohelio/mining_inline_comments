{"pr_number": 5766, "pr_title": "Adding distinct count support based on bitmap", "pr_createdAt": "2020-07-29T00:21:57Z", "pr_url": "https://github.com/apache/pinot/pull/5766", "timeline": [{"oid": "e08ecfe2bf60e72ef8a6163842a6b235493ac74e", "url": "https://github.com/apache/pinot/commit/e08ecfe2bf60e72ef8a6163842a6b235493ac74e", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-29T07:34:31Z", "type": "forcePushed"}, {"oid": "a68bfba4537c7d5b5271df668265a26a617d3fc2", "url": "https://github.com/apache/pinot/commit/a68bfba4537c7d5b5271df668265a26a617d3fc2", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-29T17:35:11Z", "type": "forcePushed"}, {"oid": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "url": "https://github.com/apache/pinot/commit/20b6ec5119ed7677fcde5f39348ec9e780eb582a", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-07-30T00:09:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNjI2MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463706260", "bodyText": "javadoc would be good.", "author": "siddharthteotia", "createdAt": "2020-07-31T16:21:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MzAwMQ==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463873001", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-07-31T22:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNjI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\nindex f74be52fd8..fbb515390f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n\n@@ -34,6 +34,11 @@ import org.roaringbitmap.PeekableIntIterator;\n import org.roaringbitmap.RoaringBitmap;\n \n \n+/**\n+ * The {@code DistinctCountBitmapAggregationFunction} calculates the number of distinct values for a given single-value\n+ * expression using RoaringBitmap. The bitmap stores the actual values for {@code INT} expression, or hash code of the\n+ * values for other data types (values with the same hash code will only be counted once).\n+ */\n public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n   protected Dictionary _dictionary;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzI2MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463707260", "bodyText": "So DistinctCount stores dictionaryId in IntHashSet (with your recent change) and here we store them in a bitmap. I am guessing this is more space efficient?", "author": "siddharthteotia", "createdAt": "2020-07-31T16:23:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n+  protected Dictionary _dictionary;\n+\n+  public DistinctCountBitmapAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTBITMAP;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+      if (bitmap != null) {\n+        for (int i = 0; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      } else {\n+        bitmap = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[0]);\n+        aggregationResultHolder.setValue(bitmap);\n+        for (int i = 1; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    RoaringBitmap bitmap = getBitmap(aggregationResultHolder);\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      bitmap.addN(dictIds, 0, length);\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        bitmap.addN(intValues, 0, length);\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        int groupKey = groupKeyArray[i];\n+        RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+        if (bitmap != null) {\n+          bitmap.or(value);\n+        } else {\n+          groupByResultHolder.setValueForKey(groupKey, value);\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        getBitmap(groupByResultHolder, groupKeyArray[i]).add(dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        for (int groupKey : groupKeysArray[i]) {\n+          RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+          if (bitmap != null) {\n+            bitmap.or(value);\n+          } else {\n+            // Clone a bitmap for the group\n+            groupByResultHolder.setValueForKey(groupKey, value.clone());\n+          }\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTc4Ng==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463885786", "bodyText": "Did a performance comparison on IntOpenHashSet vs RoaringBitmap vs BitSet, and find that the performance: BitSet > RoaringBitmap >> IntOpenHashSet. So here we use RoaringBitmap for good performance + good compression.", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNzI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\nindex f74be52fd8..fbb515390f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n\n@@ -34,6 +34,11 @@ import org.roaringbitmap.PeekableIntIterator;\n import org.roaringbitmap.RoaringBitmap;\n \n \n+/**\n+ * The {@code DistinctCountBitmapAggregationFunction} calculates the number of distinct values for a given single-value\n+ * expression using RoaringBitmap. The bitmap stores the actual values for {@code INT} expression, or hash code of the\n+ * values for other data types (values with the same hash code will only be counted once).\n+ */\n public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n   protected Dictionary _dictionary;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODU1OA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463708558", "bodyText": "This doesn't really look like a good use of bitmap for space efficiency purpose. We are storing the hashcodes of real values in the bitmap for result extraction\nSince the range of hashcodes could be arbitrary (as opposed to 0 .. N-1 for dictionaryIds), I wonder if bitmap will end up consuming more space here?", "author": "siddharthteotia", "createdAt": "2020-07-31T16:25:50Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.common.utils.DataSchema.ColumnDataType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.common.ObjectSerDeUtils;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.ObjectAggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.ObjectGroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.PeekableIntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n+  protected Dictionary _dictionary;\n+\n+  public DistinctCountBitmapAggregationFunction(ExpressionContext expression) {\n+    super(expression);\n+  }\n+\n+  @Override\n+  public AggregationFunctionType getType() {\n+    return AggregationFunctionType.DISTINCTCOUNTBITMAP;\n+  }\n+\n+  @Override\n+  public void accept(AggregationFunctionVisitorBase visitor) {\n+    visitor.visit(this);\n+  }\n+\n+  @Override\n+  public AggregationResultHolder createAggregationResultHolder() {\n+    return new ObjectAggregationResultHolder();\n+  }\n+\n+  @Override\n+  public GroupByResultHolder createGroupByResultHolder(int initialCapacity, int maxCapacity) {\n+    return new ObjectGroupByResultHolder(initialCapacity, maxCapacity);\n+  }\n+\n+  @Override\n+  public void aggregate(int length, AggregationResultHolder aggregationResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+      if (bitmap != null) {\n+        for (int i = 0; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      } else {\n+        bitmap = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[0]);\n+        aggregationResultHolder.setValue(bitmap);\n+        for (int i = 1; i < length; i++) {\n+          bitmap.or(ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]));\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    RoaringBitmap bitmap = getBitmap(aggregationResultHolder);\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      bitmap.addN(dictIds, 0, length);\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        bitmap.addN(intValues, 0, length);\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          bitmap.add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupBySV(int length, int[] groupKeyArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        int groupKey = groupKeyArray[i];\n+        RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+        if (bitmap != null) {\n+          bitmap.or(value);\n+        } else {\n+          groupByResultHolder.setValueForKey(groupKey, value);\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        getBitmap(groupByResultHolder, groupKeyArray[i]).add(dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          getBitmap(groupByResultHolder, groupKeyArray[i]).add(stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public void aggregateGroupByMV(int length, int[][] groupKeysArray, GroupByResultHolder groupByResultHolder,\n+      Map<ExpressionContext, BlockValSet> blockValSetMap) {\n+    BlockValSet blockValSet = blockValSetMap.get(_expression);\n+\n+    // Treat BYTES value as serialized RoaringBitmap\n+    DataType valueType = blockValSet.getValueType();\n+    if (valueType == DataType.BYTES) {\n+      byte[][] bytesValues = blockValSet.getBytesValuesSV();\n+      for (int i = 0; i < length; i++) {\n+        RoaringBitmap value = ObjectSerDeUtils.ROARING_BITMAP_SER_DE.deserialize(bytesValues[i]);\n+        for (int groupKey : groupKeysArray[i]) {\n+          RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+          if (bitmap != null) {\n+            bitmap.or(value);\n+          } else {\n+            // Clone a bitmap for the group\n+            groupByResultHolder.setValueForKey(groupKey, value.clone());\n+          }\n+        }\n+      }\n+      return;\n+    }\n+\n+    // For dictionary-encoded expression, store dictionary ids into the bitmap\n+    Dictionary dictionary = blockValSet.getDictionary();\n+    if (dictionary != null) {\n+      _dictionary = dictionary;\n+      int[] dictIds = blockValSet.getDictionaryIdsSV();\n+      for (int i = 0; i < length; i++) {\n+        setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], dictIds[i]);\n+      }\n+      return;\n+    }\n+\n+    // For non-dictionary-encoded expression, store hash code of the values into the bitmap\n+    switch (valueType) {\n+      case INT:\n+        int[] intValues = blockValSet.getIntValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], intValues[i]);\n+        }\n+        break;\n+      case LONG:\n+        long[] longValues = blockValSet.getLongValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Long.hashCode(longValues[i]));\n+        }\n+        break;\n+      case FLOAT:\n+        float[] floatValues = blockValSet.getFloatValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Float.hashCode(floatValues[i]));\n+        }\n+        break;\n+      case DOUBLE:\n+        double[] doubleValues = blockValSet.getDoubleValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], Double.hashCode(doubleValues[i]));\n+        }\n+        break;\n+      case STRING:\n+        String[] stringValues = blockValSet.getStringValuesSV();\n+        for (int i = 0; i < length; i++) {\n+          setValueForGroupKeys(groupByResultHolder, groupKeysArray[i], stringValues[i].hashCode());\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            \"Illegal data type for DISTINCT_COUNT_BITMAP aggregation function: \" + valueType);\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap extractAggregationResult(AggregationResultHolder aggregationResultHolder) {\n+    RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+    if (bitmap == null) {\n+      return new RoaringBitmap();\n+    }\n+\n+    if (_dictionary != null) {\n+      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      return convertToValueBitmap(bitmap, _dictionary);\n+    } else {\n+      // For serialized RoaringBitmap and non-dictionary-encoded expression, directly return the bitmap\n+      return bitmap;\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap extractGroupByResult(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+    if (bitmap == null) {\n+      return new RoaringBitmap();\n+    }\n+\n+    if (_dictionary != null) {\n+      // For dictionary-encoded expression, convert dictionary ids to hash code of the values\n+      return convertToValueBitmap(bitmap, _dictionary);\n+    } else {\n+      // For serialized RoaringBitmap and non-dictionary-encoded expression, directly return the bitmap\n+      return bitmap;\n+    }\n+  }\n+\n+  @Override\n+  public RoaringBitmap merge(RoaringBitmap intermediateResult1, RoaringBitmap intermediateResult2) {\n+    intermediateResult1.or(intermediateResult2);\n+    return intermediateResult1;\n+  }\n+\n+  @Override\n+  public boolean isIntermediateResultComparable() {\n+    return false;\n+  }\n+\n+  @Override\n+  public ColumnDataType getIntermediateResultColumnType() {\n+    return ColumnDataType.OBJECT;\n+  }\n+\n+  @Override\n+  public ColumnDataType getFinalResultColumnType() {\n+    return ColumnDataType.INT;\n+  }\n+\n+  @Override\n+  public Integer extractFinalResult(RoaringBitmap intermediateResult) {\n+    return intermediateResult.getCardinality();\n+  }\n+\n+  /**\n+   * Returns the bitmap from the result holder or creates a new one if it does not exist.\n+   */\n+  protected static RoaringBitmap getBitmap(AggregationResultHolder aggregationResultHolder) {\n+    RoaringBitmap bitmap = aggregationResultHolder.getResult();\n+    if (bitmap == null) {\n+      bitmap = new RoaringBitmap();\n+      aggregationResultHolder.setValue(bitmap);\n+    }\n+    return bitmap;\n+  }\n+\n+  /**\n+   * Returns the bitmap for the given group key or creates a new one if it does not exist.\n+   */\n+  protected static RoaringBitmap getBitmap(GroupByResultHolder groupByResultHolder, int groupKey) {\n+    RoaringBitmap bitmap = groupByResultHolder.getResult(groupKey);\n+    if (bitmap == null) {\n+      bitmap = new RoaringBitmap();\n+      groupByResultHolder.setValueForKey(groupKey, bitmap);\n+    }\n+    return bitmap;\n+  }\n+\n+  /**\n+   * Helper method to set value for the given group keys into the result holder.\n+   */\n+  private void setValueForGroupKeys(GroupByResultHolder groupByResultHolder, int[] groupKeys, int value) {\n+    for (int groupKey : groupKeys) {\n+      getBitmap(groupByResultHolder, groupKey).add(value);\n+    }\n+  }\n+\n+  /**\n+   * Helper method to read dictionary and convert dictionary ids to hash code of the values for dictionary-encoded\n+   * expression.\n+   */\n+  private static RoaringBitmap convertToValueBitmap(RoaringBitmap dictIdBitmap, Dictionary dictionary) {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjIwMg==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886202", "bodyText": "That is exactly the purpose of using RoaringBitmap, which is the well compressed version of the BitSet. The serialized RoaringBitmap size is much smaller than the serialized IntOpenHashSet.", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\nindex f74be52fd8..fbb515390f 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapAggregationFunction.java\n\n@@ -34,6 +34,11 @@ import org.roaringbitmap.PeekableIntIterator;\n import org.roaringbitmap.RoaringBitmap;\n \n \n+/**\n+ * The {@code DistinctCountBitmapAggregationFunction} calculates the number of distinct values for a given single-value\n+ * expression using RoaringBitmap. The bitmap stores the actual values for {@code INT} expression, or hash code of the\n+ * values for other data types (values with the same hash code will only be counted once).\n+ */\n public class DistinctCountBitmapAggregationFunction extends BaseSingleInputAggregationFunction<RoaringBitmap, Integer> {\n   protected Dictionary _dictionary;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODY1NQ==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463708655", "bodyText": "Javadoc would be good", "author": "siddharthteotia", "createdAt": "2020-07-31T16:26:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.query.aggregation.function;\n+\n+import java.util.Map;\n+import org.apache.pinot.common.function.AggregationFunctionType;\n+import org.apache.pinot.core.common.BlockValSet;\n+import org.apache.pinot.core.query.aggregation.AggregationResultHolder;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupByResultHolder;\n+import org.apache.pinot.core.query.request.context.ExpressionContext;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.spi.data.FieldSpec.DataType;\n+import org.roaringbitmap.RoaringBitmap;\n+\n+\n+public class DistinctCountBitmapMVAggregationFunction extends DistinctCountBitmapAggregationFunction {", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjIwNw==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886207", "bodyText": "Added", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwODY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java\nindex 99a1f4fe03..2f5dbba36c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/query/aggregation/function/DistinctCountBitmapMVAggregationFunction.java\n\n@@ -29,6 +29,11 @@ import org.apache.pinot.spi.data.FieldSpec.DataType;\n import org.roaringbitmap.RoaringBitmap;\n \n \n+/**\n+ * The {@code DistinctCountBitmapMVAggregationFunction} calculates the number of distinct values for a given multi-value\n+ * expression using RoaringBitmap. The bitmap stores the actual values for {@code INT} expression, or hash code of the\n+ * values for other data types (values with the same hash code will only be counted once).\n+ */\n public class DistinctCountBitmapMVAggregationFunction extends DistinctCountBitmapAggregationFunction {\n \n   public DistinctCountBitmapMVAggregationFunction(ExpressionContext expression) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwOTExNg==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463709116", "bodyText": "Do we not need to add end-to-end query execution test for the new function without star tree as well", "author": "siddharthteotia", "createdAt": "2020-07-31T16:27:02Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/startree/v2/DistinctCountBitmapStarTreeV2Test.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.startree.v2;", "originalCommit": "20b6ec5119ed7677fcde5f39348ec9e780eb582a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjI5MA==", "url": "https://github.com/apache/pinot/pull/5766#discussion_r463886290", "bodyText": "Good point, will add", "author": "Jackie-Jiang", "createdAt": "2020-07-31T23:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwOTExNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "url": "https://github.com/apache/pinot/commit/1a4405ff7832a77d76b08ab516fd70eaa3463895", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-08-01T00:30:42Z", "type": "commit"}, {"oid": "1a4405ff7832a77d76b08ab516fd70eaa3463895", "url": "https://github.com/apache/pinot/commit/1a4405ff7832a77d76b08ab516fd70eaa3463895", "message": "Add DistinctCountBitmap aggregation function", "committedDate": "2020-08-01T00:30:42Z", "type": "forcePushed"}]}