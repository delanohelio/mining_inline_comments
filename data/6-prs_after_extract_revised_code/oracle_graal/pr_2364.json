{"pr_number": 2364, "pr_title": "Apply trapping nullcheck to the uncompressed target for compressed po\u2026", "pr_createdAt": "2020-04-20T03:46:29Z", "pr_url": "https://github.com/oracle/graal/pull/2364", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r412887103", "bodyText": "Couldn't there be multiple uncompress usages?", "author": "dougxc", "createdAt": "2020-04-22T11:06:57Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java", "diffHunk": "@@ -287,4 +292,22 @@ private static void replaceWithTrappingNullCheck(AbstractDeoptimizeNode deopt, I\n         GraphUtil.killCFG(trappingContinuation);\n         GraphUtil.tryKillUnused(isNullNode);\n     }\n+\n+    private static NullCheckNode tryUseUncompressedNullCheck(ValueNode value, IsNullNode isNullNode) {\n+        assert isNullNode.getValue().equals(value);\n+        CompressionNode uncompressed = null;\n+        for (Node usage : value.usages()) {\n+            if (usage instanceof CompressionNode) {\n+                if (((CompressionNode) usage).getOp() == CompressionNode.CompressionOp.Uncompress) {\n+                    assert ((CompressionNode) usage).getValue().equals(value);\n+                    uncompressed = (CompressionNode) usage;", "originalCommit": "32032617a8714f69968d002d225834e8783b9010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MjMyOA==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r413492328", "bodyText": "I searched the codes that the uncompress is mostly generated together with its input. And If there are multiple uncompress usages, would they be optimized to a single one by GVN? If it exists the corner cases, I think we'd better add the restriction of the single usage of uncompress.", "author": "XiaohongGong", "createdAt": "2020-04-23T04:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwMjAzNA==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r413602034", "bodyText": "Yes, please add the restriction and only apply the transformation if there is a single uncompress usage.", "author": "dougxc", "createdAt": "2020-04-23T08:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwMjg2NQ==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r413602865", "bodyText": "OK! Thank you for review! I will update soon!", "author": "XiaohongGong", "createdAt": "2020-04-23T08:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwMzE0Mw==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r415203143", "bodyText": "Hi @dougxc I'v updated the patch according to your comment. So could you please take a look at it again? Thanks!", "author": "XiaohongGong", "createdAt": "2020-04-26T03:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM1MzYzMg==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r415353632", "bodyText": "Looks good. I've started the process of integration.", "author": "dougxc", "createdAt": "2020-04-26T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3ODQ1MA==", "url": "https://github.com/oracle/graal/pull/2364#discussion_r415478450", "bodyText": "Thanks again for your review!", "author": "XiaohongGong", "createdAt": "2020-04-27T03:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java b/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java\nindex f6108740abd..18750a906df 100644\n--- a/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java\n+++ b/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java\n\n@@ -300,8 +300,12 @@ public class UseTrappingNullChecksPhase extends BasePhase<LowTierContext> {\n             if (usage instanceof CompressionNode) {\n                 if (((CompressionNode) usage).getOp() == CompressionNode.CompressionOp.Uncompress) {\n                     assert ((CompressionNode) usage).getValue().equals(value);\n+                    if (uncompressed != null) {\n+                        // The value has multiple uncompression usages. We cannot move the nullcheck\n+                        // to any of them.\n+                        return null;\n+                    }\n                     uncompressed = (CompressionNode) usage;\n-                    break;\n                 }\n             }\n         }\n"}}, {"oid": "4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "url": "https://github.com/oracle/graal/commit/4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "message": "Apply trapping nullcheck to the uncompressed target for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for the\nsame compressed oop in Graal. One is inserted by the backend when it\nemits nullcheck. If the pointer is a compressed object, it should be\nuncompressed before the nullcheck is emitted. And another one is\ngenerated by the normal uncompressing operation. These two instructions\nare duplicated with each other.\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to apply the nullcheck to the uncompressed\nresult if it exists instead of to the compressed pointer when generating\nthe trapping nullcheck.\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb", "committedDate": "2020-04-23T10:31:32Z", "type": "forcePushed"}, {"oid": "e5b9f3f6a81704a862120dc6a4f78922865759f5", "url": "https://github.com/oracle/graal/commit/e5b9f3f6a81704a862120dc6a4f78922865759f5", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb", "committedDate": "2020-05-09T07:07:59Z", "type": "forcePushed"}, {"oid": "f49b7cd54cd012c49c52136a63724346c259a313", "url": "https://github.com/oracle/graal/commit/f49b7cd54cd012c49c52136a63724346c259a313", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb", "committedDate": "2020-05-13T04:18:55Z", "type": "forcePushed"}, {"oid": "68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "url": "https://github.com/oracle/graal/commit/68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]", "committedDate": "2020-11-06T07:44:50Z", "type": "commit"}, {"oid": "68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "url": "https://github.com/oracle/graal/commit/68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]", "committedDate": "2020-11-06T07:44:50Z", "type": "forcePushed"}]}