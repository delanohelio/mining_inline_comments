{"pr_number": 2766, "pr_title": "Fixing AArch64 emitCompare and zr/sp issues", "pr_createdAt": "2020-08-19T01:40:25Z", "pr_url": "https://github.com/oracle/graal/pull/2766", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgyOTMyNg==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472829326", "bodyText": "+1 because AArch64Assembler.java needs more asserts.", "author": "a74nh", "createdAt": "2020-08-19T07:57:34Z", "path": "compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java", "diffHunk": "@@ -1936,6 +1936,9 @@ public void subs(int size, Register dst, Register src1, Register src2, ShiftType\n     }\n \n     private void addSubShiftedInstruction(Instruction instr, Register dst, Register src1, Register src2, ShiftType shiftType, int imm, InstructionType type) {\n+        assert !dst.equals(sp);", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgzNzI5NA==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472837294", "bodyText": "Probably drop the LSL from the method name. Graal's ExtendType enum doesn't mention LSL.", "author": "a74nh", "createdAt": "2020-08-19T08:06:32Z", "path": "compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java", "diffHunk": "@@ -919,17 +919,25 @@ public void cset(int size, Register dst, ConditionFlag condition) {\n         super.csinc(size, dst, zr, zr, condition.negate());\n     }\n \n+    private static ExtendType getLSLExtendType(int size) {", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3NzA4Mw==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r473077083", "bodyText": "I wanted to have LSL in the name, since that is what I'm trying to encode there (it just so happens which type is LSL depends on the instruction size)", "author": "teshull", "createdAt": "2020-08-19T14:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgzNzI5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0MDY0Ng==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472840646", "bodyText": "Why drop the super. here? Is it because x might be sp?", "author": "a74nh", "createdAt": "2020-08-19T08:10:19Z", "path": "compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java", "diffHunk": "@@ -1802,28 +1813,24 @@ public void fmadd(int size, Register dst, Register src1, Register src2, Register\n      * Compares x and y and sets condition flags.\n      *\n      * @param size register size. Has to be 32 or 64.\n-     * @param x general purpose register. May not be null or stackpointer.\n+     * @param x general purpose register. May not be null.\n      * @param y general purpose register. May not be null or stackpointer.\n      */\n     public void cmp(int size, Register x, Register y) {\n         assert size == 32 || size == 64;\n-        super.subs(size, zr, x, y, ShiftType.LSL, 0);\n+        subs(size, zr, x, y);", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2OTQ3Mw==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r473069473", "bodyText": "Yes, I dropped the super so that it can call the aarch64macroassembler subs, which handles more combinations of xzr and sp", "author": "teshull", "createdAt": "2020-08-19T14:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0MDY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java b/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\nindex a0d4e17c0eb..07a0390d3c7 100755\n--- a/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\n+++ b/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\n\n@@ -1830,6 +1830,7 @@ public class AArch64MacroAssembler extends AArch64Assembler {\n      */\n     public void cmp(int size, Register x, int y) {\n         assert size == 32 || size == 64;\n+        assert isComparisonImmediate(y);\n         subs(size, zr, x, y);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0Mzc1OA==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472843758", "bodyText": "Do we want a assert(isComparisonImmediate(y)) check here?", "author": "a74nh", "createdAt": "2020-08-19T08:13:37Z", "path": "compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java", "diffHunk": "@@ -1802,28 +1813,24 @@ public void fmadd(int size, Register dst, Register src1, Register src2, Register\n      * Compares x and y and sets condition flags.\n      *\n      * @param size register size. Has to be 32 or 64.\n-     * @param x general purpose register. May not be null or stackpointer.\n+     * @param x general purpose register. May not be null.\n      * @param y general purpose register. May not be null or stackpointer.\n      */\n     public void cmp(int size, Register x, Register y) {\n         assert size == 32 || size == 64;\n-        super.subs(size, zr, x, y, ShiftType.LSL, 0);\n+        subs(size, zr, x, y);\n     }\n \n     /**\n      * Compares x to y and sets condition flags.\n      *\n      * @param size register size. Has to be 32 or 64.\n-     * @param x general purpose register. May not be null or stackpointer.\n+     * @param x general purpose register. May not be null or zero-register.\n      * @param y comparison immediate, {@link #isComparisonImmediate(long)} has to be true for it.", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4Njg0Ng==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r473086846", "bodyText": "Yeah, I agree. done", "author": "teshull", "createdAt": "2020-08-19T14:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0Mzc1OA=="}], "type": "inlineReview", "revised_code": {"commit": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java b/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\nindex a0d4e17c0eb..07a0390d3c7 100755\n--- a/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\n+++ b/compiler/src/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java\n\n@@ -1830,6 +1830,7 @@ public class AArch64MacroAssembler extends AArch64Assembler {\n      */\n     public void cmp(int size, Register x, int y) {\n         assert size == 32 || size == 64;\n+        assert isComparisonImmediate(y);\n         subs(size, zr, x, y);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg1Mzc5Nw==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472853797", "bodyText": "Ok, this turns \"cmp(sp,sp)\" into \"mov(r10,sp); cmp(r10,sp)\"\nFor cosmetic reasons, I want to say that you should update the right so that it does \"mov(r10,sp); cmp(r10,r10)\". But it's not going to make any difference.", "author": "a74nh", "createdAt": "2020-08-19T08:26:15Z", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -384,31 +385,44 @@ protected boolean emitCompare(PlatformKind cmpKind, Value a, Value b, Condition\n                 bExt = arithmeticLIRGen.emitSignExtend(b, compareBytes * 8, 64);\n             }\n \n-            if (LIRValueUtil.isVariable(bExt)) {\n-                left = load(bExt);\n+            /*\n+             * The AArch64 comparison instruction can treat register 31 as the stack pointer\n+             * register for the left operand, but not for the right operand.\n+             */\n+            boolean aIsStackPointer = ValueUtil.isRegister(aExt) && ValueUtil.asRegister(aExt).equals(AArch64.sp);\n+            boolean bIsStackPointer = ValueUtil.isRegister(bExt) && ValueUtil.asRegister(bExt).equals(AArch64.sp);\n+\n+            if (aIsStackPointer && bIsStackPointer) {\n+                // move b to a non-sp register", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExNzc1MA==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r473117750", "bodyText": "true. changed", "author": "teshull", "createdAt": "2020-08-19T15:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg1Mzc5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\nindex 6543d391f30..4d502a38805 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n\n@@ -387,18 +387,19 @@ public abstract class AArch64LIRGenerator extends LIRGenerator {\n \n             /*\n              * The AArch64 comparison instruction can treat register 31 as the stack pointer\n-             * register for the left operand, but not for the right operand.\n+             * register (sp) for the left operand, but not for the right operand.\n              */\n             boolean aIsStackPointer = ValueUtil.isRegister(aExt) && ValueUtil.asRegister(aExt).equals(AArch64.sp);\n             boolean bIsStackPointer = ValueUtil.isRegister(bExt) && ValueUtil.asRegister(bExt).equals(AArch64.sp);\n \n             if (aIsStackPointer && bIsStackPointer) {\n-                // move b to a non-sp register\n-                bIsStackPointer = false;\n-                bExt = emitMove(bExt);\n-            }\n-\n-            if (bIsStackPointer || (!aIsStackPointer && LIRValueUtil.isVariable(bExt))) {\n+                /*\n+                 * both a and b are sp, but this cannot be encoded in an AArch64 comparison. Hence,\n+                 * sp must be moved to a register.\n+                 */\n+                left = right = emitMove(aExt);\n+                mirrored = false;\n+            } else if (bIsStackPointer || (isCompareConstant(aExt) && !isCompareConstant(bExt))) {\n                 left = bExt;\n                 right = loadNonConst(aExt);\n                 mirrored = true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2Njg5NA==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r472866894", "bodyText": "All the changes in this patch make sense individually. But, I can't see what's actually removing the unnecessary loads. Is it the use of loadReg instead or load?", "author": "a74nh", "createdAt": "2020-08-19T08:47:28Z", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -384,31 +385,44 @@ protected boolean emitCompare(PlatformKind cmpKind, Value a, Value b, Condition\n                 bExt = arithmeticLIRGen.emitSignExtend(b, compareBytes * 8, 64);\n             }\n \n-            if (LIRValueUtil.isVariable(bExt)) {\n-                left = load(bExt);\n+            /*\n+             * The AArch64 comparison instruction can treat register 31 as the stack pointer\n+             * register for the left operand, but not for the right operand.\n+             */\n+            boolean aIsStackPointer = ValueUtil.isRegister(aExt) && ValueUtil.asRegister(aExt).equals(AArch64.sp);\n+            boolean bIsStackPointer = ValueUtil.isRegister(bExt) && ValueUtil.asRegister(bExt).equals(AArch64.sp);\n+\n+            if (aIsStackPointer && bIsStackPointer) {\n+                // move b to a non-sp register\n+                bIsStackPointer = false;\n+                bExt = emitMove(bExt);\n+            }\n+\n+            if (bIsStackPointer || (!aIsStackPointer && LIRValueUtil.isVariable(bExt))) {\n+                left = bExt;\n                 right = loadNonConst(aExt);\n                 mirrored = true;\n             } else {\n-                left = load(aExt);\n+                left = aExt;\n                 right = loadNonConst(bExt);\n                 mirrored = false;\n             }\n-            append(new AArch64Compare.CompareOp(left, loadNonCompareConst(right)));\n+            append(new AArch64Compare.CompareOp(loadReg(left), loadNonCompareConst(right)));", "originalCommit": "2c7fd2ed978304ffbbdabe8385652048789730ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4MTIzNg==", "url": "https://github.com/oracle/graal/pull/2766#discussion_r473081236", "bodyText": "Yes. Using load will introduce moves for values already assigned a registervalue. In general it would be a good idea to remove all unneeded loads in the code", "author": "teshull", "createdAt": "2020-08-19T14:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2Njg5NA=="}], "type": "inlineReview", "revised_code": {"commit": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\nindex 6543d391f30..4d502a38805 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n\n@@ -387,18 +387,19 @@ public abstract class AArch64LIRGenerator extends LIRGenerator {\n \n             /*\n              * The AArch64 comparison instruction can treat register 31 as the stack pointer\n-             * register for the left operand, but not for the right operand.\n+             * register (sp) for the left operand, but not for the right operand.\n              */\n             boolean aIsStackPointer = ValueUtil.isRegister(aExt) && ValueUtil.asRegister(aExt).equals(AArch64.sp);\n             boolean bIsStackPointer = ValueUtil.isRegister(bExt) && ValueUtil.asRegister(bExt).equals(AArch64.sp);\n \n             if (aIsStackPointer && bIsStackPointer) {\n-                // move b to a non-sp register\n-                bIsStackPointer = false;\n-                bExt = emitMove(bExt);\n-            }\n-\n-            if (bIsStackPointer || (!aIsStackPointer && LIRValueUtil.isVariable(bExt))) {\n+                /*\n+                 * both a and b are sp, but this cannot be encoded in an AArch64 comparison. Hence,\n+                 * sp must be moved to a register.\n+                 */\n+                left = right = emitMove(aExt);\n+                mirrored = false;\n+            } else if (bIsStackPointer || (isCompareConstant(aExt) && !isCompareConstant(bExt))) {\n                 left = bExt;\n                 right = loadNonConst(aExt);\n                 mirrored = true;\n"}}, {"oid": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "url": "https://github.com/oracle/graal/commit/46140f9f7b2110afd3bda5c70ae6d171f7a06604", "message": "Fixing AArch64 emitCompare and zr/sp issues\n\nPreviously the AArch64 emitCompare was issuing many unnecessary loads.\nIn addition, some of the logic for using zr/sp within cmp, sub(s), and\nadd(s) needed to be fixed.", "committedDate": "2020-08-19T15:43:07Z", "type": "commit"}, {"oid": "46140f9f7b2110afd3bda5c70ae6d171f7a06604", "url": "https://github.com/oracle/graal/commit/46140f9f7b2110afd3bda5c70ae6d171f7a06604", "message": "Fixing AArch64 emitCompare and zr/sp issues\n\nPreviously the AArch64 emitCompare was issuing many unnecessary loads.\nIn addition, some of the logic for using zr/sp within cmp, sub(s), and\nadd(s) needed to be fixed.", "committedDate": "2020-08-19T15:43:07Z", "type": "forcePushed"}]}