{"pr_number": 2181, "pr_title": "AArch64: Conditionally use barriers for atomic operations.", "pr_createdAt": "2020-02-24T06:50:48Z", "pr_url": "https://github.com/oracle/graal/pull/2181", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r383105443", "bodyText": "Temporarily insert a full barrier after each atomic operations, even though it is a non-conservative model. This is added here to resolve the renassiance banchmark hang issue (#2045) when \"STLXR\" is used together with \"LDR/DMB\" for java volatile read. This issue can also be resolved once \"LDAR/STLR\" is used for java volatile access. So once the PR #1772 is merged, the temporarily codes can be deleted.", "author": "XiaohongGong", "createdAt": "2020-02-24T06:56:42Z", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "originalCommit": "c8db37bc7a888351be06ccab499852a11057e291", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MDcyNg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397240726", "bodyText": "Yes that will do until the other PR gets pushed.", "author": "adinn", "createdAt": "2020-03-24T15:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjUwNg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425072506", "bodyText": "That condition on \"useLSE\" doesn't make much sense to me. LSE instructions don't have full barrier semantics any more than LDAXR/STLXR instructions do.", "author": "theRealAph", "createdAt": "2020-05-14T11:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODA1MQ==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435008051", "bodyText": "This temporary codes have been removed since PR 1772 has been merged. Thanks!", "author": "XiaohongGong", "createdAt": "2020-06-04T05:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3adf06358ae733ae5e8edba94144e51da78182f1", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java b/compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java\nindex 4e0cf17512e..35365dc295d 100644\n--- a/compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java\n+++ b/compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java\n\n@@ -85,12 +84,12 @@ public class AArch64AtomicMove {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n-            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+            if (useBarriers) {\n                 masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n-                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false, false);\n                 masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n             } else {\n-                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                emitCompareAndSwap(masm, size, address, result, newVal, true, true);\n                 if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n                     // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n                     // used for java volatile read.\n"}}, {"oid": "ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "url": "https://github.com/oracle/graal/commit/ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-02-27T01:35:51Z", "type": "forcePushed"}, {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "url": "https://github.com/oracle/graal/commit/fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-03-23T04:13:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397246382", "bodyText": "I think it would be cleaner to pass a new flag into the existing methods instead of adding a whole new method.  Other platforms might ignore it but that's fine.", "author": "tkrodriguez", "createdAt": "2020-03-24T15:33:04Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "diffHunk": "@@ -155,6 +155,15 @@ default boolean mayEmbedConstantLoad(Constant constant) {\n \n     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n \n+    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,", "originalCommit": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3ODk4NQ==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397578985", "bodyText": "Yes, in a sense it should be better. I was expecting to not have too much modifications for other platforms, especially the modifications to the common existing API. That's why I decided to add a new function here.", "author": "XiaohongGong", "createdAt": "2020-03-25T02:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0MzE1Mg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r424343152", "bodyText": "Update the patch to use a new flag!", "author": "XiaohongGong", "createdAt": "2020-05-13T10:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3adf06358ae733ae5e8edba94144e51da78182f1", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java b/compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java\nindex 5983edb8596..25a48500b85 100644\n--- a/compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java\n+++ b/compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java\n\n@@ -151,18 +151,9 @@ public interface LIRGeneratorTool extends DiagnosticLIRGeneratorTool, ValueKindF\n \n     void emitNullCheck(Value address, LIRFrameState state);\n \n-    Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue);\n+    Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValues, boolean useBarriers);\n \n-    Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n-\n-    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,\n-                    Value newValue, Value trueValue, Value falseValue) {\n-        return emitLogicCompareAndSwap(accessKind, address, expectedValue, newValue, trueValue, falseValue);\n-    }\n-\n-    default Value emitJavaValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {\n-        return emitValueCompareAndSwap(accessKind, address, expectedValue, newValue);\n-    }\n+    Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, boolean useBarriers);\n \n     /**\n      * Emit an atomic read-and-add instruction.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397250574", "bodyText": "I think I understand the practical meaning of this flag but I'm not sure the naming is clear enough.  So basically in ARM there are 2 ways of doing volatiles and this flag is meant to distinguish between these 2 cases?  In almost all cases Java volatile should be considered the normal one I think and maybe this flag should be something like isNonStandardVolatile?  Actually what are there cases where we use a CompareAndSwapNode against a location which is acquired using the other sequence?", "author": "tkrodriguez", "createdAt": "2020-03-24T15:38:24Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "originalCommit": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjMwNQ==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397272305", "bodyText": "There are indeed two ways of generating compare and swap code. The choice of generation strategy depends on two factors: what location is being updated and what value has been set for a AArch64 flag (UseBarriersForVolatile).\nIf UseBarriersForVolatile is true then all compare and swap operations use ldxr and stxr combined with dmb instructions.\nIf UseBarriersForVolatile is false then the nature of the memory location comes into play.\nWhen the location is a Java field then ldaxr and stlxr need to be be used. This is consistent with the semantics employed for generating Java volatile reads and implemented in PR 1772 where they translate to ldar and stlr.\nHowever, since PR has not yet been merged1772 XiahongGong has added an extra dmb at the end of ldax/stlxr sequence to deal with the disparity between the translation this patch implements and the current translation for volatiles a combination of ldr/str with dmb instructions.\nWhen the location is not a Java field then the code must use ldxr, stxr combined with dmb instructions. This is consistent with normal expectations regarding memory synchronization  non-Java data.", "author": "adinn", "createdAt": "2020-03-24T16:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NTQ5Ng==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397285496", "bodyText": "Ok, but why are the other locations that are using isJavaVolatile == false correct?  Are all of those clearly non-Java locations?  For instance in the context of SVM I think everything is a Java volatile.", "author": "tkrodriguez", "createdAt": "2020-03-24T16:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MzAzMA==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397343030", "bodyText": "As I understand it (I hope XiaohongHong will correct me if I misrepresent things) XiaohongHong has only wired up the unsafe plugins for compare and exchange/swap to pass true. Those are cases that are known to correspond to a Java application program explicitly posting a read or write to Java data. The relaxing of the semantics in these cases is compatible with the optimization implemented by PR 1772 when UseBarriersForVolatile is false and improves performance. Or rather it will be when 1772 is merged and we can omit the trailing barriers that are still in place for this patch.\nIn other cases where code internal to the JIT or Substrate creates an UnsafeCompareAndSwapNode or UnsafeCompareAndExchangeNode via the original constructor the value defaults to false which means the generator uses a more heavyweight barrier-based translation. This alternative is always consistent (on all known AArch64 arches) whether or not PR 1772 is in place. It is just less performant.\nThe reason the other cases have not been changed to use ldaxr/stlxr  is because it was not clear whether these internal uses were expecting other accesses to the target locations to be simple Java volatile field reads and writes (which would be correctly handled by the JIT once PR 1772 was merged) or to require the full semantics that is normally expected for compare and swap. The idea was to leave them as is and then convert the relevant uses one by one as needed. If you can confirm that all cases where the existing code explicitly constructs an UnsafeCompareAndSwapNode or UnsafeCompareAndExchangeNode are compatible with PR 1772 then we don't need to worry about the isJavaVolatile == false case and can always use this optimization.", "author": "adinn", "createdAt": "2020-03-24T17:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3MzY4MA==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397373680", "bodyText": "Yes that's what I'm getting at.  So for instance does the CompareAndSwapNode that we emit in the MonitorSnippets using Pointer.compareAndSwapWord need to use the conservative pattern because HotSpot uses a different pattern or can it use the more optimal pattern?  In the context of this PR it might be helpful to eliminate the constructor that passes the default value to make it more clear where we have to think about the setting of this flag.\nIn the context of SVM it's really only talking to itself I think so I would guess that always using the optimal pattern would be possible though it could necessary to have an escape hatch.\nApart from the Unsafe plugin, selecting the kind of volatile based on the LocationIdentity might work fairly well.  In the MonitorSnippets case for instance the MARK_WORD_LOCATION could be used to select the right kind for Hotspot if it needs something different but still do the normal thing for SVM.  Anyway, I'd like to get more clarity on which cases we actually need.", "author": "tkrodriguez", "createdAt": "2020-03-24T18:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTc4NA==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397599784", "bodyText": "We mainly concerns the usages in SVM, like in JNIJavaVM.addJavaVM and others in isolated, and its future usages in the internal VM of native image like GC. I'm not very much sure about where we should add the conservative barriers. But just in case, I think we should add a choice for the developer.\nFor the MonitorSnippets in HotSpot, interpreter and C1 always uses the conservative model while C2 uses the same one with Graal now.\nFor the isJavaVolatile flag, do you mean we should eliminate the constructor that will set the default value to it, or just delete it because we could also decide the memory model based on the LocationIdentity?", "author": "XiaohongGong", "createdAt": "2020-03-25T04:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5MDQwMg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397690402", "bodyText": "Anyway, I'd like to get more clarity on which cases we actually need\n\nWell, yeah, me too ;-) Only I'm not really in a position to determine that. That's why the current change was chosen: to be conservative and minimally invasive while still allowing further optimizations to be applied gradually as opportunities were  identified.\nYou are right that compilation for Substrate can probably always use the optimized model and that includes, say, the MonitorSnippets case. However, that code is currently shared with the Hotspot generation case. I'm not really clear how to separate those cases and apply the right transformation and I don't believe XiahongGong is. Advice would be very welcome.", "author": "adinn", "createdAt": "2020-03-25T08:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMzQ4OQ==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r424833489", "bodyText": "Hi @tkrodriguez , I have renamed the isJavaVolatile flag to useBarriers and eliminated the constructor that sets the default value to it. Besides, I did the modifications compared to the last version:\n\nAdd a conservative field for LocationIdentity to decide whether to use the full semantic barriers for VM internal atomic operations. I only set the flag for the CAS used LocationIdentity in MonitorSnippets currently. People can set the flag for other atomic operations if needed in future.\nRemove the reference of UseBarriersForVolatile, always use the optimized ldaxr/stlxr pattern for java Unsafe atomics.\n\nCould you please take a look whether this version is more reasonable? Thanks!", "author": "XiaohongGong", "createdAt": "2020-05-14T02:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAxMzc5Mg==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425013792", "bodyText": "The reason HotSpot uses the \"conservative\" memory barriers is that it's very old code, and no-one could guarantee that \"merely\" sequentially-consistent operations would be adequate. However, I believe that SC is really adequate for HotSpot and we quietly used such operations in the AArch64 port for years until someone noticed. Graal shouldn't need anything more than SC, and if it does anywhere, that's a bug in Graal. IMO.", "author": "theRealAph", "createdAt": "2020-05-14T09:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAzODI1Mw==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425038253", "bodyText": "Hi @theRealAph, thanks for looking at this PR. So do you mean \"ldaxr/stlxr\" is SC enough for vm internal atomics like monitor operations in Graal?  Actually we didn't met any issue for it.", "author": "XiaohongGong", "createdAt": "2020-05-14T10:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NDA5Ng==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425074096", "bodyText": "Yes, that's what I mean. However, it is possible that there is (broken) code elsewhere in Graal which assumes monitors, CAS, etc. have full-barrier semantics. I have no idea how to find such code.", "author": "theRealAph", "createdAt": "2020-05-14T11:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NDUxMQ==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425684511", "bodyText": "Yes, I'm also worried about the possible scenario and actually have no idea to make a decision. However, the main purpose of this PR is to add the full-barrier alternative implementation for CAS, so that people can have a chance to use it if needed in future.  If there is not any known issue for the current pattern (ldaxr/stlxr) used in hotspot monitor (since we have used it for long times in C2), I think we can keep using it currently in Graal. But it's still worth to add the full-barrier alternative implementation in Graal.", "author": "XiaohongGong", "createdAt": "2020-05-15T09:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "3adf06358ae733ae5e8edba94144e51da78182f1", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java b/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java\nindex e07e7d85b99..a8aa2d6bb03 100644\n--- a/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java\n+++ b/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java\n\n@@ -50,7 +50,7 @@ public abstract class AbstractCompareAndSwapNode extends FixedAccessNode impleme\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n-    protected final boolean isJavaVolatile;\n+    protected final boolean useBarriers;\n \n     @Override\n     public FrameState stateAfter() {\n"}}, {"oid": "3adf06358ae733ae5e8edba94144e51da78182f1", "url": "https://github.com/oracle/graal/commit/3adf06358ae733ae5e8edba94144e51da78182f1", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-05-13T10:40:45Z", "type": "forcePushed"}, {"oid": "cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "url": "https://github.com/oracle/graal/commit/cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-05-14T02:21:27Z", "type": "forcePushed"}, {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673", "url": "https://github.com/oracle/graal/commit/2f01e36c3eb0328d00058eb4d627be84850e6673", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-06-04T05:38:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDc5Ng==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435410796", "bodyText": "Shouldn't this be checking that true and false are 1 and 0 respectively?", "author": "tkrodriguez", "createdAt": "2020-06-04T17:01:05Z", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -151,21 +151,23 @@ public AArch64AddressValue asAddressValue(Value address) {\n     }\n \n     @Override\n-    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {\n-        Variable prevValue = newVariable(expectedValue.getValueKind());\n-        Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));\n-        append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));\n+    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue, boolean useBarriers) {\n+        emitCompareAndSwap(address, expectedValue, newValue, useBarriers);\n         assert trueValue.getValueKind().equals(falseValue.getValueKind());\n         Variable result = newVariable(trueValue.getValueKind());\n-        append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));", "originalCommit": "2f01e36c3eb0328d00058eb4d627be84850e6673", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY2OTE3Ng==", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435669176", "bodyText": "It's 1 and 0 respectively. However, I think adding an assert is better. I will fix it. Thanks for reminding!", "author": "XiaohongGong", "createdAt": "2020-06-05T03:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "chunk": "diff --git a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\nindex 36e756b1266..cf1a2447367 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java\n\n@@ -154,6 +154,7 @@ public abstract class AArch64LIRGenerator extends LIRGenerator {\n     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue, boolean useBarriers) {\n         emitCompareAndSwap(address, expectedValue, newValue, useBarriers);\n         assert trueValue.getValueKind().equals(falseValue.getValueKind());\n+        assert isIntConstant(trueValue, 1) && isIntConstant(falseValue, 0);\n         Variable result = newVariable(trueValue.getValueKind());\n         append(new CondSetOp(result, ConditionFlag.EQ));\n         return result;\n"}}, {"oid": "e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "url": "https://github.com/oracle/graal/commit/e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "committedDate": "2020-06-08T09:26:19Z", "type": "forcePushed"}, {"oid": "d852eab212231765449a9708aed200ff5d0002df", "url": "https://github.com/oracle/graal/commit/d852eab212231765449a9708aed200ff5d0002df", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/", "committedDate": "2020-11-06T07:40:46Z", "type": "forcePushed"}, {"oid": "ebb0931a863d476206ec8bfa4a049a758ee32f24", "url": "https://github.com/oracle/graal/commit/ebb0931a863d476206ec8bfa4a049a758ee32f24", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/", "committedDate": "2020-11-09T05:45:22Z", "type": "commit"}, {"oid": "ebb0931a863d476206ec8bfa4a049a758ee32f24", "url": "https://github.com/oracle/graal/commit/ebb0931a863d476206ec8bfa4a049a758ee32f24", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/", "committedDate": "2020-11-09T05:45:22Z", "type": "forcePushed"}]}