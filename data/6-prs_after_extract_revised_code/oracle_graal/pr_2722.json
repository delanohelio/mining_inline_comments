{"pr_number": 2722, "pr_title": "enable C++/LLVM interoperability calls of (class) methods and constructors", "pr_createdAt": "2020-07-29T08:29:21Z", "pr_url": "https://github.com/oracle/graal/pull/2722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1NTY4NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481955684", "bodyText": "Style issue: I think that assertion is redundant. We have a cast on the next line, so this code will fail with a good error message anyway if it's not true.", "author": "rschatz", "createdAt": "2020-09-02T10:09:13Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java", "diffHunk": "@@ -83,13 +89,31 @@ CallTarget getForeignCallTarget() {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            LLVMForeignCallNode foreignCall = new LLVMForeignCallNode(context.getLanguage(), this, interopType, sourceType);\n+            LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n             foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             assert foreignCallTarget != null;\n         }\n         return foreignCallTarget;\n     }\n \n+    CallTarget getForeignConstructorCallTarget() {\n+        if (foreignCallTarget == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n+            LLVMInteropType interopType = context.getInteropType(sourceType);\n+            assert (interopType instanceof Function);", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\nindex 9983a31e4d9..b4b02f6eec4 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\n\n@@ -82,36 +82,36 @@ public final class LLVMFunctionDescriptor extends LLVMInternalTruffleObject impl\n \n     // used for calls from foreign languages\n     // includes boundary conversions\n-    private CallTarget foreignCallTarget;\n+    private CallTarget foreignFunctionCallTarget;\n+    private CallTarget foreignConstructorCallTarget;\n \n     CallTarget getForeignCallTarget() {\n-        if (foreignCallTarget == null) {\n+        if (foreignFunctionCallTarget == null) {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n             LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n-            foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n-            assert foreignCallTarget != null;\n+            foreignFunctionCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n+            assert foreignFunctionCallTarget != null;\n         }\n-        return foreignCallTarget;\n+        return foreignFunctionCallTarget;\n     }\n \n     CallTarget getForeignConstructorCallTarget() {\n-        if (foreignCallTarget == null) {\n+        if (foreignConstructorCallTarget == null) {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            assert (interopType instanceof Function);\n             LLVMInteropType extractedType = ((Function) interopType).getParameter(0);\n             if (extractedType instanceof Value) {\n                 Structured structured = ((Value) extractedType).getBaseType();\n                 LLVMForeignCallNode foreignCall = LLVMForeignConstructorCallNode.create(\n                                 context.getLanguage(), this, interopType, sourceType, structured);\n-                foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n+                foreignConstructorCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             }\n-            assert foreignCallTarget != null;\n+            assert foreignConstructorCallTarget != null;\n         }\n-        return foreignCallTarget;\n+        return foreignConstructorCallTarget;\n     }\n \n     private static long tagSulongFunctionPointer(int id) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1NzMxMA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481957310", "bodyText": "Reusing the same variable foreignCallTarget for both getForeignCallTarget and getForeignConstructorCallTarget looks dangerous. True, a function is either a constructor or a method, not both. But what if the user somehow gets their hand on a constructor function pointer, and tries to execute it?", "author": "rschatz", "createdAt": "2020-09-02T10:12:23Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java", "diffHunk": "@@ -83,13 +89,31 @@ CallTarget getForeignCallTarget() {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            LLVMForeignCallNode foreignCall = new LLVMForeignCallNode(context.getLanguage(), this, interopType, sourceType);\n+            LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n             foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             assert foreignCallTarget != null;\n         }\n         return foreignCallTarget;\n     }\n \n+    CallTarget getForeignConstructorCallTarget() {\n+        if (foreignCallTarget == null) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\nindex 9983a31e4d9..b4b02f6eec4 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java\n\n@@ -82,36 +82,36 @@ public final class LLVMFunctionDescriptor extends LLVMInternalTruffleObject impl\n \n     // used for calls from foreign languages\n     // includes boundary conversions\n-    private CallTarget foreignCallTarget;\n+    private CallTarget foreignFunctionCallTarget;\n+    private CallTarget foreignConstructorCallTarget;\n \n     CallTarget getForeignCallTarget() {\n-        if (foreignCallTarget == null) {\n+        if (foreignFunctionCallTarget == null) {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n             LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n-            foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n-            assert foreignCallTarget != null;\n+            foreignFunctionCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n+            assert foreignFunctionCallTarget != null;\n         }\n-        return foreignCallTarget;\n+        return foreignFunctionCallTarget;\n     }\n \n     CallTarget getForeignConstructorCallTarget() {\n-        if (foreignCallTarget == null) {\n+        if (foreignConstructorCallTarget == null) {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            assert (interopType instanceof Function);\n             LLVMInteropType extractedType = ((Function) interopType).getParameter(0);\n             if (extractedType instanceof Value) {\n                 Structured structured = ((Value) extractedType).getBaseType();\n                 LLVMForeignCallNode foreignCall = LLVMForeignConstructorCallNode.create(\n                                 context.getLanguage(), this, interopType, sourceType, structured);\n-                foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n+                foreignConstructorCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             }\n-            assert foreignCallTarget != null;\n+            assert foreignConstructorCallTarget != null;\n         }\n-        return foreignCallTarget;\n+        return foreignConstructorCallTarget;\n     }\n \n     private static long tagSulongFunctionPointer(int id) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MDg2NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481960864", "bodyText": "This assertion doesn't do anything when behind a @TruffleBoundary.\nAlso logically speaking it's a contradiction: The assertion means that this method is not supposed to be used from runtime compiled code. The boundary means that it can be used from runtime compiled code even though something inside it can't.\nSince this is a parser datastructure, I would guess that the assertion is correct, and the boundary is wrong. Same thing for all the other boundaries in that file.", "author": "rschatz", "createdAt": "2020-09-02T10:19:06Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MTkzMw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481961933", "bodyText": "This code is copied from the superclass. This could be simplified to super.getElementCount() + methods.size().", "author": "rschatz", "createdAt": "2020-09-02T10:21:10Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzEzMg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963132", "bodyText": "Duplicate code from superclass. Please simplify to use super.getElementName().\nFor the index, in the else branch you can just use index -= super.getElementCount(), right?", "author": "rschatz", "createdAt": "2020-09-02T10:23:40Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzQ3NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963474", "bodyText": "Duplicate code from superclass.", "author": "rschatz", "createdAt": "2020-09-02T10:24:18Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzU3MQ==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963571", "bodyText": "Duplicate code from superclass.", "author": "rschatz", "createdAt": "2020-09-02T10:24:32Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2Mzg5OQ==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963899", "bodyText": "Duplicate code from superclass.", "author": "rschatz", "createdAt": "2020-09-02T10:25:06Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDE0NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481964144", "bodyText": "Duplicate code from superclass.", "author": "rschatz", "createdAt": "2020-09-02T10:25:26Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {\n+            if (name.equals(member.getName())) {\n+                return member.getOffsetElementType();\n+            }\n+        }\n+        int idx = getMethodIndexByName(name);\n+        if (idx >= 0) {\n+            return methods.get(idx).getReturnType();\n+        }\n+        if (LLVMSourceStaticMemberType.CollectionType.MEMBERNAME.equals(name)) {\n+            return staticMembers;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDMyOQ==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481964329", "bodyText": "Duplicate code from superclass.", "author": "rschatz", "createdAt": "2020-09-02T10:25:49Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {\n+            if (name.equals(member.getName())) {\n+                return member.getOffsetElementType();\n+            }\n+        }\n+        int idx = getMethodIndexByName(name);\n+        if (idx >= 0) {\n+            return methods.get(idx).getReturnType();\n+        }\n+        if (LLVMSourceStaticMemberType.CollectionType.MEMBERNAME.equals(name)) {\n+            return staticMembers;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers.getLocation();\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getLocation();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getLocation();\n+        }\n+        return null;\n+    }\n+\n+    private int getMethodIndexByName(String name) {\n+        for (int i = 0; i < methods.size(); i++) {\n+            LLVMSourceMethodType method = methods.get(i);\n+            if (name.contentEquals(method.getLinkageName()) || name.contentEquals(method.getName())) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\nindex 06a51b12f39..b048ce56978 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java\n\n@@ -53,7 +53,6 @@ public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n         this.methods = methods;\n     }\n \n-    @TruffleBoundary\n     public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n         CompilerAsserts.neverPartOfCompilation();\n         final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3MzY0MQ==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481973641", "bodyText": "I don't think this is really correct. This is the equivalent of calling malloc, but I think we should actually call the new operator. Not sure how to best do this though, especially since the new operator can be overloaded.\nThis will also make problems with managed mode (--llvm.managed, and EE only feature), since there malloc is swapped out with a different implementation. Calling new would solve this, too, since the default new operator will in turn call malloc.\nI'm inclined to leave it as it is now, and fix it in a followup PR, since this is quite tricky to solve. We'd have to somehow get the correct new operator to call from the debug info, and call that.", "author": "rschatz", "createdAt": "2020-09-02T10:42:53Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.interop;\n+\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.interop.ArityException;\n+import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceFunctionType;\n+import com.oracle.truffle.llvm.runtime.interop.access.LLVMInteropType;\n+import com.oracle.truffle.llvm.runtime.memory.LLVMStack.StackPointer;\n+import com.oracle.truffle.llvm.runtime.types.Type;\n+import com.oracle.truffle.llvm.runtime.types.Type.TypeOverflowException;\n+\n+public class LLVMForeignConstructorCallNode extends LLVMForeignCallNode {\n+    private final Type clazzType;\n+    private final LLVMLanguage language;\n+\n+    public static LLVMForeignConstructorCallNode create(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType,\n+                    LLVMInteropType.Structured structuredType) {\n+        Type escapeType = function.getLLVMFunction().getType().getArgumentType(0);\n+        return new LLVMForeignConstructorCallNode(language, function, interopType, sourceType, structuredType, escapeType);\n+\n+    }\n+\n+    protected LLVMForeignConstructorCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType,\n+                    LLVMInteropType.Structured structuredType, Type escapeType) {\n+        super(language, function, interopType, sourceType, structuredType, escapeType);\n+        this.language = language;\n+        this.clazzType = escapeType;\n+    }\n+\n+    @Override\n+    protected Object doCall(VirtualFrame frame, StackPointer stackPointer) throws ArityException, TypeOverflowException {\n+        Object[] rawArguments = frame.getArguments();\n+        rawArguments[0] = language.getLLVMMemory().allocateMemory(this, clazzType.getBitSize());", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\nindex e246125b72b..59c30cd5423 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\n\n@@ -29,6 +29,7 @@\n  */\n package com.oracle.truffle.llvm.runtime.interop;\n \n+import com.oracle.truffle.api.TruffleLanguage.LanguageReference;\n import com.oracle.truffle.api.frame.VirtualFrame;\n import com.oracle.truffle.api.interop.ArityException;\n import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NTg0Mg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481975842", "bodyText": "You can't store an LLVMLanguage directly in a node, you have to use LanguageReference<LLVMLanguage>.\nYou can get it with lookupLanguageReference(LLVMLanguage.class), and then you can use languageRef.get() to get the LLVMLanguage back in the doCall method.", "author": "rschatz", "createdAt": "2020-09-02T10:46:43Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.interop;\n+\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.interop.ArityException;\n+import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceFunctionType;\n+import com.oracle.truffle.llvm.runtime.interop.access.LLVMInteropType;\n+import com.oracle.truffle.llvm.runtime.memory.LLVMStack.StackPointer;\n+import com.oracle.truffle.llvm.runtime.types.Type;\n+import com.oracle.truffle.llvm.runtime.types.Type.TypeOverflowException;\n+\n+public class LLVMForeignConstructorCallNode extends LLVMForeignCallNode {\n+    private final Type clazzType;\n+    private final LLVMLanguage language;", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\nindex e246125b72b..59c30cd5423 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java\n\n@@ -29,6 +29,7 @@\n  */\n package com.oracle.truffle.llvm.runtime.interop;\n \n+import com.oracle.truffle.api.TruffleLanguage.LanguageReference;\n import com.oracle.truffle.api.frame.VirtualFrame;\n import com.oracle.truffle.api.interop.ArityException;\n import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MzYxMw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481983613", "bodyText": "You can use a @CachedContext(LLVMLanguage.class) context parameter to get the context in a more efficient way.", "author": "rschatz", "createdAt": "2020-09-02T11:01:28Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 27d3689b913..dc6c456cf5a 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -149,35 +153,71 @@ abstract class CommonPointerLibraries {\n     }\n \n     @ExportMessage\n-    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n-                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n         LLVMInteropType type = receiver.getExportType();\n         if (!(type instanceof LLVMInteropType.Clazz)) {\n             throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n         }\n-        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n-        Object[] newArguments = new Object[arguments.length + 1];\n+        return (Clazz) type;\n+    }\n+\n+    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n+        Object[] newArguments = new Object[rawArgs.length + 1];\n         newArguments[0] = receiver;\n-        for (int i = 0; i < arguments.length; i++) {\n-            newArguments[i + 1] = arguments[i];\n+        for (int i = 0; i < rawArgs.length; i++) {\n+            newArguments[i + 1] = rawArgs[i];\n         }\n-        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+        return newArguments;\n+    }\n \n-        Method method = clazz.findMethod(member, newArguments);\n+    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n         if (method == null) {\n             throw UnknownIdentifierException.create(member);\n         }\n-        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n         if (llvmFunction == null) {\n             CompilerDirectives.transferToInterpreter();\n             final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n             final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n             throw new LLVMLinkerException(msg);\n         }\n-\n-        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n-\n-        return InteropLibrary.getUncached().execute(fn, newArguments);\n+        return llvmFunction;\n     }\n \n     @ExportMessage\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MzgyNg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481983826", "bodyText": "You can use @CachedLibrary InteropLibrary interop to get a more efficient version of the interop library.", "author": "rschatz", "createdAt": "2020-09-02T11:01:53Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        if (llvmFunction == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n+            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n+            throw new LLVMLinkerException(msg);\n+        }\n+\n+        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n+\n+        return InteropLibrary.getUncached().execute(fn, newArguments);", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 27d3689b913..dc6c456cf5a 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -149,35 +153,71 @@ abstract class CommonPointerLibraries {\n     }\n \n     @ExportMessage\n-    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n-                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n         LLVMInteropType type = receiver.getExportType();\n         if (!(type instanceof LLVMInteropType.Clazz)) {\n             throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n         }\n-        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n-        Object[] newArguments = new Object[arguments.length + 1];\n+        return (Clazz) type;\n+    }\n+\n+    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n+        Object[] newArguments = new Object[rawArgs.length + 1];\n         newArguments[0] = receiver;\n-        for (int i = 0; i < arguments.length; i++) {\n-            newArguments[i + 1] = arguments[i];\n+        for (int i = 0; i < rawArgs.length; i++) {\n+            newArguments[i + 1] = rawArgs[i];\n         }\n-        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+        return newArguments;\n+    }\n \n-        Method method = clazz.findMethod(member, newArguments);\n+    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n         if (method == null) {\n             throw UnknownIdentifierException.create(member);\n         }\n-        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n         if (llvmFunction == null) {\n             CompilerDirectives.transferToInterpreter();\n             final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n             final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n             throw new LLVMLinkerException(msg);\n         }\n-\n-        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n-\n-        return InteropLibrary.getUncached().execute(fn, newArguments);\n+        return llvmFunction;\n     }\n \n     @ExportMessage\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NTU5NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481985594", "bodyText": "Also, e should probably do some caching here, since this is quite inefficient to do every time we call a method. If both clazz and member, and the argument array length are all the same, then llvmFunction should also be the same, so we can cache it. At compile time, we'd only have the comparisons, and then a direct call, instead of an expensive lookup and an indirect call.", "author": "rschatz", "createdAt": "2020-09-02T11:05:33Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 27d3689b913..dc6c456cf5a 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -149,35 +153,71 @@ abstract class CommonPointerLibraries {\n     }\n \n     @ExportMessage\n-    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n-                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n         LLVMInteropType type = receiver.getExportType();\n         if (!(type instanceof LLVMInteropType.Clazz)) {\n             throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n         }\n-        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n-        Object[] newArguments = new Object[arguments.length + 1];\n+        return (Clazz) type;\n+    }\n+\n+    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n+        Object[] newArguments = new Object[rawArgs.length + 1];\n         newArguments[0] = receiver;\n-        for (int i = 0; i < arguments.length; i++) {\n-            newArguments[i + 1] = arguments[i];\n+        for (int i = 0; i < rawArgs.length; i++) {\n+            newArguments[i + 1] = rawArgs[i];\n         }\n-        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+        return newArguments;\n+    }\n \n-        Method method = clazz.findMethod(member, newArguments);\n+    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n         if (method == null) {\n             throw UnknownIdentifierException.create(member);\n         }\n-        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n         if (llvmFunction == null) {\n             CompilerDirectives.transferToInterpreter();\n             final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n             final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n             throw new LLVMLinkerException(msg);\n         }\n-\n-        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n-\n-        return InteropLibrary.getUncached().execute(fn, newArguments);\n+        return llvmFunction;\n     }\n \n     @ExportMessage\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NjM1Nw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481986357", "bodyText": "I don't think we should create a new function descriptor every time we call the function. I think you actually want to use an LLVMAccessSymbolNode here to fetch the function pointer that points to this method.", "author": "rschatz", "createdAt": "2020-09-02T11:07:10Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        if (llvmFunction == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n+            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n+            throw new LLVMLinkerException(msg);\n+        }\n+\n+        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 27d3689b913..dc6c456cf5a 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -149,35 +153,71 @@ abstract class CommonPointerLibraries {\n     }\n \n     @ExportMessage\n-    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n-                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n         LLVMInteropType type = receiver.getExportType();\n         if (!(type instanceof LLVMInteropType.Clazz)) {\n             throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n         }\n-        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n-        Object[] newArguments = new Object[arguments.length + 1];\n+        return (Clazz) type;\n+    }\n+\n+    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n+        Object[] newArguments = new Object[rawArgs.length + 1];\n         newArguments[0] = receiver;\n-        for (int i = 0; i < arguments.length; i++) {\n-            newArguments[i + 1] = arguments[i];\n+        for (int i = 0; i < rawArgs.length; i++) {\n+            newArguments[i + 1] = rawArgs[i];\n         }\n-        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+        return newArguments;\n+    }\n \n-        Method method = clazz.findMethod(member, newArguments);\n+    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n         if (method == null) {\n             throw UnknownIdentifierException.create(member);\n         }\n-        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n         if (llvmFunction == null) {\n             CompilerDirectives.transferToInterpreter();\n             final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n             final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n             throw new LLVMLinkerException(msg);\n         }\n-\n-        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n-\n-        return InteropLibrary.getUncached().execute(fn, newArguments);\n+        return llvmFunction;\n     }\n \n     @ExportMessage\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4Njc4MA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481986780", "bodyText": "Should probably be type.getMethod(...).getName().", "author": "rschatz", "createdAt": "2020-09-02T11:08:08Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -232,6 +296,46 @@ Object readArrayElement(long idx,\n         }\n     }\n \n+    @ExportLibrary(InteropLibrary.class)\n+    public static final class ClassKeys implements TruffleObject {\n+        private final LLVMInteropType.Clazz type;\n+\n+        private ClassKeys(LLVMInteropType.Clazz type) {\n+            this.type = type;\n+        }\n+\n+        @ExportMessage\n+        boolean hasArrayElements() {\n+            return true;\n+        }\n+\n+        @ExportMessage\n+        long getArraySize() {\n+            return type.getMemberCount() + type.getMethodCount();\n+        }\n+\n+        @ExportMessage\n+        boolean isArrayElementReadable(long idx) {\n+            return Long.compareUnsigned(idx, getArraySize()) < 0;\n+        }\n+\n+        @ExportMessage\n+        Object readArrayElement(long idx,\n+                        @Cached BranchProfile exception) throws InvalidArrayIndexException {\n+            try {\n+                int index = (int) idx;\n+                if (index < type.getMemberCount()) {\n+                    return type.getMember(index).getName();\n+                } else {\n+                    return type.getMethod(index - type.getMemberCount());", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 27d3689b913..dc6c456cf5a 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -327,7 +367,7 @@ abstract class CommonPointerLibraries {\n                 if (index < type.getMemberCount()) {\n                     return type.getMember(index).getName();\n                 } else {\n-                    return type.getMethod(index - type.getMemberCount());\n+                    return type.getMethod(index - type.getMemberCount()).getName();\n                 }\n             } catch (IndexOutOfBoundsException ex) {\n                 exception.enter();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NzkzMw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481987933", "bodyText": "Not sure I understand this test. You're passing a point to the constructor? Shouldn't the constructor have zero arguments, and return a Point?", "author": "rschatz", "createdAt": "2020-09-02T11:10:32Z", "path": "sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.tests.interop;\n+\n+import org.graalvm.polyglot.Value;\n+import org.junit.BeforeClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CxxMethodsTest extends InteropTestBase {\n+\n+    private static Value allocPoint;\n+    private static Value freePoint;\n+    private static Value allocXtendPoint;\n+    private static Value freeXtendPoint;\n+\n+    private static Value getY;\n+    private static Value setX;\n+    private static Value setY;\n+\n+    private static Value constructor;\n+\n+    private static Value squaredEuclideanDistance;\n+    private static Value swap;\n+\n+    private static Value testLibrary;\n+\n+    @BeforeClass\n+    public static void loadTestBitcode() {\n+        testLibrary = loadTestBitcodeValue(\"methodsTest.cpp\");\n+\n+        allocPoint = testLibrary.getMember(\"allocNativePoint\");\n+        freePoint = testLibrary.getMember(\"freeNativePoint\");\n+        allocXtendPoint = testLibrary.getMember(\"allocNativeXtendPoint\");\n+        freeXtendPoint = testLibrary.getMember(\"freeNativeXtendPoint\");\n+        getY = testLibrary.getMember(\"getY\");\n+        setX = testLibrary.getMember(\"setX\");\n+        setY = testLibrary.getMember(\"setY\");\n+        squaredEuclideanDistance = testLibrary.getMember(\"squaredEuclideanDistance\");\n+        constructor = testLibrary.getMember(\"Point\");\n+        swap = testLibrary.getMember(\"swap\");\n+    }\n+\n+    private static void checkPoint(Value point, int x, int y) {\n+        Assert.assertTrue(\"hasMembers\", point.hasMembers());\n+        Assert.assertFalse(\"hasArrayElements\", point.hasArrayElements());\n+\n+        Assert.assertTrue(\"hasMember(x)\", point.hasMember(\"x\"));\n+        Assert.assertTrue(\"hasMember(y)\", point.hasMember(\"y\"));\n+\n+        Assert.assertEquals(\"y\", y, point.getMember(\"y\").asInt());\n+        Assert.assertEquals(\"x\", x, point.getMember(\"x\").asInt());\n+    }\n+\n+    @Test\n+    public void testAllocPoint() {\n+        Value point = allocPoint.execute();\n+        try {\n+\n+            Assert.assertTrue(\"hasMember(x)\", point.hasMember(\"x\"));\n+            Assert.assertTrue(\"hasMember(y)\", point.hasMember(\"y\"));\n+\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testGettersAndSetters() {\n+        Value point = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"setY\", 4);\n+            setX.execute(point, 30000);\n+            checkPoint(point, 30000, 4);\n+            checkPoint(point, point.invokeMember(\"getX\").asInt(), getY.execute(point).asInt());\n+\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testMemberFunction() {\n+        Value point = testLibrary.invokeMember(\"allocNativePoint\");\n+        Value point2 = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"setX\", 3);\n+            Assert.assertEquals(\"getX()==3 after setX(3)\", 3, point.invokeMember(\"getX\").asInt());\n+            setY.execute(point, -4);\n+            setX.execute(point2, -6);\n+            testLibrary.invokeMember(\"setY\", point2, 8);\n+            checkPoint(point, 3, -4);\n+            checkPoint(point2, -6, 8);\n+            // swap point <-> point2\n+            swap.execute(point, point2);\n+            checkPoint(point2, 3, -4);\n+            checkPoint(point, -6, 8);\n+            // calculate distance\n+            Value distanceResult1 = squaredEuclideanDistance.execute(point, point2);\n+            Value distanceResult2 = squaredEuclideanDistance.execute(point2, point);\n+            Value distanceResult3 = point2.invokeMember(\"squaredEuclideanDistance\", point);\n+            Value distanceResult4 = point.invokeMember(\"squaredEuclideanDistance\", point2);\n+\n+            Assert.assertEquals(\"distance(p, p2)\", 0, Double.compare(225, distanceResult1.asDouble()));\n+            Assert.assertEquals(\"distance(p2, p)\", 0, Double.compare(225, distanceResult2.asDouble()));\n+            Assert.assertEquals(\"p.distance(p2)\", 0, Double.compare(225, distanceResult3.asDouble()));\n+            Assert.assertEquals(\"p2.distance(p)\", 0, Double.compare(225, distanceResult4.asDouble()));\n+\n+        } finally {\n+            testLibrary.invokeMember(\"freeNativePoint\", point);\n+            freePoint.execute(point2);\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNonExistingMethod() {\n+        Value point = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"methodWhichDoesNotExist\");\n+        } finally {\n+            testLibrary.invokeMember(\"freeNativePoint\", point);\n+        }\n+    }\n+\n+    @Test\n+    public void testOverloadedMethods() {\n+        Value xPoint = allocXtendPoint.execute();\n+        try {\n+            xPoint.invokeMember(\"setZ\", 1);\n+            Assert.assertEquals(\"getZ()\", 1, xPoint.invokeMember(\"getZ\").asInt());\n+            Assert.assertEquals(\"getZ(2)\", 3, xPoint.invokeMember(\"getZ\", 2).asInt());\n+        } finally {\n+            freeXtendPoint.execute(xPoint);\n+        }\n+    }\n+\n+    @Test\n+    public void testInheritedMethodsFromSuperclass() {\n+        Value xPoint = allocXtendPoint.execute();\n+        try {\n+            xPoint.invokeMember(\"setX\", 6);\n+            xPoint.invokeMember(\"setY\", 7);\n+            Assert.assertEquals(\"direct call: getX()\", 12, xPoint.invokeMember(\"getX\").asInt());\n+            Assert.assertEquals(\"superclass::getY()\", 7, xPoint.invokeMember(\"getY\").asInt());\n+        } finally {\n+            freeXtendPoint.execute(xPoint);\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWrongArity() {\n+        Value point = allocPoint.execute();\n+        try {\n+            constructor.execute(point);\n+            point.invokeMember(\"setX\", 6, 9, 4);\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testConstructor() {\n+        Value point = allocPoint.execute();\n+        try {\n+            constructor.execute(point);", "originalCommit": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwNjY2Ng==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r482906666", "bodyText": "True, it does indeed not make sense to pass the parameter here. I will change it to Value point = constructor.newInstance() and also remove the execute call of allocPoint.", "author": "pichristoph", "createdAt": "2020-09-03T11:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NzkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "chunk": "diff --git a/sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java b/sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java\nindex fc35270044f..fa4d4b3de1e 100644\n--- a/sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java\n+++ b/sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java\n\n@@ -41,12 +41,7 @@ public class CxxMethodsTest extends InteropTestBase {\n     private static Value allocXtendPoint;\n     private static Value freeXtendPoint;\n \n-    private static Value getY;\n-    private static Value setX;\n-    private static Value setY;\n-\n     private static Value constructor;\n-\n     private static Value squaredEuclideanDistance;\n     private static Value swap;\n \n"}}, {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "url": "https://github.com/oracle/graal/commit/b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "message": "removing \"replaces\" attribute for Specialization", "committedDate": "2020-09-08T13:06:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjA5Mg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498736092", "bodyText": "These @Cached values are all unused. I don't think they are necessary, since this is the generic fallback specialization that does the resolving on each call.", "author": "rschatz", "createdAt": "2020-10-02T10:15:48Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)", "originalCommit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex dc6c456cf5a..519dc523f0d 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -158,33 +159,28 @@ abstract class CommonPointerLibraries {\n         @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n         static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             return interop.execute(accessSymbolNode.execute(), newArguments);\n         }\n \n         @SuppressWarnings(\"unused\")\n-        @Specialization\n+        @Specialization(replaces = \"doCached\")\n         static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             LLVMInteropType.Clazz newClazz = asClazz(receiver);\n             Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n             LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n-            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n             return interop.execute(newReceiver, newArguments);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjIwNA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498736204", "bodyText": "Should replace doCached. It usually doesn't pay off to keep the cached versions after the inline cache overflows.\nAs a nice side effect, when this replaces doCached, the allowUncached = true arguments in doCached shouldn't be needed anymore.", "author": "rschatz", "createdAt": "2020-10-02T10:16:03Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization", "originalCommit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex dc6c456cf5a..519dc523f0d 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -158,33 +159,28 @@ abstract class CommonPointerLibraries {\n         @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n         static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             return interop.execute(accessSymbolNode.execute(), newArguments);\n         }\n \n         @SuppressWarnings(\"unused\")\n-        @Specialization\n+        @Specialization(replaces = \"doCached\")\n         static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             LLVMInteropType.Clazz newClazz = asClazz(receiver);\n             Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n             LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n-            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n             return interop.execute(newReceiver, newArguments);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzUxNw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498737517", "bodyText": "We shouldn't create a new function descriptor here. I wonder whether we need a variant of LLVMAccessSymbolNode that can take a dynamic symbol as argument... /cc @Palez", "author": "rschatz", "createdAt": "2020-10-02T10:19:09Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);", "originalCommit": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2MTU5NA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498761594", "bodyText": "Currently the LLVMAccessSymbolNode must take a symbol in order to be able to access it. We could just simple create a LLVMDynAccessSymbolNode for this use case, something like:\npublic abstract class LLVMDynAccessSymbolNode extends LLVMExpressionNode {\n\n   public LLVMDynAccessSymbolNode() {\n    }\n\n    public abstract LLVMPointer execute();\n    \n@Specialization\n    LLVMPointer doAccess(LLVMSymbol symbol,\n                    @CachedContext(LLVMLanguage.class) LLVMContext context) {\n        CompilerAsserts.partialEvaluationConstant(symbol);\n        if (symbol.hasValidIndexAndID()) {\n            int bitcodeID = symbol.getBitcodeID(false);\n            if (context.symbolTableExists(bitcodeID)) {\n                AssumedValue<LLVMPointer>[] symbols = context.findSymbolTable(bitcodeID);\n                int index = symbol.getSymbolIndex(false);\n                AssumedValue<LLVMPointer> assumedValue = symbols[index];\n                if (assumedValue != null) {\n                    return assumedValue.get();\n                }\n            }\n        }\n        CompilerDirectives.transferToInterpreter();\n        throw new LLVMLinkerException(this, String.format(\"External %s %s cannot be found.\", symbol.getKind(), symbol.getName()));\n    }\n}\n\n@pichristoph Would you like me to add this class onto the repo or would you like to do it?", "author": "Palez", "createdAt": "2020-10-02T11:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2OTIxMw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r499369213", "bodyText": "@Palez if it is fine for you, I will add it. Thank you for the suggestion/solution!", "author": "pichristoph", "createdAt": "2020-10-05T06:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzUxNw=="}], "type": "inlineReview", "revised_code": {"commit": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex dc6c456cf5a..519dc523f0d 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -158,33 +159,28 @@ abstract class CommonPointerLibraries {\n         @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n         static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             return interop.execute(accessSymbolNode.execute(), newArguments);\n         }\n \n         @SuppressWarnings(\"unused\")\n-        @Specialization\n+        @Specialization(replaces = \"doCached\")\n         static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n                         @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n-                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n-                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)\n                         throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n             Object[] newArguments = addSelfObject(receiver, arguments);\n             LLVMInteropType.Clazz newClazz = asClazz(receiver);\n             Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n             LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n-            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);\n+            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n             return interop.execute(newReceiver, newArguments);\n         }\n     }\n"}}, {"oid": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "url": "https://github.com/oracle/graal/commit/24f9f8293475ee130b0a80b7230a0a0810847aaa", "message": "restructured 'invokeMember' message", "committedDate": "2020-10-05T07:40:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2Mjc5Nw==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r499462797", "bodyText": "I don't think this assertion is always correct. I'd just remove it.", "author": "rschatz", "createdAt": "2020-10-05T09:28:03Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/others/LLVMDynAccessSymbolNode.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.oracle.truffle.llvm.runtime.nodes.others;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives;\n+import com.oracle.truffle.api.dsl.CachedContext;\n+import com.oracle.truffle.api.dsl.Specialization;\n+import com.oracle.truffle.api.utilities.AssumedValue;\n+import com.oracle.truffle.llvm.runtime.LLVMContext;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.LLVMSymbol;\n+import com.oracle.truffle.llvm.runtime.except.LLVMLinkerException;\n+import com.oracle.truffle.llvm.runtime.nodes.api.LLVMNode;\n+import com.oracle.truffle.llvm.runtime.pointer.LLVMPointer;\n+\n+public abstract class LLVMDynAccessSymbolNode extends LLVMNode {\n+\n+    public LLVMDynAccessSymbolNode() {\n+    }\n+\n+    public abstract LLVMPointer execute(LLVMSymbol symbol);\n+\n+    @Specialization\n+    LLVMPointer doAccess(LLVMSymbol symbol,\n+                    @CachedContext(LLVMLanguage.class) LLVMContext context) {\n+        CompilerAsserts.partialEvaluationConstant(symbol);", "originalCommit": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65de2f0ed19e240745fc3f8a424569402a453444", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/others/LLVMDynAccessSymbolNode.java b/sulong/projects/com.oracle.truffle.llvm/src/com/oracle/truffle/llvm/initialization/StaticInitsNode.java\nsimilarity index 59%\nrename from sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/others/LLVMDynAccessSymbolNode.java\nrename to sulong/projects/com.oracle.truffle.llvm/src/com/oracle/truffle/llvm/initialization/StaticInitsNode.java\nindex 5cd51d69062..5f525726406 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/others/LLVMDynAccessSymbolNode.java\n+++ b/sulong/projects/com.oracle.truffle.llvm/src/com/oracle/truffle/llvm/initialization/StaticInitsNode.java\n\n@@ -27,45 +27,46 @@\n  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n  * OF THE POSSIBILITY OF SUCH DAMAGE.\n  */\n+package com.oracle.truffle.llvm.initialization;\n \n-package com.oracle.truffle.llvm.runtime.nodes.others;\n-\n-import com.oracle.truffle.api.CompilerAsserts;\n import com.oracle.truffle.api.CompilerDirectives;\n import com.oracle.truffle.api.dsl.CachedContext;\n import com.oracle.truffle.api.dsl.Specialization;\n-import com.oracle.truffle.api.utilities.AssumedValue;\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.nodes.ExplodeLoop;\n import com.oracle.truffle.llvm.runtime.LLVMContext;\n import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n-import com.oracle.truffle.llvm.runtime.LLVMSymbol;\n-import com.oracle.truffle.llvm.runtime.except.LLVMLinkerException;\n-import com.oracle.truffle.llvm.runtime.nodes.api.LLVMNode;\n-import com.oracle.truffle.llvm.runtime.pointer.LLVMPointer;\n+import com.oracle.truffle.llvm.runtime.LibraryLocator;\n+import com.oracle.truffle.llvm.runtime.nodes.api.LLVMStatementNode;\n \n-public abstract class LLVMDynAccessSymbolNode extends LLVMNode {\n+public abstract class StaticInitsNode extends LLVMStatementNode {\n \n-    public LLVMDynAccessSymbolNode() {\n-    }\n+    @Children final LLVMStatementNode[] statements;\n+    final Object moduleName;\n+    final String prefix;\n \n-    public abstract LLVMPointer execute(LLVMSymbol symbol);\n+    public StaticInitsNode(LLVMStatementNode[] statements, String prefix, Object moduleName) {\n+        this.statements = statements;\n+        this.prefix = prefix;\n+        this.moduleName = moduleName;\n+    }\n \n+    @ExplodeLoop\n     @Specialization\n-    LLVMPointer doAccess(LLVMSymbol symbol,\n-                    @CachedContext(LLVMLanguage.class) LLVMContext context) {\n-        CompilerAsserts.partialEvaluationConstant(symbol);\n-        if (symbol.hasValidIndexAndID()) {\n-            int bitcodeID = symbol.getBitcodeID(false);\n-            if (context.symbolTableExists(bitcodeID)) {\n-                AssumedValue<LLVMPointer>[] symbols = context.findSymbolTable(bitcodeID);\n-                int index = symbol.getSymbolIndex(false);\n-                AssumedValue<LLVMPointer> assumedValue = symbols[index];\n-                if (assumedValue != null) {\n-                    return assumedValue.get();\n-                }\n+    public void doInit(VirtualFrame frame,\n+                    @CachedContext(LLVMLanguage.class) LLVMContext ctx) {\n+        synchronized (ctx) {\n+            if (ctx.loaderTraceStream() != null) {\n+                traceExecution(ctx);\n+            }\n+            for (LLVMStatementNode stmt : statements) {\n+                stmt.execute(frame);\n             }\n         }\n-        CompilerDirectives.transferToInterpreter();\n-        throw new LLVMLinkerException(this, String.format(\"External %s %s cannot be found.\",\n-                        symbol.getKind(), symbol.getName()));\n+    }\n+\n+    @CompilerDirectives.TruffleBoundary\n+    private void traceExecution(LLVMContext ctx) {\n+        LibraryLocator.traceStaticInits(ctx, prefix, moduleName, String.format(\"[%d inst]\", statements.length));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2NDg3MA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r499464870", "bodyText": "allowUncached for nodes is wrong, that would create a new node for every call when used through an uncached library. Put the @GenerateUncached annotation on the LLVMDynAccessSymbolNode, then it should work without allowUncached = true. Also value = \"create()\" shouldn't be necessary, since that's the default (but not wrong either).", "author": "rschatz", "createdAt": "2020-10-05T09:31:10Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +143,79 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(replaces = \"doCached\")\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)", "originalCommit": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "65de2f0ed19e240745fc3f8a424569402a453444", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 519dc523f0d..7cba33c4499 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -126,98 +106,25 @@ abstract class CommonPointerLibraries {\n     static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n                     @Shared(\"isObject\") @Cached ConditionProfile isObject) {\n         if (isObject.profile(receiver.getExportType() instanceof LLVMInteropType.Struct)) {\n-            /*\n-             * check for Clazz is not needed, since Clazz inherits from Struct, and methods\n-             * (=currently the only difference between Clazz and Struct) are not modifiable\n-             */\n             LLVMInteropType.Struct struct = (LLVMInteropType.Struct) receiver.getExportType();\n             LLVMInteropType.StructMember member = struct.findMember(ident);\n             if (member == null) {\n                 // not found\n                 return false;\n             } else {\n-                return member.getType() instanceof LLVMInteropType.Value;\n+                return member.type instanceof LLVMInteropType.Value;\n             }\n         } else {\n             return false;\n         }\n     }\n \n+    /**\n+     * @param receiver\n+     * @param ident\n+     * @see InteropLibrary#isMemberInsertable(Object, String)\n+     */\n     @ExportMessage\n-    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n-        LLVMInteropType type = receiver.getExportType();\n-        if (type instanceof LLVMInteropType.Clazz) {\n-            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n-            return clazz.findMethod(ident) != null;\n-        }\n-        return false;\n-    }\n-\n-    @ExportMessage\n-    static class InvokeMember {\n-        @SuppressWarnings(\"unused\")\n-        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n-        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n-                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n-                        @Cached(value = \"arguments.length\") int argCount,\n-                        @Cached(value = \"method.getName()\") String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n-                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n-            Object[] newArguments = addSelfObject(receiver, arguments);\n-            return interop.execute(accessSymbolNode.execute(), newArguments);\n-        }\n-\n-        @SuppressWarnings(\"unused\")\n-        @Specialization(replaces = \"doCached\")\n-        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n-                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)\n-                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n-            Object[] newArguments = addSelfObject(receiver, arguments);\n-            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n-            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n-            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n-            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n-            return interop.execute(newReceiver, newArguments);\n-        }\n-    }\n-\n-    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n-        LLVMInteropType type = receiver.getExportType();\n-        if (!(type instanceof LLVMInteropType.Clazz)) {\n-            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n-        }\n-        return (Clazz) type;\n-    }\n-\n-    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n-        Object[] newArguments = new Object[rawArgs.length + 1];\n-        newArguments[0] = receiver;\n-        for (int i = 0; i < rawArgs.length; i++) {\n-            newArguments[i + 1] = rawArgs[i];\n-        }\n-        return newArguments;\n-    }\n-\n-    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n-        if (method == null) {\n-            throw UnknownIdentifierException.create(member);\n-        }\n-        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n-        if (llvmFunction == null) {\n-            CompilerDirectives.transferToInterpreter();\n-            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n-            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n-            throw new LLVMLinkerException(msg);\n-        }\n-        return llvmFunction;\n-    }\n-\n-    @ExportMessage\n-    @SuppressWarnings(\"unused\")\n     static boolean isMemberInsertable(LLVMPointerImpl receiver, String ident) {\n         return false;\n     }\n"}}, {"oid": "65de2f0ed19e240745fc3f8a424569402a453444", "url": "https://github.com/oracle/graal/commit/65de2f0ed19e240745fc3f8a424569402a453444", "message": "Add class type (to LLVM source types) and C++ method tests", "committedDate": "2020-10-05T10:45:42Z", "type": "commit"}, {"oid": "e47813aadf8f52829371fd4c3986bfed6ee5a717", "url": "https://github.com/oracle/graal/commit/e47813aadf8f52829371fd4c3986bfed6ee5a717", "message": "Update CxxMethodsTest", "committedDate": "2020-10-05T10:45:42Z", "type": "commit"}, {"oid": "e78074f41531ae40f6869bf7b889ecaa524c741f", "url": "https://github.com/oracle/graal/commit/e78074f41531ae40f6869bf7b889ecaa524c741f", "message": "Add class type to interop type structure", "committedDate": "2020-10-05T10:45:42Z", "type": "commit"}, {"oid": "070112fc7ae4f6b19d12029fb06e537fb6c70154", "url": "https://github.com/oracle/graal/commit/070112fc7ae4f6b19d12029fb06e537fb6c70154", "message": "make C++ method names accessible", "committedDate": "2020-10-05T10:45:42Z", "type": "commit"}, {"oid": "c7543828c020bfba4155f0d8d2e478dfcf2867de", "url": "https://github.com/oracle/graal/commit/c7543828c020bfba4155f0d8d2e478dfcf2867de", "message": "enable C++ method calling via Sulong interoperability", "committedDate": "2020-10-05T10:50:11Z", "type": "commit"}, {"oid": "d104f1314a9a7cf4b0b2e82b2b7b5cab94846471", "url": "https://github.com/oracle/graal/commit/d104f1314a9a7cf4b0b2e82b2b7b5cab94846471", "message": "update C++/LLVM interop method calling and add tests for it", "committedDate": "2020-10-05T10:50:11Z", "type": "commit"}, {"oid": "01de5d8826026b2ee13784aaafb1ac7942ebbb3e", "url": "https://github.com/oracle/graal/commit/01de5d8826026b2ee13784aaafb1ac7942ebbb3e", "message": "enable method overloading w.r.t parameter count", "committedDate": "2020-10-05T10:50:11Z", "type": "commit"}, {"oid": "4c1ba0267ad62420c24f433a59ea03d20cf294be", "url": "https://github.com/oracle/graal/commit/4c1ba0267ad62420c24f433a59ea03d20cf294be", "message": "enable calling inherited methods from superclasses", "committedDate": "2020-10-05T10:50:11Z", "type": "commit"}, {"oid": "c36a45170aaaadb40e89860c44a71f7c6d9dd5d9", "url": "https://github.com/oracle/graal/commit/c36a45170aaaadb40e89860c44a71f7c6d9dd5d9", "message": "Update tests for overloaded and inherited C++ methods", "committedDate": "2020-10-05T10:50:11Z", "type": "commit"}, {"oid": "3c33b4ad513bef2428c7c006dfeed51a5aab7a81", "url": "https://github.com/oracle/graal/commit/3c33b4ad513bef2428c7c006dfeed51a5aab7a81", "message": "remove unnecessary imports and warnings due to rebase", "committedDate": "2020-10-05T11:08:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4MTQ3Mg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503781472", "bodyText": "I think this is a wrong merge conflicting with e8b0489, which removed the forceInlining.", "author": "rschatz", "createdAt": "2020-10-13T08:55:07Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java", "diffHunk": "@@ -188,19 +190,20 @@ public static PackForeignArgumentsNode create(FunctionType bitcodeFunctionType,\n     }\n \n     @CompilationFinal private ContextReference<LLVMContext> ctxRef;\n-    private final LLVMInteropType.Structured returnBaseType;\n+    protected final LLVMInteropType.Structured returnBaseType;\n \n     @Child LLVMGetStackFromThreadNode getStack;\n     @Child DirectCallNode callNode;\n     @Child LLVMDataEscapeNode prepareValueForEscape;\n     @Child PackForeignArgumentsNode packArguments;\n \n-    public LLVMForeignCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType) {\n+    protected LLVMForeignCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType, Structured returnBaseType, Type escapeType) {\n         super(language);\n-        this.returnBaseType = getReturnBaseType(interopType);\n+        this.returnBaseType = returnBaseType;\n         this.getStack = LLVMGetStackFromThreadNode.create();\n         this.callNode = DirectCallNode.create(getCallTarget(function));\n-        this.prepareValueForEscape = LLVMDataEscapeNode.create(function.getLLVMFunction().getType().getReturnType());\n+        this.callNode.forceInlining();", "originalCommit": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzg4NjAzOA==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503886038", "bodyText": "Indeed, thanks!", "author": "pichristoph", "createdAt": "2020-10-13T11:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4MTQ3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "062a150f4e8c7277b2e2a4c5589931ace1deb36c", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java\nindex e77e15e25cc..90ad32a50e8 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java\n\n@@ -190,7 +190,7 @@ public abstract class LLVMForeignCallNode extends RootNode {\n     }\n \n     @CompilationFinal private ContextReference<LLVMContext> ctxRef;\n-    protected final LLVMInteropType.Structured returnBaseType;\n+    private final LLVMInteropType.Structured returnBaseType;\n \n     @Child LLVMGetStackFromThreadNode getStack;\n     @Child DirectCallNode callNode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4NDcyMQ==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503784721", "bodyText": "String concatenation is not safe on the fast path (internally this creates quite a lot of code). In this particular case, I'd just use a simple string (i.e. literally \"Receiver cannot be cast to LLVMInteropType.Clazz\", or maybe better \"Receiver type is not a class.\").", "author": "rschatz", "createdAt": "2020-10-13T08:59:36Z", "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -119,6 +146,92 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    /**\n+     * @param receiver\n+     * @param ident\n+     * @see InteropLibrary#isMemberInsertable(Object, String)\n+     */\n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        /**\n+         * @param member\n+         * @param context\n+         * @param clazz\n+         * @param method\n+         * @param argCount\n+         * @param methodName\n+         * @param llvmFunction\n+         * @see InteropLibrary#invokeMember(Object, String, Object[])\n+         */\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @Specialization(replaces = \"doCached\")\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached LLVMDynAccessSymbolNode dynAccessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");", "originalCommit": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4NTI5Mg==", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503785292", "bodyText": "(found by our internal gate)", "author": "rschatz", "createdAt": "2020-10-13T09:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4NDcyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "062a150f4e8c7277b2e2a4c5589931ace1deb36c", "chunk": "diff --git a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\nindex 918c47d940f..44121026585 100644\n--- a/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n+++ b/sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java\n\n@@ -162,82 +156,33 @@ abstract class CommonPointerLibraries {\n     }\n \n     @ExportMessage\n-    static class InvokeMember {\n-        /**\n-         * @param member\n-         * @param context\n-         * @param clazz\n-         * @param method\n-         * @param argCount\n-         * @param methodName\n-         * @param llvmFunction\n-         * @see InteropLibrary#invokeMember(Object, String, Object[])\n-         */\n-        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n-        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n-                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n-                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n-                        @Cached(value = \"arguments.length\") int argCount,\n-                        @Cached(value = \"method.getName()\") String methodName,\n-                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n-                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n-                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n-            Object[] newArguments = addSelfObject(receiver, arguments);\n-            return interop.execute(accessSymbolNode.execute(), newArguments);\n-        }\n-\n-        @Specialization(replaces = \"doCached\")\n-        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n-                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n-                        @Cached LLVMDynAccessSymbolNode dynAccessSymbolNode)\n-                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n-            Object[] newArguments = addSelfObject(receiver, arguments);\n-            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n-            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n-            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n-            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n-            return interop.execute(newReceiver, newArguments);\n-        }\n-    }\n-\n-    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n         LLVMInteropType type = receiver.getExportType();\n         if (!(type instanceof LLVMInteropType.Clazz)) {\n             throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n         }\n-        return (Clazz) type;\n-    }\n-\n-    static Object[] addSelfObject(Object receiver, Object[] rawArgs) {\n-        Object[] newArguments = new Object[rawArgs.length + 1];\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n         newArguments[0] = receiver;\n-        for (int i = 0; i < rawArgs.length; i++) {\n-            newArguments[i + 1] = rawArgs[i];\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n         }\n-        return newArguments;\n-    }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n \n-    static LLVMFunction getLLVMFunction(LLVMContext context, Method method, LLVMInteropType.Clazz clazz, String member) throws UnknownIdentifierException {\n+        Method method = clazz.findMethod(member, newArguments);\n         if (method == null) {\n             throw UnknownIdentifierException.create(member);\n         }\n-        LLVMFunction llvmFunction = context.getGlobalScope().getFunction(method.getLinkageName());\n-        if (llvmFunction == null) {\n-            CompilerDirectives.transferToInterpreter();\n-            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n-            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n-            throw new LLVMLinkerException(msg);\n-        }\n-        return llvmFunction;\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+\n+        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n+\n+        return InteropLibrary.getUncached().execute(fn, newArguments);\n     }\n \n-    /**\n-     * @param receiver\n-     * @param ident\n-     * @see InteropLibrary#isMemberInsertable(Object, String)\n-     */\n     @ExportMessage\n+    @SuppressWarnings(\"unused\")\n     static boolean isMemberInsertable(LLVMPointerImpl receiver, String ident) {\n         return false;\n     }\n"}}, {"oid": "062a150f4e8c7277b2e2a4c5589931ace1deb36c", "url": "https://github.com/oracle/graal/commit/062a150f4e8c7277b2e2a4c5589931ace1deb36c", "message": "Enable interop constructor calling and method/constructor arity checks", "committedDate": "2020-10-13T11:42:45Z", "type": "commit"}, {"oid": "7069abf73cc5f72e0ea765e53779224f546f6558", "url": "https://github.com/oracle/graal/commit/7069abf73cc5f72e0ea765e53779224f546f6558", "message": "fix checkstyle errors", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "4351240bf8f0e3b2a85d12025f14c1c002027a69", "url": "https://github.com/oracle/graal/commit/4351240bf8f0e3b2a85d12025f14c1c002027a69", "message": "restructured LLVMSourceClassLikeType.java", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "bb1c33166f6e9265f2a4ac362d5c5b25c702c447", "url": "https://github.com/oracle/graal/commit/bb1c33166f6e9265f2a4ac362d5c5b25c702c447", "message": "add error message if declared method has no implementation", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "7a62609eab6a6b923bf08ae6e86ef8df32cac718", "url": "https://github.com/oracle/graal/commit/7a62609eab6a6b923bf08ae6e86ef8df32cac718", "message": "include feedback: superclass of LLVMSourceClassLikeType; LLVMForeignCallNode; Caching", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "90ba83c8488f27ce4a56346ab5d660d2d5dedb2c", "url": "https://github.com/oracle/graal/commit/90ba83c8488f27ce4a56346ab5d660d2d5dedb2c", "message": "removing \"replaces\" attribute for Specialization", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "3a8c6fec4539c782de0624aec269768a8e38b225", "url": "https://github.com/oracle/graal/commit/3a8c6fec4539c782de0624aec269768a8e38b225", "message": "restructured 'invokeMember' message", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "d5d1aea5379d1ae1edae25510fb7009f516e4695", "url": "https://github.com/oracle/graal/commit/d5d1aea5379d1ae1edae25510fb7009f516e4695", "message": "adjust caching for invokeMember message", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "9c99bed997da64b94347b36ca6fa0f21b6614be0", "url": "https://github.com/oracle/graal/commit/9c99bed997da64b94347b36ca6fa0f21b6614be0", "message": "apply API change due to rebase", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "11b21aa592e956bd1355735d905bb70b4cfdc36b", "url": "https://github.com/oracle/graal/commit/11b21aa592e956bd1355735d905bb70b4cfdc36b", "message": "remove unnecessary imports and warnings due to rebase", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "e48fbbff94e3ee3d424520b80e0d43385fb473d9", "url": "https://github.com/oracle/graal/commit/e48fbbff94e3ee3d424520b80e0d43385fb473d9", "message": "fix formatting issue in tests", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "511e3731735758637aa999d65975c13f103f890d", "url": "https://github.com/oracle/graal/commit/511e3731735758637aa999d65975c13f103f890d", "message": "fix style issues", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "edcf10bd1c3d851860e327ffaf3a6d76a49c0278", "url": "https://github.com/oracle/graal/commit/edcf10bd1c3d851860e327ffaf3a6d76a49c0278", "message": "remove non-fast-path operation", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "82fcbe8e2bc1ccec2a73474a6c631d5ecffca88d", "url": "https://github.com/oracle/graal/commit/82fcbe8e2bc1ccec2a73474a6c631d5ecffca88d", "message": "mark unused methods", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "d3a8b1f12722880f15727d9fed499141d799c6d1", "url": "https://github.com/oracle/graal/commit/d3a8b1f12722880f15727d9fed499141d799c6d1", "message": "remove 'class' notation for class names", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "8f64a7ac68da4f31431db892a6d995c8e4bfd70e", "url": "https://github.com/oracle/graal/commit/8f64a7ac68da4f31431db892a6d995c8e4bfd70e", "message": "update test traces with method in scopes", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "80850dae5ac967b2cf2d7d0395019cd7e47a9dee", "url": "https://github.com/oracle/graal/commit/80850dae5ac967b2cf2d7d0395019cd7e47a9dee", "message": "fix copyright years", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "aa08592646749964c9c2bc9384bac9cf8506acd4", "url": "https://github.com/oracle/graal/commit/aa08592646749964c9c2bc9384bac9cf8506acd4", "message": "document unused parameters", "committedDate": "2020-10-13T11:44:05Z", "type": "commit"}, {"oid": "cabd6619099eaf06c6338f4ae535722f519bd350", "url": "https://github.com/oracle/graal/commit/cabd6619099eaf06c6338f4ae535722f519bd350", "message": "Removed string concatenation", "committedDate": "2020-10-13T11:44:06Z", "type": "commit"}, {"oid": "cabd6619099eaf06c6338f4ae535722f519bd350", "url": "https://github.com/oracle/graal/commit/cabd6619099eaf06c6338f4ae535722f519bd350", "message": "Removed string concatenation", "committedDate": "2020-10-13T11:44:06Z", "type": "forcePushed"}]}