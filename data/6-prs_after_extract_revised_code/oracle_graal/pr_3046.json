{"pr_number": 3046, "pr_title": "Debugtypes", "pr_createdAt": "2020-12-04T16:33:38Z", "pr_url": "https://github.com/oracle/graal/pull/3046", "timeline": [{"oid": "1c263a83c0a1c905815d5f8011973ea60ac15b0c", "url": "https://github.com/oracle/graal/commit/1c263a83c0a1c905815d5f8011973ea60ac15b0c", "message": "rebase and correct object header layout", "committedDate": "2020-12-06T17:25:43Z", "type": "forcePushed"}, {"oid": "58a9ea21a49254806ca7721ff2c7462ec14b82ff", "url": "https://github.com/oracle/graal/commit/58a9ea21a49254806ca7721ff2c7462ec14b82ff", "message": "rebase and correct object header layout", "committedDate": "2020-12-06T17:35:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDE2NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547244164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    elementType = debugInfoBase.lookupTypeEntry(elementTypeName);\n          \n          \n            \n                    this.elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "author": "zakkak", "createdAt": "2020-12-22T12:14:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugArrayTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo.DebugTypeKind;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+public class ArrayTypeEntry extends TypeEntry {\n+    private TypeEntry elementType;\n+    private int headerSize;\n+    private int lengthOffset;\n+\n+    public ArrayTypeEntry(String typeName, int size) {\n+        super(typeName, size);\n+    }\n+\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.ARRAY;\n+    }\n+\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        DebugArrayTypeInfo debugArrayTypeInfo = (DebugArrayTypeInfo) debugTypeInfo;\n+        String elementTypeName = TypeEntry.canonicalize(debugArrayTypeInfo.elementType());\n+        elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java\nindex a4d0fa4292a..080464d2ca4 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java\n\n@@ -49,7 +49,7 @@ public class ArrayTypeEntry extends TypeEntry {\n     public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n         DebugArrayTypeInfo debugArrayTypeInfo = (DebugArrayTypeInfo) debugTypeInfo;\n         String elementTypeName = TypeEntry.canonicalize(debugArrayTypeInfo.elementType());\n-        elementType = debugInfoBase.lookupTypeEntry(elementTypeName);\n+        this.elementType = debugInfoBase.lookupTypeEntry(elementTypeName);\n         this.headerSize = debugArrayTypeInfo.headerSize();\n         this.lengthOffset = debugArrayTypeInfo.lengthOffset();\n         debugContext.log(\"typename %s element type %s header size %d length offset %d\\n\", typeName, elementTypeName, headerSize, lengthOffset);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245128", "bodyText": "Wouldn't it be safer to use a different name? e.g. primaryFileEntry", "author": "zakkak", "createdAt": "2020-12-22T12:17:04Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -133,10 +122,14 @@ public void addPrimary(Range primary, List<DebugFrameSizeChange> frameSizeInfos,\n                 /* deopt targets should all come after normal methods */\n                 assert includesDeoptTarget == false;\n             }\n+            @SuppressWarnings(\"hiding\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNTcyNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551215725", "bodyText": "yes", "author": "adinn", "createdAt": "2021-01-04T09:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 0758b4012df..a254bcc3d20 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -122,10 +147,9 @@ public class ClassEntry extends StructureTypeEntry {\n                 /* deopt targets should all come after normal methods */\n                 assert includesDeoptTarget == false;\n             }\n-            @SuppressWarnings(\"hiding\")\n-            FileEntry fileEntry = primary.getFileEntry();\n-            assert fileEntry != null;\n-            indexFileEntry(fileEntry);\n+            FileEntry primaryFileEntry = primary.getFileEntry();\n+            assert primaryFileEntry != null;\n+            indexLocalFileEntry(primaryFileEntry);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245912", "bodyText": "As above, I would prevent the hiding (especially here where the SuppressWarnings annotation is \"hidden\" in the method signature) by using a different name, e.g. entry in this case.", "author": "zakkak", "createdAt": "2020-12-22T12:18:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -148,13 +141,18 @@ public void addSubRange(Range subrange, FileEntry subFileEntry) {\n          */\n         assert primaryEntry != null;\n         assert primaryEntry.getClassEntry() == this;\n-        primaryEntry.addSubRange(subrange, subFileEntry);\n+        primaryEntry.addSubRange(subrange);\n+        FileEntry subFileEntry = subrange.getFileEntry();\n         if (subFileEntry != null) {\n-            if (localFilesIndex.get(subFileEntry) == null) {\n-                localFiles.add(subFileEntry);\n-                localFilesIndex.put(subFileEntry, localFiles.size());\n-            }\n-            DirEntry dirEntry = subFileEntry.getDirEntry();\n+            indexFileEntry(subFileEntry);\n+        }\n+    }\n+\n+    private void indexFileEntry(@SuppressWarnings(\"hiding\") FileEntry fileEntry) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDA5Ng==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234096", "bodyText": "Yes, I renamed this to localFileEntry and also changed the method name to indexLocalFileEntry", "author": "adinn", "createdAt": "2021-01-04T10:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 0758b4012df..a254bcc3d20 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -144,15 +168,15 @@ public class ClassEntry extends StructureTypeEntry {\n         primaryEntry.addSubRange(subrange);\n         FileEntry subFileEntry = subrange.getFileEntry();\n         if (subFileEntry != null) {\n-            indexFileEntry(subFileEntry);\n+            indexLocalFileEntry(subFileEntry);\n         }\n     }\n \n-    private void indexFileEntry(@SuppressWarnings(\"hiding\") FileEntry fileEntry) {\n-        if (localFilesIndex.get(fileEntry) == null) {\n-            localFiles.add(fileEntry);\n-            localFilesIndex.put(fileEntry, localFiles.size());\n-            DirEntry dirEntry = fileEntry.getDirEntry();\n+    private void indexLocalFileEntry(FileEntry localFileEntry) {\n+        if (localFilesIndex.get(localFileEntry) == null) {\n+            localFiles.add(localFileEntry);\n+            localFilesIndex.put(localFileEntry, localFiles.size());\n+            DirEntry dirEntry = localFileEntry.getDirEntry();\n             if (dirEntry != null && localDirsIndex.get(dirEntry) == null) {\n                 localDirs.add(dirEntry);\n                 localDirsIndex.put(dirEntry, localDirs.size());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547247325", "bodyText": "nitpick: I would move this right after the constructor.", "author": "zakkak", "createdAt": "2020-12-22T12:22:16Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjQwMQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551216401", "bodyText": "yeah that's better", "author": "adinn", "createdAt": "2021-01-04T09:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 0758b4012df..a254bcc3d20 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -233,31 +257,6 @@ public class ClassEntry extends StructureTypeEntry {\n         return \"\";\n     }\n \n-    @Override\n-    public DebugTypeKind typeKind() {\n-        return DebugTypeKind.INSTANCE;\n-    }\n-\n-    @Override\n-    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n-        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n-        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n-        /* Add details of super and interface classes */\n-        String superName = debugInstanceTypeInfo.superName();\n-        if (superName != null) {\n-            superName = TypeEntry.canonicalize(superName);\n-        }\n-        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n-        if (superName != null) {\n-            this.superClass = debugInfoBase.lookupClassEntry(superName);\n-        }\n-        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n-        /* Add details of fields and field types */\n-        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n-        /* Add details of methods and method types */\n-        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n-    }\n-\n     private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n         debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n         ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547248158", "bodyText": "Another hiding :)", "author": "zakkak", "createdAt": "2020-12-22T12:24:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNjM3Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551236377", "bodyText": "renamed to methodFileEntry", "author": "adinn", "createdAt": "2021-01-04T10:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 0758b4012df..a254bcc3d20 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -233,31 +257,6 @@ public class ClassEntry extends StructureTypeEntry {\n         return \"\";\n     }\n \n-    @Override\n-    public DebugTypeKind typeKind() {\n-        return DebugTypeKind.INSTANCE;\n-    }\n-\n-    @Override\n-    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n-        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n-        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n-        /* Add details of super and interface classes */\n-        String superName = debugInstanceTypeInfo.superName();\n-        if (superName != null) {\n-            superName = TypeEntry.canonicalize(superName);\n-        }\n-        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n-        if (superName != null) {\n-            this.superClass = debugInfoBase.lookupClassEntry(superName);\n-        }\n-        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n-        /* Add details of fields and field types */\n-        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n-        /* Add details of methods and method types */\n-        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n-    }\n-\n     private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n         debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n         ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547249197", "bodyText": "Please don't hide fileEntry especially in this method where both this.fileEntry and fileEntry are being used.", "author": "zakkak", "createdAt": "2020-12-22T12:26:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")\n+        FileEntry fileEntry = debugInfoBase.ensureFileEntry(fileName, filePath, cachePath);\n+        methods.add(new MethodEntry(fileEntry, methodName, this, resultType, paramTypeArray, paramNameArray, modifiers));\n     }\n \n-    public Object primaryIndexFor(Range primaryRange) {\n-        return primaryIndex.get(primaryRange);\n-    }\n+    private static String formatParams(List<String> paramTypes, List<String> paramNames) {\n+        if (paramNames.size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        String separator = \"\";\n+        for (int i = 0; i < paramNames.size(); i++) {\n+            builder.append(separator);\n+            builder.append(paramTypes.get(i));\n+            String paramName = paramNames.get(i);\n+            if (paramName.length() > 0) {\n+                builder.append(' ');\n+                builder.append(paramName);\n+            }\n+            separator = \", \";\n+        }\n \n-    public LinkedList<DirEntry> getLocalDirs() {\n-        return localDirs;\n+        return builder.toString();\n     }\n \n-    public LinkedList<FileEntry> getLocalFiles() {\n-        return localFiles;\n+    public boolean isPrimary() {\n+        return primaryEntries.size() != 0;\n     }\n \n-    public boolean includesDeoptTarget() {\n-        return includesDeoptTarget;\n+    public ClassEntry getSuperClass() {\n+        return superClass;\n     }\n \n-    public String getCachePath() {\n-        if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n-            return \"\";\n+    public Range makePrimaryRange(String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, @SuppressWarnings(\"hiding\") FileEntry fileEntry, int lo,", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzgwNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551217804", "bodyText": "ok", "author": "adinn", "createdAt": "2021-01-04T10:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 0758b4012df..a254bcc3d20 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -233,31 +257,6 @@ public class ClassEntry extends StructureTypeEntry {\n         return \"\";\n     }\n \n-    @Override\n-    public DebugTypeKind typeKind() {\n-        return DebugTypeKind.INSTANCE;\n-    }\n-\n-    @Override\n-    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n-        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n-        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n-        /* Add details of super and interface classes */\n-        String superName = debugInstanceTypeInfo.superName();\n-        if (superName != null) {\n-            superName = TypeEntry.canonicalize(superName);\n-        }\n-        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n-        if (superName != null) {\n-            this.superClass = debugInfoBase.lookupClassEntry(superName);\n-        }\n-        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n-        /* Add details of fields and field types */\n-        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n-        /* Add details of methods and method types */\n-        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n-    }\n-\n     private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n         debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n         ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253161", "bodyText": "Is there any reason to not use this.dirEntry directly?", "author": "zakkak", "createdAt": "2020-12-22T12:35:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDE4NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234184", "bodyText": "no", "author": "adinn", "createdAt": "2021-01-04T10:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex 318a7c096b0..4e782681ba4 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n\n@@ -60,8 +60,6 @@ public class FileEntry {\n     }\n \n     public String getFullName() {\n-        @SuppressWarnings(\"hiding\")\n-        DirEntry dirEntry = getDirEntry();\n         if (dirEntry == null) {\n             return fileName;\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253288", "bodyText": "Is there any reason to not use this.dirEntry directly?", "author": "zakkak", "createdAt": "2020-12-22T12:35:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {\n+            return \"\";\n+        } else {\n+            return dirEntry.getPathString();\n+        }\n     }\n \n     public String getFullName() {\n-        return getDirEntry() != null ? getDirEntry().getPath().resolve(getFileName()).toString() : getFileName();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODYwNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551218605", "bodyText": "No :-)", "author": "adinn", "createdAt": "2021-01-04T10:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex 318a7c096b0..4e782681ba4 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n\n@@ -60,8 +60,6 @@ public class FileEntry {\n     }\n \n     public String getFullName() {\n-        @SuppressWarnings(\"hiding\")\n-        DirEntry dirEntry = getDirEntry();\n         if (dirEntry == null) {\n             return fileName;\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547259753", "bodyText": "Shouldn't this be not reachable?", "author": "zakkak", "createdAt": "2020-12-22T12:49:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -38,34 +38,158 @@\n  * underlying object file so that the latter can insert appropriate debug info.\n  */\n public interface DebugInfoProvider {\n-    /**\n-     * Access details of a specific type.\n-     */\n-    interface DebugTypeInfo {\n-    }\n+    boolean useHeapBase();\n+\n+    int oopShiftBitCount();\n+\n+    int oopFlagBitsMask();\n+\n+    int oopReferenceByteCount();\n \n     /**\n-     * Access details of a specific compiled method.\n+     * An interface implemented by items that can be located in a file.\n      */\n-    interface DebugCodeInfo {\n-        void debugContext(Consumer<DebugContext> action);\n-\n+    interface DebugFileInfo {\n         /**\n-         * @return the name of the file containing a compiled method excluding any path.\n+         * @return the name of the file containing a file element excluding any path.\n          */\n         String fileName();\n \n         /**\n-         * @return a relative path to the file containing a compiled method derived from its package\n-         *         name or null if the method is in the empty package.\n+         * @return a relative path to the file containing a file element derived from its package\n+         *         name or {@code null} if the element is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return a relative path to the source cache containing the sources of a compiled method\n-         *         or {@code null} if sources are not available.\n+         * @return a relative path to the source cache containing the cached source file of a file\n+         *         element or {@code null} if sources are not available.\n          */\n         Path cachePath();\n+    }\n+\n+    interface DebugTypeInfo extends DebugFileInfo {\n+        enum DebugTypeKind {\n+            PRIMITIVE,\n+            ENUM,\n+            INSTANCE,\n+            INTERFACE,\n+            ARRAY,\n+            HEADER;\n+\n+            @Override\n+            public String toString() {\n+                switch (this) {\n+                    case PRIMITIVE:\n+                        return \"primitive\";\n+                    case ENUM:\n+                        return \"enum\";\n+                    case INSTANCE:\n+                        return \"instance\";\n+                    case INTERFACE:\n+                        return \"interface\";\n+                    case ARRAY:\n+                        return \"array\";\n+                    case HEADER:\n+                        return \"header\";\n+                    default:\n+                        return \"???\";", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTQ2NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551235464", "bodyText": "Yes, but tell that to my IDE :-)", "author": "adinn", "createdAt": "2021-01-04T10:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 4e24ca6f2aa..2d358288845 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n\n@@ -38,44 +38,16 @@ import org.graalvm.compiler.debug.DebugContext;\n  * underlying object file so that the latter can insert appropriate debug info.\n  */\n public interface DebugInfoProvider {\n-    boolean useHeapBase();\n-\n-    int oopShiftBitCount();\n-\n-    int oopFlagBitsMask();\n-\n-    int oopReferenceByteCount();\n-\n     /**\n-     * An interface implemented by items that can be located in a file.\n+     * Access details of a specific type.\n      */\n-    interface DebugFileInfo {\n-        /**\n-         * @return the name of the file containing a file element excluding any path.\n-         */\n-        String fileName();\n-\n-        /**\n-         * @return a relative path to the file containing a file element derived from its package\n-         *         name or {@code null} if the element is in the empty package.\n-         */\n-        Path filePath();\n-\n-        /**\n-         * @return a relative path to the source cache containing the cached source file of a file\n-         *         element or {@code null} if sources are not available.\n-         */\n-        Path cachePath();\n-    }\n-\n-    interface DebugTypeInfo extends DebugFileInfo {\n+    interface DebugTypeInfo {\n         enum DebugTypeKind {\n             PRIMITIVE,\n             ENUM,\n             INSTANCE,\n             INTERFACE,\n-            ARRAY,\n-            HEADER;\n+            ARRAY;\n \n             @Override\n             public String toString() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547262924", "bodyText": "This comment looks like there is something missing here (it is not followed by any command).\nIt should be placed above writeBuiltInUnit if I am not mistaken.", "author": "zakkak", "createdAt": "2020-12-22T12:56:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -61,133 +133,1009 @@ public String getSectionName() {\n         return DW_INFO_SECTION_NAME;\n     }\n \n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        // order all content decisions after all size decisions by\n+        // making info section content depend on abbrev section size\n+        String abbrevSectionName = dwarfSections.getAbbrevSectionImpl().getSectionName();\n+        ELFObjectFile.ELFSection abbrevSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(abbrevSectionName);\n+        LayoutDecision sizeDecision = decisions.get(abbrevSection).getDecision(LayoutDecision.Kind.SIZE);\n+        deps.add(BuildDependency.createOrGet(ourContent, sizeDecision));\n+        return deps;\n+    }\n+\n     @Override\n     public void createContent() {\n-        /*\n-         * We need a single level 0 DIE for each compilation unit (CU). Each CU's Level 0 DIE is\n-         * preceded by a fixed header and terminated by a null DIE:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>uint32 length ......... excluding this length field</code>\n-         *\n-         * <li><code>uint16 dwarf_version .. always 2 ??</code>\n-         *\n-         * <li><code>uint32 abbrev offset .. always 0 ??</code>\n-         *\n-         * <li><code>uint8 address_size .... always 8</code>\n-         *\n-         * <li><code>DIE* .................. sequence of top-level and nested child entries</code>\n-         *\n-         * <li><code>null_DIE .............. == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * A DIE is a recursively defined structure. it starts with a code for the associated abbrev\n-         * entry followed by a series of attribute values, as determined by the entry, terminated by\n-         * a null value and followed by zero or more child DIEs (zero iff has_children ==\n-         * no_children).\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of\n-         * DIE</code>\n-         *\n-         * <li><code>attribute_value* ......... value sequence as determined by abbrev entry</code>\n-         *\n-         * <li><code>DIE* ..................... sequence of child DIEs (if appropriate)</code>\n-         * <li><code>\n-         *\n-         * <li><code>null_value ............... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * Note that a null_DIE looks like:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code ....... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * i.e. it also looks like a null_value.\n-         */\n+        assert !contentByteArrayCreated();\n \n         byte[] buffer = null;\n-        int pos = 0;\n+        int len = generateContent(null, buffer);\n \n-        /* CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(null, classEntry, false, buffer, pos);\n-            /*\n-             * No need to backpatch length at lengthPos.\n-             */\n-        }\n-        /* CUs for deopt targets */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            if (classEntry.includesDeoptTarget()) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(null, classEntry, true, buffer, pos);\n-                /*\n-                 * No need to backpatch length at lengthPos.\n-                 */\n-            }\n-        }\n-        buffer = new byte[pos];\n+        buffer = new byte[len];\n         super.setContent(buffer);\n     }\n \n     @Override\n     public void writeContent(DebugContext context) {\n+        assert contentByteArrayCreated();\n+\n         byte[] buffer = getContent();\n         int size = buffer.length;\n         int pos = 0;\n \n         enableLog(context, pos);\n-\n         log(context, \"  [0x%08x] DEBUG_INFO\", pos);\n         log(context, \"  [0x%08x] size = 0x%08x\", pos, size);\n-        /* write CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            /*\n-             * Save the offset of this file's CU so it can be used when writing the aranges section.\n-             */\n-            classEntry.setCUIndex(pos);\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            log(context, \"  [0x%08x] Compilation Unit\", pos, size);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(context, classEntry, false, buffer, pos);\n-            /*\n-             * Backpatch length at lengthPos (excluding length field).\n-             */\n-            patchLength(lengthPos, buffer, pos);\n+\n+        pos = generateContent(context, buffer);\n+        assert pos == size;\n+    }\n+\n+    byte computeEncoding(int flags, int bitCount) {\n+        assert bitCount > 0;\n+        if ((flags & FLAG_NUMERIC) != 0) {\n+            if (((flags & FLAG_INTEGRAL) != 0)) {\n+                if ((flags & FLAG_SIGNED) != 0) {\n+                    switch (bitCount) {\n+                        case 8:\n+                            return DW_ATE_signed_char;\n+                        default:\n+                            assert bitCount == 16 || bitCount == 32 || bitCount == 64;\n+                            return DW_ATE_signed;\n+                    }\n+                } else {\n+                    assert bitCount == 16;\n+                    return DW_ATE_unsigned; // should be UTF???\n+                }\n+            } else {\n+                assert bitCount == 32 || bitCount == 64;\n+                return DW_ATE_float;\n+            }\n+        } else {\n+            assert bitCount == 1;\n+            return DW_ATE_boolean;\n         }\n-        /* write CUs for deopt targets */\n+    }\n+\n+    public int generateContent(DebugContext context, byte[] buffer) {\n+        int pos = 0;\n+        pos = writeBuiltInUnit(context, buffer, pos);\n+\n+        // write entries for all the types known to the generator", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxOTE1OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551219159", "bodyText": "Yes it should.", "author": "adinn", "createdAt": "2021-01-04T10:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 0cf8479e725..189d86f7e6d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -201,10 +201,11 @@ public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n \n     public int generateContent(DebugContext context, byte[] buffer) {\n         int pos = 0;\n-        pos = writeBuiltInUnit(context, buffer, pos);\n \n         // write entries for all the types known to the generator\n \n+        pos = writeBuiltInUnit(context, buffer, pos);\n+\n         // write class units for non-primary classes i.e. ones which\n         // don't have associated methods\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547264804", "bodyText": "Shouldn't we rename this to DW_VERSION instead? Is there any chance to use different dwarf versions in different places?", "author": "zakkak", "createdAt": "2020-12-22T13:00:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -196,7 +1144,7 @@ private int writeCUHeader(byte[] buffer, int p) {\n             /* CU length. */\n             pos += putInt(0, scratch, 0);\n             /* DWARF version. */\n-            pos += putShort(DW_VERSION_2, scratch, 0);\n+            pos += putShort(DW_VERSION_4, scratch, 0);", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMzg0Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551223847", "bodyText": "I am already doing that. The aranges and line sections are still written as DW_VERSION_2.  n.b. it does not cause a problem for gdb.\nStill, you are right that it would be better to write all sections using a single preferred dwarf version. However, before changing anything we will need to carefully check the spec to see if updating the version of those two sections to 4 also requires changes to their format. This is probably best left for a follow-up issue.", "author": "adinn", "createdAt": "2021-01-04T10:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 0cf8479e725..c6e7b37a26f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -1144,7 +196,7 @@ public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n             /* CU length. */\n             pos += putInt(0, scratch, 0);\n             /* DWARF version. */\n-            pos += putShort(DW_VERSION_4, scratch, 0);\n+            pos += putShort(DW_VERSION_2, scratch, 0);\n             /* Abbrev offset. */\n             pos += putInt(0, scratch, 0);\n             /* Address size. */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547267693", "bodyText": "Consider extracting a new method ResolvedJavaType getJavaType(ResolvedJavaType, boolean) to reduce code duplication (i.e. keep all the instanceof checks in one place)", "author": "zakkak", "createdAt": "2020-12-22T13:07:19Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +156,132 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n+\n+    /*\n+     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n+     * lookup relative to the doubly unwrapped HostedType.\n+     *\n+     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n+     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n+     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n+     * need to use the original to name the owning type to ensure that names found in method param\n+     * and return types resolve correctly.\n      */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n+    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n+        ResolvedJavaType javaType;\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n+            if (javaType instanceof SubstitutionType) {\n+                return ((SubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n+                return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n+            } else if (javaType instanceof LambdaSubstitutionType) {\n+                return ((LambdaSubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof InjectedFieldsType) {\n+                return ((InjectedFieldsType) javaType).getOriginal();\n+            } else {\n+                return javaType;\n+            }\n+        }\n+        return hostedType.getWrapped().getWrapped();\n+    }\n+\n+    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            HostedType hostedType = hostedMethod.getDeclaringClass();\n+            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMDk5Ng==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551230996", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-04T10:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\nindex 09428b947f6..1763bc06b8d 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n\n@@ -177,17 +177,8 @@ class NativeImageDebugInfoProvider implements DebugInfoProvider {\n         if (wantOriginal) {\n             // check for wholesale replacement of the original class\n             javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            if (javaType instanceof SubstitutionType) {\n-                return ((SubstitutionType) javaType).getOriginal();\n-            } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n-                return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n-            } else if (javaType instanceof LambdaSubstitutionType) {\n-                return ((LambdaSubstitutionType) javaType).getOriginal();\n-            } else if (javaType instanceof InjectedFieldsType) {\n-                return ((InjectedFieldsType) javaType).getOriginal();\n-            } else {\n-                return javaType;\n-            }\n+            ResolvedJavaType originalType = getOriginal(javaType);\n+            return (originalType != null ? originalType : javaType);\n         }\n         return hostedType.getWrapped().getWrapped();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547271778", "bodyText": "Redundant?", "author": "zakkak", "createdAt": "2020-12-22T13:16:07Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +310,593 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.\n+                return ((HostedInstanceClass) hostedType).getInstanceSize();\n+            } else if (hostedType instanceof HostedArrayClass) {\n+                // Use the size of header common to all arrays of this type.\n+                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n+            } else if (hostedType instanceof HostedInterface) {\n+                // Use the size of the header common to all implementors.\n+                return OBJECTLAYOUT.getFirstFieldOffset();\n+            } else {\n+                // Use the number of bytes needed needed to store the value.\n+                assert hostedType instanceof HostedPrimitiveType;\n+                JavaKind javaKind = hostedType.getStorageKind();\n+                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n+            }\n+        }\n+    }\n+\n+    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n+        String typeName;\n+        int size;\n+        List<DebugFieldInfo> fieldInfos;\n+\n+        NativeImageHeaderTypeInfo(String typeName, int size) {\n+            this.typeName = typeName;\n+            this.size = size;\n+            this.fieldInfos = new LinkedList<>();\n+        }\n+\n+        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n+            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n+            fieldInfos.add(fieldinfo);\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return typeName;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.HEADER;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path cachePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            return fieldInfos.stream();\n+        }\n+\n+        private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n+            private final String name;\n+            private final String ownerType;\n+            private final String valueType;\n+            private final int offset;\n+            private final int size;\n+            private final int modifiers;\n+\n+            NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n+                this.name = name;\n+                this.ownerType = ownerType;\n+                this.valueType = valueType;\n+                this.offset = offset;\n+                this.size = size;\n+                this.modifiers = Modifier.PUBLIC;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return ownerType;\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return valueType;\n+            }\n+\n+            @Override\n+            public int offset() {\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return size;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return modifiers;\n+            }\n+\n+            @Override\n+            public String fileName() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public Path filePath() {\n+                return null;\n+            }\n+\n+            @Override\n+            public Path cachePath() {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n+        List<DebugTypeInfo> infos = new LinkedList<>();\n+        int hubOffset = OBJECTLAYOUT.getHubOffset();\n+        int referenceSize = OBJECTLAYOUT.getReferenceSize();\n+        int hubFieldSize = referenceSize;\n+        String hubTypeName = \"java.lang.Class\";\n+        int arrayLengthOffset = OBJECTLAYOUT.getArrayLengthOffset();\n+        int arrayLengthSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n+        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int objHeaderSize = OBJECTLAYOUT.getFirstFieldOffset();\n+        // we need array headers for all Java kinds\n+\n+        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n+        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+        if (idHashOffset > 0) {\n+            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+        }\n+        infos.add(objHeader);\n+\n+        // create a header for each\n+        for (JavaKind arrayKind : ARRAY_KINDS) {\n+            String name = \"_arrhdr\" + arrayKind.getTypeChar();\n+            int headerSize = OBJECTLAYOUT.getArrayBaseOffset(arrayKind);\n+            NativeImageHeaderTypeInfo arrHeader = new NativeImageHeaderTypeInfo(name, headerSize);\n+            arrHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+            if (idHashOffset > 0) {\n+                arrHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+            }\n+            arrHeader.addField(\"len\", \"int\", arrayLengthOffset, arrayLengthSize);\n+            infos.add(arrHeader);\n+        }\n+        return infos.stream();\n+    }\n+\n+    private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+\n+        NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n+            super(enumClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ENUM;\n+        }\n+    }\n+\n+    private class NativeImageDebugInstanceTypeInfo extends NativeImageDebugTypeInfo implements DebugInstanceTypeInfo {\n+        NativeImageDebugInstanceTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INSTANCE;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getFirstFieldOffset();\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            Stream<DebugFieldInfo> instanceFieldsStream = Arrays.stream(hostedType.getInstanceFields(false)).map(this::createDebugFieldInfo);\n+            if (hostedType instanceof HostedInstanceClass && hostedType.getStaticFields().length > 0) {\n+                Stream<DebugFieldInfo> staticFieldsStream = Arrays.stream(hostedType.getStaticFields()).map(this::createDebugStaticFieldInfo);\n+                return Stream.concat(instanceFieldsStream, staticFieldsStream);\n+            } else {\n+                return instanceFieldsStream;\n+            }\n+        }\n+\n+        @Override\n+        public Stream<DebugMethodInfo> methodInfoProvider() {\n+            return Arrays.stream(hostedType.getAllDeclaredMethods()).map(this::createDebugMethodInfo);\n+        }\n+\n+        @Override\n+        public String superName() {\n+            HostedClass superClass = hostedType.getSuperclass();\n+            /*\n+             * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+             * getSourceFilename to the wrapped class so for consistency we need to do the path\n+             * lookup relative to the doubly unwrapped HostedType.\n+             */\n+            if (superClass != null) {\n+                return getJavaType(superClass, true).toJavaName();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Stream<String> interfaces() {\n+            return Arrays.stream(hostedType.getInterfaces()).map(this::toJavaName);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugFieldInfo(HostedField field) {\n+            return new NativeImageDebugFieldInfo(field);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugStaticFieldInfo(ResolvedJavaField field) {\n+            return new NativeImageDebugFieldInfo((HostedField) field);\n+        }\n+\n+        protected NativeImageDebugMethodInfo createDebugMethodInfo(HostedMethod method) {\n+            return new NativeImageDebugMethodInfo(method);\n+        }\n+\n+        protected class NativeImageDebugFieldInfo extends NativeImageDebugFileInfo implements DebugFieldInfo {\n+            private final HostedField field;\n+\n+            NativeImageDebugFieldInfo(HostedField field) {\n+                super(field);\n+                this.field = field;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return field.getName();\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                HostedType valueType = field.getType();\n+                return toJavaName(valueType);\n+            }\n+\n+            @Override\n+            public int offset() {\n+                int offset = field.getLocation();\n+                // for static fields we need to add in the appropriate partition base\n+                // but only if we have a real offset\n+                if (isStatic() && offset >= 0) {\n+                    if (isPrimitive()) {\n+                        offset += primitiveStartOffset;\n+                    } else {\n+                        offset += referenceStartOffset;\n+                    }\n+                }\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return OBJECTLAYOUT.sizeInBytes(field.getType().getStorageKind());\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return field.getModifiers();\n+            }\n+\n+            private boolean isStatic() {\n+                return Modifier.isStatic(modifiers());\n+            }\n+\n+            private boolean isPrimitive() {\n+                return field.getType().getStorageKind().isPrimitive();\n+            }\n+        }\n+\n+        protected class NativeImageDebugMethodInfo extends NativeImageDebugFileInfo implements DebugMethodInfo {\n+            private final HostedMethod hostedMethod;\n+\n+            NativeImageDebugMethodInfo(HostedMethod hostedMethod) {\n+                super(hostedMethod);\n+                this.hostedMethod = hostedMethod;\n+            }\n+\n+            @Override\n+            public String name() {\n+                String name = hostedMethod.format(\"%n\");\n+                if (\"<init>\".equals(name)) {\n+                    ResolvedJavaMethod unwrapped = hostedMethod.getWrapped().getWrapped();\n+                    if (unwrapped instanceof SubstitutionMethod) {\n+                        unwrapped = ((SubstitutionMethod) unwrapped).getOriginal();\n+                    }\n+                    name = unwrapped.format(\"%h\");\n+                    if (name.indexOf('$') >= 0) {\n+                        name = name.substring(name.lastIndexOf('$') + 1);\n+                    }\n+                }\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return hostedMethod.getSignature().getReturnType(null).toJavaName();\n+            }\n+\n+            @Override\n+            public List<String> paramTypes() {\n+                LinkedList<String> paramTypes = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramTypes.add(signature.getParameterType(i, null).toJavaName());\n+                }\n+                return paramTypes;\n+            }\n+\n+            @Override\n+            public List<String> paramNames() {\n+                // can only provide blank names for now\n+                LinkedList<String> paramNames = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramNames.add(\"\");\n+                }\n+                return paramNames;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return hostedMethod.getModifiers();\n+            }\n+        }\n+    }\n+\n+    private class NativeImageDebugInterfaceTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugInterfaceTypeInfo {\n+\n+        NativeImageDebugInterfaceTypeInfo(HostedInterface interfaceClass) {\n+            super(interfaceClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INTERFACE;\n+        }\n+    }\n+\n+    private class NativeImageDebugArrayTypeInfo extends NativeImageDebugTypeInfo implements DebugArrayTypeInfo {\n+        HostedArrayClass arrayClass;\n+\n+        NativeImageDebugArrayTypeInfo(HostedArrayClass arrayClass) {\n+            super(arrayClass);\n+            this.arrayClass = arrayClass;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ARRAY;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getArrayBaseOffset(arrayClass.getComponentType().getStorageKind());\n+        }\n+\n+        @Override\n+        public int lengthOffset() {\n+            return OBJECTLAYOUT.getArrayLengthOffset();\n+        }\n+\n+        @Override\n+        public String elementType() {\n+            HostedType elementType = arrayClass.getComponentType();\n+            return toJavaName(elementType);\n+        }\n+    }\n+\n+    private class NativeImageDebugPrimitiveTypeInfo extends NativeImageDebugTypeInfo implements DebugPrimitiveTypeInfo {\n+        private final HostedPrimitiveType primitiveType;\n+\n+        NativeImageDebugPrimitiveTypeInfo(HostedPrimitiveType primitiveType) {\n+            super(primitiveType);\n+            this.primitiveType = primitiveType;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.PRIMITIVE;\n+        }\n+\n+        @Override\n+        public int bitCount() {\n+            JavaKind javaKind = primitiveType.getStorageKind();\n+            return (javaKind == JavaKind.Void ? 0 : javaKind.getBitCount());\n+        }\n+\n+        @Override\n+        public char typeChar() {\n+            return primitiveType.getStorageKind().getTypeChar();\n+        }\n+\n+        @Override\n+        public int flags() {\n+            char typeChar = primitiveType.getStorageKind().getTypeChar();\n+            switch (typeChar) {\n+                case 'B':\n+                case 'S':\n+                case 'I':\n+                case 'J': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL | FLAG_SIGNED;\n+                }\n+                case 'C': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL;\n+                }\n+                case 'F':\n+                case 'D': {\n+                    return FLAG_NUMERIC;\n+                }\n+                default: {\n+                    assert typeChar == 'V' || typeChar == 'Z';\n+                    return 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private NativeImageDebugTypeInfo createDebugTypeInfo(HostedType hostedType) {\n+        if (hostedType.isEnum()) {\n+            return new NativeImageDebugEnumTypeInfo((HostedInstanceClass) hostedType);\n+        } else if (hostedType.isInstanceClass()) {\n+            return new NativeImageDebugInstanceTypeInfo(hostedType);\n+        } else if (hostedType.isInterface()) {\n+            return new NativeImageDebugInterfaceTypeInfo((HostedInterface) hostedType);\n+        } else if (hostedType.isArray()) {\n+            return new NativeImageDebugArrayTypeInfo((HostedArrayClass) hostedType);\n+        } else if (hostedType.isPrimitive()) {\n+            return new NativeImageDebugPrimitiveTypeInfo((HostedPrimitiveType) hostedType);\n+        } else {\n+            throw new RuntimeException(\"Unknown type kind \" + hostedType.getName());\n+        }\n+    }\n+\n+    /**\n+     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo extends NativeImageDebugFileInfo implements DebugCodeInfo {\n+        private final HostedMethod hostedMethod;\n+        private final CompilationResult compilation;\n+\n+        @SuppressWarnings(\"try\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMTQ0Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551231447", "bodyText": "yes", "author": "adinn", "createdAt": "2021-01-04T10:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA=="}], "type": "inlineReview", "revised_code": {"commit": "637d66a875578c991bb171fe720f41b32601d289", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\nindex 09428b947f6..1763bc06b8d 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n\n@@ -829,7 +823,6 @@ class NativeImageDebugInfoProvider implements DebugInfoProvider {\n         private final HostedMethod hostedMethod;\n         private final CompilationResult compilation;\n \n-        @SuppressWarnings(\"try\")\n         NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n             super(method);\n             this.hostedMethod = method;\n"}}, {"oid": "637d66a875578c991bb171fe720f41b32601d289", "url": "https://github.com/oracle/graal/commit/637d66a875578c991bb171fe720f41b32601d289", "message": "fix index key duplication when a stub and the method it is derived from both get included with -O0", "committedDate": "2021-01-20T16:04:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562614089", "bodyText": "// comments should be avoided. mx eclipseformat can behave badly when code gets refactored that uses // comments. Use /* my single line comment */ instead.", "author": "olpaw", "createdAt": "2021-01-22T12:59:10Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +304,594 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDQ1NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563674455", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\nindex 4ec72db2e1b..915eac73168 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n\n@@ -156,371 +91,60 @@ class NativeImageDebugInfoProvider implements DebugInfoProvider {\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n+        return Stream.empty();\n     }\n \n     static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n \n-    /*\n-     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n-     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n-     * lookup relative to the doubly unwrapped HostedType.\n-     *\n-     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n-     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n-     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n-     * need to use the original to name the owning type to ensure that names found in method param\n-     * and return types resolve correctly.\n-     */\n-    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n-        ResolvedJavaType javaType;\n-        if (wantOriginal) {\n-            // check for wholesale replacement of the original class\n-            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            return (originalType != null ? originalType : javaType);\n-        }\n-        return hostedType.getWrapped().getWrapped();\n-    }\n-\n-    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n-        if (wantOriginal) {\n-            // check for wholesale replacement of the original class\n-            HostedType hostedType = hostedMethod.getDeclaringClass();\n-            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            if (originalType != null) {\n-                return originalType;\n-            }\n-            // check for replacement of the original method only\n-            ResolvedJavaMethod javaMethod = hostedMethod.getWrapped().getWrapped();\n-            if (javaMethod instanceof SubstitutionMethod) {\n-                return ((SubstitutionMethod) javaMethod).getOriginal().getDeclaringClass();\n-            } else if (javaMethod instanceof CustomSubstitutionMethod) {\n-                return ((CustomSubstitutionMethod) javaMethod).getOriginal().getDeclaringClass();\n-            }\n-            return hostedType.getWrapped().getWrapped();\n-        }\n-        ResolvedJavaMethod javaMethod = hostedMethod.getWrapped().getWrapped();\n-        return javaMethod.getDeclaringClass();\n-    }\n-\n-    protected static ResolvedJavaType getJavaType(HostedField hostedField, boolean wantOriginal) {\n-        if (wantOriginal) {\n-            // check for wholesale replacement of the original class\n-            HostedType hostedType = hostedField.getDeclaringClass();\n-            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            if (originalType != null) {\n-                return originalType;\n-            }\n-            // check for replacement of the original field only\n-            ResolvedJavaField javaField = hostedField.wrapped.wrapped;\n-            if (javaField instanceof SubstitutionField) {\n-                return ((SubstitutionField) javaField).getOriginal().getDeclaringClass();\n-            }\n-            return hostedType.getWrapped().getWrapped();\n-        }\n-        ResolvedJavaField javaField = hostedField.wrapped.wrapped;\n-        return javaField.getDeclaringClass();\n-    }\n-\n-    private static ResolvedJavaType getOriginal(ResolvedJavaType javaType) {\n-        if (javaType instanceof SubstitutionType) {\n-            return ((SubstitutionType) javaType).getOriginal();\n-        } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n-            return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n-        } else if (javaType instanceof LambdaSubstitutionType) {\n-            return ((LambdaSubstitutionType) javaType).getOriginal();\n-        } else if (javaType instanceof InjectedFieldsType) {\n-            return ((InjectedFieldsType) javaType).getOriginal();\n-        }\n-        return null;\n-    }\n-\n-    private static final Path cachePath = SubstrateOptions.getDebugInfoSourceCacheRoot();\n-\n-    private abstract class NativeImageDebugFileInfo implements DebugFileInfo {\n-        private Path fullFilePath;\n-\n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedType hostedType) {\n-            ResolvedJavaType javaType = getJavaType(hostedType, false);\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedMethod hostedMethod) {\n-            ResolvedJavaType javaType = getJavaType(hostedMethod, false);\n-            HostedType hostedType = hostedMethod.getDeclaringClass();\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedField hostedField) {\n-            ResolvedJavaType javaType = getJavaType(hostedField, false);\n-            HostedType hostedType = hostedField.getDeclaringClass();\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                Path filename = fullFilePath.getFileName();\n-                if (filename != null) {\n-                    return filename.toString();\n-                }\n-            }\n-            return \"\";\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path cachePath() {\n-            return cachePath;\n-        }\n-    }\n+    private abstract class NativeImageDebugTypeInfo implements DebugTypeInfo {\n \n-    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n         protected final HostedType hostedType;\n+        protected final ResolvedJavaType javaType;\n+        protected final Class<?> clazz;\n \n-        @SuppressWarnings(\"try\")\n         protected NativeImageDebugTypeInfo(HostedType hostedType) {\n-            super(hostedType);\n             this.hostedType = hostedType;\n+            this.javaType = hostedType.getWrapped();\n+            if (hostedType instanceof OriginalClassProvider) {\n+                clazz = ((OriginalClassProvider) hostedType).getJavaClass();\n+            } else {\n+                clazz = null;\n+            }\n         }\n \n         @SuppressWarnings(\"try\")\n         @Override\n         public void debugContext(Consumer<DebugContext> action) {\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\",  typeName())) {\n                 action.accept(debugContext);\n             } catch (Throwable e) {\n                 throw debugContext.handle(e);\n             }\n         }\n \n-        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n-            return getJavaType(hostedType, true).toJavaName();\n-        }\n-\n         @Override\n         public String typeName() {\n-            return toJavaName(hostedType);\n+            return hostedType.toJavaName();\n         }\n \n         @Override\n         public int size() {\n             if (hostedType instanceof HostedInstanceClass) {\n-                // We know the actual instance size in bytes.\n                 return ((HostedInstanceClass) hostedType).getInstanceSize();\n-            } else if (hostedType instanceof HostedArrayClass) {\n-                // Use the size of header common to all arrays of this type.\n-                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n-            } else if (hostedType instanceof HostedInterface) {\n-                // Use the size of the header common to all implementors.\n-                return OBJECTLAYOUT.getFirstFieldOffset();\n             } else {\n-                // Use the number of bytes needed needed to store the value.\n-                assert hostedType instanceof HostedPrimitiveType;\n-                JavaKind javaKind = hostedType.getStorageKind();\n-                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n-            }\n-        }\n-    }\n-\n-    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n-        String typeName;\n-        int size;\n-        List<DebugFieldInfo> fieldInfos;\n-\n-        NativeImageHeaderTypeInfo(String typeName, int size) {\n-            this.typeName = typeName;\n-            this.size = size;\n-            this.fieldInfos = new LinkedList<>();\n-        }\n-\n-        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n-            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n-            fieldInfos.add(fieldinfo);\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        @Override\n-        public void debugContext(Consumer<DebugContext> action) {\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n-                action.accept(debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @Override\n-        public String typeName() {\n-            return typeName;\n-        }\n-\n-        @Override\n-        public DebugTypeKind typeKind() {\n-            return DebugTypeKind.HEADER;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            return \"\";\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Path cachePath() {\n-            return null;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return size;\n-        }\n-\n-        @Override\n-        public Stream<DebugFieldInfo> fieldInfoProvider() {\n-            return fieldInfos.stream();\n-        }\n-\n-        private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n-            private final String name;\n-            private final String ownerType;\n-            private final String valueType;\n-            private final int offset;\n-            private final int size;\n-            private final int modifiers;\n-\n-            NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n-                this.name = name;\n-                this.ownerType = ownerType;\n-                this.valueType = valueType;\n-                this.offset = offset;\n-                this.size = size;\n-                this.modifiers = Modifier.PUBLIC;\n-            }\n-\n-            @Override\n-            public String name() {\n-                return name;\n-            }\n-\n-            @Override\n-            public String ownerType() {\n-                return ownerType;\n-            }\n-\n-            @Override\n-            public String valueType() {\n-                return valueType;\n-            }\n-\n-            @Override\n-            public int offset() {\n-                return offset;\n-            }\n-\n-            @Override\n-            public int size() {\n-                return size;\n-            }\n-\n-            @Override\n-            public int modifiers() {\n-                return modifiers;\n-            }\n-\n-            @Override\n-            public String fileName() {\n-                return \"\";\n-            }\n-\n-            @Override\n-            public Path filePath() {\n-                return null;\n-            }\n-\n-            @Override\n-            public Path cachePath() {\n-                return null;\n+                return hostedType.getStorageKind().getByteCount();\n             }\n         }\n     }\n \n-    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n-        List<DebugTypeInfo> infos = new LinkedList<>();\n-        int hubOffset = OBJECTLAYOUT.getHubOffset();\n-        int referenceSize = OBJECTLAYOUT.getReferenceSize();\n-        int hubFieldSize = referenceSize;\n-        String hubTypeName = \"java.lang.Class\";\n-        int arrayLengthOffset = OBJECTLAYOUT.getArrayLengthOffset();\n-        int arrayLengthSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n-        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n-        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n-        int objHeaderSize = OBJECTLAYOUT.getFirstFieldOffset();\n-        // we need array headers for all Java kinds\n-\n-        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n-        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n-        if (idHashOffset > 0) {\n-            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n-        }\n-        infos.add(objHeader);\n-\n-        // create a header for each\n-        for (JavaKind arrayKind : ARRAY_KINDS) {\n-            String name = \"_arrhdr\" + arrayKind.getTypeChar();\n-            int headerSize = OBJECTLAYOUT.getArrayBaseOffset(arrayKind);\n-            NativeImageHeaderTypeInfo arrHeader = new NativeImageHeaderTypeInfo(name, headerSize);\n-            arrHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n-            if (idHashOffset > 0) {\n-                arrHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n-            }\n-            arrHeader.addField(\"len\", \"int\", arrayLengthOffset, arrayLengthSize);\n-            infos.add(arrHeader);\n-        }\n-        return infos.stream();\n-    }\n-\n     private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+        HostedInstanceClass enumClass;\n \n         NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n             super(enumClass);\n+            this.enumClass = enumClass;\n         }\n \n-        @Override\n         public DebugTypeKind typeKind() {\n             return DebugTypeKind.ENUM;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562617542", "bodyText": "You could use:\n            while (targetMethod instanceof WrappedJavaMethod) {\n                targetMethod = ((WrappedJavaMethod) targetMethod).getWrapped();\n            }", "author": "olpaw", "createdAt": "2021-01-22T13:06:02Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -291,7 +1000,36 @@ public String className() {\n \n         @Override\n         public String methodName() {\n-            return method.format(\"%n\");\n+            ResolvedJavaMethod targetMethod = method;\n+            if (targetMethod instanceof HostedMethod) {", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU5MTExOQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563591119", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T09:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\nindex 4ec72db2e1b..915eac73168 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n\n@@ -1000,36 +510,7 @@ class NativeImageDebugInfoProvider implements DebugInfoProvider {\n \n         @Override\n         public String methodName() {\n-            ResolvedJavaMethod targetMethod = method;\n-            if (targetMethod instanceof HostedMethod) {\n-                targetMethod = ((HostedMethod) targetMethod).getWrapped();\n-            }\n-            if (targetMethod instanceof AnalysisMethod) {\n-                targetMethod = ((AnalysisMethod) targetMethod).getWrapped();\n-            }\n-            if (targetMethod instanceof SubstitutionMethod) {\n-                targetMethod = ((SubstitutionMethod) targetMethod).getOriginal();\n-            } else if (targetMethod instanceof CustomSubstitutionMethod) {\n-                targetMethod = ((CustomSubstitutionMethod) targetMethod).getOriginal();\n-            }\n-            String name = targetMethod.getName();\n-            if (name.equals(\"<init>\")) {\n-                if (method instanceof HostedMethod) {\n-                    name = getJavaType((HostedMethod) method, true).toJavaName();\n-                    if (name.indexOf('.') >= 0) {\n-                        name = name.substring(name.lastIndexOf('.') + 1);\n-                    }\n-                    if (name.indexOf('$') >= 0) {\n-                        name = name.substring(name.lastIndexOf('$') + 1);\n-                    }\n-                } else {\n-                    name = targetMethod.format(\"%h\");\n-                    if (name.indexOf('$') >= 0) {\n-                        name = name.substring(name.lastIndexOf('$') + 1);\n-                    }\n-                }\n-            }\n-            return name;\n+            return method.format(\"%n\");\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632355", "bodyText": "Start all those comments with uppercase", "author": "olpaw", "createdAt": "2021-01-22T13:32:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTgwNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671805", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\nindex 56ebdfcc3c5..f4a3d563839 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n\n@@ -139,57 +119,16 @@ public abstract class DebugInfoBase {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n-        /*\n-         * track whether we need to use a heap base regsiter\n-         */\n-        useHeapBase = debugInfoProvider.useHeapBase();\n-\n-        /*\n-         * save mask for low order flag bits\n-         */\n-        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n-        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n-        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n-        // mask must be contiguous from bit 0\n-        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n-\n-        /*\n-         * save amount we need to shift references by when loading from an object field\n-         */\n-        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n-\n-        /*\n-         * save number of bytes in a reference field\n-         */\n-        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n-\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n-        // create all the types\n         debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n-            typeName = stringTable.uniqueDebugString(typeName);\n+            String typeName = debugTypeInfo.typeName().replaceAll(\"\\\\$\", \".\");\n             DebugTypeKind typeKind = debugTypeInfo.typeKind();\n-            int byteSize = debugTypeInfo.size();\n \n-            debugContext.log(DebugContext.INFO_LEVEL, \"Register %s type %s \", typeKind.toString(), typeName);\n-            String fileName = debugTypeInfo.fileName();\n-            Path filePath = debugTypeInfo.filePath();\n-            Path cachePath = debugTypeInfo.cachePath();\n-            addTypeEntry(typeName, fileName, filePath, cachePath, byteSize, typeKind);\n-        }));\n-\n-        // now we can cross reference static and instance field details\n-        debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n-            DebugTypeKind typeKind = debugTypeInfo.typeKind();\n-\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Process %s type %s \", typeKind.toString(), typeName);\n-            TypeEntry typeEntry = lookupTypeEntry(typeName);\n-            typeEntry.addDebugInfo(this, debugTypeInfo, debugContext);\n+            debugContext.log(DebugContext.INFO_LEVEL, \"%s type %s \", typeKind.toString(), typeName);\n         }));\n \n         debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> debugCodeInfo.debugContext((debugContext) -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632620", "bodyText": "/* Create all the types */ + use the same format elsewhere below.", "author": "olpaw", "createdAt": "2021-01-22T13:33:01Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save mask for low order flag bits\n+         */\n+        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n+        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n+        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n+        // mask must be contiguous from bit 0\n+        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n+\n+        /*\n+         * save amount we need to shift references by when loading from an object field\n+         */\n+        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n+\n+        /*\n+         * save number of bytes in a reference field\n+         */\n+        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n+\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n+        // create all the types", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTg4MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671881", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\nindex 56ebdfcc3c5..f4a3d563839 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n\n@@ -139,57 +119,16 @@ public abstract class DebugInfoBase {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n-        /*\n-         * track whether we need to use a heap base regsiter\n-         */\n-        useHeapBase = debugInfoProvider.useHeapBase();\n-\n-        /*\n-         * save mask for low order flag bits\n-         */\n-        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n-        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n-        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n-        // mask must be contiguous from bit 0\n-        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n-\n-        /*\n-         * save amount we need to shift references by when loading from an object field\n-         */\n-        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n-\n-        /*\n-         * save number of bytes in a reference field\n-         */\n-        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n-\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n-        // create all the types\n         debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n-            typeName = stringTable.uniqueDebugString(typeName);\n+            String typeName = debugTypeInfo.typeName().replaceAll(\"\\\\$\", \".\");\n             DebugTypeKind typeKind = debugTypeInfo.typeKind();\n-            int byteSize = debugTypeInfo.size();\n \n-            debugContext.log(DebugContext.INFO_LEVEL, \"Register %s type %s \", typeKind.toString(), typeName);\n-            String fileName = debugTypeInfo.fileName();\n-            Path filePath = debugTypeInfo.filePath();\n-            Path cachePath = debugTypeInfo.cachePath();\n-            addTypeEntry(typeName, fileName, filePath, cachePath, byteSize, typeKind);\n-        }));\n-\n-        // now we can cross reference static and instance field details\n-        debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n-            DebugTypeKind typeKind = debugTypeInfo.typeKind();\n-\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Process %s type %s \", typeKind.toString(), typeName);\n-            TypeEntry typeEntry = lookupTypeEntry(typeName);\n-            typeEntry.addDebugInfo(this, debugTypeInfo, debugContext);\n+            debugContext.log(DebugContext.INFO_LEVEL, \"%s type %s \", typeKind.toString(), typeName);\n         }));\n \n         debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> debugCodeInfo.debugContext((debugContext) -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562640087", "bodyText": "I'd much prefer if the code below uses e.g. DwarfDebugInfo.DW_ABBREV_CODE_field_declaration1 instead of DW_ABBREV_CODE_field_declaration1 so that we do not need all these static imports.", "author": "olpaw", "createdAt": "2021-01-22T13:45:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -26,27 +26,99 @@\n \n package com.oracle.objectfile.elf.dwarf;\n \n+import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ArrayTypeEntry;\n import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.FieldEntry;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.HeaderTypeEntry;\n+import com.oracle.objectfile.debugentry.InterfaceClassEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.PrimitiveTypeEntry;\n import com.oracle.objectfile.debugentry.Range;\n+import com.oracle.objectfile.debugentry.StructureTypeEntry;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n+import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Set;\n \n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_subprogram;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_SECTION_NAME;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_INTEGRAL;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_NUMERIC;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_SIGNED;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_data_type;", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzYwOTQzOQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563609439", "bodyText": "Yes, that sounds like a better way to do it. I have actually applied the same transform to all the other files in this package that were using static imports.\nDone.", "author": "adinn", "createdAt": "2021-01-25T10:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 189d86f7e6d..c6e7b37a26f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -26,99 +26,27 @@\n \n package com.oracle.objectfile.elf.dwarf;\n \n-import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n-import com.oracle.objectfile.LayoutDecisionMap;\n-import com.oracle.objectfile.ObjectFile;\n-import com.oracle.objectfile.debugentry.ArrayTypeEntry;\n import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.FieldEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.HeaderTypeEntry;\n-import com.oracle.objectfile.debugentry.InterfaceClassEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n-import com.oracle.objectfile.debugentry.PrimitiveTypeEntry;\n import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StructureTypeEntry;\n-import com.oracle.objectfile.debugentry.TypeEntry;\n-import com.oracle.objectfile.elf.ELFObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n-import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n-import java.util.Map;\n-import java.util.Set;\n \n-import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_INTEGRAL;\n-import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_NUMERIC;\n-import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_SIGNED;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_data_type;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_layout;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_pointer;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_unit;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_builtin_unit;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_class_layout;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_class_pointer;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_class_unit1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_class_unit2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_field_declaration1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_field_declaration2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_field_declaration3;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_field_declaration4;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_header_field;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_interface_implementor;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_interface_layout;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_interface_pointer;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_declaration1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_declaration2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_location;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_parameter_declaration1;\n-// import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_parameter_declaration2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_method_parameter_declaration3;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_object_header;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_primitive_type;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_static_field_location;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_super_reference;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_void_type;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ACCESS_private;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ACCESS_protected;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ACCESS_public;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ATE_boolean;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ATE_float;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ATE_signed;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ATE_signed_char;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ATE_unsigned;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_1;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_2;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_subprogram;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_SECTION_NAME;\n import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_FLAG_true;\n import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_INFO_SECTION_NAME;\n import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_LANG_Java;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_addr;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_and;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_bra;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_breg0;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_dup;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_eq;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_lit0;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_not;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_plus;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_push_object_address;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_OP_shl;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_VERSION_4;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.TEXT_SECTION_NAME;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_VERSION_2;\n \n /**\n  * Section generator for debug_info section.\n  */\n public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-    /**\n-     * The name of a special DWARF struct type used to model an object header.\n-     */\n-    public static final String OBJECT_HEADER_STRUCT_NAME = \"_objhdr\";\n-\n-    /**\n-     * The name of a special DWARF struct type used to model an array header.\n-     */\n-    public static final String ARRAY_HEADER_STRUCT_NAME = \"_arrhdr\";\n-\n     /**\n      * an info header section always contains a fixed number of bytes.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0NDg4MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562644881", "bodyText": "Aha there it is!\nIf you also have such code why is the explicit & ~0x7L necessary in the example in DebugInfo.md?", "author": "olpaw", "createdAt": "2021-01-22T13:52:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 189d86f7e6d..c6e7b37a26f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -1221,93 +326,10 @@ public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n         }\n     }\n \n-    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n-        byte access;\n-        if (Modifier.isPublic(modifiers)) {\n-            access = DW_ACCESS_public;\n-        } else if (Modifier.isProtected(modifiers)) {\n-            access = DW_ACCESS_protected;\n-        } else if (Modifier.isPrivate(modifiers)) {\n-            access = DW_ACCESS_private;\n-        } else {\n-            // package private -- make it public for now\n-            access = DW_ACCESS_public;\n-        }\n-        return writeAttrData1(access, buffer, p);\n-    }\n-\n-    public int writeOopRelocationExpression(byte[] buffer, int p) {\n-        int pos = p;\n-        if (dwarfSections.useHeapBase()) {\n-            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()\n-            //\n-            // .... push object address (1 byte) ...... [offset]\n-            // .... duplicate object base ............. [offset, offset]\n-            // .... breq end .......................... [offset]\n-            // .... __optional_begin__ (if shift != 0)\n-            // .... push compress_shift ............... [offset, shift]\n-            // .... lsh ............................... [new_offset]\n-            // .... __optional_end__\n-            // .... push rheap + 0 .................... [rheap]\n-            // .... ADD ............................... [oop]\n-            // end: ................................... [offset=0 | oop]\n-            //\n-            // write a location rebasing the offset relative to the heapbase register\n-            byte regOp = (byte) (DW_OP_breg0 + dwarfSections.getHeapbaseRegister());\n-            // we have to size the DWARF expression by writing it to the scratch buffer\n-            // so we can write its size as a ULEB before the expression itself\n-            int shiftBitCount = dwarfSections.oopShiftBitCount();\n-            short skipBytes = (short) (shiftBitCount == 0 ? 3 : 5);\n-            int size = 7 + skipBytes;\n-            if (buffer == null) {\n-                // add ULEB size to the expression size\n-                return pos + putULEB(size, scratch, 0) + size;\n-            } else {\n-                // write the size and expression into the output buffer\n-                pos = putULEB(size, buffer, pos);\n-                pos = putByte(DW_OP_push_object_address, buffer, pos);\n-                pos = putByte(DW_OP_dup, buffer, pos);\n-                pos = putByte(DW_OP_lit0, buffer, pos);\n-                pos = putByte(DW_OP_eq, buffer, pos);\n-                pos = putByte(DW_OP_bra, buffer, pos);\n-                pos = putShort(skipBytes, buffer, pos);\n-                if (shiftBitCount > 0) {\n-                    putByte((byte) (DW_OP_lit0 + shiftBitCount), buffer, pos);\n-                    putByte(DW_OP_shl, buffer, pos);\n-                }\n-                pos = putByte(regOp, buffer, pos);\n-                pos = putSLEB(0, buffer, pos); // 1 byte\n-                return putByte(DW_OP_plus, buffer, pos);\n-            }\n-        } else {\n-            // oop is 64 bit pointer modulo low flag bits\n-            // guaranteed: mask == 2^N - 1 where N <= 5\n-            //\n-            // .... push object address .. [tagged_oop]\n-            // .... push flag bits mask .. [tagged_oop, flag_bits_mask]\n-            // .... NOT .................. [tagged_oop, oop_bits_mask]\n-            // .... AND .................. [oop]\n-\n-            // write a relocatable address relative to the heap section start\n-            int size = 4;\n-            // write the size and expression into the output buffer\n-            if (buffer == null) {\n-                return pos + putULEB(size, scratch, 0) + size;\n-            } else {\n-                pos = putULEB(size, buffer, pos);\n-                pos = putByte(DW_OP_push_object_address, buffer, pos);\n-                pos = putByte((byte) (DW_OP_lit0 + dwarfSections.oopFlagBitsMask()), buffer, pos);\n-                pos = putByte(DW_OP_not, buffer, pos);\n-                pos = putByte(DW_OP_and, buffer, pos);\n-            }\n-            return pos;\n-        }\n-    }\n-\n     /**\n-     * The debug_info section depends on abbrev section.\n+     * The debug_info section content depends on abbrev section content and offset.\n      */\n-    protected static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+    private static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n \n     @Override\n     public String targetSectionName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562654352", "bodyText": "Use the\n            /*-\n             *\n             *\n             */\n\nmethod, then eclipseformat will not reformat your comment content. (Note the - after /*)", "author": "olpaw", "createdAt": "2021-01-22T14:08:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {\n+        int pos = p;\n+        if (dwarfSections.useHeapBase()) {\n+            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MzY0NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563673645", "bodyText": "Yes, thanks for the tip.\nDone.", "author": "adinn", "createdAt": "2021-01-25T12:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 189d86f7e6d..c6e7b37a26f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -1221,93 +326,10 @@ public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n         }\n     }\n \n-    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n-        byte access;\n-        if (Modifier.isPublic(modifiers)) {\n-            access = DW_ACCESS_public;\n-        } else if (Modifier.isProtected(modifiers)) {\n-            access = DW_ACCESS_protected;\n-        } else if (Modifier.isPrivate(modifiers)) {\n-            access = DW_ACCESS_private;\n-        } else {\n-            // package private -- make it public for now\n-            access = DW_ACCESS_public;\n-        }\n-        return writeAttrData1(access, buffer, p);\n-    }\n-\n-    public int writeOopRelocationExpression(byte[] buffer, int p) {\n-        int pos = p;\n-        if (dwarfSections.useHeapBase()) {\n-            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()\n-            //\n-            // .... push object address (1 byte) ...... [offset]\n-            // .... duplicate object base ............. [offset, offset]\n-            // .... breq end .......................... [offset]\n-            // .... __optional_begin__ (if shift != 0)\n-            // .... push compress_shift ............... [offset, shift]\n-            // .... lsh ............................... [new_offset]\n-            // .... __optional_end__\n-            // .... push rheap + 0 .................... [rheap]\n-            // .... ADD ............................... [oop]\n-            // end: ................................... [offset=0 | oop]\n-            //\n-            // write a location rebasing the offset relative to the heapbase register\n-            byte regOp = (byte) (DW_OP_breg0 + dwarfSections.getHeapbaseRegister());\n-            // we have to size the DWARF expression by writing it to the scratch buffer\n-            // so we can write its size as a ULEB before the expression itself\n-            int shiftBitCount = dwarfSections.oopShiftBitCount();\n-            short skipBytes = (short) (shiftBitCount == 0 ? 3 : 5);\n-            int size = 7 + skipBytes;\n-            if (buffer == null) {\n-                // add ULEB size to the expression size\n-                return pos + putULEB(size, scratch, 0) + size;\n-            } else {\n-                // write the size and expression into the output buffer\n-                pos = putULEB(size, buffer, pos);\n-                pos = putByte(DW_OP_push_object_address, buffer, pos);\n-                pos = putByte(DW_OP_dup, buffer, pos);\n-                pos = putByte(DW_OP_lit0, buffer, pos);\n-                pos = putByte(DW_OP_eq, buffer, pos);\n-                pos = putByte(DW_OP_bra, buffer, pos);\n-                pos = putShort(skipBytes, buffer, pos);\n-                if (shiftBitCount > 0) {\n-                    putByte((byte) (DW_OP_lit0 + shiftBitCount), buffer, pos);\n-                    putByte(DW_OP_shl, buffer, pos);\n-                }\n-                pos = putByte(regOp, buffer, pos);\n-                pos = putSLEB(0, buffer, pos); // 1 byte\n-                return putByte(DW_OP_plus, buffer, pos);\n-            }\n-        } else {\n-            // oop is 64 bit pointer modulo low flag bits\n-            // guaranteed: mask == 2^N - 1 where N <= 5\n-            //\n-            // .... push object address .. [tagged_oop]\n-            // .... push flag bits mask .. [tagged_oop, flag_bits_mask]\n-            // .... NOT .................. [tagged_oop, oop_bits_mask]\n-            // .... AND .................. [oop]\n-\n-            // write a relocatable address relative to the heap section start\n-            int size = 4;\n-            // write the size and expression into the output buffer\n-            if (buffer == null) {\n-                return pos + putULEB(size, scratch, 0) + size;\n-            } else {\n-                pos = putULEB(size, buffer, pos);\n-                pos = putByte(DW_OP_push_object_address, buffer, pos);\n-                pos = putByte((byte) (DW_OP_lit0 + dwarfSections.oopFlagBitsMask()), buffer, pos);\n-                pos = putByte(DW_OP_not, buffer, pos);\n-                pos = putByte(DW_OP_and, buffer, pos);\n-            }\n-            return pos;\n-        }\n-    }\n-\n     /**\n-     * The debug_info section depends on abbrev section.\n+     * The debug_info section content depends on abbrev section content and offset.\n      */\n-    protected static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+    private static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n \n     @Override\n     public String targetSectionName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572739221", "bodyText": "Now that we have all this info in the JavaDoc of com.oracle.svm.core.heap.ReferenceAccess please refer to it here instead of replicating.", "author": "olpaw", "createdAt": "2021-02-09T09:50:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1326,207 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_private;\n+        } else {\n+            /* Actually package private -- make it public for now. */\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeIndirectOopConversionExpression(boolean isHub, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * The conversion rules are different depending on whether they apply to the hub class or", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzYzNzk5Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573637992", "bodyText": "Done", "author": "adinn", "createdAt": "2021-02-10T11:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\nindex 19d8ae3a902..c6e7b37a26f 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java\n\n@@ -1326,207 +326,10 @@ public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n         }\n     }\n \n-    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n-        byte access;\n-        if (Modifier.isPublic(modifiers)) {\n-            access = DwarfDebugInfo.DW_ACCESS_public;\n-        } else if (Modifier.isProtected(modifiers)) {\n-            access = DwarfDebugInfo.DW_ACCESS_protected;\n-        } else if (Modifier.isPrivate(modifiers)) {\n-            access = DwarfDebugInfo.DW_ACCESS_private;\n-        } else {\n-            /* Actually package private -- make it public for now. */\n-            access = DwarfDebugInfo.DW_ACCESS_public;\n-        }\n-        return writeAttrData1(access, buffer, p);\n-    }\n-\n-    public int writeIndirectOopConversionExpression(boolean isHub, byte[] buffer, int p) {\n-        int pos = p;\n-        /*\n-         * The conversion rules are different depending on whether they apply to the hub class or\n-         * any other class.\n-         *\n-         * They also vary according to whether isolates are in use and, if so, whether it is\n-         * combined with compression.\n-         *\n-         * Finally, they depend on the choice of GC, specifically it's influence on the number of GC\n-         * tag bits.\n-         *\n-         * The rules are as follows:\n-         *\n-         * H:-SpawnIsolates (explicitly disabled isolates support)\n-         *\n-         * <ul> <li>Regular oops: address64 = val64 <li> Oops pointing to hubs: address64 = val64 &\n-         * \"GC-bits bitmask\" </ul>\n-         *\n-         * -H:+SpawnIsolates -H:-UseCompressedReferences (CE default)\n-         *\n-         * <ul> <li> Regular oops: address64 = val64 + r14 <li> Oops pointing to hubs: address64 =\n-         * ((val64 >> \"num GC bits\") << \"objectAlignmentBits\") + r14 </ul>\n-         *\n-         * objectAlignmentBits should always be 3\n-         *\n-         * -H:+SpawnIsolates+ -H:+UseCompressedReferences (EE default)\n-         *\n-         * <ul> <li> Regular oops: address64 = (val32 << \"compressShift\") + r14 <li> Oops pointing\n-         * to hubs: address64 = ((val32 >> \"num GC bits\") << \"compressShift\") + r14 </ul>\n-         *\n-         * compressShift should always be 3.\n-         *\n-         * For Serial garbage collector (CE)\n-         *\n-         * <ul> <li>\"num GC bits\": 3 <li> \"GC-bits bitmask\": ~0b111 </ul>\n-         *\n-         * For G1 garbage collector (EE only)\n-         *\n-         * <ul> <li>\"num GC bits\": 5 <li> \"GC-bits bitmask\": ~0b11111 </ul>\n-         *\n-         * n.b.\n-         *\n-         * The setting for option -H:+/-SpawnIsolates is determined by useHeapBase == true/false.\n-         *\n-         * The setting for option -H:+/-UseCompressedReferences is determined by oopShiftCount ==\n-         * zero/non-zero\n-         */\n-\n-        boolean useHeapBase = dwarfSections.useHeapBase();\n-        int oopCompressShift = dwarfSections.oopCompressShift();\n-        int oopTagsShift = dwarfSections.oopTagsShift();\n-        int oopAlignShift = dwarfSections.oopAlignShift();\n-        /* we may be able to use a mask or a right shift then a left shift or just a left shift */\n-        int mask = 0;\n-        int rightShift = 0;\n-        int leftShift = 0;\n-        int exprSize = 0;\n-\n-        /*\n-         * First we compute the size of the locexpr and decide how to do any required bit-twiddling\n-         */\n-        if (!useHeapBase) {\n-            /* We must be compressing for a hub otherwise this call would not be needed. */\n-            assert isHub == true;\n-            mask = dwarfSections.oopTagsMask();\n-            assert mask != 0;\n-            /*-\n-             * We don't need to care about zero oops just mask off the tag bits.\n-             *\n-             * required expression is\n-             *\n-             *  .... push object address .. (1 byte) ..... [tagged oop]\n-             *  .... push mask ............ (1 byte) ..... [tagged oop, mask]\n-             *  .... NOT .................. (1 byte) ..... [tagged oop, ~mask]\n-             *  .... AND .................. (1 byte) ..... [raw oop]\n-             */\n-            exprSize += 4;\n-        } else {\n-            /*-\n-             * required expression will be one of these paths\n-             *\n-             *  .... push object address .. (1 byte) ..... [offset]\n-             *  .... duplicate object base  (1 byte) ..... [offset, offset]\n-             *  .... push 0 ............... (1 byte) ..... [offset, offset, 0]\n-             *  .... eq ................... (1 byte) ..... [offset]\n-             *  .... brtrue end ........... (3 bytes) .... [offset == oop == 0 if taken]\n-             *  IF mask != 0\n-             *  .... push mask ............ (1 byte) ..... [offset, mask]\n-             *  .... NOT .................. (1 byte) ..... [offset, ~mask]\n-             *  .... AND .................. (1 byte) ..... [offset]\n-             *  ELSE\n-             *    IF rightShift != 0\n-             *  .... push rightShift ...... (1 byte) ..... [offset, right shift]\n-             *  .... LSHR ................. (1 byte) ..... [offset]\n-             *    END IF\n-             *    IF leftShift != 0\n-             *  .... push leftShift ....... (1 byte) ..... [offset, left shift]\n-             *  .... LSHL ................. (1 byte) ..... [offset]\n-             *    END IF\n-             *  END IF\n-             *  .... push rheap+0 ......... (2 bytes) .... [offset, rheap]\n-             *  .... ADD .................. (1 byte) ..... [oop]\n-             * end: ...................................... [oop]\n-             *\n-             */\n-            /* Count all bytes in common path */\n-            exprSize += 10;\n-            if (isHub) {\n-                if (oopCompressShift == 0) {\n-                    /* We need to use oopAlignment for the shift. */\n-                    oopCompressShift = oopAlignShift;\n-                }\n-                if (oopCompressShift == oopTagsShift) {\n-                    /* We can use a mask to remove the bits. */\n-                    mask = dwarfSections.oopTagsMask();\n-                    exprSize += 3;\n-                } else {\n-                    /* We need two shifts to remove the bits. */\n-                    rightShift = oopTagsShift;\n-                    leftShift = oopCompressShift;\n-                    exprSize += 4;\n-                }\n-            } else {\n-                /* No flags to deal with, so we need either an uncompress or nothing. */\n-                if (oopCompressShift != 0) {\n-                    leftShift = oopCompressShift;\n-                    exprSize += 2;\n-                }\n-            }\n-        }\n-        if (buffer == null) {\n-            /* We need to write size as a ULEB then leave space for size instructions. */\n-            return pos + putULEB(exprSize, scratch, 0) + exprSize;\n-\n-        } else {\n-            /* Write size followed by the expression and check the size comes out correct. */\n-            pos = putULEB(exprSize, buffer, pos);\n-            int exprStart = pos;\n-            if (!useHeapBase) {\n-                pos = putByte(DwarfDebugInfo.DW_OP_push_object_address, buffer, pos);\n-                pos = putByte((byte) (DwarfDebugInfo.DW_OP_lit0 + mask), buffer, pos);\n-                pos = putByte(DwarfDebugInfo.DW_OP_not, buffer, pos);\n-                pos = putByte(DwarfDebugInfo.DW_OP_and, buffer, pos);\n-            } else {\n-                pos = putByte(DwarfDebugInfo.DW_OP_push_object_address, buffer, pos);\n-                /* skip to end if oop is null */\n-                pos = putByte(DwarfDebugInfo.DW_OP_dup, buffer, pos);\n-                pos = putByte(DwarfDebugInfo.DW_OP_lit0, buffer, pos);\n-                pos = putByte(DwarfDebugInfo.DW_OP_eq, buffer, pos);\n-                int skipStart = pos + 3; /* offset excludes BR op + 2 operand bytes */\n-                short offsetToEnd = (short) (exprSize - (skipStart - exprStart));\n-                pos = putByte(DwarfDebugInfo.DW_OP_bra, buffer, pos);\n-                pos = putShort(offsetToEnd, buffer, pos);\n-                /* insert mask or shifts as necessary */\n-                if (mask != 0) {\n-                    pos = putByte((byte) (DwarfDebugInfo.DW_OP_lit0 + mask), buffer, pos);\n-                    pos = putByte(DwarfDebugInfo.DW_OP_not, buffer, pos);\n-                    pos = putByte(DwarfDebugInfo.DW_OP_and, buffer, pos);\n-                } else {\n-                    if (rightShift != 0) {\n-                        pos = putByte((byte) (DwarfDebugInfo.DW_OP_lit0 + rightShift), buffer, pos);\n-                        pos = putByte(DwarfDebugInfo.DW_OP_shr, buffer, pos);\n-                    }\n-                    if (leftShift != 0) {\n-                        pos = putByte((byte) (DwarfDebugInfo.DW_OP_lit0 + leftShift), buffer, pos);\n-                        pos = putByte(DwarfDebugInfo.DW_OP_shl, buffer, pos);\n-                    }\n-                }\n-                /* add the resulting offset to the heapbase register */\n-                byte regOp = (byte) (DwarfDebugInfo.DW_OP_breg0 + dwarfSections.getHeapbaseRegister());\n-                pos = putByte(regOp, buffer, pos);\n-                pos = putSLEB(0, buffer, pos); /* 1 byte. */\n-                pos = putByte(DwarfDebugInfo.DW_OP_plus, buffer, pos);\n-                assert pos == skipStart + offsetToEnd;\n-            }\n-            /* make sure we added up correctly */\n-            assert pos == exprStart + exprSize;\n-        }\n-        return pos;\n-    }\n-\n     /**\n-     * The debug_info section depends on abbrev section.\n+     * The debug_info section content depends on abbrev section content and offset.\n      */\n-    protected static final String TARGET_SECTION_NAME = DwarfDebugInfo.TEXT_SECTION_NAME;\n+    private static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n \n     @Override\n     public String targetSectionName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572751330", "bodyText": "Never store ImageSingletons in static fields.\nImageSingleton values are only valid for a single native-image compilation. If more than one image gets built within the same JVM instance the OBJECTLAYOUT value of the first build will be reused for the second build. In this particular instance you can replace the static field with a static method ...\nstatic ObjectLayout getObjectLayout() {\nreturn ConfigurationValues.getObjectLayout();\n}\n... if using ConfigurationValues.getObjectLayout() directly feels too verbose.", "author": "olpaw", "createdAt": "2021-02-09T10:07:01Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +160,126 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0MDAyNw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573640027", "bodyText": "Done", "author": "adinn", "createdAt": "2021-02-10T11:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY5MDY4OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573690689", "bodyText": "Hmm ... Did you forget to push the related commit/s ?", "author": "olpaw", "createdAt": "2021-02-10T12:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\nindex 821ca0e4242..915eac73168 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java\n\n@@ -160,357 +91,60 @@ class NativeImageDebugInfoProvider implements DebugInfoProvider {\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n+        return Stream.empty();\n     }\n \n     static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n \n-    /*\n-     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n-     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n-     * lookup relative to the doubly unwrapped HostedType.\n-     *\n-     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n-     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n-     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n-     * need to use the original to name the owning type to ensure that names found in method param\n-     * and return types resolve correctly.\n-     */\n-    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n-        ResolvedJavaType javaType;\n-        if (wantOriginal) {\n-            /* Check for wholesale replacement of the original class. */\n-            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            return (originalType != null ? originalType : javaType);\n-        }\n-        return hostedType.getWrapped().getWrapped();\n-    }\n-\n-    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n-        if (wantOriginal) {\n-            /* Check for wholesale replacement of the original class. */\n-            HostedType hostedType = hostedMethod.getDeclaringClass();\n-            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            if (originalType != null) {\n-                return originalType;\n-            }\n-            /* Check for replacement of the original method only. */\n-            ResolvedJavaMethod javaMethod = hostedMethod.getWrapped().getWrapped();\n-            if (javaMethod instanceof SubstitutionMethod) {\n-                return ((SubstitutionMethod) javaMethod).getOriginal().getDeclaringClass();\n-            } else if (javaMethod instanceof CustomSubstitutionMethod) {\n-                return ((CustomSubstitutionMethod) javaMethod).getOriginal().getDeclaringClass();\n-            }\n-            return hostedType.getWrapped().getWrapped();\n-        }\n-        ResolvedJavaMethod javaMethod = hostedMethod.getWrapped().getWrapped();\n-        return javaMethod.getDeclaringClass();\n-    }\n-\n-    protected static ResolvedJavaType getJavaType(HostedField hostedField, boolean wantOriginal) {\n-        if (wantOriginal) {\n-            /* Check for wholesale replacement of the original class. */\n-            HostedType hostedType = hostedField.getDeclaringClass();\n-            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n-            ResolvedJavaType originalType = getOriginal(javaType);\n-            if (originalType != null) {\n-                return originalType;\n-            }\n-            /* Check for replacement of the original field only. */\n-            ResolvedJavaField javaField = hostedField.wrapped.wrapped;\n-            if (javaField instanceof SubstitutionField) {\n-                return ((SubstitutionField) javaField).getOriginal().getDeclaringClass();\n-            }\n-            return hostedType.getWrapped().getWrapped();\n-        }\n-        ResolvedJavaField javaField = hostedField.wrapped.wrapped;\n-        return javaField.getDeclaringClass();\n-    }\n-\n-    private static ResolvedJavaType getOriginal(ResolvedJavaType javaType) {\n-        if (javaType instanceof SubstitutionType) {\n-            return ((SubstitutionType) javaType).getOriginal();\n-        } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n-            return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n-        } else if (javaType instanceof LambdaSubstitutionType) {\n-            return ((LambdaSubstitutionType) javaType).getOriginal();\n-        } else if (javaType instanceof InjectedFieldsType) {\n-            return ((InjectedFieldsType) javaType).getOriginal();\n-        }\n-        return null;\n-    }\n-\n-    private static final Path cachePath = SubstrateOptions.getDebugInfoSourceCacheRoot();\n-\n-    private abstract class NativeImageDebugFileInfo implements DebugFileInfo {\n-        private Path fullFilePath;\n+    private abstract class NativeImageDebugTypeInfo implements DebugTypeInfo {\n \n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedType hostedType) {\n-            ResolvedJavaType javaType = getJavaType(hostedType, false);\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedMethod hostedMethod) {\n-            ResolvedJavaType javaType = getJavaType(hostedMethod, false);\n-            HostedType hostedType = hostedMethod.getDeclaringClass();\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        NativeImageDebugFileInfo(HostedField hostedField) {\n-            ResolvedJavaType javaType = getJavaType(hostedField, false);\n-            HostedType hostedType = hostedField.getDeclaringClass();\n-            Class<?> clazz = hostedType.getJavaClass();\n-            SourceManager sourceManager = ImageSingletons.lookup(SourceManager.class);\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugFileInfo\", hostedType)) {\n-                fullFilePath = sourceManager.findAndCacheSource(javaType, clazz, debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n-            }\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                Path filename = fullFilePath.getFileName();\n-                if (filename != null) {\n-                    return filename.toString();\n-                }\n-            }\n-            return \"\";\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path cachePath() {\n-            return cachePath;\n-        }\n-    }\n-\n-    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n         protected final HostedType hostedType;\n+        protected final ResolvedJavaType javaType;\n+        protected final Class<?> clazz;\n \n-        @SuppressWarnings(\"try\")\n         protected NativeImageDebugTypeInfo(HostedType hostedType) {\n-            super(hostedType);\n             this.hostedType = hostedType;\n+            this.javaType = hostedType.getWrapped();\n+            if (hostedType instanceof OriginalClassProvider) {\n+                clazz = ((OriginalClassProvider) hostedType).getJavaClass();\n+            } else {\n+                clazz = null;\n+            }\n         }\n \n         @SuppressWarnings(\"try\")\n         @Override\n         public void debugContext(Consumer<DebugContext> action) {\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\",  typeName())) {\n                 action.accept(debugContext);\n             } catch (Throwable e) {\n                 throw debugContext.handle(e);\n             }\n         }\n \n-        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n-            return getJavaType(hostedType, true).toJavaName();\n-        }\n-\n         @Override\n         public String typeName() {\n-            return toJavaName(hostedType);\n+            return hostedType.toJavaName();\n         }\n \n         @Override\n         public int size() {\n             if (hostedType instanceof HostedInstanceClass) {\n-                /* We know the actual instance size in bytes. */\n                 return ((HostedInstanceClass) hostedType).getInstanceSize();\n-            } else if (hostedType instanceof HostedArrayClass) {\n-                /* Use the size of header common to all arrays of this type. */\n-                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n-            } else if (hostedType instanceof HostedInterface) {\n-                /* Use the size of the header common to all implementors. */\n-                return OBJECTLAYOUT.getFirstFieldOffset();\n             } else {\n-                /* Use the number of bytes needed needed to store the value. */\n-                assert hostedType instanceof HostedPrimitiveType;\n-                JavaKind javaKind = hostedType.getStorageKind();\n-                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n-            }\n-        }\n-    }\n-\n-    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n-        String typeName;\n-        int size;\n-        List<DebugFieldInfo> fieldInfos;\n-\n-        NativeImageHeaderTypeInfo(String typeName, int size) {\n-            this.typeName = typeName;\n-            this.size = size;\n-            this.fieldInfos = new LinkedList<>();\n-        }\n-\n-        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n-            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n-            fieldInfos.add(fieldinfo);\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        @Override\n-        public void debugContext(Consumer<DebugContext> action) {\n-            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n-                action.accept(debugContext);\n-            } catch (Throwable e) {\n-                throw debugContext.handle(e);\n+                return hostedType.getStorageKind().getByteCount();\n             }\n         }\n-\n-        @Override\n-        public String typeName() {\n-            return typeName;\n-        }\n-\n-        @Override\n-        public DebugTypeKind typeKind() {\n-            return DebugTypeKind.HEADER;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            return \"\";\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Path cachePath() {\n-            return null;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return size;\n-        }\n-\n-        @Override\n-        public Stream<DebugFieldInfo> fieldInfoProvider() {\n-            return fieldInfos.stream();\n-        }\n-    }\n-\n-    private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n-        private final String name;\n-        private final String ownerType;\n-        private final String valueType;\n-        private final int offset;\n-        private final int size;\n-        private final int modifiers;\n-\n-        NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n-            this.name = name;\n-            this.ownerType = ownerType;\n-            this.valueType = valueType;\n-            this.offset = offset;\n-            this.size = size;\n-            this.modifiers = Modifier.PUBLIC;\n-        }\n-\n-        @Override\n-        public String name() {\n-            return name;\n-        }\n-\n-        @Override\n-        public String ownerType() {\n-            return ownerType;\n-        }\n-\n-        @Override\n-        public String valueType() {\n-            return valueType;\n-        }\n-\n-        @Override\n-        public int offset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return size;\n-        }\n-\n-        @Override\n-        public int modifiers() {\n-            return modifiers;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            return \"\";\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Path cachePath() {\n-            return null;\n-        }\n-    }\n-\n-    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n-        List<DebugTypeInfo> infos = new LinkedList<>();\n-        int hubOffset = OBJECTLAYOUT.getHubOffset();\n-        int hubFieldSize = referenceSize;\n-        String hubTypeName = \"java.lang.Class\";\n-        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n-        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n-        int objHeaderSize = OBJECTLAYOUT.getMinimumInstanceObjectSize();\n-\n-        /* We need array headers for all Java kinds */\n-\n-        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n-        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n-        if (idHashOffset > 0) {\n-            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n-        }\n-        infos.add(objHeader);\n-\n-        return infos.stream();\n     }\n \n     private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+        HostedInstanceClass enumClass;\n \n         NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n             super(enumClass);\n+            this.enumClass = enumClass;\n         }\n \n-        @Override\n         public DebugTypeKind typeKind() {\n             return DebugTypeKind.ENUM;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572805513", "bodyText": "/* ... */", "author": "olpaw", "createdAt": "2021-02-09T11:24:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -280,9 +250,110 @@ public boolean includesDeoptTarget() {\n \n     public String getCachePath() {\n         if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n+    }\n+\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0NjAxNg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573646016", "bodyText": "Done. The only remaining // comments are to exclude generation of speculative/currently unavailable field declarations for abbrev record in DwarfAbbrevSectionImpl.java. I really want to leave those as they are place-holders for possible future upgrades.", "author": "adinn", "createdAt": "2021-02-10T11:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\nindex 95bbc319c65..41b549494e3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java\n\n@@ -223,137 +200,89 @@ public class ClassEntry extends StructureTypeEntry {\n         }\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    public void setCUIndex(int cuIndex) {\n+        // Should only get set once to a non-negative value.\n+        assert cuIndex >= 0;\n+        assert this.cuIndex == -1;\n+        this.cuIndex = cuIndex;\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    public int getCUIndex() {\n+        // Should have been set before being read.\n+        assert cuIndex >= 0;\n+        return cuIndex;\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    public Object primaryIndexFor(Range primaryRange) {\n-        return primaryIndex.get(primaryRange);\n+    public void setDeoptCUIndex(int deoptCUIndex) {\n+        // Should only get set once to a non-negative value.\n+        assert deoptCUIndex >= 0;\n+        assert this.deoptCUIndex == -1;\n+        this.deoptCUIndex = deoptCUIndex;\n     }\n \n-    public LinkedList<DirEntry> getLocalDirs() {\n-        return localDirs;\n+    public int getDeoptCUIndex() {\n+        // Should have been set before being read.\n+        assert deoptCUIndex >= 0;\n+        return deoptCUIndex;\n     }\n \n-    public LinkedList<FileEntry> getLocalFiles() {\n-        return localFiles;\n+    public int getLineIndex() {\n+        return lineIndex;\n     }\n \n-    public boolean includesDeoptTarget() {\n-        return includesDeoptTarget;\n+    public void setLineIndex(int lineIndex) {\n+        this.lineIndex = lineIndex;\n     }\n \n-    public String getCachePath() {\n-        if (fileEntry != null) {\n-            Path cachePath = fileEntry.getCachePath();\n-            if (cachePath != null) {\n-                return cachePath.toString();\n-            }\n-        }\n-        return \"\";\n+    public void setLinePrologueSize(int linePrologueSize) {\n+        this.linePrologueSize = linePrologueSize;\n     }\n \n-    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n-        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n-        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n-        assert entry instanceof InterfaceClassEntry;\n-        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n-        interfaces.add(interfaceClassEntry);\n-        interfaceClassEntry.addImplementor(this, debugContext);\n+    public int getLinePrologueSize() {\n+        return linePrologueSize;\n     }\n \n-    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n-        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n-        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n-        int modifiers = debugMethodInfo.modifiers();\n-        List<String> paramTypes = debugMethodInfo.paramTypes();\n-        List<String> paramNames = debugMethodInfo.paramNames();\n-        assert paramTypes.size() == paramNames.size();\n-        int paramCount = paramTypes.size();\n-        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n-                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n-        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n-        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n-        String[] paramNameArray = new String[paramCount];\n-        int idx = 0;\n-        for (String paramTypeName : paramTypes) {\n-            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n-            paramTypeArray[idx++] = paramType;\n-        }\n-        paramNameArray = paramNames.toArray(paramNameArray);\n-        String fileName = debugMethodInfo.fileName();\n-        Path filePath = debugMethodInfo.filePath();\n-        Path cachePath = debugMethodInfo.cachePath();\n-        // n.b. the method file may differ from the owning class file when the method is a\n-        // substitution\n-        FileEntry methodFileEntry = debugInfoBase.ensureFileEntry(fileName, filePath, cachePath);\n-        methods.add(new MethodEntry(methodFileEntry, methodName, this, resultType, paramTypeArray, paramNameArray, modifiers));\n+    public int getTotalSize() {\n+        return totalSize;\n     }\n \n-    @Override\n-    protected FieldEntry addField(DebugInfoProvider.DebugFieldInfo debugFieldInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n-        FieldEntry fieldEntry = super.addField(debugFieldInfo, debugInfoBase, debugContext);\n-        FileEntry fieldFileEntry = fieldEntry.getFileEntry();\n-        if (fieldFileEntry != null) {\n-            indexLocalFileEntry(fieldFileEntry);\n-        }\n-        return fieldEntry;\n+    public void setTotalSize(int totalSize) {\n+        this.totalSize = totalSize;\n     }\n \n-    private static String formatParams(List<String> paramTypes, List<String> paramNames) {\n-        if (paramNames.size() == 0) {\n-            return \"\";\n-        }\n-        StringBuilder builder = new StringBuilder();\n-        String separator = \"\";\n-        for (int i = 0; i < paramNames.size(); i++) {\n-            builder.append(separator);\n-            builder.append(paramTypes.get(i));\n-            String paramName = paramNames.get(i);\n-            if (paramName.length() > 0) {\n-                builder.append(' ');\n-                builder.append(paramName);\n-            }\n-            separator = \", \";\n-        }\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n+    }\n+\n+    public String getClassName() {\n+        return className;\n+    }\n+\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n+    }\n \n-        return builder.toString();\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public boolean isPrimary() {\n-        return primaryEntries.size() != 0;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public ClassEntry getSuperClass() {\n-        return superClass;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public Range makePrimaryRange(String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, FileEntry primaryFileEntry, int lo,\n-                    int hi, int primaryLine,\n-                    int modifiers, boolean isDeoptTarget) {\n-        FileEntry fileEntryToUse = primaryFileEntry;\n-        if (fileEntryToUse == null) {\n-            /*\n-             * Search for a matching method to supply the file entry or failing that use the one\n-             * from this class.\n-             */\n-            for (MethodEntry methodEntry : methods) {\n-                if (methodEntry.match(methodName, paramSignature, returnTypeName)) {\n-                    // maybe the method's file entry\n-                    fileEntryToUse = methodEntry.getFileEntry();\n-                    break;\n-                }\n-            }\n-            if (fileEntryToUse == null) {\n-                /* last chance is the class's file entry */\n-                fileEntryToUse = this.fileEntry;\n-            }\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n+    }\n+\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            return fileEntry.getCachePath();\n+        } else {\n+            return \"\";\n         }\n-        return new Range(this.typeName, methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntryToUse, lo, hi, primaryLine, modifiers, isDeoptTarget);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572806180", "bodyText": "Sometimes your comments still start with lowercase ...", "author": "olpaw", "createdAt": "2021-02-09T11:25:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -119,36 +160,95 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          */\n \n         /*\n-         * Ensure we have a null string in the string section.\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save count of low order tag bits that may appear in references\n          */\n+        int oopTagsMask = debugInfoProvider.oopTagsMask();\n+\n+        /* tag bits must be between 1 and 32 for us to emit as DW_OP_lit<n> */\n+        assert oopTagsMask > 0 && oopTagsMask < 32;\n+        /* mask must be contiguous from bit 0 */\n+        assert ((oopTagsMask + 1) & oopTagsMask) == 0;\n+\n+        oopTagsCount = Integer.bitCount(oopTagsMask);\n+\n+        /* Save amount we need to shift references by when loading from an object field. */\n+        oopCompressShift = debugInfoProvider.oopCompressShift();\n+\n+        /* shift bit count must be either 0 or 3 */\n+        assert (oopCompressShift == 0 || oopCompressShift == 3);\n+\n+        /* Save number of bytes in a reference field. */\n+        oopReferenceSize = debugInfoProvider.oopReferenceSize();\n+\n+        /* Save alignment of a reference */\n+        oopAlignment = debugInfoProvider.oopAlignment();\n+\n+        /* Save alignment of a reference */\n+        oopAlignShift = Integer.bitCount(oopAlignment - 1);\n+\n+        /* reference alignment must be 8 bytes */", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0Nzg5NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573647894", "bodyText": "Yeah, sorry for that. I keep forgetting about this. I think I have found all such cases and corrected them.", "author": "adinn", "createdAt": "2021-02-10T11:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "chunk": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\nindex 0630c329693..f4a3d563839 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java\n\n@@ -160,95 +120,43 @@ public abstract class DebugInfoBase {\n          */\n \n         /*\n-         * track whether we need to use a heap base regsiter\n-         */\n-        useHeapBase = debugInfoProvider.useHeapBase();\n-\n-        /*\n-         * save count of low order tag bits that may appear in references\n+         * Ensure we have a null string in the string section.\n          */\n-        int oopTagsMask = debugInfoProvider.oopTagsMask();\n-\n-        /* tag bits must be between 1 and 32 for us to emit as DW_OP_lit<n> */\n-        assert oopTagsMask > 0 && oopTagsMask < 32;\n-        /* mask must be contiguous from bit 0 */\n-        assert ((oopTagsMask + 1) & oopTagsMask) == 0;\n-\n-        oopTagsCount = Integer.bitCount(oopTagsMask);\n-\n-        /* Save amount we need to shift references by when loading from an object field. */\n-        oopCompressShift = debugInfoProvider.oopCompressShift();\n-\n-        /* shift bit count must be either 0 or 3 */\n-        assert (oopCompressShift == 0 || oopCompressShift == 3);\n-\n-        /* Save number of bytes in a reference field. */\n-        oopReferenceSize = debugInfoProvider.oopReferenceSize();\n-\n-        /* Save alignment of a reference */\n-        oopAlignment = debugInfoProvider.oopAlignment();\n-\n-        /* Save alignment of a reference */\n-        oopAlignShift = Integer.bitCount(oopAlignment - 1);\n-\n-        /* reference alignment must be 8 bytes */\n-        assert oopAlignment == 8;\n-\n-        /* Ensure we have a null string in the string section. */\n         stringTable.uniqueDebugString(\"\");\n \n-        /* Create all the types. */\n-        debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n-            typeName = stringTable.uniqueDebugString(typeName);\n-            DebugTypeKind typeKind = debugTypeInfo.typeKind();\n-            int byteSize = debugTypeInfo.size();\n-\n-            debugContext.log(DebugContext.INFO_LEVEL, \"Register %s type %s \", typeKind.toString(), typeName);\n-            String fileName = debugTypeInfo.fileName();\n-            Path filePath = debugTypeInfo.filePath();\n-            Path cachePath = debugTypeInfo.cachePath();\n-            addTypeEntry(typeName, fileName, filePath, cachePath, byteSize, typeKind);\n-        }));\n-\n-        /* Now we can cross reference static and instance field details. */\n         debugInfoProvider.typeInfoProvider().forEach(debugTypeInfo -> debugTypeInfo.debugContext((debugContext) -> {\n-            String typeName = TypeEntry.canonicalize(debugTypeInfo.typeName());\n+            String typeName = debugTypeInfo.typeName().replaceAll(\"\\\\$\", \".\");\n             DebugTypeKind typeKind = debugTypeInfo.typeKind();\n \n-            debugContext.log(DebugContext.INFO_LEVEL, \"Process %s type %s \", typeKind.toString(), typeName);\n-            TypeEntry typeEntry = lookupTypeEntry(typeName);\n-            typeEntry.addDebugInfo(this, debugTypeInfo, debugContext);\n+            debugContext.log(DebugContext.INFO_LEVEL, \"%s type %s \", typeKind.toString(), typeName);\n         }));\n \n         debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> debugCodeInfo.debugContext((debugContext) -> {\n             /*\n-             * Primary file name and full method name need to be written to the debug_str section.\n+             * primary file name and full method name need to be written to the debug_str section\n              */\n             String fileName = debugCodeInfo.fileName();\n             Path filePath = debugCodeInfo.filePath();\n             Path cachePath = debugCodeInfo.cachePath();\n-            String className = TypeEntry.canonicalize(debugCodeInfo.className());\n+            // switch '$' in class names for '.'\n+            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n             String methodName = debugCodeInfo.methodName();\n             String symbolName = debugCodeInfo.symbolNameForMethod();\n-            String paramSignature = debugCodeInfo.paramSignature();\n-            String returnTypeName = TypeEntry.canonicalize(debugCodeInfo.returnTypeName());\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n             int lo = debugCodeInfo.addressLo();\n             int hi = debugCodeInfo.addressHi();\n             int primaryLine = debugCodeInfo.line();\n             boolean isDeoptTarget = debugCodeInfo.isDeoptTarget();\n-            int modifiers = debugCodeInfo.getModifiers();\n \n-            /* Search for a method defining this primary range. */\n-            ClassEntry classEntry = ensureClassEntry(className);\n-            FileEntry fileEntry = ensureFileEntry(fileName, filePath, cachePath);\n-            Range primaryRange = classEntry.makePrimaryRange(methodName, symbolName, paramSignature, returnTypeName, stringTable, fileEntry, lo, hi, primaryLine, modifiers, isDeoptTarget);\n+            Range primaryRange = new Range(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine, isDeoptTarget);\n             debugContext.log(DebugContext.INFO_LEVEL, \"PrimaryRange %s.%s %s %s:%d [0x%x, 0x%x]\", className, methodName, filePath, fileName, primaryLine, lo, hi);\n-            classEntry.indexPrimary(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n             debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n                 String fileNameAtLine = debugLineInfo.fileName();\n                 Path filePathAtLine = debugLineInfo.filePath();\n-                String classNameAtLine = TypeEntry.canonicalize(debugLineInfo.className());\n+                // Switch '$' in class names for '.'\n+                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n                 String methodNameAtLine = debugLineInfo.methodName();\n                 String symbolNameAtLine = debugLineInfo.symbolNameForMethod();\n                 int loAtLine = lo + debugLineInfo.addressLo();\n"}}, {"oid": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "url": "https://github.com/oracle/graal/commit/e3006a22f50e6d5fd968f37a87b46f988b560ae1", "message": "Basic cut of DebugTypeInfo interface and implementation", "committedDate": "2021-02-10T14:46:07Z", "type": "commit"}, {"oid": "b307ee84155fb340719a658a7be2cc9159c49c02", "url": "https://github.com/oracle/graal/commit/b307ee84155fb340719a658a7be2cc9159c49c02", "message": "Update debug info model to include details of types\n\nfirst cut of debug info model and DWARF generator employing class layouts\n\nrebase on updated master + doc and style fixes\n\nfix problem with method name computation\n\ntest type and instance printing from debuginfotest script building without isolates\n\nfix method name and file lookup\n\nupdate documentation to include details of debug type info support\n\napply consistent file lookup rules", "committedDate": "2021-02-10T14:46:22Z", "type": "commit"}, {"oid": "9c5f2150ac559e086f3f72140060821ab99f6554", "url": "https://github.com/oracle/graal/commit/9c5f2150ac559e086f3f72140060821ab99f6554", "message": "Switch C++ mapping to use Java names for base types and pointers for oops\n\nensure gdb can decode object references to addresses\n\nstyle fixes\n\nrebase and correct object header layout\n\nstyle fixes\n\nfix debuginfotest script\n\neclipse style fixes\n\ndisable test of object layout printing if gdb version less than 10\n\ncorrect pattern for gdb version match\n\ncorrections after zakkak review\n\neclipse style fixes\n\nfix index key duplication when a stub and the method it is derived from both get included with -O0\n\nfix error in lookup of original class for methods and fields\nfix related problem with constructor method names\n\nuse gdb from env var GDB_BIN if available\n\nFix typos and out of date content\n\nsimplify code\n\nadd check for printing of statci fields\n\navoid numerous static imports of constants\n\nstyle fixes\n\nadd details of currently missing features", "committedDate": "2021-02-10T14:46:33Z", "type": "commit"}, {"oid": "9757c9c94e78615d039ded8ee87bc3ab2c0351ce", "url": "https://github.com/oracle/graal/commit/9757c9c94e78615d039ded8ee87bc3ab2c0351ce", "message": "Fix conversion of indirect to war oops using wrapper subclasses", "committedDate": "2021-02-10T14:46:41Z", "type": "commit"}, {"oid": "20618672227ec0e86c17fc4953992966acf3c575", "url": "https://github.com/oracle/graal/commit/20618672227ec0e86c17fc4953992966acf3c575", "message": "Make arrays subtype object and include length as a local field\n\nminor tweak to object sizing routines", "committedDate": "2021-02-10T14:46:48Z", "type": "commit"}, {"oid": "2c3c8abf4c59df5492f9add84f8d5b442c56825d", "url": "https://github.com/oracle/graal/commit/2c3c8abf4c59df5492f9add84f8d5b442c56825d", "message": "Correct debug info test script for new object layout and to bypass latest gdb bug\n\nminor code cleanups\n\nstyle fixes\n\nfix comment text\n\nfurther fixes after latest review", "committedDate": "2021-02-10T14:46:56Z", "type": "commit"}, {"oid": "2c3c8abf4c59df5492f9add84f8d5b442c56825d", "url": "https://github.com/oracle/graal/commit/2c3c8abf4c59df5492f9add84f8d5b442c56825d", "message": "Correct debug info test script for new object layout and to bypass latest gdb bug\n\nminor code cleanups\n\nstyle fixes\n\nfix comment text\n\nfurther fixes after latest review", "committedDate": "2021-02-10T14:46:56Z", "type": "forcePushed"}]}