{"pr_number": 2442, "pr_title": "Support dynamic class loading", "pr_createdAt": "2020-05-08T09:23:58Z", "pr_url": "https://github.com/oracle/graal/pull/2442", "timeline": [{"oid": "695acccc3f381bbbcf5285a7bc7cc4833f18df2c", "url": "https://github.com/oracle/graal/commit/695acccc3f381bbbcf5285a7bc7cc4833f18df2c", "message": "Support dynamic class loading", "committedDate": "2020-05-09T08:50:18Z", "type": "forcePushed"}, {"oid": "7ac0218db0f61a9585aded6aaead7d3772d6c7e4", "url": "https://github.com/oracle/graal/commit/7ac0218db0f61a9585aded6aaead7d3772d6c7e4", "message": "Support dynamic class loading", "committedDate": "2020-05-11T03:33:59Z", "type": "forcePushed"}, {"oid": "74108cb682088b02853f9e8b148fb294540c6475", "url": "https://github.com/oracle/graal/commit/74108cb682088b02853f9e8b148fb294540c6475", "message": "Support dynamic class loading", "committedDate": "2020-05-11T07:16:25Z", "type": "forcePushed"}, {"oid": "ea993d5dc4c23c8ae0166ab6e3362c84e0fad488", "url": "https://github.com/oracle/graal/commit/ea993d5dc4c23c8ae0166ab6e3362c84e0fad488", "message": "Support dynamic class loading", "committedDate": "2020-05-11T07:22:41Z", "type": "forcePushed"}, {"oid": "4819ed448689f8558d5a0543e1d030738bc0ba41", "url": "https://github.com/oracle/graal/commit/4819ed448689f8558d5a0543e1d030738bc0ba41", "message": "Support dynamic class loading", "committedDate": "2020-05-11T07:59:22Z", "type": "forcePushed"}, {"oid": "084ad5423654f30bc81aac9eeaa53b9117f63097", "url": "https://github.com/oracle/graal/commit/084ad5423654f30bc81aac9eeaa53b9117f63097", "message": "Support dynamic class loading", "committedDate": "2020-05-11T09:45:49Z", "type": "forcePushed"}, {"oid": "61af582ca35d9081f794373c126feb347513dc1b", "url": "https://github.com/oracle/graal/commit/61af582ca35d9081f794373c126feb347513dc1b", "message": "Support dynamic class loading", "committedDate": "2020-05-14T06:30:26Z", "type": "forcePushed"}, {"oid": "397df00fcb9750df08c4a8d29c08bb39de15a3e4", "url": "https://github.com/oracle/graal/commit/397df00fcb9750df08c4a8d29c08bb39de15a3e4", "message": "Support dynamic class loading", "committedDate": "2020-05-15T06:07:05Z", "type": "forcePushed"}, {"oid": "1b2203d9ef0c985a446c3844c4befb3c12754b25", "url": "https://github.com/oracle/graal/commit/1b2203d9ef0c985a446c3844c4befb3c12754b25", "message": "Support dynamic class loading", "committedDate": "2020-05-18T12:29:04Z", "type": "forcePushed"}, {"oid": "b86745cbb2ced7d6ba8386d377ea6895feee1998", "url": "https://github.com/oracle/graal/commit/b86745cbb2ced7d6ba8386d377ea6895feee1998", "message": "Support dynamic class loading", "committedDate": "2020-06-12T02:37:03Z", "type": "forcePushed"}, {"oid": "b0b9a0dba8cf8f3d93ae8879860ee744569b32b7", "url": "https://github.com/oracle/graal/commit/b0b9a0dba8cf8f3d93ae8879860ee744569b32b7", "message": "Support dynamic class loading", "committedDate": "2020-06-12T13:52:33Z", "type": "forcePushed"}, {"oid": "1add200d89be51c9bd6b26a982f7773e54168658", "url": "https://github.com/oracle/graal/commit/1add200d89be51c9bd6b26a982f7773e54168658", "message": "Support dynamic class loading", "committedDate": "2020-06-16T05:31:38Z", "type": "forcePushed"}, {"oid": "e2eb02e4d3a69cc98de5b3c3aabb3a27644d1240", "url": "https://github.com/oracle/graal/commit/e2eb02e4d3a69cc98de5b3c3aabb3a27644d1240", "message": "Support dynamic class loading", "committedDate": "2020-06-17T06:42:02Z", "type": "forcePushed"}, {"oid": "5026216c99af1a01e8b7f5ece94dbd108e64b096", "url": "https://github.com/oracle/graal/commit/5026216c99af1a01e8b7f5ece94dbd108e64b096", "message": "Support dynamic class loading", "committedDate": "2020-06-17T06:59:39Z", "type": "forcePushed"}, {"oid": "40eeed907bf9e5c85e47d2ad54072c89283a9fc7", "url": "https://github.com/oracle/graal/commit/40eeed907bf9e5c85e47d2ad54072c89283a9fc7", "message": "Support dynamic class loading", "committedDate": "2020-06-17T08:56:39Z", "type": "forcePushed"}, {"oid": "c9b96ff5eadaabd98b1556a0a94e1b832681b5a9", "url": "https://github.com/oracle/graal/commit/c9b96ff5eadaabd98b1556a0a94e1b832681b5a9", "message": "Support dynamic class loading", "committedDate": "2020-06-17T11:37:06Z", "type": "forcePushed"}, {"oid": "b3acc3e2dd0af35ae64973d81bd48732044f9efb", "url": "https://github.com/oracle/graal/commit/b3acc3e2dd0af35ae64973d81bd48732044f9efb", "message": "Support dynamic class loading", "committedDate": "2020-06-19T11:24:45Z", "type": "forcePushed"}, {"oid": "621458baacc4bac0253f386e9c025069ca269b7c", "url": "https://github.com/oracle/graal/commit/621458baacc4bac0253f386e9c025069ca269b7c", "message": "Support dynamic class loading", "committedDate": "2020-06-19T13:18:39Z", "type": "forcePushed"}, {"oid": "8c088b733bfcba6a772512acbdce560ca5bd2f69", "url": "https://github.com/oracle/graal/commit/8c088b733bfcba6a772512acbdce560ca5bd2f69", "message": "Support dynamic class loading", "committedDate": "2020-06-19T13:22:46Z", "type": "forcePushed"}, {"oid": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "url": "https://github.com/oracle/graal/commit/5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "message": "Support dynamic class loading", "committedDate": "2020-06-22T06:47:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3Mzc2OA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r525973768", "bodyText": "How can this be non-null?", "author": "vjovanov", "createdAt": "2020-11-18T10:24:19Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public abstract class AbstractDynamicClassGenerationSupport {\n+\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected int generatedClassHashCode = 0;\n+    protected byte[] values = null;\n+\n+    private static Path dynclassDumpDir = null;\n+    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n+    protected String callerMethod;\n+\n+    public static void initDynClassDumpDir(String dir) {\n+        dynclassDumpDir = Paths.get(dir);\n+    }\n+\n+    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n+    }\n+\n+    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        if (dynclassDumpDir == null) {", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxNzk4Mw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599217983", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-03-23T02:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3Mzc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\ndeleted file mode 100644\nindex 869613819ba..00000000000\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\n+++ /dev/null\n\n@@ -1,196 +0,0 @@\n-/*\n- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-package com.oracle.svm.agent;\n-\n-import com.oracle.svm.core.util.JavaClassUtil;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n-import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n-\n-import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-\n-public abstract class AbstractDynamicClassGenerationSupport {\n-\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected int generatedClassHashCode = 0;\n-    protected byte[] values = null;\n-\n-    private static Path dynclassDumpDir = null;\n-    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n-    protected String callerMethod;\n-\n-    public static void initDynClassDumpDir(String dir) {\n-        dynclassDumpDir = Paths.get(dir);\n-    }\n-\n-    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n-    }\n-\n-    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        if (dynclassDumpDir == null) {\n-            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n-                            DEFAULT_DUMP.toAbsolutePath().toString());\n-            dynclassDumpDir = DEFAULT_DUMP;\n-        }\n-\n-        if (!Files.exists(dynclassDumpDir)) {\n-            Files.createDirectories(dynclassDumpDir);\n-        } else if (!Files.isDirectory(dynclassDumpDir)) {\n-            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n-        }\n-\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-    }\n-\n-    public abstract void traceReflects(Object result) throws IOException;\n-\n-    /**\n-     * Get class definition contents from passed in function parameter.\n-     * \n-     * @return JObject represents byte array or ByteBuffer\n-     */\n-    protected abstract JNIObjectHandle getClassDefinition();\n-\n-    public abstract boolean checkSupported();\n-\n-    protected abstract int getClassDefinitionBytesLength();\n-\n-    public abstract byte[] getClassContents();\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n-        try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n-        }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n-    }\n-\n-    public int calculateGeneratedClassHashcode() throws IOException {\n-        if (generatedClassHashCode == 0) {\n-            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n-        }\n-        return generatedClassHashCode;\n-    }\n-\n-    /**\n-     * Save dynamically defined class to file system.\n-     *\n-     */\n-    public void dumpDefinedClass() throws IOException {\n-        if (values == null) {\n-            values = getClassContents();\n-        }\n-\n-        // Get name for generated class\n-        String internalName = generatedClassName.replace('.', File.separatorChar);\n-        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n-\n-        // Get directory from package\n-        Path dumpDirs = dumpFile.getParent();\n-        if (!Files.exists(dumpDirs)) {\n-            Files.createDirectories(dumpDirs);\n-        } else if (!Files.isDirectory(dumpDirs)) {\n-            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n-        }\n-        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n-            stream.write(values);\n-        }\n-\n-        // Dump stack trace for debug usage\n-        Path dumpTraceFile = dynclassDumpDir.resolve(internalName + \".txt\");\n-        StringBuilder trace = getStackTrace(jni);\n-        try (FileOutputStream traceStream = new FileOutputStream(dumpTraceFile.toFile());) {\n-            traceStream.write(trace.toString().getBytes());\n-        }\n-    }\n-\n-    public static StringBuilder getStackTrace(JNIEnvironment jni) {\n-        StringBuilder trace = new StringBuilder();\n-        int i = 0;\n-        int maxDepth = 20;\n-        while (i < maxDepth) {\n-            String methodName = getMethodFullNameAtFrame(jni, i++);\n-            if (methodName == null) {\n-                break;\n-            }\n-            trace.append(\"    \").append(methodName).append(\"\\n\");\n-        }\n-        if (i >= maxDepth) {\n-            trace.append(\"    \").append(\"...\").append(\"\\n\");\n-        }\n-        return trace;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MTE2OQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r525981169", "bodyText": "I would avoid printing in the agent as this could alter the behavior of the program. In other places the agent uses System.err.", "author": "vjovanov", "createdAt": "2020-11-18T10:35:32Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public abstract class AbstractDynamicClassGenerationSupport {\n+\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected int generatedClassHashCode = 0;\n+    protected byte[] values = null;\n+\n+    private static Path dynclassDumpDir = null;\n+    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n+    protected String callerMethod;\n+\n+    public static void initDynClassDumpDir(String dir) {\n+        dynclassDumpDir = Paths.get(dir);\n+    }\n+\n+    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n+    }\n+\n+    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        if (dynclassDumpDir == null) {\n+            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxMzMzNQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599213335", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-03-23T02:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MTE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\ndeleted file mode 100644\nindex 869613819ba..00000000000\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\n+++ /dev/null\n\n@@ -1,196 +0,0 @@\n-/*\n- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-package com.oracle.svm.agent;\n-\n-import com.oracle.svm.core.util.JavaClassUtil;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n-import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n-\n-import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-\n-public abstract class AbstractDynamicClassGenerationSupport {\n-\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected int generatedClassHashCode = 0;\n-    protected byte[] values = null;\n-\n-    private static Path dynclassDumpDir = null;\n-    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n-    protected String callerMethod;\n-\n-    public static void initDynClassDumpDir(String dir) {\n-        dynclassDumpDir = Paths.get(dir);\n-    }\n-\n-    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n-    }\n-\n-    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        if (dynclassDumpDir == null) {\n-            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n-                            DEFAULT_DUMP.toAbsolutePath().toString());\n-            dynclassDumpDir = DEFAULT_DUMP;\n-        }\n-\n-        if (!Files.exists(dynclassDumpDir)) {\n-            Files.createDirectories(dynclassDumpDir);\n-        } else if (!Files.isDirectory(dynclassDumpDir)) {\n-            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n-        }\n-\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-    }\n-\n-    public abstract void traceReflects(Object result) throws IOException;\n-\n-    /**\n-     * Get class definition contents from passed in function parameter.\n-     * \n-     * @return JObject represents byte array or ByteBuffer\n-     */\n-    protected abstract JNIObjectHandle getClassDefinition();\n-\n-    public abstract boolean checkSupported();\n-\n-    protected abstract int getClassDefinitionBytesLength();\n-\n-    public abstract byte[] getClassContents();\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n-        try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n-        }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n-    }\n-\n-    public int calculateGeneratedClassHashcode() throws IOException {\n-        if (generatedClassHashCode == 0) {\n-            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n-        }\n-        return generatedClassHashCode;\n-    }\n-\n-    /**\n-     * Save dynamically defined class to file system.\n-     *\n-     */\n-    public void dumpDefinedClass() throws IOException {\n-        if (values == null) {\n-            values = getClassContents();\n-        }\n-\n-        // Get name for generated class\n-        String internalName = generatedClassName.replace('.', File.separatorChar);\n-        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n-\n-        // Get directory from package\n-        Path dumpDirs = dumpFile.getParent();\n-        if (!Files.exists(dumpDirs)) {\n-            Files.createDirectories(dumpDirs);\n-        } else if (!Files.isDirectory(dumpDirs)) {\n-            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n-        }\n-        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n-            stream.write(values);\n-        }\n-\n-        // Dump stack trace for debug usage\n-        Path dumpTraceFile = dynclassDumpDir.resolve(internalName + \".txt\");\n-        StringBuilder trace = getStackTrace(jni);\n-        try (FileOutputStream traceStream = new FileOutputStream(dumpTraceFile.toFile());) {\n-            traceStream.write(trace.toString().getBytes());\n-        }\n-    }\n-\n-    public static StringBuilder getStackTrace(JNIEnvironment jni) {\n-        StringBuilder trace = new StringBuilder();\n-        int i = 0;\n-        int maxDepth = 20;\n-        while (i < maxDepth) {\n-            String methodName = getMethodFullNameAtFrame(jni, i++);\n-            if (methodName == null) {\n-                break;\n-            }\n-            trace.append(\"    \").append(methodName).append(\"\\n\");\n-        }\n-        if (i >= maxDepth) {\n-            trace.append(\"    \").append(\"...\").append(\"\\n\");\n-        }\n-        return trace;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MjM1NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r525982354", "bodyText": "I would mention here that the file in place is a file and that we want to create a dir there.", "author": "vjovanov", "createdAt": "2020-11-18T10:37:26Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public abstract class AbstractDynamicClassGenerationSupport {\n+\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected int generatedClassHashCode = 0;\n+    protected byte[] values = null;\n+\n+    private static Path dynclassDumpDir = null;\n+    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n+    protected String callerMethod;\n+\n+    public static void initDynClassDumpDir(String dir) {\n+        dynclassDumpDir = Paths.get(dir);\n+    }\n+\n+    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n+    }\n+\n+    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        if (dynclassDumpDir == null) {\n+            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n+                            DEFAULT_DUMP.toAbsolutePath().toString());\n+            dynclassDumpDir = DEFAULT_DUMP;\n+        }\n+\n+        if (!Files.exists(dynclassDumpDir)) {\n+            Files.createDirectories(dynclassDumpDir);\n+        } else if (!Files.isDirectory(dynclassDumpDir)) {\n+            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxMzI2Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599213262", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-03-23T02:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4MjM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\ndeleted file mode 100644\nindex 869613819ba..00000000000\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\n+++ /dev/null\n\n@@ -1,196 +0,0 @@\n-/*\n- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-package com.oracle.svm.agent;\n-\n-import com.oracle.svm.core.util.JavaClassUtil;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n-import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n-\n-import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-\n-public abstract class AbstractDynamicClassGenerationSupport {\n-\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected int generatedClassHashCode = 0;\n-    protected byte[] values = null;\n-\n-    private static Path dynclassDumpDir = null;\n-    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n-    protected String callerMethod;\n-\n-    public static void initDynClassDumpDir(String dir) {\n-        dynclassDumpDir = Paths.get(dir);\n-    }\n-\n-    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n-    }\n-\n-    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        if (dynclassDumpDir == null) {\n-            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n-                            DEFAULT_DUMP.toAbsolutePath().toString());\n-            dynclassDumpDir = DEFAULT_DUMP;\n-        }\n-\n-        if (!Files.exists(dynclassDumpDir)) {\n-            Files.createDirectories(dynclassDumpDir);\n-        } else if (!Files.isDirectory(dynclassDumpDir)) {\n-            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n-        }\n-\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-    }\n-\n-    public abstract void traceReflects(Object result) throws IOException;\n-\n-    /**\n-     * Get class definition contents from passed in function parameter.\n-     * \n-     * @return JObject represents byte array or ByteBuffer\n-     */\n-    protected abstract JNIObjectHandle getClassDefinition();\n-\n-    public abstract boolean checkSupported();\n-\n-    protected abstract int getClassDefinitionBytesLength();\n-\n-    public abstract byte[] getClassContents();\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n-        try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n-        }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n-    }\n-\n-    public int calculateGeneratedClassHashcode() throws IOException {\n-        if (generatedClassHashCode == 0) {\n-            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n-        }\n-        return generatedClassHashCode;\n-    }\n-\n-    /**\n-     * Save dynamically defined class to file system.\n-     *\n-     */\n-    public void dumpDefinedClass() throws IOException {\n-        if (values == null) {\n-            values = getClassContents();\n-        }\n-\n-        // Get name for generated class\n-        String internalName = generatedClassName.replace('.', File.separatorChar);\n-        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n-\n-        // Get directory from package\n-        Path dumpDirs = dumpFile.getParent();\n-        if (!Files.exists(dumpDirs)) {\n-            Files.createDirectories(dumpDirs);\n-        } else if (!Files.isDirectory(dumpDirs)) {\n-            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n-        }\n-        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n-            stream.write(values);\n-        }\n-\n-        // Dump stack trace for debug usage\n-        Path dumpTraceFile = dynclassDumpDir.resolve(internalName + \".txt\");\n-        StringBuilder trace = getStackTrace(jni);\n-        try (FileOutputStream traceStream = new FileOutputStream(dumpTraceFile.toFile());) {\n-            traceStream.write(trace.toString().getBytes());\n-        }\n-    }\n-\n-    public static StringBuilder getStackTrace(JNIEnvironment jni) {\n-        StringBuilder trace = new StringBuilder();\n-        int i = 0;\n-        int maxDepth = 20;\n-        while (i < maxDepth) {\n-            String methodName = getMethodFullNameAtFrame(jni, i++);\n-            if (methodName == null) {\n-                break;\n-            }\n-            trace.append(\"    \").append(methodName).append(\"\\n\");\n-        }\n-        if (i >= maxDepth) {\n-            trace.append(\"    \").append(\"...\").append(\"\\n\");\n-        }\n-        return trace;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA1MTA3MA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526051070", "bodyText": "In the new version of the code we need to pass an extra argument here. I am working with @d-kozak to see how to do that best.", "author": "vjovanov", "createdAt": "2020-11-18T12:32:59Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -678,6 +699,124 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return allowed;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }\n+            }\n+        }\n+\n+        // Reuse verifyForName\n+        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+        boolean allowed = (accessVerifier == null || accessVerifier.verifyForName(jni, nullHandle(), definedClassName));", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NzA2MA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526197060", "bodyText": "Fixed in my branch.", "author": "vjovanov", "createdAt": "2020-11-18T15:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA1MTA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 8601923ba6b..c3f4cda0e16 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -680,23 +585,16 @@ final class BreakpointInterceptor {\n     private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint bp, boolean returnsEnumeration) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle name = getObjectArgument(0);\n-        boolean allowed = (resourceVerifier == null || resourceVerifier.verifyGetSystemResources(jni, name, callerClass));\n-        boolean result = false;\n-        if (allowed) {\n-            JNIObjectHandle returnValue = Support.callStaticObjectMethodL(jni, bp.clazz, bp.method, name);\n-            result = returnValue.notEqual(nullHandle());\n-            if (clearException(jni)) {\n-                result = false;\n-            }\n-            if (result && returnsEnumeration) {\n-                result = hasEnumerationElements(jni, returnValue);\n-            }\n+        JNIObjectHandle returnValue = Support.callStaticObjectMethodL(jni, bp.clazz, bp.method, name);\n+        boolean result = returnValue.notEqual(nullHandle());\n+        if (clearException(jni)) {\n+            result = false;\n         }\n-        traceBreakpoint(jni, nullHandle(), nullHandle(), callerClass, bp.specification.methodName, result, fromJniString(jni, name));\n-        if (!allowed) {\n-            forceGetResourceReturn(jni, returnsEnumeration);\n+        if (result && returnsEnumeration) {\n+            result = hasEnumerationElements(jni, returnValue);\n         }\n-        return allowed;\n+        traceBreakpoint(jni, nullHandle(), nullHandle(), callerClass, bp.specification.methodName, result, fromJniString(jni, name));\n+        return true;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MzkxMA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526193910", "bodyText": "I think it would be necessary to use com.oracle.svm.agent.NativeImageAgent#tryAtomicMove as a guarantee that the file will always be complete.", "author": "vjovanov", "createdAt": "2020-11-18T15:48:57Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public abstract class AbstractDynamicClassGenerationSupport {\n+\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected int generatedClassHashCode = 0;\n+    protected byte[] values = null;\n+\n+    private static Path dynclassDumpDir = null;\n+    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n+    protected String callerMethod;\n+\n+    public static void initDynClassDumpDir(String dir) {\n+        dynclassDumpDir = Paths.get(dir);\n+    }\n+\n+    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n+    }\n+\n+    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n+                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n+        if (dynclassDumpDir == null) {\n+            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n+                            DEFAULT_DUMP.toAbsolutePath().toString());\n+            dynclassDumpDir = DEFAULT_DUMP;\n+        }\n+\n+        if (!Files.exists(dynclassDumpDir)) {\n+            Files.createDirectories(dynclassDumpDir);\n+        } else if (!Files.isDirectory(dynclassDumpDir)) {\n+            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n+        }\n+\n+        this.jni = jni;\n+        this.callerClass = callerClass;\n+        // Make sure use qualified name for generatedClassName\n+        this.generatedClassName = generatedClassName.replace('/', '.');\n+        this.traceWriter = traceWriter;\n+        this.agent = agent;\n+    }\n+\n+    public abstract void traceReflects(Object result) throws IOException;\n+\n+    /**\n+     * Get class definition contents from passed in function parameter.\n+     * \n+     * @return JObject represents byte array or ByteBuffer\n+     */\n+    protected abstract JNIObjectHandle getClassDefinition();\n+\n+    public abstract boolean checkSupported();\n+\n+    protected abstract int getClassDefinitionBytesLength();\n+\n+    public abstract byte[] getClassContents();\n+\n+    protected byte[] getClassContentsFromByteArray() {\n+        // bytes parameter of defineClass method\n+        JNIObjectHandle bytes = getClassDefinition();\n+        // len parameter of defineClass method\n+        int length = getClassDefinitionBytesLength();\n+        // Get generated class' byte array\n+        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n+        byte[] contents = new byte[length];\n+        try {\n+            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n+        } finally {\n+            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n+        }\n+        return contents;\n+    }\n+\n+    protected byte[] getClassContentsFromDirectBuffer() {\n+        // DirectBuffer parameter of defineClass\n+        JNIObjectHandle directbuffer = getClassDefinition();\n+\n+        // Get byte array from DirectBuffer\n+        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n+        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n+        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n+        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n+        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n+        classContentsAsByteBuffer.get(contents);\n+        classContentsAsByteBuffer.position(0);\n+        return contents;\n+    }\n+\n+    public int calculateGeneratedClassHashcode() throws IOException {\n+        if (generatedClassHashCode == 0) {\n+            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n+        }\n+        return generatedClassHashCode;\n+    }\n+\n+    /**\n+     * Save dynamically defined class to file system.\n+     *\n+     */\n+    public void dumpDefinedClass() throws IOException {\n+        if (values == null) {\n+            values = getClassContents();\n+        }\n+\n+        // Get name for generated class\n+        String internalName = generatedClassName.replace('.', File.separatorChar);\n+        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n+\n+        // Get directory from package\n+        Path dumpDirs = dumpFile.getParent();\n+        if (!Files.exists(dumpDirs)) {\n+            Files.createDirectories(dumpDirs);\n+        } else if (!Files.isDirectory(dumpDirs)) {\n+            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n+        }\n+        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n+            stream.write(values);", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTc3MQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599421771", "bodyText": "Fixed. The dumping process is moved to NativeImageAgent , so the class files are written to the same tmp directory along with other configuration files, no need to maintain an independent dumping process here any more.", "author": "ziyilin", "createdAt": "2021-03-23T09:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MzkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\ndeleted file mode 100644\nindex 869613819ba..00000000000\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\n+++ /dev/null\n\n@@ -1,196 +0,0 @@\n-/*\n- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-package com.oracle.svm.agent;\n-\n-import com.oracle.svm.core.util.JavaClassUtil;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n-import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n-\n-import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-\n-public abstract class AbstractDynamicClassGenerationSupport {\n-\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected int generatedClassHashCode = 0;\n-    protected byte[] values = null;\n-\n-    private static Path dynclassDumpDir = null;\n-    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n-    protected String callerMethod;\n-\n-    public static void initDynClassDumpDir(String dir) {\n-        dynclassDumpDir = Paths.get(dir);\n-    }\n-\n-    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n-    }\n-\n-    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        if (dynclassDumpDir == null) {\n-            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n-                            DEFAULT_DUMP.toAbsolutePath().toString());\n-            dynclassDumpDir = DEFAULT_DUMP;\n-        }\n-\n-        if (!Files.exists(dynclassDumpDir)) {\n-            Files.createDirectories(dynclassDumpDir);\n-        } else if (!Files.isDirectory(dynclassDumpDir)) {\n-            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n-        }\n-\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-    }\n-\n-    public abstract void traceReflects(Object result) throws IOException;\n-\n-    /**\n-     * Get class definition contents from passed in function parameter.\n-     * \n-     * @return JObject represents byte array or ByteBuffer\n-     */\n-    protected abstract JNIObjectHandle getClassDefinition();\n-\n-    public abstract boolean checkSupported();\n-\n-    protected abstract int getClassDefinitionBytesLength();\n-\n-    public abstract byte[] getClassContents();\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n-        try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n-        }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n-    }\n-\n-    public int calculateGeneratedClassHashcode() throws IOException {\n-        if (generatedClassHashCode == 0) {\n-            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n-        }\n-        return generatedClassHashCode;\n-    }\n-\n-    /**\n-     * Save dynamically defined class to file system.\n-     *\n-     */\n-    public void dumpDefinedClass() throws IOException {\n-        if (values == null) {\n-            values = getClassContents();\n-        }\n-\n-        // Get name for generated class\n-        String internalName = generatedClassName.replace('.', File.separatorChar);\n-        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n-\n-        // Get directory from package\n-        Path dumpDirs = dumpFile.getParent();\n-        if (!Files.exists(dumpDirs)) {\n-            Files.createDirectories(dumpDirs);\n-        } else if (!Files.isDirectory(dumpDirs)) {\n-            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n-        }\n-        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n-            stream.write(values);\n-        }\n-\n-        // Dump stack trace for debug usage\n-        Path dumpTraceFile = dynclassDumpDir.resolve(internalName + \".txt\");\n-        StringBuilder trace = getStackTrace(jni);\n-        try (FileOutputStream traceStream = new FileOutputStream(dumpTraceFile.toFile());) {\n-            traceStream.write(trace.toString().getBytes());\n-        }\n-    }\n-\n-    public static StringBuilder getStackTrace(JNIEnvironment jni) {\n-        StringBuilder trace = new StringBuilder();\n-        int i = 0;\n-        int maxDepth = 20;\n-        while (i < maxDepth) {\n-            String methodName = getMethodFullNameAtFrame(jni, i++);\n-            if (methodName == null) {\n-                break;\n-            }\n-            trace.append(\"    \").append(methodName).append(\"\\n\");\n-        }\n-        if (i >= maxDepth) {\n-            trace.append(\"    \").append(\"...\").append(\"\\n\");\n-        }\n-        return trace;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg4NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526201884", "bodyText": "I don't see why we would fail here. I think we should simply not collect those classes ATM. Actually, we could even collect them because in the future we definitely want to support the calls with the protection domain.", "author": "vjovanov", "createdAt": "2020-11-18T15:57:35Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -678,6 +699,124 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return allowed;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }\n+            }\n+        }\n+\n+        // Reuse verifyForName\n+        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+        boolean allowed = (accessVerifier == null || accessVerifier.verifyForName(jni, nullHandle(), definedClassName));\n+        Object result = false;\n+        boolean justAdded = definedClasses.add(definedClassName);\n+        if (isDynamicallyGenerated) {\n+            if (!justAdded) {\n+                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n+                                AbstractDynamicClassGenerationSupport.getStackTrace(jni).toString());\n+                return allowed;\n+            }\n+            // Check the caller's protectionDomain is null, otherwise don't support\n+            String caller = getMethodFullNameAtFrame(jni, 1);\n+            if (\"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller)) {\n+                caller = getMethodFullNameAtFrame(jni, 2);\n+                if (!\"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class;\".equals(caller)) {\n+                    // Reflections are supported in another way, no need to track dynamic class\n+                    // loading\n+                    // used by reflection.\n+                    if (!caller.startsWith(\"sun.reflect\")) {\n+                        unsupportedExceptions.add(\"Don't support defineClass with ProtectionDomain parameter in native image. \" +", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUwMzE3Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r527503172", "bodyText": "Reporting at collecting time would let the user know the program is not supported as early as possible, so they don't have to wait to image compilation time or runtime. This unsupported message is reported at unLoad time so it wouldn't interfere the configuration collecting process.", "author": "ziyilin", "createdAt": "2020-11-20T08:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NTQzMQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r527595431", "bodyText": "One of the use cases for the agent is automatic collection of profiles in the cloud setting. For this purpose, I would like to have the agent behave exactly the same as the original.\nCould we put this kind of reporting behind a flag?", "author": "vjovanov", "createdAt": "2020-11-20T10:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxMjc3Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599212772", "bodyText": "removed the reporting here.", "author": "ziyilin", "createdAt": "2021-03-23T02:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 8601923ba6b..c3f4cda0e16 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -680,23 +585,16 @@ final class BreakpointInterceptor {\n     private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint bp, boolean returnsEnumeration) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle name = getObjectArgument(0);\n-        boolean allowed = (resourceVerifier == null || resourceVerifier.verifyGetSystemResources(jni, name, callerClass));\n-        boolean result = false;\n-        if (allowed) {\n-            JNIObjectHandle returnValue = Support.callStaticObjectMethodL(jni, bp.clazz, bp.method, name);\n-            result = returnValue.notEqual(nullHandle());\n-            if (clearException(jni)) {\n-                result = false;\n-            }\n-            if (result && returnsEnumeration) {\n-                result = hasEnumerationElements(jni, returnValue);\n-            }\n+        JNIObjectHandle returnValue = Support.callStaticObjectMethodL(jni, bp.clazz, bp.method, name);\n+        boolean result = returnValue.notEqual(nullHandle());\n+        if (clearException(jni)) {\n+            result = false;\n         }\n-        traceBreakpoint(jni, nullHandle(), nullHandle(), callerClass, bp.specification.methodName, result, fromJniString(jni, name));\n-        if (!allowed) {\n-            forceGetResourceReturn(jni, returnsEnumeration);\n+        if (result && returnsEnumeration) {\n+            result = hasEnumerationElements(jni, returnValue);\n         }\n-        return allowed;\n+        traceBreakpoint(jni, nullHandle(), nullHandle(), callerClass, bp.specification.methodName, result, fromJniString(jni, name));\n+        return true;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MDk3Mw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526680973", "bodyText": "I think this data structure needs to handle concurrent updates?", "author": "vjovanov", "createdAt": "2020-11-19T08:38:17Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -132,7 +140,8 @@\n     private static NativeImageAgent agent;\n \n     private static Map<Long, Breakpoint> installedBreakpoints;\n-\n+    private static Set<String> definedClasses = new HashSet<>();", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxODY5NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599218695", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-03-23T02:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MDk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 8601923ba6b..c3f4cda0e16 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -134,13 +131,10 @@ import jdk.vm.ci.meta.MetaUtil;\n  */\n final class BreakpointInterceptor {\n     private static TraceWriter traceWriter;\n-    private static ReflectAccessVerifier accessVerifier;\n-    private static ProxyAccessVerifier proxyVerifier;\n-    private static ResourceAccessVerifier resourceVerifier;\n     private static NativeImageAgent agent;\n \n     private static Map<Long, Breakpoint> installedBreakpoints;\n-    private static Set<String> definedClasses = new HashSet<>();\n+    private static Set<String> definedClasses = ConcurrentHashMap.newKeySet();\n     private static List<String> unsupportedExceptions = new ArrayList<>();\n     /**\n      * A map from {@link JNIMethodId} to entry point addresses for bound Java {@code native}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MjY3NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526682675", "bodyText": "Why not use SHA-256 or SHA-512 that are standard and can be used from any other language/tool?", "author": "vjovanov", "createdAt": "2020-11-19T08:40:59Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/JavaClassUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.util;\n+\n+import com.sun.org.apache.bcel.internal.classfile.Attribute;\n+import com.sun.org.apache.bcel.internal.classfile.ClassParser;\n+import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;\n+import com.sun.org.apache.bcel.internal.classfile.JavaClass;\n+import com.sun.org.apache.bcel.internal.classfile.SourceFile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class JavaClassUtil {\n+\n+    private static final String CONSTANT_PLACE_HOLDER = \"CONSTANT_PLACE_HOLDER\";\n+\n+    /**\n+     * Get hashcode of the class for verification usage. But the name of SourceFile attribute is set\n+     * to empty, because it might get changed from run to run and it's not really used in the class.\n+     *\n+     * @return byte array hashcode without SourceFile name\n+     * @throws IOException\n+     */\n+    public static int getHashCodeWithoutSourceFileInfo(byte[] classDefinition) throws IOException {\n+        ClassParser cp = new ClassParser(new ByteArrayInputStream(classDefinition), \"\");\n+        JavaClass jc = cp.parse();\n+        // Set SourceFile name's indexed utf8 value to empty\n+        List<Attribute> sourceFileAttr = Arrays.stream(jc.getAttributes()).filter(attr -> (attr instanceof SourceFile)).collect(Collectors.toList());\n+        // There should be exactly one SourceFile attribute\n+        if (sourceFileAttr.size() == 1) {\n+            SourceFile sourFile = (SourceFile) sourceFileAttr.get(0);\n+            int nameIndex = sourFile.getSourceFileIndex();\n+            String originalSourceFile = ((ConstantUtf8) (jc.getConstantPool().getConstant(nameIndex))).getBytes();\n+            if (originalSourceFile != null && originalSourceFile.length() > 0) {\n+                jc.getConstantPool().setConstant(nameIndex, new ConstantUtf8(CONSTANT_PLACE_HOLDER));\n+                return Arrays.hashCode(jc.getBytes());\n+            }\n+        }\n+        return Arrays.hashCode(classDefinition);", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxNjMyNA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r527516324", "bodyText": "I concerned the runtime performance. Here is not for security purpose to protect the class from malicious attach, but only for consistency verification, SHA-256 would be too heavy. But if there is a requirement to extend to other languages or tools, we can choose other standard but faster algorithms such as MD5.", "author": "ziyilin", "createdAt": "2020-11-20T08:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MjY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5NzkzMg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r527597932", "bodyText": "SHA-256 is about 11 cycles per byte. For a 10 kB class this would be 110k cycles or roughly 30 us.\nI think that is OK given that the VM will anyhow need to load, verify, interpret, and compile that code.", "author": "vjovanov", "createdAt": "2020-11-20T10:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MjY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTIxMjk4NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r599212985", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-03-23T02:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4MjY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "eae1c361a2a74547f380fa4c69c32a7fe08af26f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/JavaClassUtil.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/JavaClassUtil.java\nindex d3ed6287590..37482987113 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/JavaClassUtil.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/JavaClassUtil.java\n\n@@ -1,6 +1,6 @@\n /*\n  * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * Copyright (c) 2020. 2020, Alibaba Group Holding Limited. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4NTAwNQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r526685005", "bodyText": "I think it would be better to keep the dynamic classes in the same folder as other configs. This way it will be easier to use native image with -H:ConfigurationFileDirectories=. This is, for example, the case in our benchmarks.", "author": "vjovanov", "createdAt": "2020-11-19T08:44:53Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public abstract class AbstractDynamicClassGenerationSupport {\n+\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected int generatedClassHashCode = 0;\n+    protected byte[] values = null;\n+\n+    private static Path dynclassDumpDir = null;\n+    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");", "originalCommit": "5371bc88f3f8a289f8b2cc23c2dad5608ee22297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUxODUyMA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r527518520", "bodyText": "Agreed, as discussed previously (#2442 (comment) and #2442 (comment)). I'll trace all dynamic generated classes in a new configuration file and store all generated classes under the same directory.", "author": "ziyilin", "createdAt": "2020-11-20T08:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4NTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzMDM3NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r529830374", "bodyText": "Thank you for your comments @vjovanov \ud83d\udc4d\n@ziyilin , please do address #2442 (comment) and #2442 (comment) and also consider which suggestions from the object serialization PR might apply here as well. Then I will review in more depth.", "author": "peter-hofer", "createdAt": "2020-11-24T19:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY4NTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\ndeleted file mode 100644\nindex 869613819ba..00000000000\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/AbstractDynamicClassGenerationSupport.java\n+++ /dev/null\n\n@@ -1,196 +0,0 @@\n-/*\n- * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-package com.oracle.svm.agent;\n-\n-import com.oracle.svm.core.util.JavaClassUtil;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n-import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n-\n-import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-\n-public abstract class AbstractDynamicClassGenerationSupport {\n-\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected int generatedClassHashCode = 0;\n-    protected byte[] values = null;\n-\n-    private static Path dynclassDumpDir = null;\n-    private static final Path DEFAULT_DUMP = Paths.get(\"dynClass\");\n-    protected String callerMethod;\n-\n-    public static void initDynClassDumpDir(String dir) {\n-        dynclassDumpDir = Paths.get(dir);\n-    }\n-\n-    public static AbstractDynamicClassGenerationSupport getClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        return new ClassLoaderDefineClassSupport(jni, callerClass, generatedClassName, traceWriter, agent);\n-    }\n-\n-    protected AbstractDynamicClassGenerationSupport(JNIEnvironment jni, JNIObjectHandle callerClass,\n-                    String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent) throws IOException {\n-        if (dynclassDumpDir == null) {\n-            System.out.println(\"Warning: dynamic-class-dump-dir= was not set in -agentlib:native-image-agent=. Dynamically generated classes will be dumped to the default location:\" +\n-                            DEFAULT_DUMP.toAbsolutePath().toString());\n-            dynclassDumpDir = DEFAULT_DUMP;\n-        }\n-\n-        if (!Files.exists(dynclassDumpDir)) {\n-            Files.createDirectories(dynclassDumpDir);\n-        } else if (!Files.isDirectory(dynclassDumpDir)) {\n-            throw new IOException(\"File \" + dynclassDumpDir + \" already exists! Cannot create the same directory for class file dumping.\");\n-        }\n-\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-    }\n-\n-    public abstract void traceReflects(Object result) throws IOException;\n-\n-    /**\n-     * Get class definition contents from passed in function parameter.\n-     * \n-     * @return JObject represents byte array or ByteBuffer\n-     */\n-    protected abstract JNIObjectHandle getClassDefinition();\n-\n-    public abstract boolean checkSupported();\n-\n-    protected abstract int getClassDefinitionBytesLength();\n-\n-    public abstract byte[] getClassContents();\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n-        try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n-        }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n-    }\n-\n-    public int calculateGeneratedClassHashcode() throws IOException {\n-        if (generatedClassHashCode == 0) {\n-            generatedClassHashCode = JavaClassUtil.getHashCodeWithoutSourceFileInfo(getClassContents());\n-        }\n-        return generatedClassHashCode;\n-    }\n-\n-    /**\n-     * Save dynamically defined class to file system.\n-     *\n-     */\n-    public void dumpDefinedClass() throws IOException {\n-        if (values == null) {\n-            values = getClassContents();\n-        }\n-\n-        // Get name for generated class\n-        String internalName = generatedClassName.replace('.', File.separatorChar);\n-        Path dumpFile = dynclassDumpDir.resolve(internalName + \".class\");\n-\n-        // Get directory from package\n-        Path dumpDirs = dumpFile.getParent();\n-        if (!Files.exists(dumpDirs)) {\n-            Files.createDirectories(dumpDirs);\n-        } else if (!Files.isDirectory(dumpDirs)) {\n-            throw new IOException(\"File \" + dumpDirs + \" already exists! Cannot create the same name directory for dumping class file.\");\n-        }\n-        try (FileOutputStream stream = new FileOutputStream(dumpFile.toFile());) {\n-            stream.write(values);\n-        }\n-\n-        // Dump stack trace for debug usage\n-        Path dumpTraceFile = dynclassDumpDir.resolve(internalName + \".txt\");\n-        StringBuilder trace = getStackTrace(jni);\n-        try (FileOutputStream traceStream = new FileOutputStream(dumpTraceFile.toFile());) {\n-            traceStream.write(trace.toString().getBytes());\n-        }\n-    }\n-\n-    public static StringBuilder getStackTrace(JNIEnvironment jni) {\n-        StringBuilder trace = new StringBuilder();\n-        int i = 0;\n-        int maxDepth = 20;\n-        while (i < maxDepth) {\n-            String methodName = getMethodFullNameAtFrame(jni, i++);\n-            if (methodName == null) {\n-                break;\n-            }\n-            trace.append(\"    \").append(methodName).append(\"\\n\");\n-        }\n-        if (i >= maxDepth) {\n-            trace.append(\"    \").append(\"...\").append(\"\\n\");\n-        }\n-        return trace;\n-    }\n-\n-}\n"}}, {"oid": "c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "url": "https://github.com/oracle/graal/commit/c85500e2f8e6bfe83dc443aa48fb75ad8a8dcf5d", "message": "Support dynamic class loading\n\nPost rebase fixup\n\nUse separated config for dynamic class cloading", "committedDate": "2020-12-17T14:34:15Z", "type": "forcePushed"}, {"oid": "622d19d0481b1e614a6ca6fc85852cae50cbffc3", "url": "https://github.com/oracle/graal/commit/622d19d0481b1e614a6ca6fc85852cae50cbffc3", "message": "Support dynamic class loading\n\nPost rebase fixup\n\nUse separated config for dynamic class cloading", "committedDate": "2020-12-17T14:45:51Z", "type": "forcePushed"}, {"oid": "eae1c361a2a74547f380fa4c69c32a7fe08af26f", "url": "https://github.com/oracle/graal/commit/eae1c361a2a74547f380fa4c69c32a7fe08af26f", "message": "Support dynamic class loading\n\nPost rebase fixup\n\nUse separated config for dynamic class cloading", "committedDate": "2020-12-18T02:15:26Z", "type": "forcePushed"}, {"oid": "10b527c17f7bcc2c747183e6d5e79688b84e06c1", "url": "https://github.com/oracle/graal/commit/10b527c17f7bcc2c747183e6d5e79688b84e06c1", "message": "Support dynamic class loading\n\nPost rebase fixup\n\nUse separated config for dynamic class cloading", "committedDate": "2020-12-21T07:04:13Z", "type": "forcePushed"}, {"oid": "8cd48dde92c48eaedeccbff8955025e77f838e25", "url": "https://github.com/oracle/graal/commit/8cd48dde92c48eaedeccbff8955025e77f838e25", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-08T13:19:52Z", "type": "forcePushed"}, {"oid": "cc4555fe4ac2b053fa5071ee1b2dc3f4799eb147", "url": "https://github.com/oracle/graal/commit/cc4555fe4ac2b053fa5071ee1b2dc3f4799eb147", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-19T15:58:29Z", "type": "forcePushed"}, {"oid": "dba07cc54eea99e3719919e022e68a2c7b86a1e2", "url": "https://github.com/oracle/graal/commit/dba07cc54eea99e3719919e022e68a2c7b86a1e2", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-19T16:09:22Z", "type": "forcePushed"}, {"oid": "67814e49510c57be5b2bfeb755f5e39f484b3ac1", "url": "https://github.com/oracle/graal/commit/67814e49510c57be5b2bfeb755f5e39f484b3ac1", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-19T17:11:14Z", "type": "forcePushed"}, {"oid": "714886bbc73726afe9040beecee24b7564e2dff5", "url": "https://github.com/oracle/graal/commit/714886bbc73726afe9040beecee24b7564e2dff5", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-19T17:12:58Z", "type": "forcePushed"}, {"oid": "1d63863f369e30392f43e9b77f6b40384a3110da", "url": "https://github.com/oracle/graal/commit/1d63863f369e30392f43e9b77f6b40384a3110da", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-19T17:21:24Z", "type": "forcePushed"}, {"oid": "e5b9ad7aa228890c070ea31e9b9e2968b9dccefd", "url": "https://github.com/oracle/graal/commit/e5b9ad7aa228890c070ea31e9b9e2968b9dccefd", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-22T02:07:28Z", "type": "forcePushed"}, {"oid": "e3f43a05ae7fc4be1cbe339a2d0ee3ea80af3b12", "url": "https://github.com/oracle/graal/commit/e3f43a05ae7fc4be1cbe339a2d0ee3ea80af3b12", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-22T02:20:40Z", "type": "forcePushed"}, {"oid": "0ae0876624ac68737d6ab3e0fe3e920625260d5d", "url": "https://github.com/oracle/graal/commit/0ae0876624ac68737d6ab3e0fe3e920625260d5d", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-22T02:41:57Z", "type": "forcePushed"}, {"oid": "2f9073f2aa4b7ab3472b455573892e6fea3ff813", "url": "https://github.com/oracle/graal/commit/2f9073f2aa4b7ab3472b455573892e6fea3ff813", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-22T11:35:30Z", "type": "forcePushed"}, {"oid": "8231d6520420b4cf12e6567cd87dbd2bad9a8898", "url": "https://github.com/oracle/graal/commit/8231d6520420b4cf12e6567cd87dbd2bad9a8898", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-22T11:47:23Z", "type": "forcePushed"}, {"oid": "b18ecdb8e6f780d65ecb086562a80f5411127a64", "url": "https://github.com/oracle/graal/commit/b18ecdb8e6f780d65ecb086562a80f5411127a64", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-23T02:41:42Z", "type": "forcePushed"}, {"oid": "479fe5d4fdcb4f643edbf7b1ac8023ca52a64d27", "url": "https://github.com/oracle/graal/commit/479fe5d4fdcb4f643edbf7b1ac8023ca52a64d27", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-23T09:51:22Z", "type": "forcePushed"}, {"oid": "c59ce596166213eecc44de5bd554c52986280376", "url": "https://github.com/oracle/graal/commit/c59ce596166213eecc44de5bd554c52986280376", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-23T11:36:08Z", "type": "forcePushed"}, {"oid": "e696dcdb14958683dde0ec4c8930b20eeb9b6285", "url": "https://github.com/oracle/graal/commit/e696dcdb14958683dde0ec4c8930b20eeb9b6285", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-23T11:42:58Z", "type": "forcePushed"}, {"oid": "fefa1fe8f9d8125f456c6244e5ac84958035fa54", "url": "https://github.com/oracle/graal/commit/fefa1fe8f9d8125f456c6244e5ac84958035fa54", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-26T02:15:39Z", "type": "forcePushed"}, {"oid": "98f80147901082a822f76dde76af757036aad82d", "url": "https://github.com/oracle/graal/commit/98f80147901082a822f76dde76af757036aad82d", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-03-26T05:06:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc5NjkyNA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608796924", "bodyText": "This seems unused now, please remove if that is the case.\nPlease check the entire PR for unused code and unnecessary whitespace changes.", "author": "peter-hofer", "createdAt": "2021-04-07T16:09:53Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -169,6 +177,18 @@ private static void traceBreakpoint(JNIEnvironment env, JNIObjectHandle clazz, J\n         }\n     }\n \n+    static void traceBreakpoint(JNIEnvironment env, JNIObjectHandle clazz, JNIObjectHandle declaringClass,\n+                    JNIObjectHandle callerClass, String function, boolean allowWrite, boolean unsafeAccess, Object result,\n+                    String fieldName) {\n+        if (traceWriter != null) {\n+            traceWriter.traceCall(\"reflect\", function, getClassNameOr(env, clazz, null, TraceWriter.UNKNOWN_VALUE),\n+                            getClassNameOr(env, declaringClass, null, TraceWriter.UNKNOWN_VALUE),\n+                            getClassNameOr(env, callerClass, null, TraceWriter.UNKNOWN_VALUE), result, allowWrite, unsafeAccess,\n+                            fieldName);\n+            guarantee(!testException(env));\n+        }\n+    }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNTA3OA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611615078", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2021-04-12T13:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc5NjkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -177,18 +178,6 @@ final class BreakpointInterceptor {\n         }\n     }\n \n-    static void traceBreakpoint(JNIEnvironment env, JNIObjectHandle clazz, JNIObjectHandle declaringClass,\n-                    JNIObjectHandle callerClass, String function, boolean allowWrite, boolean unsafeAccess, Object result,\n-                    String fieldName) {\n-        if (traceWriter != null) {\n-            traceWriter.traceCall(\"reflect\", function, getClassNameOr(env, clazz, null, TraceWriter.UNKNOWN_VALUE),\n-                            getClassNameOr(env, declaringClass, null, TraceWriter.UNKNOWN_VALUE),\n-                            getClassNameOr(env, callerClass, null, TraceWriter.UNKNOWN_VALUE), result, allowWrite, unsafeAccess,\n-                            fieldName);\n-            guarantee(!testException(env));\n-        }\n-    }\n-\n     private static boolean forName(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle name = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgwMDk3NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608800974", "bodyText": "This is not an issue that needs to be handled or reported in the agent, but should be reported during the image build or at image runtime.", "author": "peter-hofer", "createdAt": "2021-04-07T16:15:12Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }\n+            }\n+        }\n+\n+        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+        Object result = false;\n+        boolean justAdded = definedClasses.add(definedClassName);\n+        if (isDynamicallyGenerated) {\n+            if (!justAdded) {\n+                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n+                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDk3MQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614971", "bodyText": "Removed.", "author": "ziyilin", "createdAt": "2021-04-12T13:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgwMDk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTkxMTMyMA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r615911320", "bodyText": "unsupportedExceptions and reportExceptions are unused now.", "author": "peter-hofer", "createdAt": "2021-04-19T14:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgwMDk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgxNzgyMw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608817823", "bodyText": "This will execute postDefineClass twice because we are currently inside it in the breakpoint and will continue executing there after returning. It also seems unnecessary because the class is already loaded and postDefineClass does nothing of significance and is private, so it cannot be overridden in subclasses.", "author": "peter-hofer", "createdAt": "2021-04-07T16:37:07Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }\n+            }\n+        }\n+\n+        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+        Object result = false;\n+        boolean justAdded = definedClasses.add(definedClassName);\n+        if (isDynamicallyGenerated) {\n+            if (!justAdded) {\n+                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n+                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n+                return true;\n+            }\n+            // Check the caller is using byte array or directedBuffer\n+            String caller = getMethodFullNameAtFrame(jni, 1);\n+            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n+            // Verify if defineClass succeeds\n+            // As we hook on postDefineClass method which is the last step of defineClass, so if\n+            // it can execute successfully, the whole defineClass method can execute\n+            // successfully\n+            JNIValue args = StackValue.get(2, JNIValue.class);\n+            args.addressOf(0).setObject(getObjectArgument(1));\n+            args.addressOf(1).setObject(getObjectArgument(2));\n+            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n+            if (clearException(jni)) {\n+                // No need to proceed if any exception happens\n+                result = false;\n+            } else {\n+                result = true;\n+            }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDgwNg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614806", "bodyText": "Fixed by changing postDefineClass method to onClassFileLoadHook method.", "author": "ziyilin", "createdAt": "2021-04-12T13:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgxNzgyMw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgxODg0NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608818845", "bodyText": "Please undo this and instead wrap the exception in an unchecked (runtime) exception where it is thrown.", "author": "peter-hofer", "createdAt": "2021-04-07T16:38:26Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -1269,15 +1379,29 @@ private static void bindNativeBreakpoint(JNIEnvironment jni, NativeBreakpoint bp\n         }\n     }\n \n+    public static void reportExceptions() {\n+        if (!unsupportedExceptions.isEmpty()) {\n+            System.err.println(unsupportedExceptions.size() + \" unsupported features are detected \");\n+            StringBuilder errorMsg = new StringBuilder();\n+            for (int i = 0; i < unsupportedExceptions.size(); i++) {\n+                errorMsg.append(unsupportedExceptions.get(i)).append(\"\\n\");\n+            }\n+            throw new UnsupportedOperationException(errorMsg.toString());\n+        } else {\n+            unsupportedExceptions = null;\n+        }\n+    }\n+\n     public static void onUnload() {\n         installedBreakpoints = null;\n         nativeBreakpoints = null;\n         observedExplicitLoadClassCallSites = null;\n         traceWriter = null;\n+        definedClasses = null;\n     }\n \n     private interface BreakpointHandler {\n-        boolean dispatch(JNIEnvironment jni, Breakpoint bp);\n+        boolean dispatch(JNIEnvironment jni, Breakpoint bp) throws IOException;", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDc1NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614755", "bodyText": "Fixed", "author": "ziyilin", "createdAt": "2021-04-12T13:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgxODg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -1397,11 +1349,10 @@ final class BreakpointInterceptor {\n         nativeBreakpoints = null;\n         observedExplicitLoadClassCallSites = null;\n         traceWriter = null;\n-        definedClasses = null;\n     }\n \n     private interface BreakpointHandler {\n-        boolean dispatch(JNIEnvironment jni, Breakpoint bp) throws IOException;\n+        boolean dispatch(JNIEnvironment jni, Breakpoint bp);\n     }\n \n     private static final BreakpointSpecification[] BREAKPOINT_SPECIFICATIONS = {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgyNzY3Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608827672", "bodyText": "Why not use the ClassFileLoadHook event instead? It provides the class name and bytes directly without having to extract them from parameters and locals.", "author": "peter-hofer", "createdAt": "2021-04-07T16:50:41Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDY5NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614694", "bodyText": "You are right. I have removed the postDefineClass method and added a new method onClassFileLoadHook instead.", "author": "ziyilin", "createdAt": "2021-04-12T13:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgyNzY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgyODUzNA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608828534", "bodyText": "Please reuse the existing AccessAdvisor object and for brevity also the LazyValueUtils methods (with static imports).", "author": "peter-hofer", "createdAt": "2021-04-07T16:51:55Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDYxOA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614618", "bodyText": "Fixed as the whole postDefine method is removed.", "author": "ziyilin", "createdAt": "2021-04-12T13:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgyODUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMDM0Nw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608830347", "bodyText": "I don't think it's necessary to instantiate this class, it should be fine to pass everything as arguments to trace and pass needed values on to other methods at that point.", "author": "peter-hofer", "createdAt": "2021-04-07T16:54:28Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2021, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.security.NoSuchAlgorithmException;\n+\n+import static com.oracle.svm.jvmtiagentbase.Support.getIntArgument;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+import static com.oracle.svm.jvmtiagentbase.Support.getObjectArgument;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+\n+/**\n+ * Support dynamic class loading that is implemented by java.lang.ClassLoader.defineClass.\n+ */\n+public class ClassLoaderDefineClassSupport {", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxNDU0Ng==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611614546", "bodyText": "Fixed by making trace method static.", "author": "ziyilin", "createdAt": "2021-04-12T13:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMDM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\nindex f30de2bdcce..47ed24063e3 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\n\n@@ -27,85 +27,32 @@ package com.oracle.svm.agent;\n \n import com.oracle.svm.core.util.JavaClassUtil;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n \n-import java.nio.ByteBuffer;\n import java.security.NoSuchAlgorithmException;\n \n-import static com.oracle.svm.jvmtiagentbase.Support.getIntArgument;\n import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-import static com.oracle.svm.jvmtiagentbase.Support.getObjectArgument;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n \n /**\n  * Support dynamic class loading that is implemented by java.lang.ClassLoader.defineClass.\n  */\n public class ClassLoaderDefineClassSupport {\n \n-    private static final String DEFINE_CLASS_BYTEARRAY_SIG = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class;\";\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected String generatedClassHashCode = null;\n-    protected byte[] values = null;\n-    private boolean isByteArray;\n-\n-    protected String callerMethod;\n-\n-    public ClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass, String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent, boolean isByteArray) {\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-        callerMethod = getMethodFullNameAtFrame(jni, 1);\n-        this.isByteArray = isByteArray;\n-    }\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n+    private static String calculateGeneratedClassSHA(byte[] values) {\n+        String generatedClassHashCode;\n         try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n+            generatedClassHashCode = JavaClassUtil.getSHAWithoutSourceFileInfo(values);\n+        } catch (NoSuchAlgorithmException e) {\n+            generatedClassHashCode = null;\n         }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n+        return generatedClassHashCode;\n     }\n \n-    private String calculateGeneratedClassSHA() throws NoSuchAlgorithmException {\n-        if (generatedClassHashCode == null) {\n-            generatedClassHashCode = JavaClassUtil.getSHAWithoutSourceFileInfo(getClassContents());\n+    public static void trace(TraceWriter traceWriter, byte[] classContents, String generatedClassName, Object result) {\n+        assert classContents != null;\n+        if (generatedClassName != null && result != null) {\n+            // Trace dynamically generated class in config file\n+            traceWriter.traceDefineClass(generatedClassName.replace('/', '.'), calculateGeneratedClassSHA(classContents), classContents, result);\n         }\n-        return generatedClassHashCode;\n     }\n \n     public static StringBuilder getStackTrace(JNIEnvironment jni) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMTM1OQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608831359", "bodyText": "Please clean up visibilities and modifiers in the entire PR: none of the members in this class need to be protected as far as I can tell and should be either private or package-visible and potentially final.", "author": "peter-hofer", "createdAt": "2021-04-07T16:55:52Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2021, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent;\n+\n+import com.oracle.svm.core.util.JavaClassUtil;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIMethodId;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import org.graalvm.nativeimage.c.type.CCharPointer;\n+import org.graalvm.nativeimage.c.type.CTypeConversion;\n+import org.graalvm.nativeimage.c.type.VoidPointer;\n+import org.graalvm.word.WordFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.security.NoSuchAlgorithmException;\n+\n+import static com.oracle.svm.jvmtiagentbase.Support.getIntArgument;\n+import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n+import static com.oracle.svm.jvmtiagentbase.Support.getObjectArgument;\n+import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n+\n+/**\n+ * Support dynamic class loading that is implemented by java.lang.ClassLoader.defineClass.\n+ */\n+public class ClassLoaderDefineClassSupport {\n+\n+    private static final String DEFINE_CLASS_BYTEARRAY_SIG = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class;\";\n+    protected JNIEnvironment jni;\n+    protected JNIObjectHandle callerClass;\n+    protected final String generatedClassName;\n+    protected TraceWriter traceWriter;\n+    protected NativeImageAgent agent;\n+    protected String generatedClassHashCode = null;\n+    protected byte[] values = null;\n+    private boolean isByteArray;", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMzg3MA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611613870", "bodyText": "Fixed by removing them.", "author": "ziyilin", "createdAt": "2021-04-12T13:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMTM1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\nindex f30de2bdcce..47ed24063e3 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/ClassLoaderDefineClassSupport.java\n\n@@ -27,85 +27,32 @@ package com.oracle.svm.agent;\n \n import com.oracle.svm.core.util.JavaClassUtil;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n-import com.oracle.svm.jni.nativeapi.JNIMethodId;\n-import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n-import org.graalvm.nativeimage.c.type.CCharPointer;\n-import org.graalvm.nativeimage.c.type.CTypeConversion;\n-import org.graalvm.nativeimage.c.type.VoidPointer;\n-import org.graalvm.word.WordFactory;\n \n-import java.nio.ByteBuffer;\n import java.security.NoSuchAlgorithmException;\n \n-import static com.oracle.svm.jvmtiagentbase.Support.getIntArgument;\n import static com.oracle.svm.jvmtiagentbase.Support.getMethodFullNameAtFrame;\n-import static com.oracle.svm.jvmtiagentbase.Support.getObjectArgument;\n-import static com.oracle.svm.jvmtiagentbase.Support.jniFunctions;\n \n /**\n  * Support dynamic class loading that is implemented by java.lang.ClassLoader.defineClass.\n  */\n public class ClassLoaderDefineClassSupport {\n \n-    private static final String DEFINE_CLASS_BYTEARRAY_SIG = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class;\";\n-    protected JNIEnvironment jni;\n-    protected JNIObjectHandle callerClass;\n-    protected final String generatedClassName;\n-    protected TraceWriter traceWriter;\n-    protected NativeImageAgent agent;\n-    protected String generatedClassHashCode = null;\n-    protected byte[] values = null;\n-    private boolean isByteArray;\n-\n-    protected String callerMethod;\n-\n-    public ClassLoaderDefineClassSupport(JNIEnvironment jni, JNIObjectHandle callerClass, String generatedClassName, TraceWriter traceWriter, NativeImageAgent agent, boolean isByteArray) {\n-        this.jni = jni;\n-        this.callerClass = callerClass;\n-        // Make sure use qualified name for generatedClassName\n-        this.generatedClassName = generatedClassName.replace('/', '.');\n-        this.traceWriter = traceWriter;\n-        this.agent = agent;\n-        callerMethod = getMethodFullNameAtFrame(jni, 1);\n-        this.isByteArray = isByteArray;\n-    }\n-\n-    protected byte[] getClassContentsFromByteArray() {\n-        // bytes parameter of defineClass method\n-        JNIObjectHandle bytes = getClassDefinition();\n-        // len parameter of defineClass method\n-        int length = getClassDefinitionBytesLength();\n-        // Get generated class' byte array\n-        CCharPointer byteArray = jniFunctions().getGetByteArrayElements().invoke(jni, bytes, WordFactory.nullPointer());\n-        byte[] contents = new byte[length];\n+    private static String calculateGeneratedClassSHA(byte[] values) {\n+        String generatedClassHashCode;\n         try {\n-            CTypeConversion.asByteBuffer(byteArray, length).get(contents);\n-        } finally {\n-            jniFunctions().getReleaseByteArrayElements().invoke(jni, bytes, byteArray, 0);\n+            generatedClassHashCode = JavaClassUtil.getSHAWithoutSourceFileInfo(values);\n+        } catch (NoSuchAlgorithmException e) {\n+            generatedClassHashCode = null;\n         }\n-        return contents;\n-    }\n-\n-    protected byte[] getClassContentsFromDirectBuffer() {\n-        // DirectBuffer parameter of defineClass\n-        JNIObjectHandle directbuffer = getClassDefinition();\n-\n-        // Get byte array from DirectBuffer\n-        VoidPointer baseAddr = jniFunctions().getGetDirectBufferAddress().invoke(jni, directbuffer);\n-        JNIMethodId limitMId = agent.handles().getMethodId(jni, agent.handles().javaNioByteBuffer, \"limit\", \"()I\", false);\n-        int limit = jniFunctions().getCallIntMethod().invoke(jni, directbuffer, limitMId);\n-        ByteBuffer classContentsAsByteBuffer = CTypeConversion.asByteBuffer(baseAddr, limit);\n-        byte[] contents = new byte[classContentsAsByteBuffer.limit()];\n-        classContentsAsByteBuffer.get(contents);\n-        classContentsAsByteBuffer.position(0);\n-        return contents;\n+        return generatedClassHashCode;\n     }\n \n-    private String calculateGeneratedClassSHA() throws NoSuchAlgorithmException {\n-        if (generatedClassHashCode == null) {\n-            generatedClassHashCode = JavaClassUtil.getSHAWithoutSourceFileInfo(getClassContents());\n+    public static void trace(TraceWriter traceWriter, byte[] classContents, String generatedClassName, Object result) {\n+        assert classContents != null;\n+        if (generatedClassName != null && result != null) {\n+            // Trace dynamically generated class in config file\n+            traceWriter.traceDefineClass(generatedClassName.replace('/', '.'), calculateGeneratedClassSHA(classContents), classContents, result);\n         }\n-        return generatedClassHashCode;\n     }\n \n     public static StringBuilder getStackTrace(JNIEnvironment jni) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMzAwNg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608833006", "bodyText": "I don't think any of these have to be public.", "author": "peter-hofer", "createdAt": "2021-04-07T16:57:58Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java", "diffHunk": "@@ -39,17 +39,27 @@\n     final JNIObjectHandle javaLangClass;\n     final JNIMethodId javaLangClassForName3;\n     final JNIMethodId javaUtilEnumerationNextElement;\n-    final JNIMethodId javaLangClassGetDeclaredMethod;\n-    final JNIMethodId javaLangClassGetDeclaredConstructor;\n-    final JNIMethodId javaLangClassGetDeclaredField;\n-    final JNIMethodId javaLangClassGetName;\n-\n     final JNIMethodId javaLangReflectMemberGetName;\n     final JNIMethodId javaLangReflectMemberGetDeclaringClass;\n-\n     final JNIMethodId javaUtilEnumerationHasMoreElements;\n-\n+    final JNIMethodId javaUtilMissingResourceExceptionCtor3;\n+    public final JNIMethodId javaLangClassLoaderGetResource;\n     final JNIObjectHandle javaLangClassLoader;\n+    public final JNIObjectHandle javaNioByteBuffer;\n+    public final JNIObjectHandle javaLangSecurityException;\n+    public final JNIObjectHandle javaLangNoClassDefFoundError;\n+    public final JNIObjectHandle javaLangNoSuchMethodError;\n+    public final JNIObjectHandle javaLangIncompatibleClassChangeError;\n+    final JNIObjectHandle javaLangNoSuchMethodException;\n+    public final JNIObjectHandle javaLangNoSuchFieldError;\n+    final JNIObjectHandle javaLangNoSuchFieldException;\n+    final JNIObjectHandle javaLangClassNotFoundException;\n+    final JNIObjectHandle javaLangRuntimeException;\n+    final JNIObjectHandle javaUtilMissingResourceException;\n+    final JNIMethodId javaLangClassGetDeclaredMethod;\n+    final JNIMethodId javaLangClassGetDeclaredConstructor;\n+    final JNIMethodId javaLangClassGetDeclaredField;\n+    final JNIMethodId javaLangClassGetName;", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjExNDMxNA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612114314", "bodyText": "Fixed", "author": "ziyilin", "createdAt": "2021-04-13T04:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzMzAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "1fdbdb6a38fb769a6df61ddf0ab89785c65749f4", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java\nindex 564300cf882..7d0efb2de24 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java\n\n@@ -42,20 +42,8 @@ public class NativeImageAgentJNIHandleSet extends JNIHandleSet {\n     final JNIMethodId javaLangReflectMemberGetName;\n     final JNIMethodId javaLangReflectMemberGetDeclaringClass;\n     final JNIMethodId javaUtilEnumerationHasMoreElements;\n-    final JNIMethodId javaUtilMissingResourceExceptionCtor3;\n-    public final JNIMethodId javaLangClassLoaderGetResource;\n+    final JNIMethodId javaLangClassLoaderGetResource;\n     final JNIObjectHandle javaLangClassLoader;\n-    public final JNIObjectHandle javaNioByteBuffer;\n-    public final JNIObjectHandle javaLangSecurityException;\n-    public final JNIObjectHandle javaLangNoClassDefFoundError;\n-    public final JNIObjectHandle javaLangNoSuchMethodError;\n-    public final JNIObjectHandle javaLangIncompatibleClassChangeError;\n-    final JNIObjectHandle javaLangNoSuchMethodException;\n-    public final JNIObjectHandle javaLangNoSuchFieldError;\n-    final JNIObjectHandle javaLangNoSuchFieldException;\n-    final JNIObjectHandle javaLangClassNotFoundException;\n-    final JNIObjectHandle javaLangRuntimeException;\n-    final JNIObjectHandle javaUtilMissingResourceException;\n     final JNIMethodId javaLangClassGetDeclaredMethod;\n     final JNIMethodId javaLangClassGetDeclaredConstructor;\n     final JNIMethodId javaLangClassGetDeclaredField;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzNTQxMw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r608835413", "bodyText": "This is slow. If checks like this cannot be avoided, compare against a jmethodID from the handle set.", "author": "peter-hofer", "createdAt": "2021-04-07T17:01:14Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }\n+            }\n+        }\n+\n+        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+        Object result = false;\n+        boolean justAdded = definedClasses.add(definedClassName);\n+        if (isDynamicallyGenerated) {\n+            if (!justAdded) {\n+                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n+                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n+                return true;\n+            }\n+            // Check the caller is using byte array or directedBuffer\n+            String caller = getMethodFullNameAtFrame(jni, 1);\n+            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMzY4NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611613685", "bodyText": "Fixed as the whole postDefine method is removed.", "author": "ziyilin", "createdAt": "2021-04-12T13:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgzNTQxMw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTcyNjU1Ng==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609726556", "bodyText": "This seems expensive and I am not convinced of the $/$$ heuristic either. But there is no single perfect way to determine whether a class was generated.\nHowever, have you looked into the supplied ProtectionDomain object and its CodeSource object? It seems like an equally good indicator whether that object or its return value for getLocation are null and querying them is cheap.\n(The question of where to draw the line here is tricky. For example, we probably want to capture classes from the network or from nested JARs which do have a valid URL. I suppose we will have to improve this for cases like that over time.)", "author": "peter-hofer", "createdAt": "2021-04-08T13:53:41Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -573,6 +593,96 @@ private static boolean handleGetSystemResources(JNIEnvironment jni, Breakpoint b\n         return true;\n     }\n \n+    /**\n+     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n+     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n+     * benefit of being always able to get defined class' name even if defineClass' classname\n+     * parameter is null.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n+        boolean isDynamicallyGenerated = false;\n+\n+        // Get class name from the argument \"name\" of\n+        // defineClass(String name, byte[] b, int off, int len)\n+        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n+        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n+        final String definedClassName;\n+        JNIObjectHandle self = getObjectArgument(0);\n+        // 1. Don't have a name for class before defining.\n+        // The class is dynamically generated.\n+        if (nameFromDefineClassParam == null) {\n+            isDynamicallyGenerated = true;\n+            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n+            // pd)\n+            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n+        } else {\n+            definedClassName = nameFromDefineClassParam;\n+            // Filter out internal classes which are definitely not dynamically generated\n+            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n+            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n+            postDefineCLassAccessAdvisor.setInLivePhase(true);\n+            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n+                isDynamicallyGenerated = false;\n+            }\n+\n+            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n+            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n+            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n+                isDynamicallyGenerated = true;\n+            } else {\n+                // 3. A dynamically defined class always return null\n+                // when call java.lang.ClassLoader.getResource(classname)\n+                // This is the accurate but slow way.\n+                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n+                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n+                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n+                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n+                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n+                }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjQwNzIwMg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612407202", "bodyText": "I have removed the $/$$ way.\nThis part of code is now working inside the onClassFileLoadHook. There are 3 checks:\n\nif the classloader is null, it is not dynamic class\nif the class name is null, it is the dynamic class\nStill check via getResource\n\nThere is still no guarantee that a dynamic class always has a null ProtectionDomain or null CodeSource.location. User can provide any ProtectionDomain to defineClass.\ngetResource is slow, but is accurate.", "author": "ziyilin", "createdAt": "2021-04-13T12:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTcyNjU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTkwOTEzOQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r615909139", "bodyText": "Do you have an example for a custom class loader that provides a ProtectionDomain and CodeSource with a URL while getResource for the same class would return null?", "author": "peter-hofer", "createdAt": "2021-04-19T14:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTcyNjU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\nindex 94b47afab5c..16b6339be58 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java\n\n@@ -593,96 +582,6 @@ final class BreakpointInterceptor {\n         return true;\n     }\n \n-    /**\n-     * java.lang.ClassLoader.postDefineClass is always called in java.lang.ClassLoader.defineClass,\n-     * so intercepting postDefineClass is equivalent to intercepting defineClass but with extra\n-     * benefit of being always able to get defined class' name even if defineClass' classname\n-     * parameter is null.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static boolean postDefineClass(JNIEnvironment jni, Breakpoint bp) {\n-        boolean isDynamicallyGenerated = false;\n-\n-        // Get class name from the argument \"name\" of\n-        // defineClass(String name, byte[] b, int off, int len)\n-        // The first argument is implicitly \"this\", so \"name\" is the 2nd parameter.\n-        String nameFromDefineClassParam = fromJniString(jni, getObjectArgument(1, 1));\n-        final String definedClassName;\n-        JNIObjectHandle self = getObjectArgument(0);\n-        // 1. Don't have a name for class before defining.\n-        // The class is dynamically generated.\n-        if (nameFromDefineClassParam == null) {\n-            isDynamicallyGenerated = true;\n-            // Get name from parameter \"c\" of method postDefineClass(Class<?> c, ProtectionDomain\n-            // pd)\n-            definedClassName = getClassNameOrNull(jni, getObjectArgument(1));\n-        } else {\n-            definedClassName = nameFromDefineClassParam;\n-            // Filter out internal classes which are definitely not dynamically generated\n-            // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-            AccessAdvisor postDefineCLassAccessAdvisor = new AccessAdvisor();\n-            postDefineCLassAccessAdvisor.setInLivePhase(true);\n-            if (postDefineCLassAccessAdvisor.shouldIgnore(new LazyValue<>(() -> definedClassName), new LazyValue<>(() -> null))) {\n-                isDynamicallyGenerated = false;\n-            }\n-\n-            // 2. Class with name starts with $ or contains $$ is usually dynamically generated\n-            String className = definedClassName.substring(definedClassName.lastIndexOf('.') + 1);\n-            if (className.startsWith(\"$\") || className.contains(\"$$\")) {\n-                isDynamicallyGenerated = true;\n-            } else {\n-                // 3. A dynamically defined class always return null\n-                // when call java.lang.ClassLoader.getResource(classname)\n-                // This is the accurate but slow way.\n-                String asResourceName = definedClassName.replace('.', '/') + \".class\";\n-                try (CCharPointerHolder resourceNameHolder = toCString(asResourceName);) {\n-                    JNIObjectHandle resourceNameJString = jniFunctions().getNewStringUTF().invoke(jni, resourceNameHolder.get());\n-                    JNIObjectHandle returnValue = callObjectMethodL(jni, self, agent.handles().javaLangClassLoaderGetResource, resourceNameJString);\n-                    isDynamicallyGenerated = returnValue.equal(nullHandle());\n-                }\n-            }\n-        }\n-\n-        // CallerClass is always java.lang.ClassLoader, we only check the defined class\n-        Object result = false;\n-        boolean justAdded = definedClasses.add(definedClassName);\n-        if (isDynamicallyGenerated) {\n-            if (!justAdded) {\n-                unsupportedExceptions.add(\"Class \" + definedClassName + \" has been defined before. Multiple definitions are not supported.\\n\" +\n-                                ClassLoaderDefineClassSupport.getStackTrace(jni).toString());\n-                return true;\n-            }\n-            // Check the caller is using byte array or directedBuffer\n-            String caller = getMethodFullNameAtFrame(jni, 1);\n-            boolean isByteArray = \"java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;\".equals(caller);\n-            // Verify if defineClass succeeds\n-            // As we hook on postDefineClass method which is the last step of defineClass, so if\n-            // it can execute successfully, the whole defineClass method can execute\n-            // successfully\n-            JNIValue args = StackValue.get(2, JNIValue.class);\n-            args.addressOf(0).setObject(getObjectArgument(1));\n-            args.addressOf(1).setObject(getObjectArgument(2));\n-            jniFunctions().getCallVoidMethodA().invoke(jni, self, bp.method, args);\n-            if (clearException(jni)) {\n-                // No need to proceed if any exception happens\n-                result = false;\n-            } else {\n-                result = true;\n-            }\n-            try {\n-                JNIObjectHandle callerClass = getDirectCallerClass();\n-                ClassLoaderDefineClassSupport dynamicSupport = new ClassLoaderDefineClassSupport(jni, callerClass,\n-                                definedClassName, traceWriter, agent, isByteArray);\n-                dynamicSupport.trace(result);\n-                return true;\n-            } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-            }\n-        } else {\n-            return true;\n-        }\n-    }\n-\n     private static boolean newProxyInstance(JNIEnvironment jni, Breakpoint bp) {\n         JNIObjectHandle callerClass = getDirectCallerClass();\n         JNIObjectHandle classLoader = getObjectArgument(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTczMzgxNA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609733814", "bodyText": "Why p.getResourceConfiguration()? Is this even necessary?", "author": "peter-hofer", "createdAt": "2021-04-08T14:00:31Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java", "diffHunk": "@@ -299,6 +306,11 @@ private static void generate(Iterator<String> argsIter, boolean acceptTraceFileA\n                 p.getSerializationConfiguration().printJson(writer);\n             }\n         }\n+        for (URI uri : outputSet.getDynamicClassLoadingConfigPaths()) {\n+            try (JsonWriter writer = new JsonWriter(Paths.get(uri))) {\n+                p.getResourceConfiguration().printJson(writer);", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjExNDIyNQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612114225", "bodyText": "I've changed it to p.getDynamicClassesConfiguration().", "author": "ziyilin", "createdAt": "2021-04-13T04:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTczMzgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\nindex f5065f45b96..c98fa4bfa21 100644\n--- a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\n+++ b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\n\n@@ -306,7 +306,7 @@ public class ConfigurationTool {\n                 p.getSerializationConfiguration().printJson(writer);\n             }\n         }\n-        for (URI uri : outputSet.getDynamicClassLoadingConfigPaths()) {\n+        for (URI uri : outputSet.getDynamicClassesConfigPaths()) {\n             try (JsonWriter writer = new JsonWriter(Paths.get(uri))) {\n                 p.getResourceConfiguration().printJson(writer);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgxNTEwOQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609815109", "bodyText": "Why not use traceCall? Everything can be put in args.", "author": "peter-hofer", "createdAt": "2021-04-08T15:19:15Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/TraceWriter.java", "diffHunk": "@@ -110,6 +110,19 @@ public void traceCall(String tracer, String function, Object clazz, Object decla\n         traceEntry(entry);\n     }\n \n+    public void traceDefineClass(String definedClassName, String checksum, byte[] classContents, Object result) {\n+        Map<String, Object> entry = new HashMap<>();\n+        entry.put(\"tracer\", \"classDefiner\");\n+        entry.put(\"definedClassName\", definedClassName);\n+        entry.put(\"checksum\", checksum);\n+        // classContents will be dumped to file and then set dumpedFileName\n+        // at the end of tracing process\n+        entry.put(\"dumpedFileName\", null);\n+        entry.put(\"classContents\", classContents);\n+        entry.put(\"result\", result);\n+        traceEntry(entry);\n+    }\n+", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjExNDIwMg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612114202", "bodyText": "Fixed", "author": "ziyilin", "createdAt": "2021-04-13T04:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgxNTEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1fdbdb6a38fb769a6df61ddf0ab89785c65749f4", "chunk": "diff --git a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/TraceWriter.java b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/TraceWriter.java\nindex 4c619549ad1..14ec5b108e4 100644\n--- a/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/TraceWriter.java\n+++ b/substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/TraceWriter.java\n\n@@ -110,19 +110,6 @@ public abstract class TraceWriter implements Closeable {\n         traceEntry(entry);\n     }\n \n-    public void traceDefineClass(String definedClassName, String checksum, byte[] classContents, Object result) {\n-        Map<String, Object> entry = new HashMap<>();\n-        entry.put(\"tracer\", \"classDefiner\");\n-        entry.put(\"definedClassName\", definedClassName);\n-        entry.put(\"checksum\", checksum);\n-        // classContents will be dumped to file and then set dumpedFileName\n-        // at the end of tracing process\n-        entry.put(\"dumpedFileName\", null);\n-        entry.put(\"classContents\", classContents);\n-        entry.put(\"result\", result);\n-        traceEntry(entry);\n-    }\n-\n     abstract void traceEntry(Map<String, Object> entry);\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgxNzU3NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609817574", "bodyText": "This should be inconsistent with the other styles and a bit shorter perhaps, how about --dynamic-classes-input/-output? In fact, I think we should drop the extra loading in other places too.", "author": "peter-hofer", "createdAt": "2021-04-08T15:21:42Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java", "diffHunk": "@@ -195,6 +195,12 @@ private static void generate(Iterator<String> argsIter, boolean acceptTraceFileA\n                     set.getSerializationConfigPaths().add(requirePathUri(current, value));\n                     break;\n \n+                case \"--dynamicClassLoading-input\":\n+                    set = inputSet; // fall through\n+                case \"--dynamicClassLoading-output\":\n+                    set.getDynamicClassLoadingConfigPaths().add(requirePathUri(current, value));\n+                    break;", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMzM1OQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611613359", "bodyText": "Fixed, and all loading post-fixes are removed.", "author": "ziyilin", "createdAt": "2021-04-12T13:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgxNzU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\nindex f5065f45b96..c98fa4bfa21 100644\n--- a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\n+++ b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/ConfigurationTool.java\n\n@@ -195,10 +195,10 @@ public class ConfigurationTool {\n                     set.getSerializationConfigPaths().add(requirePathUri(current, value));\n                     break;\n \n-                case \"--dynamicClassLoading-input\":\n+                case \"--dynamic-classes-input\":\n                     set = inputSet; // fall through\n-                case \"--dynamicClassLoading-output\":\n-                    set.getDynamicClassLoadingConfigPaths().add(requirePathUri(current, value));\n+                case \"--dynamic-classes-output\":\n+                    set.getDynamicClassesConfigPaths().add(requirePathUri(current, value));\n                     break;\n \n                 case \"--trace-input\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgyNTcyNg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609825726", "bodyText": "Dead code?", "author": "peter-hofer", "createdAt": "2021-04-08T15:29:57Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java", "diffHunk": "@@ -82,4 +82,11 @@ protected static long asLong(Object value, String propertyName) {\n         }\n         throw new JSONParserException(\"Invalid long value '\" + value + \"' for element '\" + propertyName + \"'\");\n     }\n+\n+    static int asInteger(Object value, String propertyName) {\n+        if (value instanceof Integer) {\n+            return (int) value;\n+        }\n+        throw new JSONParserException(\"Invalid int value '\" + value + \"' for element '\" + propertyName + \"'\");\n+    }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMzI4Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611613282", "bodyText": "Removed", "author": "ziyilin", "createdAt": "2021-04-12T13:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgyNTcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java\nindex 308e6c4d347..2d294af067a 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java\n\n@@ -82,11 +82,4 @@ public abstract class ConfigurationParser {\n         }\n         throw new JSONParserException(\"Invalid long value '\" + value + \"' for element '\" + propertyName + \"'\");\n     }\n-\n-    static int asInteger(Object value, String propertyName) {\n-        if (value instanceof Integer) {\n-            return (int) value;\n-        }\n-        throw new JSONParserException(\"Invalid int value '\" + value + \"' for element '\" + propertyName + \"'\");\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgyOTU0NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609829544", "bodyText": "Why are the changes in this class needed when there is ConfigurationDynamicClass?", "author": "peter-hofer", "createdAt": "2021-04-08T15:33:46Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationType.java", "diffHunk": "@@ -49,6 +49,8 @@\n     private boolean allDeclaredConstructors;\n     private boolean allPublicConstructors;\n \n+    private int dynamicClassChecksum = 0;\n+", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMzEzNw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611613137", "bodyText": "Removed.", "author": "ziyilin", "createdAt": "2021-04-12T13:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgyOTU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationType.java b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationType.java\nindex 67fefad1443..c7a1e798502 100644\n--- a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationType.java\n+++ b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationType.java\n\n@@ -49,8 +49,6 @@ public class ConfigurationType implements JsonPrintable {\n     private boolean allDeclaredConstructors;\n     private boolean allPublicConstructors;\n \n-    private int dynamicClassChecksum = 0;\n-\n     public ConfigurationType(String qualifiedJavaName) {\n         assert qualifiedJavaName.indexOf('/') == -1 : \"Requires qualified Java name, not internal representation\";\n         assert !qualifiedJavaName.startsWith(\"[\") : \"Requires Java source array syntax, for example java.lang.String[]\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgzMjYxOA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609832618", "bodyText": "Misses checks for extraneous items.", "author": "peter-hofer", "createdAt": "2021-04-08T15:36:40Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassLoadingConfigurationParser.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.configure;\n+\n+import com.oracle.svm.core.util.json.JSONParser;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.Map;\n+\n+public class DynamicClassLoadingConfigurationParser extends ConfigurationParser {\n+\n+    DynamicClassLoadingParserFunction function;\n+\n+    public DynamicClassLoadingConfigurationParser(DynamicClassLoadingParserFunction function) {\n+        this.function = function;\n+    }\n+\n+    @Override\n+    public void parseAndRegister(Reader reader) throws IOException {\n+        JSONParser parser = new JSONParser(reader);\n+        Object json = parser.parse();\n+        for (Object dynamicDefinedClass : asList(json, \"first level of document must be an array of dynamic defined classes\")) {\n+            Map<String, Object> data = asMap(dynamicDefinedClass, \"second level of document must be dynamic defined class descriptor objects \");\n+            String definedClassName = asString(data.get(\"name\"));\n+            String dumpedFileName = asString(data.get(\"classFile\"));\n+            String checksum = asString(data.get(\"checksum\"));", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjExNDE3Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612114172", "bodyText": "Fixed", "author": "ziyilin", "createdAt": "2021-04-13T04:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTgzMjYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassLoadingConfigurationParser.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassesConfigurationParser.java\nsimilarity index 89%\nrename from substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassLoadingConfigurationParser.java\nrename to substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassesConfigurationParser.java\nindex 3f8780da982..a6fdb07c1e5 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassLoadingConfigurationParser.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/DynamicClassesConfigurationParser.java\n\n@@ -31,11 +31,11 @@ import java.io.IOException;\n import java.io.Reader;\n import java.util.Map;\n \n-public class DynamicClassLoadingConfigurationParser extends ConfigurationParser {\n+public class DynamicClassesConfigurationParser extends ConfigurationParser {\n \n-    DynamicClassLoadingParserFunction function;\n+    DynamicClassesParserFunction function;\n \n-    public DynamicClassLoadingConfigurationParser(DynamicClassLoadingParserFunction function) {\n+    public DynamicClassesConfigurationParser(DynamicClassesParserFunction function) {\n         this.function = function;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg0Njc0NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609846745", "bodyText": "What about other characters that are valid in a class name, but not in the file system, or limits for file name or path lengths? This should be more defensive and handle having more than one class with the same name.", "author": "peter-hofer", "createdAt": "2021-04-08T15:51:30Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationDynamicClass.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.configure.config;\n+\n+import com.oracle.svm.configure.json.JsonPrintable;\n+import com.oracle.svm.configure.json.JsonWriter;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public final class ConfigurationDynamicClass implements JsonPrintable {\n+\n+    private final String qualifiedJavaName;\n+    private final String checksum;\n+    private final String classFile;\n+    private final byte[] classContents;\n+\n+    public static ConfigurationDynamicClass newTraceTimeConfig(String qualifiedJavaName, String checksum, byte[] classContents) {\n+        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, null, classContents);\n+    }\n+\n+    public static ConfigurationDynamicClass newBuildTImeConfig(String qualifiedJavaName, String checksum, String classFile) {\n+        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, classFile, null);\n+    }\n+\n+    private ConfigurationDynamicClass(String qualifiedJavaName, String checksum, String classFile, byte[] classContents) {\n+        assert qualifiedJavaName.indexOf('/') == -1 : \"Requires qualified Java name, not internal representation\";\n+        assert !qualifiedJavaName.startsWith(\"[\") : \"Requires Java source array syntax, for example java.lang.String[]\";\n+        this.qualifiedJavaName = qualifiedJavaName;\n+        this.checksum = checksum;\n+        this.classContents = classContents;\n+        this.classFile = classFile;\n+    }\n+\n+    public boolean contains(String definedClassName, String checksum2Match) {\n+        return definedClassName != null && definedClassName.equals(qualifiedJavaName) && checksum2Match.equals(this.checksum);\n+    }\n+\n+    @Override\n+    public void printJson(JsonWriter writer) throws IOException {\n+        // Mangle class' qualified name into a system independent format\n+        String internalName = qualifiedJavaName.replace(\".\", ConfigurationFiles.MANGLE_SLASH);", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjQxNjU2NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612416565", "bodyText": "As now I directly read the class file into byte array to call defineClass instead of finding class from class path, there is no need to keep the package information in the file name. Actually the file name can be anything that is unique.\nWhat do you think using the already calculated SHA value as file name? In this way the file name is unique, and furthermore, we can save one entry in configuration file. As the file name is from SHA, only one of classFile and checksum entry is needed.", "author": "ziyilin", "createdAt": "2021-04-13T12:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg0Njc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTkwMTQ4NQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r615901485", "bodyText": "Yes, I believe the way forward is using a unique hash code in the file name, potentially the unqualified name too for identifiability to the developer.", "author": "peter-hofer", "createdAt": "2021-04-19T14:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg0Njc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "411191cb052afe6d3636d92a3bf77d5437cf6d01", "chunk": "diff --git a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationDynamicClass.java b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationDynamicClass.java\nindex b178bc3c4c0..0a5380f65f8 100644\n--- a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationDynamicClass.java\n+++ b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/ConfigurationDynamicClass.java\n\n@@ -38,24 +38,25 @@ public final class ConfigurationDynamicClass implements JsonPrintable {\n \n     private final String qualifiedJavaName;\n     private final String checksum;\n-    private final String classFile;\n+    private final Path classFilePath;\n     private final byte[] classContents;\n \n-    public static ConfigurationDynamicClass newTraceTimeConfig(String qualifiedJavaName, String checksum, byte[] classContents) {\n-        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, null, classContents);\n+    public static ConfigurationDynamicClass newAgentTraceTimeConfig(String qualifiedJavaName, String checksum, byte[] classContents) {\n+        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, classContents, null);\n     }\n \n-    public static ConfigurationDynamicClass newBuildTImeConfig(String qualifiedJavaName, String checksum, String classFile) {\n-        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, classFile, null);\n+    public static ConfigurationDynamicClass newAgentMergeTimeConfig(String qualifiedJavaName, String checksum, Path classFile) {\n+        return new ConfigurationDynamicClass(qualifiedJavaName, checksum, null, classFile);\n     }\n \n-    private ConfigurationDynamicClass(String qualifiedJavaName, String checksum, String classFile, byte[] classContents) {\n+    private ConfigurationDynamicClass(String qualifiedJavaName, String checksum, byte[] classContents, Path classFilePath) {\n         assert qualifiedJavaName.indexOf('/') == -1 : \"Requires qualified Java name, not internal representation\";\n         assert !qualifiedJavaName.startsWith(\"[\") : \"Requires Java source array syntax, for example java.lang.String[]\";\n+        assert ! (classContents==null && classFilePath==null): \"classContents and classFilePath can't be null at the same time\";\n         this.qualifiedJavaName = qualifiedJavaName;\n         this.checksum = checksum;\n         this.classContents = classContents;\n-        this.classFile = classFile;\n+        this.classFilePath = classFilePath;\n     }\n \n     public boolean contains(String definedClassName, String checksum2Match) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg0OTExNw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609849117", "bodyText": "Dead code?", "author": "peter-hofer", "createdAt": "2021-04-08T15:53:56Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java", "diffHunk": "@@ -247,6 +247,11 @@ public void processEntry(Map<String, ?> entry) {\n                 resourceConfiguration.addBundle((String) args.get(2));\n                 break;\n             }\n+            case \"checksum\": {\n+                expectSize(args, 1);\n+                configuration.getOrCreateType(clazzOrDeclaringClass).setDynamicClassChecksum((Integer) args.get(0));\n+                break;\n+            }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMjk5Mw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611612993", "bodyText": "Removed this case. Not needed any more.", "author": "ziyilin", "createdAt": "2021-04-12T13:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg0OTExNw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java\nindex e6793043b87..6a1906d9670 100644\n--- a/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java\n+++ b/substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java\n\n@@ -247,11 +247,6 @@ class ReflectionProcessor extends AbstractProcessor {\n                 resourceConfiguration.addBundle((String) args.get(2));\n                 break;\n             }\n-            case \"checksum\": {\n-                expectSize(args, 1);\n-                configuration.getOrCreateType(clazzOrDeclaringClass).setDynamicClassChecksum((Integer) args.get(0));\n-                break;\n-            }\n             default:\n                 System.err.println(\"Unsupported reflection method: \" + function);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1MDEyOQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609850129", "bodyText": "Why not simply static methods?", "author": "peter-hofer", "createdAt": "2021-04-08T15:55:09Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java", "diffHunk": "@@ -526,3 +539,47 @@ public Object transform(MetaAccessProvider metaAccess, ResolvedJavaField origina\n         }\n     }\n }\n+\n+final class ClassLoaderHelper {", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMjYwMw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611612603", "bodyText": "Fixed", "author": "ziyilin", "createdAt": "2021-04-12T13:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1MDEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\nindex 5913850d68f..a2142ca298b 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\n\n@@ -541,20 +533,7 @@ class PackageFieldTransformer implements RecomputeFieldValue.CustomFieldValueTra\n }\n \n final class ClassLoaderHelper {\n-\n-    private String className;\n-    private byte[] classContents;\n-\n-    ClassLoaderHelper(byte[] b, String name) throws IOException {\n-        classContents = b;\n-        if (name == null) {\n-            className = JavaClassUtil.getClassName(b);\n-        } else {\n-            className = name;\n-        }\n-    }\n-\n-    public Class<?> doDefineClass() {\n+    public static Class<?> doDefineClass(String className) {\n         try {\n             return ClassForNameSupport.forName(className, false);\n         } catch (ClassNotFoundException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1MzI5Nw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609853297", "bodyText": "What's the reason behind not supporting this? Can't we set the protection domain on the class object (e.g. indirectly through a map), or ignore it? Or is this some esoteric case?", "author": "peter-hofer", "createdAt": "2021-04-08T15:58:23Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java", "diffHunk": "@@ -414,21 +416,32 @@ private void clearAssertionStatus() {\n     private static native void registerNatives();\n \n     @Substitute\n-    @SuppressWarnings({\"unused\", \"static-method\"})\n-    private Class<?> defineClass(String name, byte[] b, int off, int len) {\n-        throw VMError.unsupportedFeature(\"Defining classes from new bytecodes run time.\");\n+    @SuppressWarnings(\"unused\")\n+    Class<?> defineClass(String name, byte[] b, int off, int len)\n+                    throws ClassFormatError {\n+        try {\n+            ClassLoaderHelper helper = new ClassLoaderHelper(b, name);\n+            // Verify the runtime class is the same as previously prepared by byte array hashcode\n+            helper.verifyClassUnchanged();\n+            return helper.doDefineClass();\n+        } catch (IOException e) {\n+            ClassFormatError error = new ClassFormatError(\"Can't get class info \" +\n+                            \"from provided byte array.\");\n+            error.initCause(e);\n+            throw error;\n+        }\n     }\n \n     @Substitute\n-    @SuppressWarnings({\"unused\", \"static-method\"})\n+    @SuppressWarnings(\"unused\")\n     private Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) {\n-        throw VMError.unsupportedFeature(\"Defining classes from new bytecodes run time.\");\n+        throw VMError.unsupportedFeature(\"Define class with protection domain is not supported\");\n     }\n \n     @Substitute\n-    @SuppressWarnings({\"unused\", \"static-method\"})\n+    @SuppressWarnings(\"unused\")\n     private Class<?> defineClass(String name, java.nio.ByteBuffer b, ProtectionDomain protectionDomain) {\n-        throw VMError.unsupportedFeature(\"Defining classes from new bytecodes run time.\");\n+        throw VMError.unsupportedFeature(\"Define class with protection domain is not supported\");\n     }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMDYxMDQ1OA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r610610458", "bodyText": "defineClass APIs with ProtectionDomain parameter will call ClassLoader.checkCerts method to check if the class' certs match with the other same-package-classes'. However, Substrate VM does not store certs files from jar files to native image at build time, so there is always nothing to compare at image runtime. If the API is supported now, it behaves differently from what JDK does. I think finding a proper solution to reserve jar's certs files is beyond this PR's scope, so I leave these two APIs as unimplemented for now.", "author": "ziyilin", "createdAt": "2021-04-09T13:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1MzI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\nindex 5913850d68f..a2142ca298b 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_java_lang_ClassLoader.java\n\n@@ -419,17 +419,9 @@ final class Target_java_lang_ClassLoader {\n     @SuppressWarnings(\"unused\")\n     Class<?> defineClass(String name, byte[] b, int off, int len)\n                     throws ClassFormatError {\n-        try {\n-            ClassLoaderHelper helper = new ClassLoaderHelper(b, name);\n-            // Verify the runtime class is the same as previously prepared by byte array hashcode\n-            helper.verifyClassUnchanged();\n-            return helper.doDefineClass();\n-        } catch (IOException e) {\n-            ClassFormatError error = new ClassFormatError(\"Can't get class info \" +\n-                            \"from provided byte array.\");\n-            error.initCause(e);\n-            throw error;\n-        }\n+        String definedClassName = name == null ? JavaClassUtil.getClassName(b) : name;\n+        ClassLoaderHelper.verifyClassUnchanged(definedClassName, b);\n+        return ClassLoaderHelper.doDefineClass(definedClassName);\n     }\n \n     @Substitute\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1ODI0NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609858244", "bodyText": "The hash code should be kept in a compact byte array (should be converted during parsing).", "author": "peter-hofer", "createdAt": "2021-04-08T16:03:44Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/ClassForNameSupport.java", "diffHunk": "@@ -41,12 +41,19 @@ static ClassForNameSupport singleton() {\n \n     /** The map used to collect registered classes. */\n     private final EconomicMap<String, Class<?>> knownClasses = ImageHeapMap.create();\n+    private final EconomicMap<String, String> dynamicGeneratedClasses = ImageHeapMap.create();", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMjQ3NA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611612474", "bodyText": "Fixed by changing dynamicGeneratedClasses to EconomicMap<String, byte[]>", "author": "ziyilin", "createdAt": "2021-04-12T13:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg1ODI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/ClassForNameSupport.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/ClassForNameSupport.java\nindex e6761de3e27..3c3453e63f6 100644\n--- a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/ClassForNameSupport.java\n+++ b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/ClassForNameSupport.java\n\n@@ -41,7 +41,8 @@ public final class ClassForNameSupport {\n \n     /** The map used to collect registered classes. */\n     private final EconomicMap<String, Class<?>> knownClasses = ImageHeapMap.create();\n-    private final EconomicMap<String, String> dynamicGeneratedClasses = ImageHeapMap.create();\n+    /** Store class name and checksum byte array as key-value pair. */\n+    private final EconomicMap<String, byte[]> dynamicGeneratedClasses = ImageHeapMap.create();\n \n     @Platforms(Platform.HOSTED_ONLY.class)\n     public static void registerClass(Class<?> clazz) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg2NDA5Nw==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609864097", "bodyText": "Needs proper rethrowing.", "author": "peter-hofer", "createdAt": "2021-04-08T16:09:39Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.dynamicclassloading.hosted;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.c.libc.TemporaryBuildDirectoryProvider;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.DynamicClassLoadingConfigurationParser;\n+import com.oracle.svm.core.hub.ClassForNameSupport;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.MultiClassLoaderReporter;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@AutomaticFeature\n+public class DynamicClassLoadingFeature implements Feature {\n+\n+    class DynamicClassContainer {\n+        Class<?> clazz;\n+        String name;\n+        String checksum;\n+\n+        DynamicClassContainer(Class<?> clazz, String name, String checksum) {\n+            this.clazz = clazz;\n+            this.name = name;\n+            this.checksum = checksum;\n+        }\n+    }\n+\n+    private Map<String, DynamicClassContainer> dynamicClassContainers = new HashMap<>();\n+    private List<StringBuilder> errMsgs = new ArrayList<>();\n+\n+    /**\n+     * Reflectively call protected method URLClassLoader.addURL.\n+     *\n+     * @param url url to add into the URLClassLoader\n+     * @param classLoader URLClassLoader instance\n+     */\n+    private static void addURL2URLClassLoader(URL url, URLClassLoader classLoader) {\n+        Method addURL = ReflectionUtil.lookupMethod(URLClassLoader.class, \"addURL\", URL.class);\n+        try {\n+            addURL.invoke(classLoader, url);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+        }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMTY3OA==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611611678", "bodyText": "Fixed.", "author": "ziyilin", "createdAt": "2021-04-12T13:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg2NDA5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java b/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\nsimilarity index 58%\nrename from substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java\nrename to substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\nindex 90d91f64df6..c831c112814 100644\n--- a/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java\n+++ b/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\n\n@@ -23,39 +23,39 @@\n  * or visit www.oracle.com if you need additional information or have any\n  * questions.\n  */\n-package com.oracle.svm.reflect.dynamicclassloading.hosted;\n+package com.oracle.svm.reflect.dynamicclasses.hosted;\n \n // Checkstyle: allow reflection\n \n import com.oracle.svm.core.annotate.AutomaticFeature;\n-import com.oracle.svm.core.c.libc.TemporaryBuildDirectoryProvider;\n import com.oracle.svm.core.configure.ConfigurationFiles;\n-import com.oracle.svm.core.configure.DynamicClassLoadingConfigurationParser;\n+import com.oracle.svm.core.configure.DynamicClassesConfigurationParser;\n import com.oracle.svm.core.hub.ClassForNameSupport;\n import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n import com.oracle.svm.hosted.FeatureImpl;\n-import com.oracle.svm.hosted.ImageClassLoader;\n import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n import com.oracle.svm.reflect.MultiClassLoaderReporter;\n import com.oracle.svm.util.ReflectionUtil;\n-import org.graalvm.nativeimage.ImageSingletons;\n import org.graalvm.nativeimage.hosted.Feature;\n \n-import java.io.IOException;\n+import java.io.FileInputStream;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.net.URLClassLoader;\n-import java.nio.file.Files;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n @AutomaticFeature\n-public class DynamicClassLoadingFeature implements Feature {\n+public class DynamicClassesFeature implements Feature {\n \n     class DynamicClassContainer {\n         Class<?> clazz;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg2NjY1Mg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609866652", "bodyText": "Not clean and the static field will not work when there is more than one image build in the process (server mode). You might need to add a method to collect the locations and return them so you can use them in the feature's afterRegistration method.", "author": "peter-hofer", "createdAt": "2021-04-08T16:12:11Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/config/ConfigurationParserUtils.java", "diffHunk": "@@ -124,12 +131,14 @@ public boolean tryAdvance(Consumer<? super URL> action) {\n                 throw UserError.abort(\"Could not open %s: %s\", url, e.getMessage());\n             }\n         }).sum();\n-\n         return parsedCount;\n     }\n \n     private static void doParseAndRegister(ConfigurationParser parser, Reader reader, String featureName, Object location, HostedOptionKey<LocatableMultiOptionValue.Strings> option) {\n         try {\n+            if (featureName.equals(\"dynamicClassLoading\") && location instanceof URL) {\n+                dynamicClassLoadingDirs.add((URL) location);\n+            }", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM4MTk4OQ==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r612381989", "bodyText": "Removed the dynamicClassLoadingDirs. The original way is to fetch the dumped class file from all possible locations setting by -H:DynamicClassesConfigurationFiles= and -H:DynamicClassesConfigurationResources= , but the class file should be located in the dynClasses directory under the configuration file's directory. So we only need to follow the location of the currently parsed dynamicClass configuration file to look for the dumped class files.", "author": "ziyilin", "createdAt": "2021-04-13T12:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg2NjY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/config/ConfigurationParserUtils.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/config/ConfigurationParserUtils.java\nindex ef581205ea9..c08644d60d4 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/config/ConfigurationParserUtils.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/config/ConfigurationParserUtils.java\n\n@@ -136,8 +136,8 @@ public final class ConfigurationParserUtils {\n \n     private static void doParseAndRegister(ConfigurationParser parser, Reader reader, String featureName, Object location, HostedOptionKey<LocatableMultiOptionValue.Strings> option) {\n         try {\n-            if (featureName.equals(\"dynamicClassLoading\") && location instanceof URL) {\n-                dynamicClassLoadingDirs.add((URL) location);\n+            if (featureName.equals(\"dynamicClasses\") && location instanceof URL) {\n+                dynamicClassesDirs.add((URL) location);\n             }\n             parser.parseAndRegister(reader);\n         } catch (IOException | JSONParserException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg4MDM5Ng==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r609880396", "bodyText": "Assuming that the image class loader is a URLClassLoader and manipulating it through reflection does not seem like a good idea at all (especially with the module system). These steps need proper support in ImageClassLoader and AbstractNativeImageClassLoaderSupport and its subclasses and that probably entail creating a ClassLoader subclass for these purposes.\nMoreover it seems very roundabout and not safe to reconstruct a class directory hierarchy, add it to the loader's class path (which potentially) and load the class from there. Is it not possible to just load the class from a byte array with the file's contents (other than that we need to call defineClass somehow)?\nThis really needs fixing.", "author": "peter-hofer", "createdAt": "2021-04-08T16:27:18Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.dynamicclassloading.hosted;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.c.libc.TemporaryBuildDirectoryProvider;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.DynamicClassLoadingConfigurationParser;\n+import com.oracle.svm.core.hub.ClassForNameSupport;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.MultiClassLoaderReporter;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@AutomaticFeature\n+public class DynamicClassLoadingFeature implements Feature {\n+\n+    class DynamicClassContainer {\n+        Class<?> clazz;\n+        String name;\n+        String checksum;\n+\n+        DynamicClassContainer(Class<?> clazz, String name, String checksum) {\n+            this.clazz = clazz;\n+            this.name = name;\n+            this.checksum = checksum;\n+        }\n+    }\n+\n+    private Map<String, DynamicClassContainer> dynamicClassContainers = new HashMap<>();\n+    private List<StringBuilder> errMsgs = new ArrayList<>();\n+\n+    /**\n+     * Reflectively call protected method URLClassLoader.addURL.\n+     *\n+     * @param url url to add into the URLClassLoader\n+     * @param classLoader URLClassLoader instance\n+     */\n+    private static void addURL2URLClassLoader(URL url, URLClassLoader classLoader) {\n+        Method addURL = ReflectionUtil.lookupMethod(URLClassLoader.class, \"addURL\", URL.class);\n+        try {\n+            addURL.invoke(classLoader, url);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Reflectively call protected method URLClassLoader.findClass.\n+     *\n+     * @param name target class name\n+     * @param classLoader\n+     * @return the class found with the given name\n+     * @throws ClassNotFoundException\n+     */\n+    private static Class<?> callFindClass(String name, URLClassLoader classLoader) throws ClassNotFoundException {\n+        Method findClass = ReflectionUtil.lookupMethod(URLClassLoader.class, \"findClass\", String.class);\n+        try {\n+            return (Class<?>) findClass.invoke(classLoader, name);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new ClassNotFoundException(name);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRegistration(AfterRegistrationAccess a) {\n+        FeatureImpl.AfterRegistrationAccessImpl access = (FeatureImpl.AfterRegistrationAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+        URLClassLoader cl = (URLClassLoader) imageClassLoader.getClassLoader();", "originalCommit": "98f80147901082a822f76dde76af757036aad82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxMTczNg==", "url": "https://github.com/oracle/graal/pull/2442#discussion_r611611736", "bodyText": "Now read the class file into byte array and then reflectively call defineClass with the byte array data.", "author": "ziyilin", "createdAt": "2021-04-12T13:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTg4MDM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "chunk": "diff --git a/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java b/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\nsimilarity index 58%\nrename from substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java\nrename to substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\nindex 90d91f64df6..c831c112814 100644\n--- a/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclassloading/hosted/DynamicClassLoadingFeature.java\n+++ b/substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/dynamicclasses/hosted/DynamicClassesFeature.java\n\n@@ -23,39 +23,39 @@\n  * or visit www.oracle.com if you need additional information or have any\n  * questions.\n  */\n-package com.oracle.svm.reflect.dynamicclassloading.hosted;\n+package com.oracle.svm.reflect.dynamicclasses.hosted;\n \n // Checkstyle: allow reflection\n \n import com.oracle.svm.core.annotate.AutomaticFeature;\n-import com.oracle.svm.core.c.libc.TemporaryBuildDirectoryProvider;\n import com.oracle.svm.core.configure.ConfigurationFiles;\n-import com.oracle.svm.core.configure.DynamicClassLoadingConfigurationParser;\n+import com.oracle.svm.core.configure.DynamicClassesConfigurationParser;\n import com.oracle.svm.core.hub.ClassForNameSupport;\n import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n import com.oracle.svm.hosted.FeatureImpl;\n-import com.oracle.svm.hosted.ImageClassLoader;\n import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n import com.oracle.svm.reflect.MultiClassLoaderReporter;\n import com.oracle.svm.util.ReflectionUtil;\n-import org.graalvm.nativeimage.ImageSingletons;\n import org.graalvm.nativeimage.hosted.Feature;\n \n-import java.io.IOException;\n+import java.io.FileInputStream;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.net.URLClassLoader;\n-import java.nio.file.Files;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n @AutomaticFeature\n-public class DynamicClassLoadingFeature implements Feature {\n+public class DynamicClassesFeature implements Feature {\n \n     class DynamicClassContainer {\n         Class<?> clazz;\n"}}, {"oid": "2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "url": "https://github.com/oracle/graal/commit/2630b3fbf35e32d79fb7e95c7139b33a23cd627f", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-12T13:01:07Z", "type": "forcePushed"}, {"oid": "1fdbdb6a38fb769a6df61ddf0ab89785c65749f4", "url": "https://github.com/oracle/graal/commit/1fdbdb6a38fb769a6df61ddf0ab89785c65749f4", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-13T04:06:26Z", "type": "forcePushed"}, {"oid": "411191cb052afe6d3636d92a3bf77d5437cf6d01", "url": "https://github.com/oracle/graal/commit/411191cb052afe6d3636d92a3bf77d5437cf6d01", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-13T12:00:18Z", "type": "forcePushed"}, {"oid": "a062142e38b1df96eb2a6275815b048fdc442fb6", "url": "https://github.com/oracle/graal/commit/a062142e38b1df96eb2a6275815b048fdc442fb6", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-13T12:52:40Z", "type": "forcePushed"}, {"oid": "132bac9be8dc02b044a6f3f59bbd539b98365e37", "url": "https://github.com/oracle/graal/commit/132bac9be8dc02b044a6f3f59bbd539b98365e37", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-14T02:34:36Z", "type": "forcePushed"}, {"oid": "74f64421fbb065fc73b718066112d0becb826b10", "url": "https://github.com/oracle/graal/commit/74f64421fbb065fc73b718066112d0becb826b10", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-14T03:26:35Z", "type": "forcePushed"}, {"oid": "a13778c14da682910b87ad1d64fe12b2aec4c56c", "url": "https://github.com/oracle/graal/commit/a13778c14da682910b87ad1d64fe12b2aec4c56c", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-14T04:08:47Z", "type": "commit"}, {"oid": "a13778c14da682910b87ad1d64fe12b2aec4c56c", "url": "https://github.com/oracle/graal/commit/a13778c14da682910b87ad1d64fe12b2aec4c56c", "message": "Support dynamic class loading\n\nSupport dynamic class loading for native image", "committedDate": "2021-04-14T04:08:47Z", "type": "forcePushed"}]}