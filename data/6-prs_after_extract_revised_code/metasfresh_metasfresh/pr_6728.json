{"pr_number": 6728, "pr_title": "#6615 comment out credit memo after partial request", "pr_createdAt": "2020-05-25T10:23:13Z", "pr_url": "https://github.com/metasfresh/metasfresh/pull/6728", "timeline": [{"oid": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3", "url": "https://github.com/metasfresh/metasfresh/commit/5901ffe3a3c079201f2a2aed2a7d9537d47998e3", "message": "#6615 comment out credit memo after partial request\n\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-25T10:21:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDMyMg==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429910322", "bodyText": "avoid string concatenation", "author": "teosarca", "createdAt": "2020-05-25T12:31:26Z", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);", "originalCommit": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NzIwMw==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429947203", "bodyText": "done", "author": "metas-rc", "createdAt": "2020-05-25T13:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDMyMg=="}], "type": "inlineReview", "revised_code": {"commit": "45903504c59f8349d770625c00fc7d7e3f1d70b8", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\nindex 26f22de9f4..42a1681e9e 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n\n@@ -112,166 +112,10 @@ class CreditMemoInvoiceCopyHandler implements IDocCopyHandler<I_C_Invoice, I_C_I\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);\n+\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo,  invoice);\n \n \t\t\treturn;\n \t\t}\n-\n-\t\t// // task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// // so we won't know the exact qtys to re-invoice.\n-\t\t// creditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\t\t//\n-\t\t// // CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\t// creditMemo.setIsTaxIncluded(true);\n-\t\t//\n-\t\t// // get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\t// final CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\t// final CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\t// final BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\t\t//\n-\t\t// // Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// // Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\t// final BigDecimal openfraction = openAmt\n-\t\t// // gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t// // this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t// .setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t// .divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\t\t//\n-\t\t// final IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\t\t//\n-\t\t// //\n-\t\t// // Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\t// final List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\t// Collections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\t\t//\n-\t\t// BigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\t// final Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\t\t//\n-\t\t// //\n-\t\t// // For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\t// final Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// final BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\t\t//\n-\t\t// // Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t// // Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t// final BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// creditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n-\t\t//\n-\t\t// newTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t// taxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n-\t\t// }\n-\t\t//\n-\t\t// //\n-\t\t// // Now we check for rounding errors and correct the amounts if necessary.\n-\t\t// // Note that our amounts can't be too big but only too small (by one 'smallestAmt' for each I_C_InvoiceTax).\n-\t\t// // Also note that due to the ordering of 'invoiceTaxes' we correct the invoiceTax with the biggest rate first\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// if (creditMemoGrandTotal.compareTo(openAmt) == 0)\n-\t\t// {\n-\t\t// break;\n-\t\t// }\n-\t\t// if (creditMemoGrandTotal.compareTo(openAmt) < 0)\n-\t\t// {\n-\t\t// newTaxAmounts.put(invoiceTax,\n-\t\t// newTaxAmounts.get(invoiceTax).add(smallestAmtInCurrency));\n-\t\t// creditMemoGrandTotal = creditMemoGrandTotal.add(smallestAmtInCurrency);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// Check.errorIf(true, \"On evaluating {}, we have creditMemoGrandTotal={} and openAmt={}\", invoiceTax, creditMemoGrandTotal, openAmt);\n-\t\t// }\n-\t\t// }\n-\t\t//\n-\t\t// // gh #448: in the past this error occurred when openfraction's scale was two low.\n-\t\t// Check.errorIf(creditMemoGrandTotal.compareTo(openAmt) != 0, \"creditMemoGrandTotal={} is different from openAmt={}; openfraction={}\", creditMemoGrandTotal, openAmt, openfraction);\n-\t\t//\n-\t\t// //\n-\t\t// // Now that we have computed the tax values where we need to end up with our credit memo,\n-\t\t// // We do basically the same on invoice line level. The credit memo lines were copied from the invoice lines, so they still contain the original amounts which we can use\n-\t\t// final Map<I_C_InvoiceTax, List<I_C_InvoiceLine>> tax2lines = new IdentityHashMap<>();\n-\t\t//\n-\t\t// final List<de.metas.adempiere.model.I_C_InvoiceLine> lines = invoicePA.retrieveLines(creditMemo, trxName);\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t// {\n-\t\t// if (creditMemoLine.isDescription())\n-\t\t// {\n-\t\t// continue; // not changing description lines\n-\t\t// }\n-\t\t// final I_C_InvoiceTax invoiceTax = taxId2Invoicetax.get(creditMemoLine.getC_Tax_ID());\n-\t\t// List<I_C_InvoiceLine> linesForInvoiceTax = tax2lines.get(invoiceTax);\n-\t\t// if (linesForInvoiceTax == null)\n-\t\t// {\n-\t\t// linesForInvoiceTax = new ArrayList<>();\n-\t\t// tax2lines.put(invoiceTax, linesForInvoiceTax);\n-\t\t//\n-\t\t// }\n-\t\t// linesForInvoiceTax.add(creditMemoLine);\n-\t\t// }\n-\t\t//\n-\t\t// final Map<I_C_InvoiceLine, BigDecimal> line2newLineGrossAmt = new IdentityHashMap<>();\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// BigDecimal sumPerTax = BigDecimal.ZERO;\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t// {\n-\t\t// final BigDecimal newLineNetAmt = creditMemoLine.getLineNetAmt().multiply(openfraction);\n-\t\t// final BigDecimal newLineGrossAmt;\n-\t\t// if (invoiceTax.isTaxIncluded())\n-\t\t// {\n-\t\t// newLineGrossAmt = newLineNetAmt.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// newLineGrossAmt = newLineNetAmt\n-\t\t// .multiply(invoiceTax.getC_Tax().getRate()\n-\t\t// .add(Env.ONEHUNDRED)\n-\t\t// .divide(Env.ONEHUNDRED))\n-\t\t// .setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// }\n-\t\t// line2newLineGrossAmt.put(creditMemoLine, newLineGrossAmt);\n-\t\t// sumPerTax = sumPerTax.add(newLineGrossAmt);\n-\t\t// }\n-\t\t//\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t// {\n-\t\t// final BigDecimal targetSum = newTaxAmounts.get(invoiceTax);\n-\t\t// if (sumPerTax.compareTo(targetSum) == 0)\n-\t\t// {\n-\t\t// break;\n-\t\t// }\n-\t\t// if (sumPerTax.compareTo(targetSum) < 0)\n-\t\t// {\n-\t\t// line2newLineGrossAmt.put(creditMemoLine, line2newLineGrossAmt.get(creditMemoLine).add(smallestAmtInCurrency));\n-\t\t// sumPerTax = sumPerTax.add(smallestAmtInCurrency);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// Check.errorIf(true, \"invoiceTax {} has has targetSum={}, but the credit memo lines for this tax have sumPerTax={} (difference may not be more than {})\",\n-\t\t// invoiceTax, targetSum, sumPerTax, smallestAmtInCurrency);\n-\t\t// }\n-\t\t// }\n-\t\t// }\n-\t\t//\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t// {\n-\t\t// creditMemoLine.setQtyEntered(ONE);\n-\t\t// creditMemoLine.setQtyInvoiced(ONE);\n-\t\t// creditMemoLine.setPriceEntered(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t// creditMemoLine.setPriceActual(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t//\n-\t\t// // 07090: setting priceUOM to 0, because we set the Qty to 1, and the priceUOM only makes sense in the context of the original Qty (but this is a partial-ammount credit memo)\n-\t\t// InterfaceWrapperHelper.create(creditMemoLine, de.metas.adempiere.model.I_C_InvoiceLine.class).setPrice_UOM_ID(0);\n-\t\t//\n-\t\t// InterfaceWrapperHelper.save(creditMemoLine);\n-\t\t// }\n-\t\t//\n-\t\t// // make sure new credit memo grand total is set\n-\t\t// creditMemo.setGrandTotal(creditMemoGrandTotal);\n-\t\t// InterfaceWrapperHelper.save(creditMemo);\n-\n \t}\n \n \tprivate void completeAndAllocateCreditMemo(final de.metas.adempiere.model.I_C_Invoice invoice, final de.metas.adempiere.model.I_C_Invoice creditMemo)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDQ2Ng==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429910466", "bodyText": "remove this huge commented code chunk.", "author": "teosarca", "createdAt": "2020-05-25T12:31:49Z", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,161 +110,167 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n+\t\telse\n \t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n+\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);\n \n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n+\t\t\treturn;\n \t\t}\n \n+\t\t// // task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,", "originalCommit": "5901ffe3a3c079201f2a2aed2a7d9537d47998e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0NzI0Ng==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r429947246", "bodyText": "done", "author": "metas-rc", "createdAt": "2020-05-25T13:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "45903504c59f8349d770625c00fc7d7e3f1d70b8", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\nindex 26f22de9f4..42a1681e9e 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n\n@@ -112,166 +112,10 @@ class CreditMemoInvoiceCopyHandler implements IDocCopyHandler<I_C_Invoice, I_C_I\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tlogger.warn(\"The credit memo \" + creditMemo + \" should be a partial allocation of invoice \" + invoice);\n+\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo,  invoice);\n \n \t\t\treturn;\n \t\t}\n-\n-\t\t// // task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// // so we won't know the exact qtys to re-invoice.\n-\t\t// creditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\t\t//\n-\t\t// // CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\t// creditMemo.setIsTaxIncluded(true);\n-\t\t//\n-\t\t// // get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\t// final CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\t// final CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\t// final BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\t\t//\n-\t\t// // Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// // Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\t// final BigDecimal openfraction = openAmt\n-\t\t// // gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t// // this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t// .setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t// .divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\t\t//\n-\t\t// final IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\t\t//\n-\t\t// //\n-\t\t// // Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\t// final List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\t// Collections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\t\t//\n-\t\t// BigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\t// final Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\t\t//\n-\t\t// //\n-\t\t// // For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\t// final Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// final BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\t\t//\n-\t\t// // Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t// // Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t// final BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// creditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n-\t\t//\n-\t\t// newTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t// taxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n-\t\t// }\n-\t\t//\n-\t\t// //\n-\t\t// // Now we check for rounding errors and correct the amounts if necessary.\n-\t\t// // Note that our amounts can't be too big but only too small (by one 'smallestAmt' for each I_C_InvoiceTax).\n-\t\t// // Also note that due to the ordering of 'invoiceTaxes' we correct the invoiceTax with the biggest rate first\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// if (creditMemoGrandTotal.compareTo(openAmt) == 0)\n-\t\t// {\n-\t\t// break;\n-\t\t// }\n-\t\t// if (creditMemoGrandTotal.compareTo(openAmt) < 0)\n-\t\t// {\n-\t\t// newTaxAmounts.put(invoiceTax,\n-\t\t// newTaxAmounts.get(invoiceTax).add(smallestAmtInCurrency));\n-\t\t// creditMemoGrandTotal = creditMemoGrandTotal.add(smallestAmtInCurrency);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// Check.errorIf(true, \"On evaluating {}, we have creditMemoGrandTotal={} and openAmt={}\", invoiceTax, creditMemoGrandTotal, openAmt);\n-\t\t// }\n-\t\t// }\n-\t\t//\n-\t\t// // gh #448: in the past this error occurred when openfraction's scale was two low.\n-\t\t// Check.errorIf(creditMemoGrandTotal.compareTo(openAmt) != 0, \"creditMemoGrandTotal={} is different from openAmt={}; openfraction={}\", creditMemoGrandTotal, openAmt, openfraction);\n-\t\t//\n-\t\t// //\n-\t\t// // Now that we have computed the tax values where we need to end up with our credit memo,\n-\t\t// // We do basically the same on invoice line level. The credit memo lines were copied from the invoice lines, so they still contain the original amounts which we can use\n-\t\t// final Map<I_C_InvoiceTax, List<I_C_InvoiceLine>> tax2lines = new IdentityHashMap<>();\n-\t\t//\n-\t\t// final List<de.metas.adempiere.model.I_C_InvoiceLine> lines = invoicePA.retrieveLines(creditMemo, trxName);\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t// {\n-\t\t// if (creditMemoLine.isDescription())\n-\t\t// {\n-\t\t// continue; // not changing description lines\n-\t\t// }\n-\t\t// final I_C_InvoiceTax invoiceTax = taxId2Invoicetax.get(creditMemoLine.getC_Tax_ID());\n-\t\t// List<I_C_InvoiceLine> linesForInvoiceTax = tax2lines.get(invoiceTax);\n-\t\t// if (linesForInvoiceTax == null)\n-\t\t// {\n-\t\t// linesForInvoiceTax = new ArrayList<>();\n-\t\t// tax2lines.put(invoiceTax, linesForInvoiceTax);\n-\t\t//\n-\t\t// }\n-\t\t// linesForInvoiceTax.add(creditMemoLine);\n-\t\t// }\n-\t\t//\n-\t\t// final Map<I_C_InvoiceLine, BigDecimal> line2newLineGrossAmt = new IdentityHashMap<>();\n-\t\t// for (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t// {\n-\t\t// BigDecimal sumPerTax = BigDecimal.ZERO;\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t// {\n-\t\t// final BigDecimal newLineNetAmt = creditMemoLine.getLineNetAmt().multiply(openfraction);\n-\t\t// final BigDecimal newLineGrossAmt;\n-\t\t// if (invoiceTax.isTaxIncluded())\n-\t\t// {\n-\t\t// newLineGrossAmt = newLineNetAmt.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// newLineGrossAmt = newLineNetAmt\n-\t\t// .multiply(invoiceTax.getC_Tax().getRate()\n-\t\t// .add(Env.ONEHUNDRED)\n-\t\t// .divide(Env.ONEHUNDRED))\n-\t\t// .setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t// }\n-\t\t// line2newLineGrossAmt.put(creditMemoLine, newLineGrossAmt);\n-\t\t// sumPerTax = sumPerTax.add(newLineGrossAmt);\n-\t\t// }\n-\t\t//\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t// {\n-\t\t// final BigDecimal targetSum = newTaxAmounts.get(invoiceTax);\n-\t\t// if (sumPerTax.compareTo(targetSum) == 0)\n-\t\t// {\n-\t\t// break;\n-\t\t// }\n-\t\t// if (sumPerTax.compareTo(targetSum) < 0)\n-\t\t// {\n-\t\t// line2newLineGrossAmt.put(creditMemoLine, line2newLineGrossAmt.get(creditMemoLine).add(smallestAmtInCurrency));\n-\t\t// sumPerTax = sumPerTax.add(smallestAmtInCurrency);\n-\t\t// }\n-\t\t// else\n-\t\t// {\n-\t\t// Check.errorIf(true, \"invoiceTax {} has has targetSum={}, but the credit memo lines for this tax have sumPerTax={} (difference may not be more than {})\",\n-\t\t// invoiceTax, targetSum, sumPerTax, smallestAmtInCurrency);\n-\t\t// }\n-\t\t// }\n-\t\t// }\n-\t\t//\n-\t\t// for (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t// {\n-\t\t// creditMemoLine.setQtyEntered(ONE);\n-\t\t// creditMemoLine.setQtyInvoiced(ONE);\n-\t\t// creditMemoLine.setPriceEntered(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t// creditMemoLine.setPriceActual(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t//\n-\t\t// // 07090: setting priceUOM to 0, because we set the Qty to 1, and the priceUOM only makes sense in the context of the original Qty (but this is a partial-ammount credit memo)\n-\t\t// InterfaceWrapperHelper.create(creditMemoLine, de.metas.adempiere.model.I_C_InvoiceLine.class).setPrice_UOM_ID(0);\n-\t\t//\n-\t\t// InterfaceWrapperHelper.save(creditMemoLine);\n-\t\t// }\n-\t\t//\n-\t\t// // make sure new credit memo grand total is set\n-\t\t// creditMemo.setGrandTotal(creditMemoGrandTotal);\n-\t\t// InterfaceWrapperHelper.save(creditMemo);\n-\n \t}\n \n \tprivate void completeAndAllocateCreditMemo(final de.metas.adempiere.model.I_C_Invoice invoice, final de.metas.adempiere.model.I_C_Invoice creditMemo)\n"}}, {"oid": "45903504c59f8349d770625c00fc7d7e3f1d70b8", "url": "https://github.com/metasfresh/metasfresh/commit/45903504c59f8349d770625c00fc7d7e3f1d70b8", "message": "#6615 delete unneeded code and refactoring warning message\n\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-25T13:53:29Z", "type": "commit"}, {"oid": "49b35739a841f6ac542d095c75703a991b9bc5ee", "url": "https://github.com/metasfresh/metasfresh/commit/49b35739a841f6ac542d095c75703a991b9bc5ee", "message": "#6615 don't assume anything on this level. The user will make they needed changes.\n\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-25T14:26:07Z", "type": "commit"}, {"oid": "35d41eedba207434c3d6e152da673ef1e4bfb109", "url": "https://github.com/metasfresh/metasfresh/commit/35d41eedba207434c3d6e152da673ef1e4bfb109", "message": "#6615 update CreateCreditMemo process description\n\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-25T15:23:55Z", "type": "commit"}, {"oid": "8d2800d36522913ddff31494281b68c38c4c64ee", "url": "https://github.com/metasfresh/metasfresh/commit/8d2800d36522913ddff31494281b68c38c4c64ee", "message": "#6615 Allow the user to allocate as much as they want on a credit memo\n\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-25T15:24:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTY0Mg==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430239642", "bodyText": "What the purpose of this warning?\nI mean, whom is it for? and what shall the recipient do with it?\nI think if we want to make the system more supportable, then debug is enough.\n\"Warn\" messages should imho be actionably", "author": "metas-ts", "createdAt": "2020-05-26T08:24:11Z", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -114,178 +110,24 @@ private void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice in\n \t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n \t\t\treturn;\n \t\t}\n-\n-\t\t// task 08927: we won't be able to re-invoice partial credit memos because we will set the invoiceLines' QtyInvoiced to 1,\n-\t\t// so we won't know the exact qtys to re-invoice.\n-\t\tcreditMemo.setIsCreditedInvoiceReinvoicable(false);\n-\n-\t\t// CreditMemo lines shall be including tax. This makes our life easier further below\n-\t\tcreditMemo.setIsTaxIncluded(true);\n-\n-\t\t// get our currency precision and the smallest possible amount (in most currencies this is 0.01)\n-\t\tfinal CurrencyId currencyId = CurrencyId.ofRepoId(invoice.getC_Currency_ID());\n-\t\tfinal CurrencyPrecision precision = Services.get(ICurrencyDAO.class).getStdPrecision(currencyId);\n-\t\tfinal BigDecimal smallestAmtInCurrency = ONE.setScale(precision.toInt(), RoundingMode.HALF_UP).divide(BigDecimal.TEN.pow(precision.toInt()));\n-\n-\t\t// Compute the factor we can use to get the credit memo amounts from their respective invoice amounts.\n-\t\t// Note that by rounding to \"floor\", the rounded value won't ever be greater than the \"correct\" value\n-\t\tfinal BigDecimal openfraction = openAmt\n-\t\t\t\t// gh #448: make sure to choose openfraction's scale such that it's length after the decimal point (it is generally <=1) is in the same order as the size of the numbers which we divide.\n-\t\t\t\t// this is important to guarantee that the rounding error is not bigger than 'smallestAmtInCurrency'\n-\t\t\t\t.setScale(openAmt.precision() + invoice.getGrandTotal().precision(), BigDecimal.ROUND_HALF_UP)\n-\t\t\t\t.divide(invoice.getGrandTotal(), RoundingMode.FLOOR);\n-\n-\t\tfinal IInvoiceDAO invoicePA = Services.get(IInvoiceDAO.class);\n-\n-\t\t//\n-\t\t// Get the C_InvoiceTax records of 'invoice' taxes, ordered by tax rate, with the biggest tax rate first\n-\t\tfinal List<I_C_InvoiceTax> invoiceTaxes = invoicePA.retrieveTaxes(invoice);\n-\t\tCollections.sort(invoiceTaxes, (o1, o2) -> o1.getC_Tax().getRate().compareTo(o2.getC_Tax().getRate()) * -1);\n-\n-\t\tBigDecimal creditMemoGrandTotal = BigDecimal.ZERO;\n-\t\tfinal Map<I_C_InvoiceTax, BigDecimal> newTaxAmounts = new IdentityHashMap<>();\n-\n-\t\t//\n-\t\t// For every I_C_InvoiceTax of 'invoice', we get the fraction of the tax amount that shall be credited\n-\t\tfinal Map<Integer, I_C_InvoiceTax> taxId2Invoicetax = new HashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tfinal BigDecimal taxGrossAmt = invoiceTax.getTaxBaseAmt().add(invoiceTax.getTaxAmt());\n-\n-\t\t\t// Note that once again, we round to \"floor\", so the rounded value won't be greater than the \"correct\" value\n-\t\t\t// Also note that if 'creditTaxGrossAmt' is less than the \"correct\" value, the difference is never bigger than than 'smallestAmtInCurrency'.\n-\t\t\tfinal BigDecimal creditTaxGrossAmt = taxGrossAmt.multiply(openfraction).setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(creditTaxGrossAmt);\n-\n-\t\t\tnewTaxAmounts.put(invoiceTax, creditTaxGrossAmt);\n-\t\t\ttaxId2Invoicetax.put(invoiceTax.getC_Tax_ID(), invoiceTax);\n-\t\t}\n-\n-\t\t//\n-\t\t// Now we check for rounding errors and correct the amounts if necessary.\n-\t\t// Note that our amounts can't be too big but only too small (by one 'smallestAmt' for each I_C_InvoiceTax).\n-\t\t// Also note that due to the ordering of 'invoiceTaxes' we correct the invoiceTax with the biggest rate first\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) == 0)\n-\t\t\t{\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif (creditMemoGrandTotal.compareTo(openAmt) < 0)\n-\t\t\t{\n-\t\t\t\tnewTaxAmounts.put(invoiceTax,\n-\t\t\t\t\t\tnewTaxAmounts.get(invoiceTax).add(smallestAmtInCurrency));\n-\t\t\t\tcreditMemoGrandTotal = creditMemoGrandTotal.add(smallestAmtInCurrency);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tCheck.errorIf(true, \"On evaluating {}, we have creditMemoGrandTotal={} and openAmt={}\", invoiceTax, creditMemoGrandTotal, openAmt);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// gh #448: in the past this error occurred when openfraction's scale was two low.\n-\t\tCheck.errorIf(creditMemoGrandTotal.compareTo(openAmt) != 0, \"creditMemoGrandTotal={} is different from openAmt={}; openfraction={}\", creditMemoGrandTotal, openAmt, openfraction);\n-\n-\t\t//\n-\t\t// Now that we have computed the tax values where we need to end up with our credit memo,\n-\t\t// We do basically the same on invoice line level. The credit memo lines were copied from the invoice lines, so they still contain the original amounts which we can use\n-\t\tfinal Map<I_C_InvoiceTax, List<I_C_InvoiceLine>> tax2lines = new IdentityHashMap<>();\n-\n-\t\tfinal List<de.metas.adempiere.model.I_C_InvoiceLine> lines = invoicePA.retrieveLines(creditMemo, trxName);\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n-\t\t{\n-\t\t\tif (creditMemoLine.isDescription())\n-\t\t\t{\n-\t\t\t\tcontinue; // not changing description lines\n-\t\t\t}\n-\t\t\tfinal I_C_InvoiceTax invoiceTax = taxId2Invoicetax.get(creditMemoLine.getC_Tax_ID());\n-\t\t\tList<I_C_InvoiceLine> linesForInvoiceTax = tax2lines.get(invoiceTax);\n-\t\t\tif (linesForInvoiceTax == null)\n-\t\t\t{\n-\t\t\t\tlinesForInvoiceTax = new ArrayList<>();\n-\t\t\t\ttax2lines.put(invoiceTax, linesForInvoiceTax);\n-\n-\t\t\t}\n-\t\t\tlinesForInvoiceTax.add(creditMemoLine);\n-\t\t}\n-\n-\t\tfinal Map<I_C_InvoiceLine, BigDecimal> line2newLineGrossAmt = new IdentityHashMap<>();\n-\t\tfor (final I_C_InvoiceTax invoiceTax : invoiceTaxes)\n-\t\t{\n-\t\t\tBigDecimal sumPerTax = BigDecimal.ZERO;\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal newLineNetAmt = creditMemoLine.getLineNetAmt().multiply(openfraction);\n-\t\t\t\tfinal BigDecimal newLineGrossAmt;\n-\t\t\t\tif (invoiceTax.isTaxIncluded())\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tnewLineGrossAmt = newLineNetAmt\n-\t\t\t\t\t\t\t.multiply(invoiceTax.getC_Tax().getRate()\n-\t\t\t\t\t\t\t\t\t.add(Env.ONEHUNDRED)\n-\t\t\t\t\t\t\t\t\t.divide(Env.ONEHUNDRED))\n-\t\t\t\t\t\t\t.setScale(precision.toInt(), RoundingMode.FLOOR);\n-\t\t\t\t}\n-\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, newLineGrossAmt);\n-\t\t\t\tsumPerTax = sumPerTax.add(newLineGrossAmt);\n-\t\t\t}\n-\n-\t\t\tfor (final I_C_InvoiceLine creditMemoLine : tax2lines.get(invoiceTax))\n-\t\t\t{\n-\t\t\t\tfinal BigDecimal targetSum = newTaxAmounts.get(invoiceTax);\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) == 0)\n-\t\t\t\t{\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (sumPerTax.compareTo(targetSum) < 0)\n-\t\t\t\t{\n-\t\t\t\t\tline2newLineGrossAmt.put(creditMemoLine, line2newLineGrossAmt.get(creditMemoLine).add(smallestAmtInCurrency));\n-\t\t\t\t\tsumPerTax = sumPerTax.add(smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tCheck.errorIf(true, \"invoiceTax {} has has targetSum={}, but the credit memo lines for this tax have sumPerTax={} (difference may not be more than {})\",\n-\t\t\t\t\t\t\tinvoiceTax, targetSum, sumPerTax, smallestAmtInCurrency);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (final I_C_InvoiceLine creditMemoLine : lines)\n+\t\telse\n \t\t{\n-\t\t\tcreditMemoLine.setQtyEntered(ONE);\n-\t\t\tcreditMemoLine.setQtyInvoiced(ONE);\n-\t\t\tcreditMemoLine.setPriceEntered(line2newLineGrossAmt.get(creditMemoLine));\n-\t\t\tcreditMemoLine.setPriceActual(line2newLineGrossAmt.get(creditMemoLine));\n-\n-\t\t\t// 07090: setting priceUOM to 0, because we set the Qty to 1, and the priceUOM only makes sense in the context of the original Qty (but this is a partial-ammount credit memo)\n-\t\t\tInterfaceWrapperHelper.create(creditMemoLine, de.metas.adempiere.model.I_C_InvoiceLine.class).setPrice_UOM_ID(0);\n+\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo, invoice);", "originalCommit": "8d2800d36522913ddff31494281b68c38c4c64ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTA4NQ==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430251085", "bodyText": "I dropped de.metas.invoice.service.impl.CreditMemoInvoiceCopyHandler.handlePartialRequests(I_C_Invoice, I_C_Invoice) as discussed.", "author": "metas-rc", "createdAt": "2020-05-26T08:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7c3effcc03d8ba3a11fdb2e289141b56e109cf4a", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\nindex 0dd97b7a71..e23cc53063 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n\n@@ -96,28 +54,6 @@ class CreditMemoInvoiceCopyHandler implements IDocCopyHandler<I_C_Invoice, I_C_I\n \t\treturn CreditMemoInvoiceLineCopyHandler.getInstance();\n \t}\n \n-\t/**\n-\t * Task https://github.com/metasfresh/metasfresh/issues/6615\n-\t * When a credit memo comes after a partial allocation, we no longer do the automatic calculation per lines and taxes,\n-\t * but create a credit memo based on the whole qtys and prices of the invoice and let the user decide what they do next.\n-\t */\n-\tprivate void handlePartialRequests(final de.metas.adempiere.model.I_C_Invoice invoice,\n-\t\t\tfinal de.metas.adempiere.model.I_C_Invoice creditMemo)\n-\t{\n-\t\tfinal BigDecimal allocatedAmt = Services.get(IAllocationDAO.class).retrieveAllocatedAmt(invoice);\n-\t\tif (allocatedAmt == null || allocatedAmt.signum() == 0)\n-\t\t{\n-\t\t\t// skip non-partial lines (a line is partially allocated if the allocated amount is not null or 0)\n-\t\t\treturn;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tlogger.warn(\"The credit memo {} should be a partial allocation of invoice {}.\", creditMemo, invoice);\n-\n-\t\t\treturn;\n-\t\t}\n-\t}\n-\n \tprivate void completeAndAllocateCreditMemo(final de.metas.adempiere.model.I_C_Invoice invoice, final de.metas.adempiere.model.I_C_Invoice creditMemo)\n \t{\n \t\tif (!creditCtx.isCompleteAndAllocate())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTkwNQ==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430239905", "bodyText": "`why do we need this when it's unused? pls remove or add a quick comment to explain", "author": "metas-ts", "createdAt": "2020-05-26T08:24:42Z", "path": "backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java", "diffHunk": "@@ -63,8 +50,12 @@\n {\n \tprivate final InvoiceCreditContext creditCtx;\n \tprivate final BigDecimal openAmt;\n+\n+\t@SuppressWarnings(\"unused\")\n \tprivate final String trxName;", "originalCommit": "8d2800d36522913ddff31494281b68c38c4c64ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI1MTk2NQ==", "url": "https://github.com/metasfresh/metasfresh/pull/6728#discussion_r430251965", "bodyText": "This was added when I thought we should keep the code commented out. And ofc I didn't see it when I deleted the code, because it had a suppress warning \ud83e\udd26\nThanks for finding it. Cleaned up now.", "author": "metas-rc", "createdAt": "2020-05-26T08:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzOTkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3effcc03d8ba3a11fdb2e289141b56e109cf4a", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\nindex 0dd97b7a71..e23cc53063 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/invoice/service/impl/CreditMemoInvoiceCopyHandler.java\n\n@@ -49,21 +20,10 @@ import de.metas.util.Services;\n class CreditMemoInvoiceCopyHandler implements IDocCopyHandler<I_C_Invoice, I_C_InvoiceLine>\n {\n \tprivate final InvoiceCreditContext creditCtx;\n-\tprivate final BigDecimal openAmt;\n-\n-\t@SuppressWarnings(\"unused\")\n-\tprivate final String trxName;\n-\n-\tprivate static final transient Logger logger = LogManager.getLogger(CreditMemoInvoiceCopyHandler.class);\n \n-\tpublic CreditMemoInvoiceCopyHandler(final Properties ctx,\n-\t\t\tfinal InvoiceCreditContext creditCtx,\n-\t\t\tfinal BigDecimal openAmt,\n-\t\t\tfinal String trxName)\n+\tpublic CreditMemoInvoiceCopyHandler(final InvoiceCreditContext creditCtx)\n \t{\n \t\tthis.creditCtx = creditCtx;\n-\t\tthis.openAmt = openAmt;\n-\t\tthis.trxName = trxName;\n \t}\n \n \t@Override\n"}}, {"oid": "7c3effcc03d8ba3a11fdb2e289141b56e109cf4a", "url": "https://github.com/metasfresh/metasfresh/commit/7c3effcc03d8ba3a11fdb2e289141b56e109cf4a", "message": "#6615 Cleanup the code.\n\n* The old partial credit memo handling is no longer needed so we decided to drop it completely, not keep it for docu purposes.\nhttps://github.com/metasfresh/metasfresh/issues/6615", "committedDate": "2020-05-26T08:41:29Z", "type": "commit"}]}