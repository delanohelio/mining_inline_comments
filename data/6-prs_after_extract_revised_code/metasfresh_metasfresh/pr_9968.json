{"pr_number": 9968, "pr_title": "Fix wrong Org for ProductPlanning when created from ProductPlanningSchema", "pr_createdAt": "2020-09-18T05:57:14Z", "pr_url": "https://github.com/metasfresh/metasfresh/pull/9968", "timeline": [{"oid": "b55bbcf865c17da39e71f0a5c11ec620520d65da", "url": "https://github.com/metasfresh/metasfresh/commit/b55bbcf865c17da39e71f0a5c11ec620520d65da", "message": "Fix wrong Org for ProductPlanning when created from ProductPlanningSchema\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-18T05:53:54Z", "type": "commit"}, {"oid": "163afedbb41d01d8b1f5251803bca2ae46bd39f5", "url": "https://github.com/metasfresh/metasfresh/commit/163afedbb41d01d8b1f5251803bca2ae46bd39f5", "message": "Deduplicate ProductPlanningSchemas faster\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-18T06:13:01Z", "type": "commit"}, {"oid": "eea0dc6b364d1c45bfdc41837136ecbd9d50a037", "url": "https://github.com/metasfresh/metasfresh/commit/eea0dc6b364d1c45bfdc41837136ecbd9d50a037", "message": "Update TRL\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-18T10:43:57Z", "type": "commit"}, {"oid": "a3f7f1987eaf6b846d940827120cc798dd958b7e", "url": "https://github.com/metasfresh/metasfresh/commit/a3f7f1987eaf6b846d940827120cc798dd958b7e", "message": "Add explanation for junit\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-18T11:08:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1ODI4NA==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490858284", "bodyText": "it's not a great deal, just asking; do you know if we can't teach intellij to put the annotations before the final?", "author": "metas-ts", "createdAt": "2020-09-18T10:38:22Z", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaBL.java", "diffHunk": "@@ -61,28 +65,30 @@\n \t\t\t\t.collect(ImmutableList.toImmutableList());\n \t}\n \n-\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(final I_M_Product product)\n+\tprivate List<I_PP_Product_Planning> createOrUpdateProductPlanningsForProductSelector(@NonNull final I_M_Product product)\n \t{\n \t\tfinal ProductId productId = ProductId.ofRepoId(product.getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(product.getAD_Org_ID());\n \t\tfinal ProductPlanningSchemaSelector selector = ProductPlanningSchemaSelector.ofNullableCode(product.getM_ProductPlanningSchema_Selector());\n \t\tif (selector == null)\n \t\t{\n \t\t\treturn ImmutableList.of();\n \t\t}\n \n-\t\treturn createOrUpdateProductPlanningsForSelector(productId, selector);\n+\t\treturn createOrUpdateProductPlanningsForSelector(productId, orgId, selector);\n \t}\n \n \t@Override\n \tpublic List<I_PP_Product_Planning> createOrUpdateProductPlanningsForSelector(\n-\t\t\t@NonNull final ProductId productId,\n-\t\t\t@NonNull final ProductPlanningSchemaSelector selector)\n+\t\t\tfinal @NonNull ProductId productId,", "originalCommit": "163afedbb41d01d8b1f5251803bca2ae46bd39f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NzM5MA==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490877390", "bodyText": "unfortunately not available, but there is a feature request (with duplicates): https://youtrack.jetbrains.com/issue/IDEA-168035", "author": "TheBestPessimist", "createdAt": "2020-09-18T11:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg1ODI4NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490876925", "bodyText": "i would suggest to extract that code in an model interceptor.\nAs a side benefit we will not wire\"private final IProductPlanningSchemaBL productPlanningSchemaBL\"  service each time a product is loaded.", "author": "teosarca", "createdAt": "2020-09-18T11:15:40Z", "path": "backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java", "diffHunk": "@@ -335,9 +342,9 @@ private void createOrUpdateProductPlanningsForSelector()\n \t\t}\n \t\t\n \t\tfinal ProductId productId = ProductId.ofRepoId(getM_Product_ID());\n+\t\tfinal OrgId orgId = OrgId.ofRepoId(getAD_Org_ID());\n \n-\t\tfinal IProductPlanningSchemaBL productPlanningSchemaBL = Services.get(IProductPlanningSchemaBL.class);\n-\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, productPlanningSchemaSelector);\n+\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, orgId, productPlanningSchemaSelector);", "originalCommit": "a3f7f1987eaf6b846d940827120cc798dd958b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3ODgwNQ==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490878805", "bodyText": "This code is called only once after the product was created, afaiu from\n\t@Override\n    protected boolean MProduct.afterSave(boolean newRecord, boolean success) {\n    [...]\n\tif(newRecord)\n\t\t{\n\t\t\tcreateOrUpdateProductPlanningsForSelector();\n\t\t}\nso isnt' this already in Product's model interceptor?\n\nAs a side benefit we will not wire\"private final IProductPlanningSchemaBL productPlanningSchemaBL\" service each time a product is loaded.\n\nShould i make productPlanningSchemaBL local to the function instead of a class field?", "author": "TheBestPessimist", "createdAt": "2020-09-18T11:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4NTYwNA==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491885604", "bodyText": "done", "author": "TheBestPessimist", "createdAt": "2020-09-21T08:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjkyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b9077ab87fd898dfb3a66dad16c68196edd1c233", "chunk": "diff --git a/backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java b/backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java\nindex c626ab2f5a..665d0e9c42 100644\n--- a/backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java\n+++ b/backend/de.metas.business/src/main/java-legacy/org/compiere/model/MProduct.java\n\n@@ -325,27 +321,9 @@ public class MProduct extends X_M_Product\n \t\t\tinsert_Tree(X_AD_Tree.TREETYPE_Product);\n \t\t}\n \t\t\n-\t\tif(newRecord)\n-\t\t{\n-\t\t\tcreateOrUpdateProductPlanningsForSelector();\n-\t\t}\n-\n \t\treturn true;\n \t}\t// afterSave\n \t\n-\tprivate void createOrUpdateProductPlanningsForSelector()\n-\t{\n-\t\tfinal ProductPlanningSchemaSelector productPlanningSchemaSelector = ProductPlanningSchemaSelector.ofNullableCode(getM_ProductPlanningSchema_Selector());\n-\t\tif (productPlanningSchemaSelector == null)\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n-\t\t\n-\t\tfinal ProductId productId = ProductId.ofRepoId(getM_Product_ID());\n-\t\tfinal OrgId orgId = OrgId.ofRepoId(getAD_Org_ID());\n-\n-\t\tproductPlanningSchemaBL.createOrUpdateProductPlanningsForSelector(productId, orgId, productPlanningSchemaSelector);\n-\t}\n \n \t@Override\n \tprotected boolean beforeDelete()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490882053", "bodyText": "this is too fragile IMHO", "author": "teosarca", "createdAt": "2020-09-18T11:25:52Z", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -70,23 +80,82 @@ public static ProductPlanningSchema getById(@NonNull final ProductPlanningSchema\n \t}\n \n \t/**\n-\t * @return All the active Product Planning Schema entries with the given Product Planning Schema Selector\n+\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org. If the org does not match, fallback to org *.\n+\t * If there are 2 identical Product Planning Schemas, one for orgParam and one for *, we shall return only the one for orgParam.\n \t */\n-\tpublic static List<ProductPlanningSchema> retrieveSchemasForSelector(\n-\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector)\n+\t@NonNull\n+\tpublic static ImmutableSet<ProductPlanningSchema> retrieveSchemasForSelectorAndOrg(\n+\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector,\n+\t\t\t@NonNull final OrgId orgId)\n \t{\n-\t\treturn Services.get(IQueryBL.class)\n+\t\tfinal ImmutableMap<ProductPlanningSchemaId, ProductPlanningSchema> schemasWithDuplicateOrgs = Services.get(IQueryBL.class)\n \t\t\t\t.createQueryBuilder(I_M_Product_PlanningSchema.class)\n \t\t\t\t.addOnlyActiveRecordsFilter()\n \t\t\t\t.addOnlyContextClient()\n \t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n+\t\t\t\t.addInArrayFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId, OrgId.ANY)\n \t\t\t\t.create()\n+\t\t\t\t.list()\n \t\t\t\t.stream()\n-\t\t\t\t.map(record -> toProductPlanningSchema(record))\n-\t\t\t\t.collect(ImmutableList.toImmutableList());\n+\t\t\t\t.map(ProductPlanningSchemaDAO::toProductPlanningSchema)\n+\t\t\t\t.collect(ImmutableMap.toImmutableMap(ProductPlanningSchema::getId, Function.identity()));\n+\n+\t\t// remove duplicates where everything is the same, except the org, and repoId\n+\t\t// Technical: I am using the set.add property that if an object already exists in a set, the duplicate will not be inserted but skipped.\n+\t\tfinal Set<ProductPlanningSchemaIgnoringOrgAndId> schemasNoDuplicateOrgs = schemasWithDuplicateOrgs.values().stream()\n+\t\t\t\t.sorted(Comparator.comparing(ProductPlanningSchema::getOrgId).reversed()) // * org remains last\n+\t\t\t\t.map(ProductPlanningSchemaIgnoringOrgAndId::new)\n+\t\t\t\t.collect(GuavaCollectors.toImmutableSet());\n+\n+\t\tfinal ImmutableSet.Builder<ProductPlanningSchema> result = ImmutableSet.builder();\n+\t\tfor (final ProductPlanningSchemaIgnoringOrgAndId s : schemasNoDuplicateOrgs)\n+\t\t{\n+\t\t\tresult.add(schemasWithDuplicateOrgs.get(s.getSchema().getId()));\n+\t\t}\n+\n+\t\treturn result.build();\n \t}\n \n-\tprivate static ProductPlanningSchema toProductPlanningSchema(final I_M_Product_PlanningSchema record)\n+\t/**\n+\t * Used as a delegate to ProductPlanningSchema, to calculate if 2 schemas are equals, ignoring only their ID and Org\n+\t */\n+\n+\t@Value\n+\tprivate static class ProductPlanningSchemaIgnoringOrgAndId\n+\t{\n+\t\tProductPlanningSchema schema;\n+\n+\t\t@Override\n+\t\tpublic boolean equals(final Object o)", "originalCommit": "a3f7f1987eaf6b846d940827120cc798dd958b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkwNDYwOQ==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490904609", "bodyText": "what do you mean? Why is it fragile?", "author": "TheBestPessimist", "createdAt": "2020-09-18T12:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk1MTczNA==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491951734", "bodyText": "updated after functional change.", "author": "TheBestPessimist", "createdAt": "2020-09-21T10:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg4MjA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "66b9c24865a45bd7b2382e8a3d4f73af29c69912", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java b/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\nindex a1888dd21a..ed3f4176cb 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\n\n@@ -80,78 +83,24 @@ final class ProductPlanningSchemaDAO\n \t}\n \n \t/**\n-\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org. If the org does not match, fallback to org *.\n-\t * If there are 2 identical Product Planning Schemas, one for orgParam and one for *, we shall return only the one for orgParam.\n+\t * Returns the Product Planning Schema entries with the given Product Planning Schema Selector and Org.\n \t */\n \t@NonNull\n \tpublic static ImmutableSet<ProductPlanningSchema> retrieveSchemasForSelectorAndOrg(\n \t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector,\n \t\t\t@NonNull final OrgId orgId)\n \t{\n-\t\tfinal ImmutableMap<ProductPlanningSchemaId, ProductPlanningSchema> schemasWithDuplicateOrgs = Services.get(IQueryBL.class)\n+\t\treturn queryBL\n \t\t\t\t.createQueryBuilder(I_M_Product_PlanningSchema.class)\n \t\t\t\t.addOnlyActiveRecordsFilter()\n \t\t\t\t.addOnlyContextClient()\n \t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n-\t\t\t\t.addInArrayFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId, OrgId.ANY)\n+\t\t\t\t.addEqualsFilter(I_M_Product_PlanningSchema.COLUMNNAME_AD_Org_ID, orgId)\n \t\t\t\t.create()\n \t\t\t\t.list()\n \t\t\t\t.stream()\n \t\t\t\t.map(ProductPlanningSchemaDAO::toProductPlanningSchema)\n-\t\t\t\t.collect(ImmutableMap.toImmutableMap(ProductPlanningSchema::getId, Function.identity()));\n-\n-\t\t// remove duplicates where everything is the same, except the org, and repoId\n-\t\t// Technical: I am using the set.add property that if an object already exists in a set, the duplicate will not be inserted but skipped.\n-\t\tfinal Set<ProductPlanningSchemaIgnoringOrgAndId> schemasNoDuplicateOrgs = schemasWithDuplicateOrgs.values().stream()\n-\t\t\t\t.sorted(Comparator.comparing(ProductPlanningSchema::getOrgId).reversed()) // * org remains last\n-\t\t\t\t.map(ProductPlanningSchemaIgnoringOrgAndId::new)\n-\t\t\t\t.collect(GuavaCollectors.toImmutableSet());\n-\n-\t\tfinal ImmutableSet.Builder<ProductPlanningSchema> result = ImmutableSet.builder();\n-\t\tfor (final ProductPlanningSchemaIgnoringOrgAndId s : schemasNoDuplicateOrgs)\n-\t\t{\n-\t\t\tresult.add(schemasWithDuplicateOrgs.get(s.getSchema().getId()));\n-\t\t}\n-\n-\t\treturn result.build();\n-\t}\n-\n-\t/**\n-\t * Used as a delegate to ProductPlanningSchema, to calculate if 2 schemas are equals, ignoring only their ID and Org\n-\t */\n-\n-\t@Value\n-\tprivate static class ProductPlanningSchemaIgnoringOrgAndId\n-\t{\n-\t\tProductPlanningSchema schema;\n-\n-\t\t@Override\n-\t\tpublic boolean equals(final Object o)\n-\t\t{\n-\t\t\tif (schema == o)\n-\t\t\t\treturn true;\n-\t\t\tif (o == null || getClass() != o.getClass())\n-\t\t\t\treturn false;\n-\t\t\tfinal ProductPlanningSchema that = ((ProductPlanningSchemaIgnoringOrgAndId)o).getSchema();\n-\t\t\treturn schema.isAttributeDependant() == that.isAttributeDependant() &&\n-\t\t\t\t\tschema.isCreatePlan() == that.isCreatePlan() &&\n-\t\t\t\t\tschema.isCompleteGeneratedDocuments() == that.isCompleteGeneratedDocuments() &&\n-\t\t\t\t\tschema.isPickDirectlyIfFeasible() == that.isPickDirectlyIfFeasible() &&\n-\t\t\t\t\tschema.getSelector() == that.getSelector() &&\n-\t\t\t\t\tObjects.equals(schema.getPlantId(), that.getPlantId()) &&\n-\t\t\t\t\tObjects.equals(schema.getWarehouseId(), that.getWarehouseId()) &&\n-\t\t\t\t\tObjects.equals(schema.getPlannerId(), that.getPlannerId()) &&\n-\t\t\t\t\tObjects.equals(schema.getManufactured(), that.getManufactured()) &&\n-\t\t\t\t\tObjects.equals(schema.getRoutingId(), that.getRoutingId()) &&\n-\t\t\t\t\tObjects.equals(schema.getDistributionNetworkId(), that.getDistributionNetworkId()) &&\n-\t\t\t\t\tschema.getOnMaterialReceiptWithDestWarehouse() == that.getOnMaterialReceiptWithDestWarehouse();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int hashCode()\n-\t\t{\n-\t\t\treturn Objects.hash(schema.getSelector(), schema.getPlantId(), schema.getWarehouseId(), schema.isAttributeDependant(), schema.getPlannerId(), schema.getManufactured(), schema.isCreatePlan(), schema.isCompleteGeneratedDocuments(), schema.isPickDirectlyIfFeasible(), schema.getRoutingId(), schema.getDistributionNetworkId(), schema.getOnMaterialReceiptWithDestWarehouse());\n-\t\t}\n+\t\t\t\t.collect(ImmutableSet.toImmutableSet());\n \t}\n \n \t@NonNull\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxMDE0Mg==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r490910142", "bodyText": "consider moving this method to ProductDAO", "author": "teosarca", "createdAt": "2020-09-18T12:19:41Z", "path": "backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java", "diffHunk": "@@ -154,7 +223,7 @@ public static void save(@NonNull final ProductPlanningSchema schema)\n \t/**\n \t * @return All the active products with the given product planning schema selector\n \t */\n-\tpublic static Set<ProductId> retrieveProductIdsForSchemaSelector(\n+\tpublic static Set<ImmutablePair<ProductId, OrgId>> retrieveProductIdsForSchemaSelector(", "originalCommit": "a3f7f1987eaf6b846d940827120cc798dd958b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4MDUyNA==", "url": "https://github.com/metasfresh/metasfresh/pull/9968#discussion_r491880524", "bodyText": "done", "author": "TheBestPessimist", "createdAt": "2020-09-21T08:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxMDE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4b3cefd25578442f968f3a6402ac0daf9357c8bb", "chunk": "diff --git a/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java b/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\nindex a1888dd21a..eb63b8eb6d 100644\n--- a/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\n+++ b/backend/de.metas.business/src/main/java/de/metas/product/impl/ProductPlanningSchemaDAO.java\n\n@@ -220,28 +220,6 @@ final class ProductPlanningSchemaDAO\n \t\t\t\t.list();\n \t}\n \n-\t/**\n-\t * @return All the active products with the given product planning schema selector\n-\t */\n-\tpublic static Set<ImmutablePair<ProductId, OrgId>> retrieveProductIdsForSchemaSelector(\n-\t\t\t@NonNull final ProductPlanningSchemaSelector productPlanningSchemaSelector)\n-\t{\n-\t\treturn Services.get(IQueryBL.class)\n-\t\t\t\t.createQueryBuilder(I_M_Product.class)\n-\t\t\t\t.addOnlyActiveRecordsFilter()\n-\t\t\t\t.addOnlyContextClient()\n-\t\t\t\t.addEqualsFilter(I_M_Product.COLUMNNAME_M_ProductPlanningSchema_Selector, productPlanningSchemaSelector)\n-\t\t\t\t.create()\n-\t\t\t\t.listColumns(I_M_Product.COLUMNNAME_M_Product_ID, I_M_Product.COLUMNNAME_AD_Org_ID)\n-\t\t\t\t.stream()\n-\t\t\t\t.map(pair -> {\n-\t\t\t\t\tfinal ProductId productId = ProductId.ofRepoId((int)pair.get(I_M_Product.COLUMNNAME_M_Product_ID));\n-\t\t\t\t\tfinal OrgId orgId = OrgId.ofRepoId((int)pair.get(I_M_Product.COLUMNNAME_AD_Org_ID));\n-\t\t\t\t\treturn ImmutablePair.of(productId, orgId);\n-\t\t\t\t})\n-\t\t\t\t.collect(Collectors.toSet());\n-\t}\n-\n \t/**\n \t * @return the product planning for the given product and schema if found, null otherwise.\n \t */\n"}}, {"oid": "4b3cefd25578442f968f3a6402ac0daf9357c8bb", "url": "https://github.com/metasfresh/metasfresh/commit/4b3cefd25578442f968f3a6402ac0daf9357c8bb", "message": "Refactoring\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T08:48:04Z", "type": "commit"}, {"oid": "b9077ab87fd898dfb3a66dad16c68196edd1c233", "url": "https://github.com/metasfresh/metasfresh/commit/b9077ab87fd898dfb3a66dad16c68196edd1c233", "message": "Refactoring: extract method to own interceptor\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:04:11Z", "type": "commit"}, {"oid": "66b9c24865a45bd7b2382e8a3d4f73af29c69912", "url": "https://github.com/metasfresh/metasfresh/commit/66b9c24865a45bd7b2382e8a3d4f73af29c69912", "message": "Create Product Plans for the current org only.\n\nProductPlanningSchema for org * is removed.\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:07:50Z", "type": "commit"}, {"oid": "a61c49515d42fbed83512a164e12562ebf8677cd", "url": "https://github.com/metasfresh/metasfresh/commit/a61c49515d42fbed83512a164e12562ebf8677cd", "message": "Extract OrgId to field\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:13:54Z", "type": "commit"}, {"oid": "a096cf99438e711a14b1a5f6efc626b95ca4360b", "url": "https://github.com/metasfresh/metasfresh/commit/a096cf99438e711a14b1a5f6efc626b95ca4360b", "message": "Update Junit test\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:36:19Z", "type": "commit"}, {"oid": "807b32983e4c86d7cbfd9e3f497d53da4c7d3062", "url": "https://github.com/metasfresh/metasfresh/commit/807b32983e4c86d7cbfd9e3f497d53da4c7d3062", "message": "Change the org of the ProductPlanningSchema - no longer use *\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:42:46Z", "type": "commit"}, {"oid": "c3c265f1539aa43f455ea156b38b49577d0a703d", "url": "https://github.com/metasfresh/metasfresh/commit/c3c265f1539aa43f455ea156b38b49577d0a703d", "message": "This sql looks better\n\nhttps://github.com/metasfresh/metasfresh/issues/9958", "committedDate": "2020-09-21T10:58:15Z", "type": "commit"}]}