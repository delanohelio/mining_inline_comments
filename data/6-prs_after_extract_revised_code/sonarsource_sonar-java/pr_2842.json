{"pr_number": 2842, "pr_title": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "pr_createdAt": "2020-02-24T17:07:23Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2842", "timeline": [{"oid": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "url": "https://github.com/SonarSource/sonar-java/commit/fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "message": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "committedDate": "2020-02-25T09:21:40Z", "type": "commit"}, {"oid": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "url": "https://github.com/SonarSource/sonar-java/commit/fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "message": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "committedDate": "2020-02-25T09:21:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwOTkxMg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383809912", "bodyText": "We should support the sticky bit, setguid, setuid. Those bits are set using ocal 4 digits:\nruntime.exec(\"chmod 1770 file.json\"); // FP\nruntime.exec(\"chmod 3770 file.json\"); // FP\nruntime.exec(\"chmod 0770 file.json\"); // FP\n\nWe should only consider an isolated octal number:\nruntime.exec(\"chmod 770 file111.json\"); // FP\n\nThis a proposal:\n\"(^|\\\\s)[0-7]{2,3}[1-7](\\\\s|$)\"", "author": "alban-auzeill", "createdAt": "2020-02-25T11:03:49Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex d94f3a836..eef98d0df 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -22,14 +22,17 @@ package org.sonar.java.checks.security;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.sonar.check.Rule;\n import org.sonar.java.matcher.MethodMatcher;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Type;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewArrayTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S2612\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzNDM3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383834370", "bodyText": "the command could be chmod or /bin/chmod", "author": "alban-auzeill", "createdAt": "2020-02-25T11:57:08Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {\n+      reportIssue(identifier, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private static boolean isPosixPermission(IdentifierTree identifier) {\n+    return POSIX_OTHER_PERMISSIONS.contains(identifier.name())\n+      && identifier.symbolType().isSubtypeOf(\"java.nio.file.attribute.PosixFilePermission\");\n+  }\n+\n+  private static boolean isBeingRemoved(IdentifierTree identifier) {\n+    Tree parent = identifier.parent();\n+    while (parent != null) {\n+      // Whatever the owner of \"remove\", we assume the property is dropped if calling a method \"remove\"\n+      // (implemented by all classes extending Collection)\n+      if (parent.is(Tree.Kind.METHOD_INVOCATION) && ((MethodInvocationTree) parent).symbol().name().contains(\"remove\")) {\n+        return true;\n+      }\n+      parent = parent.parent();\n+    }\n+    return false;\n+  }\n+\n+  private void check(MethodInvocationTree mit) {\n+    if (POSIX_FILE_PERMISSIONS_FROM_STRING.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (sensitivePermissionsAsString(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    } else if (RUNTIME_EXEC.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (arg0.symbolType().is(JAVA_LANG_STRING) && sensitiveChmodCommand(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(chmod -> chmod.length() == 9)\n+      .filter(chmod -> !chmod.endsWith(\"---\"))\n+      .isPresent();\n+  }\n+\n+  private static boolean sensitiveChmodCommand(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(cmd -> cmd.trim().startsWith(\"chmod\"))", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex d94f3a836..eef98d0df 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -22,14 +22,17 @@ package org.sonar.java.checks.security;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.sonar.check.Rule;\n import org.sonar.java.matcher.MethodMatcher;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Type;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewArrayTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S2612\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NjcxOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383846719", "bodyText": "The exec method accepts a string array in order to separate the command from the arguments, the correct form should be:\nruntime.exec(new String[] {\"chmod\", \"777\", \"file.json\"});\n\nI think that putting a hardcoded filename is a corner case. In real-life examples, I don't expect to see the above example or this one:\nruntime.exec(\"chmod 777 file.json\");\n\nUsually the file name is a variable, and developers probablly use this form:\nruntime.exec(new String[] {\"chmod\", \"777\", filename});\nruntime.exec(new String[] {\"/bin/chmod\", \"--recursive\", \"777\", filename});\n\nLike in those CVEs: Recent Java exploitation trends and malware\nAnd if we want to support exec with a string argument, It should probably be this form:\nruntime.exec(\"chmod 777 \\\"\" + filename + \"\\\"\");", "author": "alban-auzeill", "createdAt": "2020-02-25T12:25:09Z", "path": "java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package checks.security;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class FilePermissionsCheck {\n+\n+  // using PosixFilePermission to set file permissions 757\n+  public void setPermissions(Path filePath) throws Exception {\n+\n+    Set<PosixFilePermission> perms = new HashSet<>();\n+    // user permission\n+    perms.add(PosixFilePermission.OWNER_READ);\n+    perms.add(PosixFilePermission.OWNER_WRITE);\n+    perms.add(PosixFilePermission.OWNER_EXECUTE);\n+    // group permissions\n+    perms.add(PosixFilePermission.GROUP_READ);\n+    perms.add(PosixFilePermission.GROUP_EXECUTE);\n+    // others permissions\n+    perms.add(PosixFilePermission.OTHERS_READ); // Noncompliant {{Make sure this permission is safe.}}\n+    perms.add(PosixFilePermission.OTHERS_WRITE); // Noncompliant\n+    perms.add(PosixFilePermission.OTHERS_EXECUTE); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, perms);\n+\n+    System.out.println(MyEnum.OTHERS_EXECUTE);\n+  }\n+\n+  public void setPermissionsFromString(Path filePath, String permissions) throws Exception {\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(permissions)); // Compliant: because we can't say something about the content of 'permissions'\n+  }\n+\n+  public void setOthersPermissionsHardCoded(Path filePath) throws Exception {\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx---\")); // Compliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxr--\")); // Noncompliant [[sc=77;ec=88]] {{Make sure this permission is safe.}}\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx-w-\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx--x\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrw-\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxr-x\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx-wx\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrwx\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"invalid\")); // Compliant\n+  }\n+\n+  public void setPermissionsUsingRuntimeExec(Runtime runtime) throws Exception {\n+    runtime.exec(\"chmod 777 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 775 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 774 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 771 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 770 file.json\"); // Compliant\n+\n+    runtime.exec(\"chmod 770 777 file1.json file2.json\"); // Noncompliant\n+\n+    runtime.exec(\"chmod 777 file.json\", new String[] {}); // Noncompliant\n+    runtime.exec(\"chmod 777 file.json\", new String[] {}, new File(\"\")); // Noncompliant\n+\n+    runtime.exec(\"chmod o+w file.json\"); // Noncompliant\n+    runtime.exec(\"chmod o=rwx file.json\"); // Noncompliant\n+    runtime.exec(\"chmod o-rwx file.json\"); // Compliant\n+\n+    runtime.exec(\"mvn clean install\"); // Compliant\n+    runtime.exec(new String[] {\"mvn clean install\"}); // Compliant\n+    runtime.exec(new String[] {\"chmod 777 file.json\"}); // FN - not considering arrays", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java b/java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java\nindex 232528617..6ed6d4f1d 100644\n--- a/java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java\n\n@@ -51,25 +51,39 @@ class FilePermissionsCheck {\n     Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"invalid\")); // Compliant\n   }\n \n-  public void setPermissionsUsingRuntimeExec(Runtime runtime) throws Exception {\n+  public void setPermissionsUsingRuntimeExec(Runtime runtime, String filename, String[] args) throws Exception {\n     runtime.exec(\"chmod 777 file.json\"); // Noncompliant\n     runtime.exec(\"chmod 775 file.json\"); // Noncompliant\n     runtime.exec(\"chmod 774 file.json\"); // Noncompliant\n     runtime.exec(\"chmod 771 file.json\"); // Noncompliant\n     runtime.exec(\"chmod 770 file.json\"); // Compliant\n+    runtime.exec(\"chmod 1770 file.json\"); // Compliant - using sticky bit\n \n     runtime.exec(\"chmod 770 777 file1.json file2.json\"); // Noncompliant\n \n-    runtime.exec(\"chmod 777 file.json\", new String[] {}); // Noncompliant\n+    runtime.exec(\"/bin/chmod 777 file.json\", new String[] {}); // Noncompliant\n     runtime.exec(\"chmod 777 file.json\", new String[] {}, new File(\"\")); // Noncompliant\n \n     runtime.exec(\"chmod o+w file.json\"); // Noncompliant\n     runtime.exec(\"chmod o=rwx file.json\"); // Noncompliant\n     runtime.exec(\"chmod o-rwx file.json\"); // Compliant\n+    runtime.exec(\"chmod +w file.json\"); // Noncompliant\n+    runtime.exec(\"chmod a+w file.json\"); // Noncompliant\n+    runtime.exec(\"chmod =rwx file.json\"); // Noncompliant\n+    runtime.exec(\"chmod u=rwx,g=rx,o=r file.json\"); // Noncompliant\n \n     runtime.exec(\"mvn clean install\"); // Compliant\n-    runtime.exec(new String[] {\"mvn clean install\"}); // Compliant\n-    runtime.exec(new String[] {\"chmod 777 file.json\"}); // FN - not considering arrays\n+    runtime.exec(new String[] {\"mvn\", \"clean\", \"install\"}); // Compliant\n+    runtime.exec(new String[] {\"mvn\", \"sonar:sonar\"}); // Compliant\n+\n+    runtime.exec(new String[] {\"chmod\", \"777\", filename}); // Noncompliant\n+    runtime.exec(new String[] {\"chmod\", \"770\", filename}); // Compliant\n+    runtime.exec(new String[] {\"/bin/chmod\", \"--recursive\", \"777\", filename}); // Noncompliant\n+    runtime.exec(new String[] {\"/bin/chmod\", \"--R\", \"770\", filename}); // Compliant\n+\n+    runtime.exec(new String[] {\"/bin/chmod\", \"--recursive\", filename}); // Compliant - malformed chmod\n+\n+    runtime.exec(args); // Compliant\n   }\n \n   public void setPermissionsSafe(Path filePath) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MjAyNg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383862026", "bodyText": "o means others and a means all (including others), this is a false-negative:\nchmod a+rwx file.json\n\no is not always after u g a, this is a false-negative:\nchmod ou+r file.json\n\nAnd unfortunalty, u g o a are optional, and the default value is all, this is a false-negative:\nchmod +rwx file.json\n\nThis a proposal:\n\"(^|\\\\s|,)([ug]*+[ao][ugao]*+)?[+=][sStT]*+[rwxX][rwxXsStT]*+(\\\\s|,|$)\"\n\nAnd some noncompliant examples:\n    runtime.exec(\"chmod +w file.json\"); // Noncompliant\n    runtime.exec(\"chmod a+w file.json\"); // Noncompliant\n    runtime.exec(\"chmod =rwx file.json\"); // Noncompliant\n    runtime.exec(\"chmod u=rwx,g=rx,o=r file.json\"); // Noncompliant", "author": "alban-auzeill", "createdAt": "2020-02-25T12:58:26Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex d94f3a836..eef98d0df 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -22,14 +22,17 @@ package org.sonar.java.checks.security;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.sonar.check.Rule;\n import org.sonar.java.matcher.MethodMatcher;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Type;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewArrayTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S2612\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NTUyMA==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383865520", "bodyText": "I would prefer is being added instead of is being removed, we could have some FN but not this kind of FP:\n    Set<PosixFilePermission> posixFilePermissions = Files.getPosixFilePermissions(filePath);\n    if (posixFilePermissions.contains(PosixFilePermission.OTHERS_READ)) { // false-positive\n      // ...\n    }", "author": "alban-auzeill", "createdAt": "2020-02-25T13:05:31Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex d94f3a836..eef98d0df 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -22,14 +22,17 @@ package org.sonar.java.checks.security;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.sonar.check.Rule;\n import org.sonar.java.matcher.MethodMatcher;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Type;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewArrayTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S2612\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzIzNg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383867236", "bodyText": "Nice and easy way to test: chmod.endsWith(\"---\") (you see, from time to time I could agree...\ud83d\ude09)", "author": "alban-auzeill", "createdAt": "2020-02-25T13:09:11Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {\n+      reportIssue(identifier, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private static boolean isPosixPermission(IdentifierTree identifier) {\n+    return POSIX_OTHER_PERMISSIONS.contains(identifier.name())\n+      && identifier.symbolType().isSubtypeOf(\"java.nio.file.attribute.PosixFilePermission\");\n+  }\n+\n+  private static boolean isBeingRemoved(IdentifierTree identifier) {\n+    Tree parent = identifier.parent();\n+    while (parent != null) {\n+      // Whatever the owner of \"remove\", we assume the property is dropped if calling a method \"remove\"\n+      // (implemented by all classes extending Collection)\n+      if (parent.is(Tree.Kind.METHOD_INVOCATION) && ((MethodInvocationTree) parent).symbol().name().contains(\"remove\")) {\n+        return true;\n+      }\n+      parent = parent.parent();\n+    }\n+    return false;\n+  }\n+\n+  private void check(MethodInvocationTree mit) {\n+    if (POSIX_FILE_PERMISSIONS_FROM_STRING.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (sensitivePermissionsAsString(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    } else if (RUNTIME_EXEC.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (arg0.symbolType().is(JAVA_LANG_STRING) && sensitiveChmodCommand(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(chmod -> chmod.length() == 9)\n+      .filter(chmod -> !chmod.endsWith(\"---\"))", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "744778ff55ddade59a886ec538efa02d417fef42", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex d94f3a836..eef98d0df 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -22,14 +22,17 @@ package org.sonar.java.checks.security;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.regex.Pattern;\n import org.sonar.check.Rule;\n import org.sonar.java.matcher.MethodMatcher;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Type;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewArrayTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S2612\")\n"}}, {"oid": "744778ff55ddade59a886ec538efa02d417fef42", "url": "https://github.com/SonarSource/sonar-java/commit/744778ff55ddade59a886ec538efa02d417fef42", "message": "fix from review", "committedDate": "2020-02-25T16:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyOTcyOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r384029729", "bodyText": "--recursive is just one of the possible options that can be pass to chmod, but there are others and multiple options can be passed.\nNo need to know at which index is the mode argument, we can safely test isSensisitiveChmodMode on all the initializers list (skipping first).", "author": "alban-auzeill", "createdAt": "2020-02-25T17:45:46Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -112,10 +122,43 @@ private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n       .isPresent();\n   }\n \n-  private static boolean sensitiveChmodCommand(ExpressionTree arg0) {\n-    return arg0.asConstant(String.class)\n-      .filter(cmd -> cmd.trim().startsWith(\"chmod\"))\n-      .filter(cmd -> CHMOD_OCTAL_PATTERN.matcher(cmd).find() || SIMPLIFIED_CHMOD_OTHER_PATTERN.matcher(cmd).find())\n+  private void checkExecSingleStringArgument(ExpressionTree arg0) {\n+    if (chmodCommand(arg0).filter(FilePermissionsCheck::isSensisitiveChmodMode).isPresent()) {\n+      reportIssue(arg0, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private void checkExecStringArrayArgument(NewArrayTree newArrayTree) {\n+    List<ExpressionTree> initializers = newArrayTree.initializers();\n+    if (initializers.size() < 3) {\n+      // malformed\n+      return;\n+    }\n+    if (!chmodCommand(initializers.get(0)).isPresent()) {\n+      return;\n+    }\n+    ExpressionTree modeArg = initializers.get(1);\n+    if (initializers.size() > 3 && isRecursiveArgument(modeArg)) {", "originalCommit": "744778ff55ddade59a886ec538efa02d417fef42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9484b5923991ea8413073372bf65ba3fc0e4d489", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\nindex eef98d0df..3eb5a0114 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java\n\n@@ -130,30 +130,19 @@ public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n \n   private void checkExecStringArrayArgument(NewArrayTree newArrayTree) {\n     List<ExpressionTree> initializers = newArrayTree.initializers();\n-    if (initializers.size() < 3) {\n-      // malformed\n+    if (initializers.size() < 3 || !chmodCommand(initializers.get(0)).isPresent()) {\n+      // malformed or not chmod\n       return;\n     }\n-    if (!chmodCommand(initializers.get(0)).isPresent()) {\n-      return;\n-    }\n-    ExpressionTree modeArg = initializers.get(1);\n-    if (initializers.size() > 3 && isRecursiveArgument(modeArg)) {\n-      // mode is going to be next argument\n-      modeArg = initializers.get(2);\n-    }\n-    if (modeArg.asConstant(String.class).filter(FilePermissionsCheck::isSensisitiveChmodMode).isPresent()) {\n-      reportIssue(modeArg, ISSUE_MESSAGE);\n+    // check all other arguments against sensitive configuration\n+    for (int i = 1; i < initializers.size(); i++) {\n+      ExpressionTree arg = initializers.get(i);\n+      if (arg.asConstant(String.class).filter(FilePermissionsCheck::isSensisitiveChmodMode).isPresent()) {\n+        reportIssue(arg, ISSUE_MESSAGE);\n+      }\n     }\n   }\n \n-  private static boolean isRecursiveArgument(ExpressionTree arg) {\n-    return arg.asConstant(String.class)\n-      .map(String::trim)\n-      .filter(cmd -> \"--recursive\".equals(cmd) || \"-R\".equals(cmd))\n-      .isPresent();\n-  }\n-\n   private static Optional<String> chmodCommand(ExpressionTree expr) {\n     return expr.asConstant(String.class).filter(cmd -> cmd.contains(\"chmod\"));\n   }\n"}}, {"oid": "9484b5923991ea8413073372bf65ba3fc0e4d489", "url": "https://github.com/SonarSource/sonar-java/commit/9484b5923991ea8413073372bf65ba3fc0e4d489", "message": "fix", "committedDate": "2020-02-26T10:07:03Z", "type": "commit"}]}