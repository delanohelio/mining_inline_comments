{"pr_number": 3301, "pr_title": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular expressions should be followed by an expression that can't match the empty string", "pr_createdAt": "2020-11-26T16:57:11Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3301", "timeline": [{"oid": "be4b74713e3199317c8412a58d86a74f9e2ab4be", "url": "https://github.com/SonarSource/sonar-java/commit/be4b74713e3199317c8412a58d86a74f9e2ab4be", "message": "Move the code to track matchers in S5860 into its own helper class\n\nAlso implement several improvements to the accuracy of the tracking.", "committedDate": "2020-11-26T17:00:21Z", "type": "forcePushed"}, {"oid": "9371ec1ecc383c10fcadc3540cec61088a180968", "url": "https://github.com/SonarSource/sonar-java/commit/9371ec1ecc383c10fcadc3540cec61088a180968", "message": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular ...\n\n... expressions should be followed by an expression that can't match\nthe empty string", "committedDate": "2020-11-26T20:03:24Z", "type": "forcePushed"}, {"oid": "41ae63a339151fb3d1d354ee6596eaa93bf578eb", "url": "https://github.com/SonarSource/sonar-java/commit/41ae63a339151fb3d1d354ee6596eaa93bf578eb", "message": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular ...\n\n... expressions should be followed by an expression that can't match\nthe empty string", "committedDate": "2020-11-26T20:11:44Z", "type": "forcePushed"}, {"oid": "9439f727743977197149dbb725857f7bc5e37256", "url": "https://github.com/SonarSource/sonar-java/commit/9439f727743977197149dbb725857f7bc5e37256", "message": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular ...\n\n... expressions should be followed by an expression that can't match\nthe empty string", "committedDate": "2020-11-26T20:21:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NDUyNQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3301#discussion_r531594525", "bodyText": "Looks to me that we could simplify this using a foreach:\nmethodsCalledOnRegex.forEach((regex, invocations) -> checkRegex(regex, invocations, escapingRegexes.contains(regex)));", "author": "m-g-sonar", "createdAt": "2020-11-27T13:13:26Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.ReturnStatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+public abstract class AbstractRegexCheckTrackingMatchers extends AbstractRegexCheck {\n+\n+  /**\n+   * The methods for which we want to know whether they're invoked on the given regex. These should either be methods of\n+   * the Pattern or Matcher class or part of REGEX_METHODS.\n+   */\n+  protected abstract MethodMatchers trackedMethodMatchers();\n+\n+  /**\n+   * @param regexForLiterals The regex to be checked\n+   * @param trackedMethodsCalled The list of method invocations performed on the Pattern or Matcher object associated\n+   *                             with the regex (only taking into account methods returned by trackedMethodMatchers)\n+   * @param didEscape Whether or not the regex escaped the method in which it was created (via return, being assigned to\n+   *                  a non-local variable or being passed to a different method). If true, trackedMethodsCalled may not\n+   *                  be exhaustive.\n+   */\n+  protected abstract void checkRegex(RegexParseResult regexForLiterals, List<MethodInvocationTree> trackedMethodsCalled, boolean didEscape);\n+\n+  private static final String JAVA_UTIL_REGEX_PATTERN = \"java.util.regex.Pattern\";\n+  private static final String JAVA_UTIL_REGEX_MATCHER = \"java.util.regex.Matcher\";\n+\n+  private static final MethodMatchers PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(JAVA_UTIL_REGEX_PATTERN)\n+    .names(\"matcher\")\n+    .addParametersMatcher(\"java.lang.CharSequence\")\n+    .build();\n+\n+  private static final MethodMatchers PATTERN_COMPILE = MethodMatchers.create()\n+    .ofTypes(JAVA_UTIL_REGEX_PATTERN)\n+    .names(\"compile\")\n+    .withAnyParameters()\n+    .build();\n+\n+  private static final MethodMatchers PATTERN_OR_MATCHER_ARGUMENT = MethodMatchers.create()\n+    .ofAnyType()\n+    .anyName()\n+    .addParametersMatcher(types -> types.stream().anyMatch(AbstractRegexCheckTrackingMatchers::isPatternOrMatcher))\n+    .build();\n+\n+  private static boolean isPatternOrMatcher(Type type) {\n+    String name = type.fullyQualifiedName();\n+    return name.equals(JAVA_UTIL_REGEX_PATTERN) || name.equals(JAVA_UTIL_REGEX_MATCHER);\n+  }\n+\n+  private final MethodMatchers matchers = MethodMatchers.or(REGEX_METHODS, PATTERN_MATCHER, PATTERN_OR_MATCHER_ARGUMENT, trackedMethodMatchers());\n+\n+  /**\n+   * Maps a variable containing either a Pattern or a Matcher associated with a pattern to the RegexParseResult of\n+   * the corresponding regex.\n+   */\n+  private final Map<Symbol, RegexParseResult> variableToRegex = new HashMap<>();\n+\n+  private final Map<MethodInvocationTree, RegexParseResult> methodInvocationToRegex = new HashMap<>();\n+\n+  private final Map<RegexParseResult, List<MethodInvocationTree>> methodsCalledOnRegex = new LinkedHashMap<>();\n+\n+  /**\n+   * This sets contains all regexes whose Pattern and/or Matcher object escapes, meaning it is used in such a way that\n+   * we no longer know which methods are called on it.\n+   */\n+  private final Set<RegexParseResult> escapingRegexes = new HashSet<>();\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    List<Tree.Kind> nodes = new ArrayList<>(super.nodesToVisit());\n+    // visit more nodes than method invocations\n+    nodes.add(Tree.Kind.RETURN_STATEMENT);\n+    nodes.add(Tree.Kind.COMPILATION_UNIT);\n+    return nodes;\n+  }\n+\n+  @Override\n+  public void leaveNode(Tree tree) {\n+    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {\n+      collectReturnedVariables(((ReturnStatementTree) tree).expression());\n+    } else if (tree.is(Tree.Kind.COMPILATION_UNIT)) {\n+      for (Map.Entry<RegexParseResult, List<MethodInvocationTree>> entry : methodsCalledOnRegex.entrySet()) {", "originalCommit": "9439f727743977197149dbb725857f7bc5e37256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa6425ecb4dbfe174e26cf84f42a6c5b74c9d972", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java b/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\nindex a554bec60..e2172454e 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\n\n@@ -128,8 +128,10 @@ public abstract class AbstractRegexCheckTrackingMatchers extends AbstractRegexCh\n       methodInvocationToRegex.clear();\n       methodsCalledOnRegex.clear();\n       escapingRegexes.clear();\n-    } else if (matchers.matches((MethodInvocationTree) tree)) {\n+    } else if (tree instanceof MethodInvocationTree && matchers.matches((MethodInvocationTree) tree)) {\n       onMethodInvocationFound((MethodInvocationTree) tree);\n+    } else {\n+      super.visitNode(tree);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMjQxOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3301#discussion_r531602418", "bodyText": "this should probably be stored in a constant, because trackedMethodMatchers() is called way too many times, and we probably don't want to perform the or() all the time.\nAnother option could be to cache it in AbstractRegexCheckTrackingMatchers, and then only call the cached one.", "author": "m-g-sonar", "createdAt": "2020-11-27T13:29:04Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchType.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.List;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+public abstract class AbstractRegexCheckTrackingMatchType extends AbstractRegexCheckTrackingMatchers {\n+\n+  protected enum MatchType {\n+    FULL, PARTIAL, BOTH, UNKNOWN\n+  }\n+\n+  private static final MethodMatchers PARTIAL_MATCHERS = MethodMatchers.or(\n+    MethodMatchers.create()\n+      .ofTypes(\"java.util.regex.Pattern\", \"java.lang.String\")\n+      .names(\"split\", \"splitAsStream\", \"asPredicate\")\n+      .withAnyParameters()\n+      .build(),\n+    MethodMatchers.create()\n+      .ofTypes(\"java.util.regex.Matcher\")\n+      .names(\"find\")\n+      .withAnyParameters()\n+      .build()\n+  );\n+\n+  private static final MethodMatchers FULL_MATCHERS = MethodMatchers.create()\n+      .ofTypes(\"java.util.regex.Pattern\", \"java.util.regex.Matcher\", \"java.lang.String\")\n+      .names(\"matches\", \"asMatchPredicate\")\n+      .withAnyParameters()\n+      .build();\n+\n+  protected abstract void checkRegex(RegexParseResult regex, MatchType matchType);\n+\n+  @Override\n+  protected MethodMatchers trackedMethodMatchers() {\n+    return MethodMatchers.or(PARTIAL_MATCHERS, FULL_MATCHERS);", "originalCommit": "9439f727743977197149dbb725857f7bc5e37256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14de6a79c58b7a8ac196b76424168e706a841d23", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchType.java b/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchType.java\ndeleted file mode 100644\nindex 2b59bd20b..000000000\n--- a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchType.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * SonarQube Java\n- * Copyright (C) 2012-2020 SonarSource SA\n- * mailto:info AT sonarsource DOT com\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 3 of the License, or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n- */\n-package org.sonar.java.checks.regex;\n-\n-import java.util.List;\n-import org.sonar.java.regex.RegexParseResult;\n-import org.sonar.plugins.java.api.semantic.MethodMatchers;\n-import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n-\n-public abstract class AbstractRegexCheckTrackingMatchType extends AbstractRegexCheckTrackingMatchers {\n-\n-  protected enum MatchType {\n-    FULL, PARTIAL, BOTH, UNKNOWN\n-  }\n-\n-  private static final MethodMatchers PARTIAL_MATCHERS = MethodMatchers.or(\n-    MethodMatchers.create()\n-      .ofTypes(\"java.util.regex.Pattern\", \"java.lang.String\")\n-      .names(\"split\", \"splitAsStream\", \"asPredicate\")\n-      .withAnyParameters()\n-      .build(),\n-    MethodMatchers.create()\n-      .ofTypes(\"java.util.regex.Matcher\")\n-      .names(\"find\")\n-      .withAnyParameters()\n-      .build()\n-  );\n-\n-  private static final MethodMatchers FULL_MATCHERS = MethodMatchers.create()\n-      .ofTypes(\"java.util.regex.Pattern\", \"java.util.regex.Matcher\", \"java.lang.String\")\n-      .names(\"matches\", \"asMatchPredicate\")\n-      .withAnyParameters()\n-      .build();\n-\n-  protected abstract void checkRegex(RegexParseResult regex, MatchType matchType);\n-\n-  @Override\n-  protected MethodMatchers trackedMethodMatchers() {\n-    return MethodMatchers.or(PARTIAL_MATCHERS, FULL_MATCHERS);\n-  }\n-\n-  @Override\n-  protected void checkRegex(RegexParseResult regexForLiterals, List<MethodInvocationTree> trackedMethodsCalled, boolean didEscape) {\n-    MatchType matchType;\n-    if (didEscape) {\n-      matchType = MatchType.UNKNOWN;\n-    } else {\n-      boolean partial = trackedMethodsCalled.stream().anyMatch(PARTIAL_MATCHERS::matches);\n-      boolean full = trackedMethodsCalled.stream().anyMatch(FULL_MATCHERS::matches);\n-      if (partial && full) {\n-        matchType = MatchType.BOTH;\n-      } else if (partial) {\n-        matchType = MatchType.PARTIAL;\n-      } else if (full) {\n-        matchType = MatchType.FULL;\n-      } else {\n-        matchType = MatchType.UNKNOWN;\n-      }\n-    }\n-    checkRegex(regexForLiterals, matchType);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNDU1NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3301#discussion_r531604555", "bodyText": "I understand the problem of levels of hierarchy... and in fact, I believe we should modify the parent AbstractRegexCheck to not anymore rely on AbstractMethodDetection.\nWe already specialized the behavior of the initial AbstractMethodDetection too much. We would benefit in doing it simpler, by focusing only on method invocations directly in the AbstractRegexCheck.", "author": "m-g-sonar", "createdAt": "2020-11-27T13:33:08Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.java.model.JUtils;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.ReturnStatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+public abstract class AbstractRegexCheckTrackingMatchers extends AbstractRegexCheck {", "originalCommit": "9439f727743977197149dbb725857f7bc5e37256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aa6425ecb4dbfe174e26cf84f42a6c5b74c9d972", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java b/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\nindex a554bec60..e2172454e 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/regex/AbstractRegexCheckTrackingMatchers.java\n\n@@ -128,8 +128,10 @@ public abstract class AbstractRegexCheckTrackingMatchers extends AbstractRegexCh\n       methodInvocationToRegex.clear();\n       methodsCalledOnRegex.clear();\n       escapingRegexes.clear();\n-    } else if (matchers.matches((MethodInvocationTree) tree)) {\n+    } else if (tree instanceof MethodInvocationTree && matchers.matches((MethodInvocationTree) tree)) {\n       onMethodInvocationFound((MethodInvocationTree) tree);\n+    } else {\n+      super.visitNode(tree);\n     }\n   }\n \n"}}, {"oid": "aa6425ecb4dbfe174e26cf84f42a6c5b74c9d972", "url": "https://github.com/SonarSource/sonar-java/commit/aa6425ecb4dbfe174e26cf84f42a6c5b74c9d972", "message": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular ...\n\n... expressions should be followed by an expression that can't match\nthe empty string", "committedDate": "2020-12-01T15:16:53Z", "type": "forcePushed"}, {"oid": "14de6a79c58b7a8ac196b76424168e706a841d23", "url": "https://github.com/SonarSource/sonar-java/commit/14de6a79c58b7a8ac196b76424168e706a841d23", "message": "Move the code to track matchers in S5860 into its own helper class\n\nAlso implement several improvements to the accuracy of the tracking.", "committedDate": "2020-12-02T15:15:57Z", "type": "commit"}, {"oid": "8f042943f460a97681e1c002ea6101f3ad4a2aa2", "url": "https://github.com/SonarSource/sonar-java/commit/8f042943f460a97681e1c002ea6101f3ad4a2aa2", "message": "Add support for annotations and RegExUtils", "committedDate": "2020-12-02T15:18:48Z", "type": "forcePushed"}, {"oid": "36b2168cdf546fbd6d4ec6d1fe1019aa209a900f", "url": "https://github.com/SonarSource/sonar-java/commit/36b2168cdf546fbd6d4ec6d1fe1019aa209a900f", "message": "SONARJAVA-3567 Rule S6019: Reluctant quantifiers in regular ...\n\n... expressions should be followed by an expression that can't match\nthe empty string", "committedDate": "2020-12-02T15:38:16Z", "type": "commit"}, {"oid": "763b418e3754567c5a5de88e17646631544c7050", "url": "https://github.com/SonarSource/sonar-java/commit/763b418e3754567c5a5de88e17646631544c7050", "message": "Make AbstractRegexCheck not inherit from AbstractMethodDetection", "committedDate": "2020-12-02T15:38:38Z", "type": "commit"}, {"oid": "763b418e3754567c5a5de88e17646631544c7050", "url": "https://github.com/SonarSource/sonar-java/commit/763b418e3754567c5a5de88e17646631544c7050", "message": "Make AbstractRegexCheck not inherit from AbstractMethodDetection", "committedDate": "2020-12-02T15:38:38Z", "type": "forcePushed"}]}