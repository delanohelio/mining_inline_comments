{"pr_number": 3297, "pr_title": "SONARJAVA-3564 Implement intersects and supersetOf helper for regex automata", "pr_createdAt": "2020-11-24T05:56:58Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3297", "timeline": [{"oid": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9", "url": "https://github.com/SonarSource/sonar-java/commit/d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9", "message": "SONARJAVA-3564 RegexParser set activeFlags on group and character AutomatonState", "committedDate": "2020-11-24T06:07:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMxMTI5NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r529311294", "bodyText": "It probably makes sense to initialize activeFlags in the constructor rather than parse and to get rid of initialFlags altogether (this would also entail getting rid of RegexParseResult.initialFlags, which should be fine because we can just use parseResult.getResult().activeFlags() instead).", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-24T09:01:56Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java", "diffHunk": "@@ -81,6 +83,7 @@ public RegexParser(RegexSource source, FlagSet initialFlags) {\n   }\n \n   public RegexParseResult parse() {\n+    this.activeFlags = initialFlags;", "originalCommit": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4Mjk0Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r530182946", "bodyText": "I removed the field initialFlags but keept the getter getInitialFlags().", "author": "alban-auzeill", "createdAt": "2020-11-25T08:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMxMTI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "99b73e0db24372a894bfb05c1c3e0ec8f227e548", "chunk": "diff --git a/java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java b/java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java\nindex a9264972b..890153ef3 100644\n--- a/java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java\n+++ b/java-frontend/src/main/java/org/sonar/java/regex/RegexParser.java\n\n@@ -79,11 +79,11 @@ public class RegexParser {\n     this.source = source;\n     this.characters = new RegexLexer(source);\n     this.characters.setFreeSpacingMode(initialFlags.contains(Pattern.COMMENTS));\n-    this.initialFlags = initialFlags;\n+    this.activeFlags = initialFlags;\n   }\n \n   public RegexParseResult parse() {\n-    this.activeFlags = initialFlags;\n+    FlagSet initialFlags = activeFlags;\n     List<RegexTree> results = new ArrayList<>();\n     do {\n       RegexTree result = parseDisjunction();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMTY5Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r529331696", "bodyText": "If we decide to remove RegexParseResult.initialFlags, RegexTrees should never use FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-24T09:18:27Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java", "diffHunk": "@@ -30,7 +30,7 @@\n   private final List<JavaCharacter> orOperators;\n \n   public DisjunctionTree(RegexSource source, IndexRange range, List<RegexTree> alternatives, List<JavaCharacter> orOperators) {\n-    super(source, range);\n+    super(source, range, FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE);", "originalCommit": "d7aae3166cd62418c9a22e9e1ed3a5cc08ed54d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4MjA3Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r530182077", "bodyText": "I have set correct activeFlags on all AutomatonState and removed FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE", "author": "alban-auzeill", "createdAt": "2020-11-25T08:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMTY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "99b73e0db24372a894bfb05c1c3e0ec8f227e548", "chunk": "diff --git a/java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java b/java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java\nindex 15b2f0a04..389d21ff4 100644\n--- a/java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java\n+++ b/java-frontend/src/main/java/org/sonar/java/regex/ast/DisjunctionTree.java\n\n@@ -29,8 +29,8 @@ public class DisjunctionTree extends RegexTree {\n \n   private final List<JavaCharacter> orOperators;\n \n-  public DisjunctionTree(RegexSource source, IndexRange range, List<RegexTree> alternatives, List<JavaCharacter> orOperators) {\n-    super(source, range, FLAGS_HAVE_NO_EFFECT_ON_THIS_STATE);\n+  public DisjunctionTree(RegexSource source, IndexRange range, List<RegexTree> alternatives, List<JavaCharacter> orOperators, FlagSet activeFlags) {\n+    super(source, range, activeFlags);\n     this.alternatives = Collections.unmodifiableList(alternatives);\n     this.orOperators = Collections.unmodifiableList(orOperators);\n   }\n"}}, {"oid": "5a64f10c2f928331936d2810ba7dc72b656410ec", "url": "https://github.com/SonarSource/sonar-java/commit/5a64f10c2f928331936d2810ba7dc72b656410ec", "message": "SONARJAVA-3564 Implement intersects and supersetOf helper for regex automata without LookAroundTree, BoundaryTree and DotTree support", "committedDate": "2020-11-24T17:33:47Z", "type": "forcePushed"}, {"oid": "b1729f681889270c0212b347c076535770f4159c", "url": "https://github.com/SonarSource/sonar-java/commit/b1729f681889270c0212b347c076535770f4159c", "message": "SONARJAVA-3564 Implement intersects and supersetOf helper for regex automata without LookAroundTree, BoundaryTree and DotTree support", "committedDate": "2020-11-24T18:20:03Z", "type": "forcePushed"}, {"oid": "99b73e0db24372a894bfb05c1c3e0ec8f227e548", "url": "https://github.com/SonarSource/sonar-java/commit/99b73e0db24372a894bfb05c1c3e0ec8f227e548", "message": "SONARJAVA-3564 Fix ReluctantQuantifierCheck getActiveFlagSet() removal", "committedDate": "2020-11-24T21:20:13Z", "type": "forcePushed"}, {"oid": "469bfdf9c017ef7cd5561b125174e4081e2d3a16", "url": "https://github.com/SonarSource/sonar-java/commit/469bfdf9c017ef7cd5561b125174e4081e2d3a16", "message": "SONARJAVA-3564 DotTree support to intersects and supersetOf helper for regex automata", "committedDate": "2020-11-25T07:54:09Z", "type": "forcePushed"}, {"oid": "8c0cec7c6ca2e4eb31b910ef21e1ce3680a99127", "url": "https://github.com/SonarSource/sonar-java/commit/8c0cec7c6ca2e4eb31b910ef21e1ce3680a99127", "message": "SONARJAVA-3550 Rule S5994: Regex patterns following a possessive quantifier should not always fail", "committedDate": "2020-11-26T08:57:26Z", "type": "forcePushed"}, {"oid": "8d756a13783c4115bcf19138212d3f1ce1e7eae8", "url": "https://github.com/SonarSource/sonar-java/commit/8d756a13783c4115bcf19138212d3f1ce1e7eae8", "message": "SONARJAVA-3550 Add a regex database list to test regex rules", "committedDate": "2020-11-26T09:29:23Z", "type": "forcePushed"}, {"oid": "5afbfeeef0963237e9835bd551e07921414592fa", "url": "https://github.com/SonarSource/sonar-java/commit/5afbfeeef0963237e9835bd551e07921414592fa", "message": "SONARJAVA-3550 Rule S5994: Regex patterns following a possessive quantifier should not always fail", "committedDate": "2020-11-26T09:28:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxMDIxNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532610216", "bodyText": "This doesn't really test what I wanted to test. The intent was to have a regex where the reluctantly quantified bit is subject to a flag, but the part after the reluctant quantifier is not. Previously the flag wouldn't have been taken into account in that case because it called flagActive for both arguments after both have been parsed. With the new system, both arguments should have accurate flags.\nSo to test this with the features we currently support, (?U:\\\\s*?)\\u202F would be an example of a current FN that should be fixed by the change in how flags are tracked.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T13:50:50Z", "path": "java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java", "diffHunk": "@@ -21,7 +21,8 @@ void noncompliant(String str) {\n     str.matches(\".*?\\\\P{L}\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"\\\\p{L}*+\".}}\n     str.matches(\"\\\\[.*?\\\\]\"); // Noncompliant [[sc=21;ec=24]] {{Replace this use of a reluctant quantifier with \"[^\\\\]]*+\".}}\n     str.matches(\".+?[abc]\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"[^abc]++\".}}\n-    \n+    str.matches(\"(?i:.*?[a-z])\"); // Noncompliant [[sc=22;ec=25]] {{Replace this use of a reluctant quantifier with \"[^a-z]*+\".}}", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NjQ3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r533476470", "bodyText": "Unfortunately ReluctantQuantifierCheck only supports DOT and ESCAPED_CHARACTER_CLASS before the *?, and only PLAIN_CHARACTER, ESCAPED_CHARACTER_CLASS, CHARACTER_CLASS after.\nSo it was not possible to have different active flags before and after *?. For this, I had to change the rule implementation \ud83d\ude1e to support NON_CAPTURING_GROUP.\nSee this commit: SONARJAVA-3564 ReluctantQuantifierCheck support mixed active flags", "author": "alban-auzeill", "createdAt": "2020-12-01T14:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYxMDIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "351d8fbbd4b519715a1bbcbc94b4e4c6b6a37c57", "chunk": "diff --git a/java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java b/java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java\nindex 81e9f8587..b5499bd22 100644\n--- a/java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java\n+++ b/java-checks-test-sources/src/main/java/checks/regex/ReluctantQuantifierCheck.java\n\n@@ -21,8 +26,7 @@ public class ReluctantQuantifierCheck {\n     str.matches(\".*?\\\\P{L}\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"\\\\p{L}*+\".}}\n     str.matches(\"\\\\[.*?\\\\]\"); // Noncompliant [[sc=21;ec=24]] {{Replace this use of a reluctant quantifier with \"[^\\\\]]*+\".}}\n     str.matches(\".+?[abc]\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"[^abc]++\".}}\n-    str.matches(\"(?i:.*?[a-z])\"); // Noncompliant [[sc=22;ec=25]] {{Replace this use of a reluctant quantifier with \"[^a-z]*+\".}}\n-\n+    \n     // This replacement might not be equivalent in case of full match, but is equivalent in case of split\n     str.matches(\".+?[^abc]\"); // Noncompliant [[sc=18;ec=21]] {{Replace this use of a reluctant quantifier with \"[abc]++\".}}\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc0NzgwMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532747802", "bodyText": "Should be Character.MAX_CODE_POINT without the - 1 unless I'm missing something.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T16:55:13Z", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -45,38 +50,69 @@\n    * non-null and the tree returned by {@code getValue} will be the element of the character class which matches that\n    * code point.\n    */\n-  private TreeMap<Integer, CharacterClassElementTree> contents = new TreeMap<>();\n+  private TreeMap<Integer, RegexSyntaxElement> contents = new TreeMap<>();\n \n   private boolean containsUnknownCharacters = false;\n \n   public SimplifiedRegexCharacterClass() {\n   }\n \n-  public SimplifiedRegexCharacterClass(CharacterClassElementTree tree, FlagSet flags) {\n-    add(tree, flags);\n+  public SimplifiedRegexCharacterClass(CharacterClassElementTree tree) {\n+    add(tree);\n+  }\n+\n+  public SimplifiedRegexCharacterClass(DotTree tree) {\n+    char[] orderedExcludedCharacters;\n+    if (tree.activeFlags().contains(Pattern.DOTALL)) {\n+      orderedExcludedCharacters = new char[] {};\n+    } else if (tree.activeFlags().contains(Pattern.UNIX_LINES)) {\n+      orderedExcludedCharacters = new char[] {'\\n'};\n+    } else {\n+      orderedExcludedCharacters = new char[] {'\\n', '\\r', '\\u0085', '\\u2028', '\\u2029'};\n+    }\n+    int from = 0;\n+    for (char excludedCharacter : orderedExcludedCharacters) {\n+      int to = excludedCharacter - 1;\n+      if (to > from) {\n+        addRange(from, to, tree);\n+      }\n+      from = excludedCharacter + 1;\n+    }\n+    addRange(from, Character.MAX_CODE_POINT - 1, tree);", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22e85b2566b0b63fb173008e9dfe9e8e29405219", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\nindex 2e0445753..fe4f3fb21 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n\n@@ -111,16 +111,17 @@ public class SimplifiedRegexCharacterClass {\n     Map.Entry<Integer, RegexSyntaxElement> entry = iter.next();\n     while (iter.hasNext()) {\n       Map.Entry<Integer, RegexSyntaxElement> nextEntry = iter.next();\n-      if (entry.getValue() != null) {\n-        Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(entry.getKey());\n-        if ((before != null && before.getValue() != null)\n-          || !contents.subMap(entry.getKey(), false, nextEntry.getKey(), false).isEmpty()) {\n-          return true;\n-        }\n+      if (entry.getValue() != null && hasEntryBetween(entry.getKey(), nextEntry.getKey())) {\n+        return true;\n       }\n       entry = nextEntry;\n     }\n-    return false;\n+    return entry.getValue() != null && hasEntryBetween(entry.getKey(), Character.MAX_CODE_POINT);\n+  }\n+\n+  private boolean hasEntryBetween(int from, int to) {\n+    Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(from);\n+    return ((before != null && before.getValue() != null) || !contents.subMap(from, false, to, false).isEmpty());\n   }\n \n   public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MzkzMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532773931", "bodyText": "Create ticket", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T17:32:20Z", "path": "java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java", "diffHunk": "@@ -52,4 +69,226 @@ void testIntersectionWithTrueAsDefaultAnswer() {\n     assertFalse(empty.intersects(aToZ, true));\n     assertFalse(empty.intersects(unknown, true));\n   }\n+\n+  @Test\n+  void intersects_dot() {\n+    assertIntersects(\".\", \"a\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \".\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\0\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\uFFFF\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"a\", \".\", true, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"[a-z]\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\"[a-z]\", \".\", false, NO_FLAGS).isTrue();\n+\n+    // by default [\\r\\n\\u0085\\u2028\\u2029] excluded from DotTree\n+    assertIntersects(\".\", \"[\\r\\n\\u0085\\u2028\\u2029]\", false, NO_FLAGS).isFalse();\n+    assertIntersects(\".\", \"\\b\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \" \", false, NO_FLAGS).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, NO_FLAGS).isTrue();\n+  }\n+   \n+  @Test\n+  void intersects_dot_unix_lines() {\n+    // only \\n excluded when UNIX_LINES is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES).isFalse();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.UNIX_LINES).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.UNIX_LINES).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_dot_all() {\n+    // no exclusion and UNIX_LINES is ignored when DOTALL is set\n+    assertIntersects(\".\", \"\\n\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"[^a]\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES | Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\b\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\t\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\f\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \" \", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\r\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u0085\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2028\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \"\\u2029\", false, Pattern.DOTALL).isTrue();\n+    assertIntersects(\".\", \".\", false, Pattern.DOTALL).isTrue();\n+  }\n+\n+  @Test\n+  void intersects_with_utf16() {\n+    String maxCodePoint = new String(Character.toChars(Character.MAX_CODE_POINT));\n+    // two characters\n+    assertThat(maxCodePoint).hasSize(2);\n+    // but a single code point\n+    assertThat(maxCodePoint.codePoints().count()).isEqualTo(1);\n+    // and java Pattern support it\n+    assertThat(maxCodePoint).matches(\".\");\n+\n+    RegexTree result = parseRegex(maxCodePoint, new FlagSet()).getResult();\n+    // FIXME result should be a single PlainCharacterTree and not a SequenceTree of two PlainCharacterTree s\n+    // In oder to assert: assertIntersects(\".\", maxCodePoint, false, NO_FLAGS).isTrue();\n+    // Instead of:\n+    assertThat(result).isInstanceOf(SequenceTree.class);", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjcxOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r533956719", "bodyText": "Created https://jira.sonarsource.com/browse/SONARJAVA-3624", "author": "alban-auzeill", "createdAt": "2020-12-02T07:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MzkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "351d8fbbd4b519715a1bbcbc94b4e4c6b6a37c57", "chunk": "diff --git a/java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java b/java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java\nindex da1602eb1..9c040e2ce 100644\n--- a/java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java\n+++ b/java-checks/src/test/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClassTest.java\n\n@@ -69,226 +52,4 @@ class SimplifiedRegexCharacterClassTest {\n     assertFalse(empty.intersects(aToZ, true));\n     assertFalse(empty.intersects(unknown, true));\n   }\n-\n-  @Test\n-  void intersects_dot() {\n-    assertIntersects(\".\", \"a\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \".\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \"\\0\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \"\\uFFFF\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\"a\", \".\", true, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \"[a-z]\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\"[a-z]\", \".\", false, NO_FLAGS).isTrue();\n-\n-    // by default [\\r\\n\\u0085\\u2028\\u2029] excluded from DotTree\n-    assertIntersects(\".\", \"[\\r\\n\\u0085\\u2028\\u2029]\", false, NO_FLAGS).isFalse();\n-    assertIntersects(\".\", \"\\b\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \"\\f\", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \" \", false, NO_FLAGS).isTrue();\n-    assertIntersects(\".\", \"\\t\", false, NO_FLAGS).isTrue();\n-  }\n-   \n-  @Test\n-  void intersects_dot_unix_lines() {\n-    // only \\n excluded when UNIX_LINES is set\n-    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES).isFalse();\n-    assertIntersects(\".\", \"[^a]\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\b\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\t\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\f\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \" \", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\r\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\u0085\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\u2028\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \"\\u2029\", false, Pattern.UNIX_LINES).isTrue();\n-    assertIntersects(\".\", \".\", false, Pattern.UNIX_LINES).isTrue();\n-  }\n-\n-  @Test\n-  void intersects_dot_all() {\n-    // no exclusion and UNIX_LINES is ignored when DOTALL is set\n-    assertIntersects(\".\", \"\\n\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"[^a]\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\n\", false, Pattern.UNIX_LINES | Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\b\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\t\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\f\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \" \", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\r\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\u0085\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\u2028\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \"\\u2029\", false, Pattern.DOTALL).isTrue();\n-    assertIntersects(\".\", \".\", false, Pattern.DOTALL).isTrue();\n-  }\n-\n-  @Test\n-  void intersects_with_utf16() {\n-    String maxCodePoint = new String(Character.toChars(Character.MAX_CODE_POINT));\n-    // two characters\n-    assertThat(maxCodePoint).hasSize(2);\n-    // but a single code point\n-    assertThat(maxCodePoint.codePoints().count()).isEqualTo(1);\n-    // and java Pattern support it\n-    assertThat(maxCodePoint).matches(\".\");\n-\n-    RegexTree result = parseRegex(maxCodePoint, new FlagSet()).getResult();\n-    // FIXME result should be a single PlainCharacterTree and not a SequenceTree of two PlainCharacterTree s\n-    // In oder to assert: assertIntersects(\".\", maxCodePoint, false, NO_FLAGS).isTrue();\n-    // Instead of:\n-    assertThat(result).isInstanceOf(SequenceTree.class);\n-  }\n-\n-  @Test\n-  void superset_of_characters_or_range() {\n-    assertSupersetOf(\"a\", \"a\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"a\", \"b\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-d]\", \"a\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-d]\", \"b\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[b-d]\", \"c\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[b-d]\", \"d\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[b-d]\", \"e\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"a\", \"[a]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"a\", \"[ab]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[a-z]\", \"[b-e]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-z]\", \"[b-e]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-d]\", \"[a-e]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[a-d]\", \"[b-e]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-d]\", \"[a-d]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[a-c]\", \"[a-c]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-ce-g]\", \"[a-ce-g]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-g]\", \"[a-de-g]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-de-g]\", \"[a-g]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[b-dg-i]\", \"[a-dg-i]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-dg-i]\", \"[b-eg-i]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-dg-i]\", \"[b-df-i]\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[b-dg-i]\", \"[b-dg-j]\", true, NO_FLAGS).isFalse();\n-  }\n-\n-  @Test\n-  void superset_of_dot_default() {\n-    assertSupersetOf(\".\", \"a\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \"\\0\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \"\\uFFFF\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"a\", \".\", true, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"[a-z]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[a-z]\", \".\", false, NO_FLAGS).isFalse();\n-\n-    // by default [\\r\\n\\u0085\\u2028\\u2029] excluded from DotTree\n-    assertSupersetOf(\".\", \"[^\\r\\n\\u0085\\u2028\\u2029]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \"\\r\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"\\n\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"\\u0085\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"\\u2028\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"\\u2029\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\".\", \"\\b\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \"\\f\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \" \", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\".\", \"\\t\", false, NO_FLAGS).isTrue();\n-  }\n-\n-  @Test\n-  void superset_of_dot_unix_lines() {\n-    // only \\n excluded when UNIX_LINES is set\n-    assertSupersetOf(\".\", \"[^\\n]\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\r\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\n\", false, Pattern.UNIX_LINES).isFalse();\n-    assertSupersetOf(\".\", \"\\u0085\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\u2028\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\u2029\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\b\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\f\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \" \", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \"\\t\", false, Pattern.UNIX_LINES).isTrue();\n-    assertSupersetOf(\".\", \".\", false, Pattern.UNIX_LINES).isTrue();\n-  }\n-\n-  @Test\n-  void superset_of_dot_all() {\n-    // no exclusion\n-    assertSupersetOf(\".\", \"[^a]\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\r\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\n\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\u0085\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\u2028\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\u2029\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\b\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\f\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \" \", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \"\\t\", false, Pattern.DOTALL).isTrue();\n-    assertSupersetOf(\".\", \".\", false, Pattern.DOTALL).isTrue();\n-    // UNIX_LINES is ignored when DOTALL is set\n-    assertSupersetOf(\".\", \"\\n\", false, Pattern.UNIX_LINES|Pattern.DOTALL).isTrue();\n-  }\n-\n-  @Test\n-  void superset_of_predefined_character_classes() {\n-    assertSupersetOf(\"\\\\d\", \"[0-9]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[0-9]\", \"\\\\d\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"\\\\d\", \"[2-5]\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"[2-5]\", \"\\\\d\", false, NO_FLAGS).isFalse();\n-    assertSupersetOf(\"[^a-z]\", \"\\\\d\", false, NO_FLAGS).isTrue();\n-    assertSupersetOf(\"\\\\d\", \"[^a-z]\", true, NO_FLAGS).isFalse();\n-  }\n-\n-  @Test\n-  void superset_of_case_insensitive() {\n-    int flags = Pattern.CASE_INSENSITIVE;\n-    assertSupersetOf(\"A\", \"a\", false, flags).isTrue();\n-    assertSupersetOf(\"a\", \"A\", false, flags).isTrue();\n-    assertSupersetOf(\"[a-z]\", \"[B-F]\", false, flags).isTrue();\n-    assertSupersetOf(\"[a-f]\", \"[B-Z]\", true, flags).isFalse();\n-  }\n-\n-  @Test\n-  void superset_of_default_answer() {\n-    int flags = Pattern.UNICODE_CHARACTER_CLASS;\n-    assertSupersetOf(\"[0-9]\", \"\\\\d\", false, flags).isFalse();\n-    assertSupersetOf(\"[0-9]\", \"\\\\d\", true, flags).isTrue();\n-  }\n-\n-  @Test\n-  void superset_of_empty_set() {\n-    SimplifiedRegexCharacterClass empty = new SimplifiedRegexCharacterClass();\n-    assertThat(empty.supersetOf(empty, true)).isTrue();\n-    assertThat(empty.supersetOf(empty, false)).isTrue();\n-  }\n-\n-  @Test\n-  void conversion() {\n-    PlainCharacterTree plainCharacterTree = (PlainCharacterTree) parseRegex(\"a\", new FlagSet()).getResult();\n-    assertThat(SimplifiedRegexCharacterClass.of(plainCharacterTree)).isNotNull();\n-\n-    DotTree dotTree = (DotTree) parseRegex(\".\", new FlagSet()).getResult();\n-    assertThat(SimplifiedRegexCharacterClass.of(dotTree)).isNotNull();\n-\n-    SequenceTree sequenceTree = (SequenceTree) parseRegex(\"ab\", new FlagSet()).getResult();\n-    assertThat(SimplifiedRegexCharacterClass.of(sequenceTree)).isNull();\n-  }\n-\n-  private static AbstractBooleanAssert<?> assertIntersects(String regex1, String regex2, boolean defaultAnswer, int flags) {\n-    FlagSet flagSet = new FlagSet(flags);\n-    RegexTree tree1 = parseRegex(regex1, flagSet).getResult();\n-    RegexTree tree2 = parseRegex(regex2, flagSet).getResult();\n-    SimplifiedRegexCharacterClass characterClass1 = SimplifiedRegexCharacterClass.of(tree1);\n-    SimplifiedRegexCharacterClass characterClass2 = SimplifiedRegexCharacterClass.of(tree2);\n-    return assertThat(characterClass1.intersects(characterClass2, defaultAnswer));\n-  }\n-\n-  private static AbstractBooleanAssert<?> assertSupersetOf(String superset, String subset, boolean defaultAnswer, int flags) {\n-    FlagSet flagSet = new FlagSet(flags);\n-    RegexTree supersetResult = parseRegex(superset, flagSet).getResult();\n-    RegexTree subsetResult = parseRegex(subset, flagSet).getResult();\n-    SimplifiedRegexCharacterClass supersetCharacterClass = SimplifiedRegexCharacterClass.of(supersetResult);\n-    SimplifiedRegexCharacterClass subsetCharacterClass = SimplifiedRegexCharacterClass.of(subsetResult);\n-    return assertThat(supersetCharacterClass.supersetOf(subsetCharacterClass, defaultAnswer));\n-  }\n-\n-  static RegexParseResult parseRegex(String stringLiteral, FlagSet flagSet) {\n-    String literalSourceCode = \"\\\"\" + StringEscapeUtils.escapeJava(stringLiteral) + \"\\\"\";\n-    InternalSyntaxToken literalToken = new InternalSyntaxToken(1, 1, literalSourceCode, Collections.emptyList(), false);\n-    List<LiteralTree> literals = Collections.singletonList(new LiteralTreeImpl(Tree.Kind.STRING_LITERAL, literalToken));\n-    RegexParseResult result = new RegexParser(new RegexSource(literals), flagSet).parse();\n-    assertThat(result.getSyntaxErrors()).isEmpty();\n-    return result;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODkxMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532808911", "bodyText": "If that only contains unknown characters and this is empty, the result should still be true false even if the default answer is true. So return !isEmpty() || !that.containsUnknownCharacters;.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T18:27:20Z", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -87,9 +123,36 @@ public boolean intersects(SimplifiedRegexCharacterClass that, boolean defaultAns\n     return false;\n   }\n \n-  public void addRange(int from, int to, CharacterClassElementTree tree) {\n+  public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n+    if (that.containsUnknownCharacters && !defaultAnswer) {\n+      return false;\n+    }\n+    Iterator<Map.Entry<Integer, RegexSyntaxElement>> thatIter = that.contents.entrySet().iterator();\n+    if (!thatIter.hasNext()) {\n+      // that.contents is empty, any set is a superset of it\n+      return true;", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22e85b2566b0b63fb173008e9dfe9e8e29405219", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\nindex 2e0445753..fe4f3fb21 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n\n@@ -111,16 +111,17 @@ public class SimplifiedRegexCharacterClass {\n     Map.Entry<Integer, RegexSyntaxElement> entry = iter.next();\n     while (iter.hasNext()) {\n       Map.Entry<Integer, RegexSyntaxElement> nextEntry = iter.next();\n-      if (entry.getValue() != null) {\n-        Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(entry.getKey());\n-        if ((before != null && before.getValue() != null)\n-          || !contents.subMap(entry.getKey(), false, nextEntry.getKey(), false).isEmpty()) {\n-          return true;\n-        }\n+      if (entry.getValue() != null && hasEntryBetween(entry.getKey(), nextEntry.getKey())) {\n+        return true;\n       }\n       entry = nextEntry;\n     }\n-    return false;\n+    return entry.getValue() != null && hasEntryBetween(entry.getKey(), Character.MAX_CODE_POINT);\n+  }\n+\n+  private boolean hasEntryBetween(int from, int to) {\n+    Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(from);\n+    return ((before != null && before.getValue() != null) || !contents.subMap(from, false, to, false).isEmpty());\n   }\n \n   public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg5MTc4Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532891783", "bodyText": "There's a bug here if that ends with a range that goes up to MAX_CODE_POINT (inclusive), in which case the last entry of that.contents won't be a null entry. I've fixed the same bug for intersects in my PR.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T20:44:39Z", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java", "diffHunk": "@@ -87,9 +123,36 @@ public boolean intersects(SimplifiedRegexCharacterClass that, boolean defaultAns\n     return false;\n   }\n \n-  public void addRange(int from, int to, CharacterClassElementTree tree) {\n+  public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n+    if (that.containsUnknownCharacters && !defaultAnswer) {\n+      return false;\n+    }\n+    Iterator<Map.Entry<Integer, RegexSyntaxElement>> thatIter = that.contents.entrySet().iterator();\n+    if (!thatIter.hasNext()) {\n+      // that.contents is empty, any set is a superset of it\n+      return true;\n+    }\n+    Map.Entry<Integer, RegexSyntaxElement> thatEntry = thatIter.next();\n+    while (thatIter.hasNext()) {\n+      Map.Entry<Integer, RegexSyntaxElement> thatNextEntry = thatIter.next();\n+      if (thatEntry.getValue() != null) {\n+        Map.Entry<Integer, RegexSyntaxElement> thisBefore = contents.floorEntry(thatEntry.getKey());\n+        if (thisBefore == null || thisBefore.getValue() == null) {\n+          return false;\n+        }\n+        NavigableMap<Integer, RegexSyntaxElement> thisSubMap = contents.subMap(thatEntry.getKey(), false, thatNextEntry.getKey(), false);\n+        if (thisSubMap.values().stream().anyMatch(Objects::isNull)) {\n+          return false;\n+        }\n+      }\n+      thatEntry = thatNextEntry;\n+    }\n+    return true;", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22e85b2566b0b63fb173008e9dfe9e8e29405219", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\nindex 2e0445753..fe4f3fb21 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/SimplifiedRegexCharacterClass.java\n\n@@ -111,16 +111,17 @@ public class SimplifiedRegexCharacterClass {\n     Map.Entry<Integer, RegexSyntaxElement> entry = iter.next();\n     while (iter.hasNext()) {\n       Map.Entry<Integer, RegexSyntaxElement> nextEntry = iter.next();\n-      if (entry.getValue() != null) {\n-        Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(entry.getKey());\n-        if ((before != null && before.getValue() != null)\n-          || !contents.subMap(entry.getKey(), false, nextEntry.getKey(), false).isEmpty()) {\n-          return true;\n-        }\n+      if (entry.getValue() != null && hasEntryBetween(entry.getKey(), nextEntry.getKey())) {\n+        return true;\n       }\n       entry = nextEntry;\n     }\n-    return false;\n+    return entry.getValue() != null && hasEntryBetween(entry.getKey(), Character.MAX_CODE_POINT);\n+  }\n+\n+  private boolean hasEntryBetween(int from, int to) {\n+    Map.Entry<Integer, RegexSyntaxElement> before = contents.floorEntry(from);\n+    return ((before != null && before.getValue() != null) || !contents.subMap(from, false, to, false).isEmpty());\n   }\n \n   public boolean supersetOf(SimplifiedRegexCharacterClass that, boolean defaultAnswer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwNDU2NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3297#discussion_r532904564", "bodyText": "I believe we should still report the issue if the continuation is not a RegexSyntaxElement. If the non-regex-syntax continuation has a single successor (i.e. it's not a branch), we can just report on that successor instead (or, if it's still not a regex syntax element, keep following single edges until we find one or a branch). And if it's a branch (as might be the case for something like (xx++)+x) we should probably still report by only reporting on the repetition itself with the message adjusted accordingly.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-30T21:08:53Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.Collections;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.RegexTreeHelper;\n+import org.sonar.java.checks.helpers.SubAutomaton;\n+import org.sonar.java.regex.RegexCheck;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.FinalState;\n+import org.sonar.java.regex.ast.Quantifier;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.java.regex.ast.RegexSyntaxElement;\n+import org.sonar.java.regex.ast.RepetitionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5994\")\n+public class PossessiveQuantifierContinuationCheck extends AbstractRegexCheck {\n+\n+  private static final String MESSAGE = \"Change this impossible to match sub-pattern that conflicts with the previous possessive quantifier.\";\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    new Visitor(regexForLiterals.getFinalState()).visit(regexForLiterals);\n+  }\n+\n+  private class Visitor extends RegexBaseVisitor {\n+\n+    private final FinalState finalState;\n+\n+    public Visitor(FinalState finalState) {\n+      this.finalState = finalState;\n+    }\n+\n+    @Override\n+    public void visitRepetition(RepetitionTree repetitionTree) {\n+      AutomatonState continuation = repetitionTree.continuation();\n+      if (doesRepetitionContinuationAlwaysFail(repetitionTree) && continuation instanceof RegexSyntaxElement) {", "originalCommit": "5afbfeeef0963237e9835bd551e07921414592fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "351d8fbbd4b519715a1bbcbc94b4e4c6b6a37c57", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java\ndeleted file mode 100644\nindex ad4e47e33..000000000\n--- a/java-checks/src/main/java/org/sonar/java/checks/regex/PossessiveQuantifierContinuationCheck.java\n+++ /dev/null\n\n@@ -1,74 +0,0 @@\n-/*\n- * SonarQube Java\n- * Copyright (C) 2012-2020 SonarSource SA\n- * mailto:info AT sonarsource DOT com\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 3 of the License, or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n- */\n-package org.sonar.java.checks.regex;\n-\n-import java.util.Collections;\n-import org.sonar.check.Rule;\n-import org.sonar.java.checks.helpers.RegexTreeHelper;\n-import org.sonar.java.checks.helpers.SubAutomaton;\n-import org.sonar.java.regex.RegexCheck;\n-import org.sonar.java.regex.RegexParseResult;\n-import org.sonar.java.regex.ast.AutomatonState;\n-import org.sonar.java.regex.ast.FinalState;\n-import org.sonar.java.regex.ast.Quantifier;\n-import org.sonar.java.regex.ast.RegexBaseVisitor;\n-import org.sonar.java.regex.ast.RegexSyntaxElement;\n-import org.sonar.java.regex.ast.RepetitionTree;\n-import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n-\n-@Rule(key = \"S5994\")\n-public class PossessiveQuantifierContinuationCheck extends AbstractRegexCheck {\n-\n-  private static final String MESSAGE = \"Change this impossible to match sub-pattern that conflicts with the previous possessive quantifier.\";\n-\n-  @Override\n-  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n-    new Visitor(regexForLiterals.getFinalState()).visit(regexForLiterals);\n-  }\n-\n-  private class Visitor extends RegexBaseVisitor {\n-\n-    private final FinalState finalState;\n-\n-    public Visitor(FinalState finalState) {\n-      this.finalState = finalState;\n-    }\n-\n-    @Override\n-    public void visitRepetition(RepetitionTree repetitionTree) {\n-      AutomatonState continuation = repetitionTree.continuation();\n-      if (doesRepetitionContinuationAlwaysFail(repetitionTree) && continuation instanceof RegexSyntaxElement) {\n-        reportIssue((RegexSyntaxElement) continuation, MESSAGE, null,\n-            Collections.singletonList(new RegexCheck.RegexIssueLocation(repetitionTree, \"Previous possessive repetition\")));\n-      }\n-      super.visitRepetition(repetitionTree);\n-    }\n-\n-    private boolean doesRepetitionContinuationAlwaysFail(RepetitionTree repetitionTree) {\n-      if (repetitionTree.getQuantifier().getModifier() != Quantifier.Modifier.POSSESSIVE) {\n-        return false;\n-      }\n-      SubAutomaton potentialSuperset = new SubAutomaton(repetitionTree, repetitionTree.continuation(), false);\n-      SubAutomaton potentialSubset = new SubAutomaton(repetitionTree.continuation(), finalState, true);\n-      return RegexTreeHelper.supersetOf(potentialSuperset, potentialSubset, false);\n-    }\n-  }\n-\n-}\n"}}, {"oid": "22e85b2566b0b63fb173008e9dfe9e8e29405219", "url": "https://github.com/SonarSource/sonar-java/commit/22e85b2566b0b63fb173008e9dfe9e8e29405219", "message": "SONARJAVA-3550 Rule S5994: Regex patterns following a possessive quantifier should not always fail", "committedDate": "2020-12-01T09:41:06Z", "type": "forcePushed"}, {"oid": "351d8fbbd4b519715a1bbcbc94b4e4c6b6a37c57", "url": "https://github.com/SonarSource/sonar-java/commit/351d8fbbd4b519715a1bbcbc94b4e4c6b6a37c57", "message": "SONARJAVA-3564 RegexParser set activeFlags on group and character AutomatonState", "committedDate": "2020-12-01T18:45:18Z", "type": "commit"}, {"oid": "2dfedf677d8a56ac078b5f37af873fab0e307630", "url": "https://github.com/SonarSource/sonar-java/commit/2dfedf677d8a56ac078b5f37af873fab0e307630", "message": "SONARJAVA-3564 Implement supersetOf helper for regex character classes", "committedDate": "2020-12-01T18:45:19Z", "type": "commit"}, {"oid": "e004a11fe6918210d4ade5b7a214204bc2cd5132", "url": "https://github.com/SonarSource/sonar-java/commit/e004a11fe6918210d4ade5b7a214204bc2cd5132", "message": "SONARJAVA-3564 Implement intersects and supersetOf helper for regex automata without LookAroundTree, BoundaryTree and DotTree support", "committedDate": "2020-12-01T18:45:19Z", "type": "commit"}, {"oid": "53063b9bbd2d625a6ba6fb5efde28012011f0663", "url": "https://github.com/SonarSource/sonar-java/commit/53063b9bbd2d625a6ba6fb5efde28012011f0663", "message": "SONARJAVA-3564 RegexParser set activeFlags for type of AutomatonState", "committedDate": "2020-12-01T18:45:19Z", "type": "commit"}, {"oid": "076c6c4b3c1109873c944b85ef26ce91a3541494", "url": "https://github.com/SonarSource/sonar-java/commit/076c6c4b3c1109873c944b85ef26ce91a3541494", "message": "SONARJAVA-3564 Fix ReluctantQuantifierCheck getActiveFlagSet() removal", "committedDate": "2020-12-01T18:45:20Z", "type": "commit"}, {"oid": "72bc32cdf3fe00613011109bbb3bb744280cfa57", "url": "https://github.com/SonarSource/sonar-java/commit/72bc32cdf3fe00613011109bbb3bb744280cfa57", "message": "SONARJAVA-3564 DotTree support to intersects and supersetOf helper for regex automata", "committedDate": "2020-12-01T18:45:20Z", "type": "commit"}, {"oid": "726096392f5f93b17ac27efafe85852f95e6e831", "url": "https://github.com/SonarSource/sonar-java/commit/726096392f5f93b17ac27efafe85852f95e6e831", "message": "SONARJAVA-3564 intersects and supersetOf should not match empty expressions", "committedDate": "2020-12-01T18:45:21Z", "type": "commit"}, {"oid": "fff3f614e12cbc8dce52b8046446c41a6dace2fb", "url": "https://github.com/SonarSource/sonar-java/commit/fff3f614e12cbc8dce52b8046446c41a6dace2fb", "message": "SONARJAVA-3564 S5994 fix FN when repetition continuation is not a RegexSyntaxElement", "committedDate": "2020-12-01T18:45:22Z", "type": "forcePushed"}, {"oid": "3b4d4c9ead12c3ed122e55ca6d7315f41773f988", "url": "https://github.com/SonarSource/sonar-java/commit/3b4d4c9ead12c3ed122e55ca6d7315f41773f988", "message": "SONARJAVA-3550 Rule S5994: Regex patterns following a possessive quantifier should not always fail", "committedDate": "2020-12-01T19:00:00Z", "type": "commit"}, {"oid": "ee8584e9d9108b45467c211dadf5d42ede25215d", "url": "https://github.com/SonarSource/sonar-java/commit/ee8584e9d9108b45467c211dadf5d42ede25215d", "message": "SONARJAVA-3564 ReluctantQuantifierCheck support mixed active flags", "committedDate": "2020-12-01T19:00:00Z", "type": "commit"}, {"oid": "8ef074aee7950c2b912ec19ee7417c1e711ee319", "url": "https://github.com/SonarSource/sonar-java/commit/8ef074aee7950c2b912ec19ee7417c1e711ee319", "message": "SONARJAVA-3564 fix SimplifiedRegexCharacterClass for Character.MAX_CODE_POINT", "committedDate": "2020-12-01T19:00:00Z", "type": "commit"}, {"oid": "f516f9cf5c5d8879daef3770a135b351277e62a0", "url": "https://github.com/SonarSource/sonar-java/commit/f516f9cf5c5d8879daef3770a135b351277e62a0", "message": "SONARJAVA-3564 S5994 fix FN when repetition continuation is not a RegexSyntaxElement", "committedDate": "2020-12-01T19:00:00Z", "type": "commit"}, {"oid": "f516f9cf5c5d8879daef3770a135b351277e62a0", "url": "https://github.com/SonarSource/sonar-java/commit/f516f9cf5c5d8879daef3770a135b351277e62a0", "message": "SONARJAVA-3564 S5994 fix FN when repetition continuation is not a RegexSyntaxElement", "committedDate": "2020-12-01T19:00:00Z", "type": "forcePushed"}, {"oid": "c76e42d6f9a89d68e2cf33aa4646d55b45877f5b", "url": "https://github.com/SonarSource/sonar-java/commit/c76e42d6f9a89d68e2cf33aa4646d55b45877f5b", "message": "SONARJAVA-3564 Reduce complexity of SimplifiedRegexCharacterClass#supersetOf", "committedDate": "2020-12-01T19:25:21Z", "type": "commit"}]}