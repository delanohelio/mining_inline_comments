{"pr_number": 3135, "pr_title": "SONARJAVA-3069 Adapt SE engine to Switch Expressions", "pr_createdAt": "2020-08-07T18:26:09Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3135", "timeline": [{"oid": "f64e6a06959910b2410b06216ba76b99b4f14a13", "url": "https://github.com/SonarSource/sonar-java/commit/f64e6a06959910b2410b06216ba76b99b4f14a13", "message": "Fix CFG generation for switch expressions\n\nThe generated CFG for switch expressions previously included the\nswitch expression twice, once as a terminator (as it should be) and\nonce as an expression in the block that used the result of the switch\nexpression. This would make the switch expression the top of the stack\ninstead of the result and once the user popped the switch expression,\nthe result of the switch expression would be left on the stack when\nthe stack should either be empty or contain the results of other\nsubexpressions.\n\nWith the CFG fixed, switch expressions should now be handled properly\nwith no need to change the symbolic execution engine itself.", "committedDate": "2020-08-07T18:26:12Z", "type": "forcePushed"}, {"oid": "52d1f750ce5c243d236a905dd1acdc74ccce685b", "url": "https://github.com/SonarSource/sonar-java/commit/52d1f750ce5c243d236a905dd1acdc74ccce685b", "message": "Track values through switch statements", "committedDate": "2020-08-13T15:22:17Z", "type": "forcePushed"}, {"oid": "09b4e0e23684d48b4dbd158cc1a6e4a2ede8b135", "url": "https://github.com/SonarSource/sonar-java/commit/09b4e0e23684d48b4dbd158cc1a6e4a2ede8b135", "message": "Track values through switch statements", "committedDate": "2020-08-13T15:41:06Z", "type": "forcePushed"}, {"oid": "ee70212250619473a5cdca2e1962b08b9f4c5b34", "url": "https://github.com/SonarSource/sonar-java/commit/ee70212250619473a5cdca2e1962b08b9f4c5b34", "message": "Track values through switch statements", "committedDate": "2020-08-13T15:50:52Z", "type": "forcePushed"}, {"oid": "6854260d3c575d620bf53953af0b18f93f378dec", "url": "https://github.com/SonarSource/sonar-java/commit/6854260d3c575d620bf53953af0b18f93f378dec", "message": "Track values through switch statements", "committedDate": "2020-08-13T17:03:09Z", "type": "forcePushed"}, {"oid": "32c5706bfc9b357a4f4171c8590b30c28e4f49d5", "url": "https://github.com/SonarSource/sonar-java/commit/32c5706bfc9b357a4f4171c8590b30c28e4f49d5", "message": "Track values through switch statements", "committedDate": "2020-08-14T10:18:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU0NjI1MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3135#discussion_r470546251", "bodyText": "Is this always true or just in the case of boolean constraints? If not, under which conditions would SymbolicValue.setConstraint return a list of multiple items? And if so, why doesn't it return an option instead of a list?", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-08-14T10:32:55Z", "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "diffHunk": "@@ -502,6 +512,59 @@ private static ExpressionTree cleanupCondition(ExpressionTree condition) {\n     return cleanedUpCondition;\n   }\n \n+  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n+    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n+    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n+    ProgramState state = poppedSwitchValue.state;\n+\n+    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n+    for (CaseGroupTree caseGroup : caseGroups) {\n+      int numberOfCaseValues = caseGroup.labels()\n+        .stream()\n+        .map(CaseLabelTree::expressions)\n+        .mapToInt(List::size)\n+        .sum();\n+      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n+      state = poppedCaseValues.state;\n+      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n+    }\n+\n+    ProgramState elseState = state;\n+    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n+    // default block exists, the block after the switch statement.\n+    CFG.Block elseBlock = null;\n+    for (CFG.Block successor : programPosition.successors()) {\n+      CaseGroupTree caseGroup = successor.caseGroup();\n+      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+        continue;\n+      }\n+\n+      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n+        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n+        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n+        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n+        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n+      }\n+      if (successor.isDefaultBlock()) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+      }\n+    }\n+    assert(elseBlock != null);\n+    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n+  }\n+\n+  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {\n+    List<ProgramState> states = condition.setConstraint(state, constraint);\n+    if (states.isEmpty()) {\n+      return state;\n+    }\n+    assert(states.size() == 1);", "originalCommit": "32c5706bfc9b357a4f4171c8590b30c28e4f49d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6da93bac149186c3b6602a964ea294d621b04fe9", "chunk": "diff --git a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\nindex 423281da7..18ed5d145 100644\n--- a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\n+++ b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\n\n@@ -512,59 +502,6 @@ public class ExplodedGraphWalker {\n     return cleanedUpCondition;\n   }\n \n-  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n-    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n-    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n-    ProgramState state = poppedSwitchValue.state;\n-\n-    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n-    for (CaseGroupTree caseGroup : caseGroups) {\n-      int numberOfCaseValues = caseGroup.labels()\n-        .stream()\n-        .map(CaseLabelTree::expressions)\n-        .mapToInt(List::size)\n-        .sum();\n-      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n-      state = poppedCaseValues.state;\n-      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n-    }\n-\n-    ProgramState elseState = state;\n-    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n-    // default block exists, the block after the switch statement.\n-    CFG.Block elseBlock = null;\n-    for (CFG.Block successor : programPosition.successors()) {\n-      CaseGroupTree caseGroup = successor.caseGroup();\n-      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n-        assert(elseBlock == null);\n-        elseBlock = successor;\n-        continue;\n-      }\n-\n-      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n-        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n-        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n-        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n-        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n-      }\n-      if (successor.isDefaultBlock()) {\n-        assert(elseBlock == null);\n-        elseBlock = successor;\n-      }\n-    }\n-    assert(elseBlock != null);\n-    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n-  }\n-\n-  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {\n-    List<ProgramState> states = condition.setConstraint(state, constraint);\n-    if (states.isEmpty()) {\n-      return state;\n-    }\n-    assert(states.size() == 1);\n-    return states.get(0);\n-  }\n-\n   private void handleBranch(CFG.Block programPosition, Tree condition) {\n     handleBranch(programPosition, condition, true);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU0ODQ2Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3135#discussion_r470548466", "bodyText": "I'm a bit unsure about this method because I'm generally a bit unsure about what SymbolicValue.setConstraint does (compared to ProgramState.addConstraint). From the code it looks like it adds the constraint unless it's already there, but that doesn't explain why it failed to properly add the constraints when I used ProgramState.addConstraint instead of this method.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-08-14T10:38:18Z", "path": "java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java", "diffHunk": "@@ -502,6 +512,59 @@ private static ExpressionTree cleanupCondition(ExpressionTree condition) {\n     return cleanedUpCondition;\n   }\n \n+  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n+    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n+    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n+    ProgramState state = poppedSwitchValue.state;\n+\n+    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n+    for (CaseGroupTree caseGroup : caseGroups) {\n+      int numberOfCaseValues = caseGroup.labels()\n+        .stream()\n+        .map(CaseLabelTree::expressions)\n+        .mapToInt(List::size)\n+        .sum();\n+      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n+      state = poppedCaseValues.state;\n+      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n+    }\n+\n+    ProgramState elseState = state;\n+    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n+    // default block exists, the block after the switch statement.\n+    CFG.Block elseBlock = null;\n+    for (CFG.Block successor : programPosition.successors()) {\n+      CaseGroupTree caseGroup = successor.caseGroup();\n+      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+        continue;\n+      }\n+\n+      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n+        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n+        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n+        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n+        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n+      }\n+      if (successor.isDefaultBlock()) {\n+        assert(elseBlock == null);\n+        elseBlock = successor;\n+      }\n+    }\n+    assert(elseBlock != null);\n+    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n+  }\n+\n+  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {", "originalCommit": "32c5706bfc9b357a4f4171c8590b30c28e4f49d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6da93bac149186c3b6602a964ea294d621b04fe9", "chunk": "diff --git a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\nindex 423281da7..18ed5d145 100644\n--- a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\n+++ b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java\n\n@@ -512,59 +502,6 @@ public class ExplodedGraphWalker {\n     return cleanedUpCondition;\n   }\n \n-  private void handleSwitch(CFG.Block programPosition, List<CaseGroupTree> caseGroups) {\n-    ProgramState.Pop poppedSwitchValue = programState.unstackValue(1);\n-    ProgramState.SymbolicValueSymbol switchValue = poppedSwitchValue.valuesAndSymbols.get(0);\n-    ProgramState state = poppedSwitchValue.state;\n-\n-    Map<CaseGroupTree, List<ProgramState.SymbolicValueSymbol>> caseValues = new HashMap<>();\n-    for (CaseGroupTree caseGroup : caseGroups) {\n-      int numberOfCaseValues = caseGroup.labels()\n-        .stream()\n-        .map(CaseLabelTree::expressions)\n-        .mapToInt(List::size)\n-        .sum();\n-      ProgramState.Pop poppedCaseValues = state.unstackValue(numberOfCaseValues);\n-      state = poppedCaseValues.state;\n-      caseValues.put(caseGroup, poppedCaseValues.valuesAndSymbols);\n-    }\n-\n-    ProgramState elseState = state;\n-    // The block that will be taken when all case-conditions are false. This will either be the default-block or, if no\n-    // default block exists, the block after the switch statement.\n-    CFG.Block elseBlock = null;\n-    for (CFG.Block successor : programPosition.successors()) {\n-      CaseGroupTree caseGroup = successor.caseGroup();\n-      if (caseGroup == null || !caseValues.containsKey(caseGroup)) {\n-        assert(elseBlock == null);\n-        elseBlock = successor;\n-        continue;\n-      }\n-\n-      for (ProgramState.SymbolicValueSymbol caseValue : caseValues.get(caseGroup)) {\n-        SymbolicValue equality = constraintManager.createEquality(switchValue, caseValue);\n-        ProgramState ps = setConstraint(state, equality, BooleanConstraint.TRUE);\n-        enqueue(new ProgramPoint(successor), ps, node.exitPath);\n-        elseState = setConstraint(elseState, equality, BooleanConstraint.FALSE);\n-      }\n-      if (successor.isDefaultBlock()) {\n-        assert(elseBlock == null);\n-        elseBlock = successor;\n-      }\n-    }\n-    assert(elseBlock != null);\n-    enqueue(new ProgramPoint(elseBlock), elseState, node.exitPath);\n-  }\n-\n-  private static ProgramState setConstraint(ProgramState state, SymbolicValue condition, BooleanConstraint constraint) {\n-    List<ProgramState> states = condition.setConstraint(state, constraint);\n-    if (states.isEmpty()) {\n-      return state;\n-    }\n-    assert(states.size() == 1);\n-    return states.get(0);\n-  }\n-\n   private void handleBranch(CFG.Block programPosition, Tree condition) {\n     handleBranch(programPosition, condition, true);\n   }\n"}}, {"oid": "db7af7ee0cf4008089c3fa961f3c0d3fb1249e7a", "url": "https://github.com/SonarSource/sonar-java/commit/db7af7ee0cf4008089c3fa961f3c0d3fb1249e7a", "message": "Track values through switch statements", "committedDate": "2020-08-14T13:19:30Z", "type": "forcePushed"}, {"oid": "6da93bac149186c3b6602a964ea294d621b04fe9", "url": "https://github.com/SonarSource/sonar-java/commit/6da93bac149186c3b6602a964ea294d621b04fe9", "message": "Fix CFG generation for switch expressions\n\nThe generated CFG for switch expressions previously included the\nswitch expression twice, once as a terminator (as it should be) and\nonce as an expression in the block that used the result of the switch\nexpression. This would make the switch expression the top of the stack\ninstead of the result and once the user popped the switch expression,\nthe result of the switch expression would be left on the stack when\nthe stack should either be empty or contain the results of other\nsubexpressions.", "committedDate": "2020-08-24T09:14:57Z", "type": "commit"}, {"oid": "167d86b267bcd03ac384dc7a7247725d40b8e016", "url": "https://github.com/SonarSource/sonar-java/commit/167d86b267bcd03ac384dc7a7247725d40b8e016", "message": "Change order of switch stack consumption in ExplodedGraphWalker", "committedDate": "2020-08-24T09:15:54Z", "type": "forcePushed"}, {"oid": "acf7292b012744e2b443ea0c17f619e8f30f8551", "url": "https://github.com/SonarSource/sonar-java/commit/acf7292b012744e2b443ea0c17f619e8f30f8551", "message": "Track values through switch statements", "committedDate": "2020-08-24T11:40:45Z", "type": "commit"}, {"oid": "10eda88a51fd18adaa2d5030c493e8f421eeced0", "url": "https://github.com/SonarSource/sonar-java/commit/10eda88a51fd18adaa2d5030c493e8f421eeced0", "message": "Fix order of switch elements addition in block", "committedDate": "2020-08-24T11:40:45Z", "type": "commit"}, {"oid": "3e3aa82da5068608c41ff3c9585585e18cd60973", "url": "https://github.com/SonarSource/sonar-java/commit/3e3aa82da5068608c41ff3c9585585e18cd60973", "message": "Change order of switch stack consumption in ExplodedGraphWalker", "committedDate": "2020-08-24T11:40:45Z", "type": "commit"}, {"oid": "3e3aa82da5068608c41ff3c9585585e18cd60973", "url": "https://github.com/SonarSource/sonar-java/commit/3e3aa82da5068608c41ff3c9585585e18cd60973", "message": "Change order of switch stack consumption in ExplodedGraphWalker", "committedDate": "2020-08-24T11:40:45Z", "type": "forcePushed"}, {"oid": "ddd8e452ef12b40d7d6bec93b55690d7a8c2e8bd", "url": "https://github.com/SonarSource/sonar-java/commit/ddd8e452ef12b40d7d6bec93b55690d7a8c2e8bd", "message": "Use Preconditions instead of asserts and fix code smells", "committedDate": "2020-08-24T15:32:08Z", "type": "commit"}]}