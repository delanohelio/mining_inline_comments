{"pr_number": 3237, "pr_title": "SONARJAVA-3547 Improve rule S1612 to replace casts with method reference", "pr_createdAt": "2020-10-05T16:54:44Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3237", "timeline": [{"oid": "37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "url": "https://github.com/SonarSource/sonar-java/commit/37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "message": "SONARJAVA-3547 Improve rule S1612 to replace casts with method reference", "committedDate": "2020-10-07T16:09:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4MTMzNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3237#discussion_r501481336", "bodyText": "what if the type is unknown but the symbols are matched by the frontend? I fear it's going to return \"!unknown!\" here.\nInstead of:\nreturn Optional.of(typeCastTree.type().symbolType().name());\nI would use something like so we use directly the TypeTree, which, even unresolved, will display the correct name:\nreturn Optional.of(ExpressionsHelper.concatenate(typeCastTree.type()));", "author": "m-g-sonar", "createdAt": "2020-10-08T06:40:57Z", "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -106,6 +127,23 @@ private void visitLambdaExpression(LambdaExpressionTree tree) {\n     return Optional.empty();\n   }\n \n+  private static Optional<String> getTypeCast(@Nullable Tree statement, LambdaExpressionTree tree) {\n+    if (statement == null) {\n+      return Optional.empty();\n+    }\n+    Tree expr = statement;\n+    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {\n+      expr = ExpressionUtils.skipParentheses((ParenthesizedTree) statement);\n+    }\n+    if (expr.is(Tree.Kind.TYPE_CAST)) {\n+      TypeCastTree typeCastTree = (TypeCastTree) expr;\n+      if (isSingleParamCast(typeCastTree.expression(), tree)) {\n+        return Optional.of(typeCastTree.type().symbolType().name());", "originalCommit": "37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9dae2d7a47813bcc1e999a7dff10317af5dae2ad", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\nindex e0f53ef16..54eb14cb4 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n\n@@ -131,10 +127,11 @@ public class ReplaceLambdaByMethodRefCheck extends SubscriptionVisitor {\n     if (statement == null) {\n       return Optional.empty();\n     }\n-    Tree expr = statement;\n-    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {\n-      expr = ExpressionUtils.skipParentheses((ParenthesizedTree) statement);\n-    }\n+    return ExpressionUtils.skipParentheses(statement)\n+      .flatMap(expr -> getTypeCastName(tree, expr));\n+  }\n+\n+  private static Optional<String> getTypeCastName(LambdaExpressionTree tree, ExpressionTree expr) {\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), tree)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4MTkxMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3237#discussion_r501481910", "bodyText": "I feel this check defeats a bit the purpose of using ExpressionUtils.skipParentheses(...);, Won't it be possible to already arrive here which a (Nullable) ExpressionTree instead? It would make things easier.", "author": "m-g-sonar", "createdAt": "2020-10-08T06:42:25Z", "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -106,6 +127,23 @@ private void visitLambdaExpression(LambdaExpressionTree tree) {\n     return Optional.empty();\n   }\n \n+  private static Optional<String> getTypeCast(@Nullable Tree statement, LambdaExpressionTree tree) {\n+    if (statement == null) {\n+      return Optional.empty();\n+    }\n+    Tree expr = statement;\n+    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {", "originalCommit": "37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9dae2d7a47813bcc1e999a7dff10317af5dae2ad", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\nindex e0f53ef16..54eb14cb4 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n\n@@ -131,10 +127,11 @@ public class ReplaceLambdaByMethodRefCheck extends SubscriptionVisitor {\n     if (statement == null) {\n       return Optional.empty();\n     }\n-    Tree expr = statement;\n-    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {\n-      expr = ExpressionUtils.skipParentheses((ParenthesizedTree) statement);\n-    }\n+    return ExpressionUtils.skipParentheses(statement)\n+      .flatMap(expr -> getTypeCastName(tree, expr));\n+  }\n+\n+  private static Optional<String> getTypeCastName(LambdaExpressionTree tree, ExpressionTree expr) {\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n       if (isSingleParamCast(typeCastTree.expression(), tree)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4MzIyOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3237#discussion_r501483228", "bodyText": "The only reason of keeping the lambda as 2nd parameter is to ultimately check for the parameter symbol (3 calls below). Wouldn't it be possible to check this earlier (only one param for instance) and only pass a symbol?", "author": "m-g-sonar", "createdAt": "2020-10-08T06:45:33Z", "path": "java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -87,6 +93,21 @@ private void visitLambdaExpression(LambdaExpressionTree tree) {\n     return Optional.empty();\n   }\n \n+  private static Optional<String> getTypeCast(LambdaExpressionTree lambda) {\n+    Tree lambdaBody = lambda.body();\n+    if (isBlockWithOneStatement(lambdaBody)) {\n+      return getTypeCastFromReturn(((BlockTree) lambdaBody).body().get(0), lambda);\n+    }\n+    return getTypeCast(lambdaBody, lambda);\n+  }\n+\n+  private static Optional<String> getTypeCastFromReturn(Tree statement, LambdaExpressionTree lambda) {", "originalCommit": "37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6b5840fe72d8a272aca0c03a7c93775e6c10594f", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\nindex e0f53ef16..cbacd3e5b 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/ReplaceLambdaByMethodRefCheck.java\n\n@@ -55,109 +54,102 @@ public class ReplaceLambdaByMethodRefCheck extends SubscriptionVisitor {\n \n   @Override\n   public void visitNode(Tree tree) {\n-    if (!hasSemantic()) {\n-      return;\n-    }\n     visitLambdaExpression((LambdaExpressionTree) tree);\n   }\n \n   private void visitLambdaExpression(LambdaExpressionTree tree) {\n     if (isReplaceableSingleMethodInvocation(tree) || isBodyBlockInvokingMethod(tree)) {\n-      context.reportIssue(this, tree.arrowToken(), \"Replace this lambda with a method reference.\" + context.getJavaVersion().java8CompatibilityMessage());\n+      reportIssue(tree.arrowToken(), \"Replace this lambda with a method reference.\" + context.getJavaVersion().java8CompatibilityMessage());\n     } else {\n       getTypeCast(tree)\n-        .ifPresent(type ->\n-          context.reportIssue(this, tree.arrowToken(),\n-            \"Replace this lambda with method reference '\" + type + \".class::cast'.\" + context.getJavaVersion().java8CompatibilityMessage())\n-        );\n+        .ifPresent(type -> reportIssue(tree.arrowToken(),\n+          \"Replace this lambda with method reference '\" + type + \".class::cast'.\" + context.getJavaVersion().java8CompatibilityMessage()));\n       getNullCheck(tree)\n-        .ifPresent(nullMethod ->\n-          context.reportIssue(this, tree.arrowToken(),\n-            \"Replace this lambda with method reference 'Objects::\" + nullMethod + \"'.\" + context.getJavaVersion().java8CompatibilityMessage())\n-        );\n+        .ifPresent(nullMethod -> reportIssue(tree.arrowToken(),\n+          \"Replace this lambda with method reference 'Objects::\" + nullMethod + \"'.\" + context.getJavaVersion().java8CompatibilityMessage()));\n     }\n   }\n \n   private static Optional<String> getNullCheck(LambdaExpressionTree lambda) {\n-    Tree lambdaBody = lambda.body();\n-    if (isBlockWithOneStatement(lambdaBody)) {\n-      return getNullCheckFromReturn(((BlockTree) lambdaBody).body().get(0), lambda);\n-    }\n-    return getNullCheck(lambdaBody, lambda);\n+    return getLambdaSingleParamSymbol(lambda).flatMap(symbol -> {\n+      Tree lambdaBody = lambda.body();\n+      if (isBlockWithOneStatement(lambdaBody)) {\n+        return getNullCheckFromReturn(((BlockTree) lambdaBody).body().get(0), symbol);\n+      }\n+      return getNullCheck(lambdaBody, symbol);\n+    });\n   }\n \n-  private static Optional<String> getNullCheckFromReturn(Tree statement, LambdaExpressionTree lambda) {\n+  private static Optional<String> getNullCheckFromReturn(Tree statement, Symbol paramSymbol) {\n     if (statement.is(Tree.Kind.RETURN_STATEMENT)) {\n-      return getNullCheck(((ReturnStatementTree) statement).expression(), lambda);\n+      return getNullCheck(((ReturnStatementTree) statement).expression(), paramSymbol);\n     }\n     return Optional.empty();\n   }\n \n-  private static Optional<String> getTypeCast(LambdaExpressionTree lambda) {\n-    Tree lambdaBody = lambda.body();\n-    if (isBlockWithOneStatement(lambdaBody)) {\n-      return getTypeCastFromReturn(((BlockTree) lambdaBody).body().get(0), lambda);\n-    }\n-    return getTypeCast(lambdaBody, lambda);\n+  private static Optional<String> getNullCheck(@Nullable Tree statement, Symbol paramSymbol) {\n+    return ExpressionUtils.expressionWithoutParentheses(statement).flatMap(expr -> {\n+      if (expr.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {\n+        BinaryExpressionTree bet = (BinaryExpressionTree) expr;\n+        ExpressionTree leftOperand = ExpressionUtils.skipParentheses(bet.leftOperand());\n+        ExpressionTree rightOperand = ExpressionUtils.skipParentheses(bet.rightOperand());\n+        if (nullAgainstParam(leftOperand, rightOperand, paramSymbol) || nullAgainstParam(rightOperand, leftOperand, paramSymbol)) {\n+          return Optional.of(expr.is(Tree.Kind.EQUAL_TO) ? \"isNull\" : \"nonNull\");\n+        }\n+      }\n+      return Optional.empty();\n+    });\n   }\n \n-  private static Optional<String> getTypeCastFromReturn(Tree statement, LambdaExpressionTree lambda) {\n-    if (statement.is(Tree.Kind.RETURN_STATEMENT)) {\n-      return getTypeCast(((ReturnStatementTree) statement).expression(), lambda);\n+  private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Symbol paramSymbol) {\n+    if (o1.is(Tree.Kind.NULL_LITERAL) && o2.is(Tree.Kind.IDENTIFIER)) {\n+      return paramSymbol.equals(((IdentifierTree) o2).symbol());\n     }\n-    return Optional.empty();\n+    return false;\n   }\n \n-  private static Optional<String> getNullCheck(@Nullable Tree statement, LambdaExpressionTree tree) {\n-    if (statement == null) {\n-      return Optional.empty();\n-    }\n-    Tree expr = statement;\n-    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {\n-      expr = ExpressionUtils.skipParentheses((ParenthesizedTree) statement);\n-    }\n-    if (expr.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {\n-      BinaryExpressionTree bet = (BinaryExpressionTree) expr;\n-      ExpressionTree leftOperand = ExpressionUtils.skipParentheses(bet.leftOperand());\n-      ExpressionTree rightOperand = ExpressionUtils.skipParentheses(bet.rightOperand());\n-      if (nullAgainstParam(leftOperand, rightOperand, tree) || nullAgainstParam(rightOperand, leftOperand, tree)) {\n-        return Optional.of(expr.is(Tree.Kind.EQUAL_TO) ? \"isNull\" : \"nonNull\");\n+  private static Optional<String> getTypeCast(LambdaExpressionTree lambda) {\n+    return getLambdaSingleParamSymbol(lambda).flatMap(symbol -> {\n+      Tree lambdaBody = lambda.body();\n+      if (isBlockWithOneStatement(lambdaBody)) {\n+        return getTypeCastFromReturn(((BlockTree) lambdaBody).body().get(0), symbol);\n       }\n+      return getTypeCast(lambdaBody, symbol);\n+    });\n+  }\n+\n+  private static Optional<String> getTypeCastFromReturn(Tree statement, Symbol symbol) {\n+    if (statement.is(Tree.Kind.RETURN_STATEMENT)) {\n+      return getTypeCast(((ReturnStatementTree) statement).expression(), symbol);\n     }\n     return Optional.empty();\n   }\n \n-  private static Optional<String> getTypeCast(@Nullable Tree statement, LambdaExpressionTree tree) {\n+  private static Optional<String> getTypeCast(@Nullable Tree statement, Symbol symbol) {\n     if (statement == null) {\n       return Optional.empty();\n     }\n-    Tree expr = statement;\n-    if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {\n-      expr = ExpressionUtils.skipParentheses((ParenthesizedTree) statement);\n-    }\n+    return ExpressionUtils.expressionWithoutParentheses(statement)\n+      .flatMap(expr -> getTypeCastName(symbol, expr));\n+  }\n+\n+  private static Optional<String> getTypeCastName(Symbol symbol, ExpressionTree expr) {\n     if (expr.is(Tree.Kind.TYPE_CAST)) {\n       TypeCastTree typeCastTree = (TypeCastTree) expr;\n-      if (isSingleParamCast(typeCastTree.expression(), tree)) {\n+      if (isSingleParamCast(typeCastTree.expression(), symbol)) {\n         return Optional.of(typeCastTree.type().symbolType().name());\n       }\n     }\n     return Optional.empty();\n   }\n \n-  private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, LambdaExpressionTree tree) {\n-    if (o1.is(Tree.Kind.NULL_LITERAL) && o2.is(Tree.Kind.IDENTIFIER)) {\n-      List<VariableTree> parameters = tree.parameters();\n-      return parameters.size() == 1 && parameters.get(0).symbol().equals(((IdentifierTree) o2).symbol());\n-    }\n-    return false;\n+  private static boolean isSingleParamCast(ExpressionTree expression, Symbol symbol) {\n+    return expression.is(Tree.Kind.IDENTIFIER) && symbol.equals(((IdentifierTree) expression).symbol());\n   }\n \n-  private static boolean isSingleParamCast(ExpressionTree expression, LambdaExpressionTree tree) {\n-    if (expression.is(Tree.Kind.IDENTIFIER)) {\n-      List<VariableTree> parameters = tree.parameters();\n-      return parameters.size() == 1 && parameters.get(0).symbol().equals(((IdentifierTree) expression).symbol());\n-    }\n-    return false;\n+  private static Optional<Symbol> getLambdaSingleParamSymbol(LambdaExpressionTree tree) {\n+    List<VariableTree> parameters = tree.parameters();\n+    return parameters.size() == 1 ? Optional.of(parameters.get(0).symbol()) : Optional.empty();\n   }\n \n   private static boolean isReplaceableSingleMethodInvocation(LambdaExpressionTree lambdaTree) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ4MzYwNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3237#discussion_r501483606", "bodyText": "This change does not seem required to me, you kept it in the other file.", "author": "m-g-sonar", "createdAt": "2020-10-08T06:46:25Z", "path": "java-checks-test-sources/src/main/files/non-compiling/checks/ReplaceLambdaByMethodRefCheck.java", "diffHunk": "@@ -1,4 +1,10 @@\n-import java.util.*;", "originalCommit": "37ed9cc545fc1bf106ccab5961b068e0f8dac3b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f20a04203eff7245ace3b97127017dea9d67aaf5", "chunk": "diff --git a/java-checks-test-sources/src/main/files/non-compiling/checks/ReplaceLambdaByMethodRefCheck.java b/java-checks-test-sources/src/main/files/non-compiling/checks/ReplaceLambdaByMethodRefCheck.java\nindex c3b575e46..80999386a 100644\n--- a/java-checks-test-sources/src/main/files/non-compiling/checks/ReplaceLambdaByMethodRefCheck.java\n+++ b/java-checks-test-sources/src/main/files/non-compiling/checks/ReplaceLambdaByMethodRefCheck.java\n\n@@ -1,10 +1,6 @@\n package checks;\n \n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n+import java.util.*;\n import java.util.function.BiConsumer;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n"}}, {"oid": "9dae2d7a47813bcc1e999a7dff10317af5dae2ad", "url": "https://github.com/SonarSource/sonar-java/commit/9dae2d7a47813bcc1e999a7dff10317af5dae2ad", "message": "WIP", "committedDate": "2020-11-12T13:48:13Z", "type": "forcePushed"}, {"oid": "6b5840fe72d8a272aca0c03a7c93775e6c10594f", "url": "https://github.com/SonarSource/sonar-java/commit/6b5840fe72d8a272aca0c03a7c93775e6c10594f", "message": "WIP", "committedDate": "2020-11-13T12:29:52Z", "type": "forcePushed"}, {"oid": "f20a04203eff7245ace3b97127017dea9d67aaf5", "url": "https://github.com/SonarSource/sonar-java/commit/f20a04203eff7245ace3b97127017dea9d67aaf5", "message": "WIP", "committedDate": "2020-11-13T12:33:48Z", "type": "forcePushed"}, {"oid": "25886ec980b1daa653a2f6a55241bc2872cd8298", "url": "https://github.com/SonarSource/sonar-java/commit/25886ec980b1daa653a2f6a55241bc2872cd8298", "message": "WIP", "committedDate": "2020-11-13T12:56:41Z", "type": "forcePushed"}, {"oid": "df28299a82f39a603ed401d72fb486c553140939", "url": "https://github.com/SonarSource/sonar-java/commit/df28299a82f39a603ed401d72fb486c553140939", "message": "WIP", "committedDate": "2020-11-13T13:13:34Z", "type": "forcePushed"}, {"oid": "e46620b077288f73cd9446df1a089f48dd7b6f4e", "url": "https://github.com/SonarSource/sonar-java/commit/e46620b077288f73cd9446df1a089f48dd7b6f4e", "message": "SONARJAVA-3547 Improve rule S1612 to replace casts with method reference", "committedDate": "2020-11-13T13:18:26Z", "type": "forcePushed"}, {"oid": "8bf41b53554b8ed1be631924115be2a16961e7bb", "url": "https://github.com/SonarSource/sonar-java/commit/8bf41b53554b8ed1be631924115be2a16961e7bb", "message": "SONARJAVA-3547 Improve rule S1612 to replace casts with method reference", "committedDate": "2020-11-13T13:43:44Z", "type": "commit"}, {"oid": "8bf41b53554b8ed1be631924115be2a16961e7bb", "url": "https://github.com/SonarSource/sonar-java/commit/8bf41b53554b8ed1be631924115be2a16961e7bb", "message": "SONARJAVA-3547 Improve rule S1612 to replace casts with method reference", "committedDate": "2020-11-13T13:43:44Z", "type": "forcePushed"}]}