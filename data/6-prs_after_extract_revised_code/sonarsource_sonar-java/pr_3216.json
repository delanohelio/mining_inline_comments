{"pr_number": 3216, "pr_title": "SONARJAVA-3396 Rule S5808 Authorizations should be based on strong decisions", "pr_createdAt": "2020-09-25T14:05:53Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3216", "timeline": [{"oid": "9fa69ba13a5453db31fa825fa70af7b30c139460", "url": "https://github.com/SonarSource/sonar-java/commit/9fa69ba13a5453db31fa825fa70af7b30c139460", "message": "SONARJAVA-3396 Rule S5808 Authorizations should be based on strong decisions", "committedDate": "2020-09-25T14:04:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxODY4Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3216#discussion_r495818687", "bodyText": "An identifier could be different from ACCESS_GRANTED, ACCESS_ABSTAIN, ACCESS_DENIED, true, false like a variable, and in this case it could be complex. This is a FP:\n    @Override\n    public int vote(Authentication authentication, Object object, Collection collection) { // false-positive\n      int access = ACCESS_DENIED;\n      if(testAccess(authentication, object, collection)) {\n        access = ACCESS_GRANTED;\n      }\n      return access;\n    }", "author": "alban-auzeill", "createdAt": "2020-09-28T09:48:56Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/AuthorizationsStrongDecisionsCheck.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.ReturnStatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5808\")\n+public class AuthorizationsStrongDecisionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String AUTHENTICATION = \"org.springframework.security.core.Authentication\";\n+  private static final String JAVA_OBJECT = \"java.lang.Object\";\n+\n+  private static final MethodMatchers ACCESS_DECISION_VOTER_VOTE = MethodMatchers.create()\n+    .ofSubTypes(\"org.springframework.security.access.AccessDecisionVoter\")\n+    .names(\"vote\")\n+    .addParametersMatcher(AUTHENTICATION, JAVA_OBJECT, \"java.util.Collection\")\n+    .build();\n+\n+  private static final MethodMatchers PERMISSION_EVALUATOR_HAS_PERMISSION = MethodMatchers.create()\n+    .ofSubTypes(\"org.springframework.security.access.PermissionEvaluator\")\n+    .names(\"hasPermission\")\n+    .addParametersMatcher(AUTHENTICATION, JAVA_OBJECT, JAVA_OBJECT)\n+    .addParametersMatcher(AUTHENTICATION, \"java.io.Serializable\", \"java.lang.String\", JAVA_OBJECT)\n+    .build();\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodTree methodTree = (MethodTree) tree;\n+    if (ACCESS_DECISION_VOTER_VOTE.matches(methodTree)) {\n+      reportNoStrongDecision(methodTree,\n+        e -> e.is(Tree.Kind.IDENTIFIER) && \"ACCESS_DENIED\".equals(((IdentifierTree) e).name()), \"vote\", \"ACCESS_DENIED\");\n+    } else if (PERMISSION_EVALUATOR_HAS_PERMISSION.matches(methodTree)) {\n+      reportNoStrongDecision(methodTree, e -> e.asConstant(Boolean.class).filter(Boolean.FALSE::equals).isPresent(), \"hasPermission\", \"false\");\n+    }\n+  }\n+\n+  private void reportNoStrongDecision(MethodTree methodTree, Predicate<ExpressionTree> isStrongDecision, String methodName, String strongDecision) {\n+    ReturnStatementVisitor returnStatementVisitor = new ReturnStatementVisitor(isStrongDecision);\n+    methodTree.accept(returnStatementVisitor);\n+    if (!returnStatementVisitor.takesStrongDecision()) {\n+      reportIssue(methodTree.simpleName(), String.format(\"\\\"%s\\\" method should return at least one time %s.\", methodName, strongDecision));\n+    }\n+  }\n+\n+  private static class ReturnStatementVisitor extends BaseTreeVisitor {\n+\n+    private final Predicate<ExpressionTree> isStrongDecision;\n+    private boolean containsComplexReturn = false;\n+    private boolean takesStrongDecision = false;\n+\n+    ReturnStatementVisitor(Predicate<ExpressionTree> isStrongDecision) {\n+      this.isStrongDecision = isStrongDecision;\n+    }\n+\n+    public boolean takesStrongDecision() {\n+      // We don't compute the return value when the expression is complex (method call, expression),\n+      // and consider it as strong decision to avoid FP\n+      return takesStrongDecision || containsComplexReturn;\n+    }\n+\n+    @Override\n+    public void visitReturnStatement(ReturnStatementTree tree) {\n+      ExpressionTree expression = tree.expression();\n+      if (expression != null && (expression instanceof LiteralTree || expression.is(Tree.Kind.IDENTIFIER))) {", "originalCommit": "9fa69ba13a5453db31fa825fa70af7b30c139460", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b05b754982a426bee58ed14247a0cb4181619b13", "chunk": "diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/AuthorizationsStrongDecisionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/AuthorizationsStrongDecisionsCheck.java\nindex 34c6d6b09..fdb1c675e 100644\n--- a/java-checks/src/main/java/org/sonar/java/checks/security/AuthorizationsStrongDecisionsCheck.java\n+++ b/java-checks/src/main/java/org/sonar/java/checks/security/AuthorizationsStrongDecisionsCheck.java\n\n@@ -63,10 +63,9 @@ public class AuthorizationsStrongDecisionsCheck extends IssuableSubscriptionVisi\n   public void visitNode(Tree tree) {\n     MethodTree methodTree = (MethodTree) tree;\n     if (ACCESS_DECISION_VOTER_VOTE.matches(methodTree)) {\n-      reportNoStrongDecision(methodTree,\n-        e -> e.is(Tree.Kind.IDENTIFIER) && \"ACCESS_DENIED\".equals(((IdentifierTree) e).name()), \"vote\", \"ACCESS_DENIED\");\n+      reportNoStrongDecision(methodTree, AuthorizationsStrongDecisionsCheck::isStrongVoteDecision, \"vote\", \"ACCESS_DENIED\");\n     } else if (PERMISSION_EVALUATOR_HAS_PERMISSION.matches(methodTree)) {\n-      reportNoStrongDecision(methodTree, e -> e.asConstant(Boolean.class).filter(Boolean.FALSE::equals).isPresent(), \"hasPermission\", \"false\");\n+      reportNoStrongDecision(methodTree, AuthorizationsStrongDecisionsCheck::isStrongHasPermissionDecision, \"hasPermission\", \"false\");\n     }\n   }\n \n"}}, {"oid": "b05b754982a426bee58ed14247a0cb4181619b13", "url": "https://github.com/SonarSource/sonar-java/commit/b05b754982a426bee58ed14247a0cb4181619b13", "message": "Better support of identifier returned", "committedDate": "2020-09-28T12:18:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAzNTI1NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3216#discussion_r496035254", "bodyText": "There's false-negatives because we don't support the second form:\n\nreturn ACCESS_GRANTED;\nreturn AccessDecisionVoter.ACCESS_GRANTED;", "author": "alban-auzeill", "createdAt": "2020-09-28T15:22:13Z", "path": "java-checks-test-sources/src/main/java/checks/security/AuthorizationsStrongDecisionsCheck.java", "diffHunk": "@@ -0,0 +1,298 @@\n+package checks.security;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.function.Predicate;\n+import org.springframework.security.access.AccessDecisionVoter;\n+import org.springframework.security.access.ConfigAttribute;\n+import org.springframework.security.access.PermissionEvaluator;\n+import org.springframework.security.core.Authentication;\n+\n+public class AuthorizationsStrongDecisionsCheck {\n+\n+  // AccessDecisionVoter =================================================\n+\n+  class WeakNightVoter implements AccessDecisionVoter {\n+    @Override\n+    public int vote(Authentication authentication, Object object, Collection collection) { // Noncompliant [[sc=16;ec=20]] {{\"vote\" method should return at least one time ACCESS_DENIED.}}\n+      Calendar calendar = Calendar.getInstance();\n+      int currentHour = calendar.get(Calendar.HOUR_OF_DAY);\n+      if(currentHour >= 8 && currentHour <= 19) {\n+        return ACCESS_GRANTED;", "originalCommit": "b05b754982a426bee58ed14247a0cb4181619b13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8889e611451bdb003441fedaab09d2f90a43df02", "chunk": "diff --git a/java-checks-test-sources/src/main/java/checks/security/AuthorizationsStrongDecisionsCheck.java b/java-checks-test-sources/src/main/java/checks/security/AuthorizationsStrongDecisionsCheck.java\nindex 854c8fd83..4992a547a 100644\n--- a/java-checks-test-sources/src/main/java/checks/security/AuthorizationsStrongDecisionsCheck.java\n+++ b/java-checks-test-sources/src/main/java/checks/security/AuthorizationsStrongDecisionsCheck.java\n\n@@ -133,6 +133,18 @@ public class AuthorizationsStrongDecisionsCheck {\n     protected abstract int getVote(Authentication authentication);\n   }\n \n+  abstract class ReturnQualifiedName implements AccessDecisionVoter {\n+    @Override\n+    public int vote(Authentication authentication, Object object, Collection collection) { // Noncompliant\n+      if(testAccess(authentication, object, collection)) {\n+        return AccessDecisionVoter.ACCESS_GRANTED;\n+      } else if (collection.isEmpty()) {\n+        return ReturnQualifiedName.ACCESS_ABSTAIN;\n+      }\n+      return AccessDecisionVoter.ACCESS_ABSTAIN;\n+    }\n+  }\n+\n   // Return literals, but nothing complex, still make sense to recommend returning ACCESS_DENIED, and not own int.\n   abstract class ReturnSomethingElse implements AccessDecisionVoter {\n     @Override\n"}}, {"oid": "8889e611451bdb003441fedaab09d2f90a43df02", "url": "https://github.com/SonarSource/sonar-java/commit/8889e611451bdb003441fedaab09d2f90a43df02", "message": "Support constant qualified name", "committedDate": "2020-09-29T07:17:30Z", "type": "commit"}]}