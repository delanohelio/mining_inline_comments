{"pr_number": 15000, "pr_title": "Add plan check for runtime optimization", "pr_createdAt": "2020-08-10T18:57:19Z", "pr_url": "https://github.com/prestodb/presto/pull/15000", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r468901662", "bodyText": "We shouldn't have a seperate runtime planchecker, since the runtime plan has the same requirements as the \"final\" plan. Instead, we should be running the planchecker for the final stage after doing runtime optimization", "author": "rschlussel", "createdAt": "2020-08-11T22:33:01Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -74,6 +74,9 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new VerifyProjectionLocality(),\n                         new DynamicFiltersChecker(),\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n+                .putAll(\n+                        Stage.RUNTIME,", "originalCommit": "38db5e2ad4c8f684dd12effff496dac840df73da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzIyMQ==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470123221", "bodyText": "Discussed offline. We do not want to modify any existing checks in the FINAL and FRAGMENT stages, but there are problems for using each of the two stage to carry out runtime checking (e.g. FINAL is targeting a whole plan, FRAGMENT is generic whereas the streaming property check is specific to fragments with their exchange sources materialized). So decide to add a RUNTIME stage and copy all necessary checks into this stage. Future runtime checks around exchange materialized stages will also go into this new category.", "author": "pguofb", "createdAt": "2020-08-13T17:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NDY5Ng==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470764696", "bodyText": "sorry, been thinking about this again.  is there a way to make this check in the \"fragment\" section, but for it to only run if the plan has a tablescan stage.  Because the check isn't specific to anything that happens at runtime, it's just that runtime optimization happens to only involve certain kinds of fragments", "author": "rschlussel", "createdAt": "2020-08-14T17:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NTcxMQ==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470765711", "bodyText": "Sure, totally make sense.", "author": "pguofb", "createdAt": "2020-08-14T17:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "22f9dcc3b7ac84b1c67ea96a073a4de5d4d2a0c3", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java\nindex b44e849c7b..af029714e0 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java\n\n@@ -76,7 +76,15 @@ public final class PlanChecker\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n                 .putAll(\n                         Stage.RUNTIME,\n-                        new ValidateRuntimeSwappedJoins())\n+                        new CheckUnsupportedExternalFunctions(),\n+                        new ValidateDependenciesChecker(),\n+                        new NoDuplicatePlanNodeIdsChecker(),\n+                        new TypeValidator(),\n+                        new NoSubqueryExpressionLeftChecker(),\n+                        new NoIdentifierLeftChecker(),\n+                        new VerifyNoOriginalExpression(),\n+                        new DynamicFiltersChecker(),\n+                        new ValidateStreamingJoins())\n                 .build();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMjMyMA==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r468902320", "bodyText": "This plan checker is too specific to a particular optimizer rule.  PlanCheckers should be enforcing general requirements for a valid plan regardless of what optimizers ran.", "author": "rschlussel", "createdAt": "2020-08-11T22:34:45Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateRuntimeSwappedJoins", "originalCommit": "38db5e2ad4c8f684dd12effff496dac840df73da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzk3OA==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470123978", "bodyText": "Discussed offline. The naming is changed to reflect its actual purpose.", "author": "pguofb", "createdAt": "2020-08-13T17:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMjMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "22f9dcc3b7ac84b1c67ea96a073a4de5d4d2a0c3", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\nsimilarity index 66%\nrename from presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java\nrename to presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\nindex 35358b1db0..b342241ba8 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\n\n@@ -24,12 +24,14 @@ import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RemoteSourceNode;\n import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n \n import java.util.List;\n \n import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n"}}, {"oid": "22f9dcc3b7ac84b1c67ea96a073a4de5d4d2a0c3", "url": "https://github.com/prestodb/presto/commit/22f9dcc3b7ac84b1c67ea96a073a4de5d4d2a0c3", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateRuntimeSwappedJoin check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required distribution properties.\n- Add a new category (RUNTIME) in planChecker that will be invoked by\nSqlQueryScheduler after runtime optimizations on each stage.", "committedDate": "2020-08-13T17:22:45Z", "type": "forcePushed"}, {"oid": "0e9c57e417e4761695cf488d1ef4ec91f25b0574", "url": "https://github.com/prestodb/presto/commit/0e9c57e417e4761695cf488d1ef4ec91f25b0574", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateStreamingJoins check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required streaming properties.\n- Invoke planChecker to check each fragment that is runtime optimized.", "committedDate": "2020-08-14T18:11:50Z", "type": "forcePushed"}, {"oid": "9b1711099780498160a198a6bebce9ca42db2852", "url": "https://github.com/prestodb/presto/commit/9b1711099780498160a198a6bebce9ca42db2852", "message": "Bypass fragment sanityCheck for TestCostCalculator\n\nTestCostCalculator tests create a lot of mock plans that are all\nsingle-staged and without proper exchanges in it. This will break\nfragment sanity checks while building fragmentedPlans. Instead,\nextract the statsAndConsts generation logic here to bypass unnecessary\nfragment generation logic and sanity checks.", "committedDate": "2020-08-14T20:38:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjM2NA==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472466364", "bodyText": "I worry about this because then we won't know if this feature breaks.  I think we should let it fail instead, or at least have a test mode that we let fail and turn on for all our tests (similar to ignore-stats-calculator-failures)", "author": "rschlussel", "createdAt": "2020-08-18T20:23:41Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java", "diffHunk": "@@ -538,7 +556,13 @@ private StreamingPlanSection tryCostBasedOptimize(StreamingPlanSection section)\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        try {\n+                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        }\n+                        catch (RuntimeException e) {", "originalCommit": "4c77723ef8d58b03eb59352067e29ba35cd7d1de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NTA2MQ==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472485061", "bodyText": "Sure, let's just have it fail instead.", "author": "pguofb", "createdAt": "2020-08-18T20:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "8480a59d5d3da0029d2193549f661da4f426ef7b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java\nindex 3d7cbcd75f..f4af46bbca 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java\n\n@@ -556,13 +556,8 @@ public class LegacySqlQueryScheduler\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        try {\n-                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n-                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n-                        }\n-                        catch (RuntimeException e) {\n-                            log.error(format(\"Skip runtime optimization on Fragment %s due to failed sanity check: %s\", newPlanFragment.get().getId().toString(), e.getMessage()));\n-                        }\n+                        planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n                     }\n                 });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NzM1MA==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472467350", "bodyText": "ditto", "author": "rschlussel", "createdAt": "2020-08-18T20:24:44Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java", "diffHunk": "@@ -428,7 +446,13 @@ private StreamingPlanSection tryCostBasedOptimize(StreamingPlanSection section)\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        try {\n+                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        }\n+                        catch (RuntimeException e) {", "originalCommit": "4c77723ef8d58b03eb59352067e29ba35cd7d1de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8480a59d5d3da0029d2193549f661da4f426ef7b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java\nindex 54cad7f98e..2458982097 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java\n\n@@ -446,13 +446,8 @@ public class SqlQueryScheduler\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        try {\n-                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n-                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n-                        }\n-                        catch (RuntimeException e) {\n-                            log.error(format(\"Skip runtime optimization on Fragment (%s) due to failed sanity check: %s\", newPlanFragment.get().getId().toString(), e.getMessage()));\n-                        }\n+                        planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n                     }\n                 });\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2OTgxMA==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472469810", "bodyText": "error message shouldn't mention runtime swapped join", "author": "rschlussel", "createdAt": "2020-08-18T20:27:15Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RemoteSourceNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateStreamingJoins\n+        implements Checker\n+{\n+    @Override\n+    public void validate(PlanNode planNode, Session session, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+    {\n+        planNode.accept(new Visitor(session, metadata, sqlParser, types, warningCollector), null);\n+    }\n+\n+    private static final class Visitor\n+            extends InternalPlanVisitor<Void, Void>\n+    {\n+        private final Session session;\n+        private final Metadata metadata;\n+        private final SqlParser sqlParser;\n+        private final TypeProvider types;\n+        private final WarningCollector warningCollector;\n+\n+        private Visitor(Session sesstion, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+        {\n+            this.session = sesstion;\n+            this.metadata = metadata;\n+            this.sqlParser = sqlParser;\n+            this.types = types;\n+            this.warningCollector = warningCollector;\n+        }\n+\n+        @Override\n+        public Void visitPlan(PlanNode node, Void context)\n+        {\n+            node.getSources().forEach(source -> source.accept(this, context));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitJoin(JoinNode node, Void context)\n+        {\n+            // Validate the streaming property of the join node is satisfied when no RemoteSourceNode is involved.\n+            if (!searchFrom(node).where(RemoteSourceNode.class::isInstance).matches()) {\n+                List<VariableReferenceExpression> buildJoinVariables = node.getCriteria().stream()\n+                        .map(JoinNode.EquiJoinClause::getRight)\n+                        .collect(toImmutableList());\n+                StreamPreferredProperties requiredBuildProperty;\n+                if (getTaskConcurrency(session) > 1) {\n+                    requiredBuildProperty = exactlyPartitionedOn(buildJoinVariables);\n+                }\n+                else {\n+                    requiredBuildProperty = singleStream();\n+                }\n+                StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());", "originalCommit": "4c77723ef8d58b03eb59352067e29ba35cd7d1de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8480a59d5d3da0029d2193549f661da4f426ef7b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\nindex 7d23bba703..d0933e7362 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\n\n@@ -90,7 +90,7 @@ public class ValidateStreamingJoins\n                     requiredBuildProperty = singleStream();\n                 }\n                 StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n-                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for join: %s\", node.getId());\n \n                 StreamPreferredProperties requiredProbeProperty;\n                 if (isSpillEnabled(session)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDI3Mg==", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472470272", "bodyText": "error message shouldn't mention runtime swapped join", "author": "rschlussel", "createdAt": "2020-08-18T20:27:41Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RemoteSourceNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateStreamingJoins\n+        implements Checker\n+{\n+    @Override\n+    public void validate(PlanNode planNode, Session session, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+    {\n+        planNode.accept(new Visitor(session, metadata, sqlParser, types, warningCollector), null);\n+    }\n+\n+    private static final class Visitor\n+            extends InternalPlanVisitor<Void, Void>\n+    {\n+        private final Session session;\n+        private final Metadata metadata;\n+        private final SqlParser sqlParser;\n+        private final TypeProvider types;\n+        private final WarningCollector warningCollector;\n+\n+        private Visitor(Session sesstion, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+        {\n+            this.session = sesstion;\n+            this.metadata = metadata;\n+            this.sqlParser = sqlParser;\n+            this.types = types;\n+            this.warningCollector = warningCollector;\n+        }\n+\n+        @Override\n+        public Void visitPlan(PlanNode node, Void context)\n+        {\n+            node.getSources().forEach(source -> source.accept(this, context));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitJoin(JoinNode node, Void context)\n+        {\n+            // Validate the streaming property of the join node is satisfied when no RemoteSourceNode is involved.\n+            if (!searchFrom(node).where(RemoteSourceNode.class::isInstance).matches()) {\n+                List<VariableReferenceExpression> buildJoinVariables = node.getCriteria().stream()\n+                        .map(JoinNode.EquiJoinClause::getRight)\n+                        .collect(toImmutableList());\n+                StreamPreferredProperties requiredBuildProperty;\n+                if (getTaskConcurrency(session) > 1) {\n+                    requiredBuildProperty = exactlyPartitionedOn(buildJoinVariables);\n+                }\n+                else {\n+                    requiredBuildProperty = singleStream();\n+                }\n+                StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());\n+\n+                StreamPreferredProperties requiredProbeProperty;\n+                if (isSpillEnabled(session)) {\n+                    requiredProbeProperty = fixedParallelism();\n+                }\n+                else {\n+                    requiredProbeProperty = defaultParallelism(session);\n+                }\n+                StreamProperties probeProperties = derivePropertiesRecursively(node.getLeft(), metadata, session, types, sqlParser);\n+                checkArgument(requiredProbeProperty.isSatisfiedBy(probeProperties), \"Probe side needs an additional local exchange for runtime swapped join: %s\", node.getId());", "originalCommit": "4c77723ef8d58b03eb59352067e29ba35cd7d1de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8480a59d5d3da0029d2193549f661da4f426ef7b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\nindex 7d23bba703..d0933e7362 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java\n\n@@ -90,7 +90,7 @@ public class ValidateStreamingJoins\n                     requiredBuildProperty = singleStream();\n                 }\n                 StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n-                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for join: %s\", node.getId());\n \n                 StreamPreferredProperties requiredProbeProperty;\n                 if (isSpillEnabled(session)) {\n"}}, {"oid": "8480a59d5d3da0029d2193549f661da4f426ef7b", "url": "https://github.com/prestodb/presto/commit/8480a59d5d3da0029d2193549f661da4f426ef7b", "message": "Bypass fragment sanityCheck for TestCostCalculator\n\nTestCostCalculator tests create a lot of mock plans that are all\nsingle-staged and without proper exchanges in it. This will break\nfragment sanity checks while building fragmentedPlans. Instead,\nextract the statsAndConsts generation logic here to bypass unnecessary\nfragment generation logic and sanity checks.", "committedDate": "2020-08-18T20:57:49Z", "type": "forcePushed"}, {"oid": "322d99b40b550b4ecadb0ce08cb615e200c73005", "url": "https://github.com/prestodb/presto/commit/322d99b40b550b4ecadb0ce08cb615e200c73005", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateStreamingJoins check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required streaming properties.\n- Invoke planChecker to check each fragment that is runtime optimized.\n- Bypass fragment sanityCheck for TestCostCalculator", "committedDate": "2020-08-19T16:46:08Z", "type": "forcePushed"}, {"oid": "95c281672b22ac033e282d506da3561b0f2ebdb7", "url": "https://github.com/prestodb/presto/commit/95c281672b22ac033e282d506da3561b0f2ebdb7", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateStreamingJoins check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required streaming properties.\n- Invoke planChecker to check each fragment that is runtime optimized.\n- Bypass fragment sanityCheck for TestCostCalculator", "committedDate": "2020-08-19T19:31:02Z", "type": "forcePushed"}, {"oid": "24d85d85f9033c845f03ef5eed9ba7b920642550", "url": "https://github.com/prestodb/presto/commit/24d85d85f9033c845f03ef5eed9ba7b920642550", "message": "Refactor RuntimeReorderJoin use PropertyDerivation\n\n- Refactor the add/skip local exchange logic in RuntimeReorderJoins\nto use the same checking as AddLocalExchange, namely the\nStreamPropertyDervations.\n- Check if the probe side is valid when removing unnecessary local\nexchange.\n- Check if the build side needs an additional local exchange.", "committedDate": "2020-08-20T03:37:29Z", "type": "commit"}, {"oid": "5e4b845ab361e7c5cdb180d708083076af8fbfa6", "url": "https://github.com/prestodb/presto/commit/5e4b845ab361e7c5cdb180d708083076af8fbfa6", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateStreamingJoins check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required streaming properties.\n- Invoke planChecker to check each fragment that is runtime optimized.\n- Bypass fragment sanityCheck for TestCostCalculator", "committedDate": "2020-08-20T03:37:29Z", "type": "commit"}, {"oid": "5e4b845ab361e7c5cdb180d708083076af8fbfa6", "url": "https://github.com/prestodb/presto/commit/5e4b845ab361e7c5cdb180d708083076af8fbfa6", "message": "Invoke runtime plan checker in SqlQueryScheduler\n\n- Add a ValidateStreamingJoins check rule to planChecker that\nspecifically investigate if the probe and build side of a join node\nsatisfies required streaming properties.\n- Invoke planChecker to check each fragment that is runtime optimized.\n- Bypass fragment sanityCheck for TestCostCalculator", "committedDate": "2020-08-20T03:37:29Z", "type": "forcePushed"}]}