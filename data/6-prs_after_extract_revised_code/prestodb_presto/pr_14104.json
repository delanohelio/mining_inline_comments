{"pr_number": 14104, "pr_title": "Resource Management related cleanup", "pr_createdAt": "2020-02-14T07:49:30Z", "pr_url": "https://github.com/prestodb/presto/pull/14104", "timeline": [{"oid": "cffce86630ec92f7a34ec6436fb4a4e981b955c5", "url": "https://github.com/prestodb/presto/commit/cffce86630ec92f7a34ec6436fb4a4e981b955c5", "message": "Simplify token management in protocol Query\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-02-14T07:59:49Z", "type": "forcePushed"}, {"oid": "d5e7a3eba3ab30ac709f4eed051ddf5a52ff31fa", "url": "https://github.com/prestodb/presto/commit/d5e7a3eba3ab30ac709f4eed051ddf5a52ff31fa", "message": "Simplify token management in protocol Query\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-02-14T08:01:15Z", "type": "forcePushed"}, {"oid": "2079065f5c3df44188b70ea2d980a21226225601", "url": "https://github.com/prestodb/presto/commit/2079065f5c3df44188b70ea2d980a21226225601", "message": "Simplify token management in protocol Query\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-02-17T03:11:39Z", "type": "forcePushed"}, {"oid": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc", "url": "https://github.com/prestodb/presto/commit/8b254b1563b6cbcbb9047c72d35761bf00bc49fc", "message": "Simplify token management in protocol Query\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-02-27T04:49:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwNDcyMQ==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386804721", "bodyText": "note this line get removed in bfa2524 :)", "author": "wenleix", "createdAt": "2020-03-03T05:21:59Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "diffHunk": "@@ -174,6 +171,8 @@ public SqlQueryManager(\n \n         this.clusterSizeMonitor = requireNonNull(clusterSizeMonitor, \"clusterSizeMonitor is null\");", "originalCommit": "de474765992817101620820a20b9d4bb55cd9220", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java b/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\nindex 662560aa02..33e311dee4 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\n\n@@ -171,8 +174,6 @@ public class SqlQueryManager\n \n         this.clusterSizeMonitor = requireNonNull(clusterSizeMonitor, \"clusterSizeMonitor is null\");\n \n-        this.path = sqlEnvironmentConfig.getPath();\n-\n         this.maxQueryLength = queryManagerConfig.getMaxQueryLength();\n         this.maxQueryCpuTime = queryManagerConfig.getQueryMaxCpuTime();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxODY1MA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386818650", "bodyText": "Just double check: now slug is provided as a parameter, while in the old PR, slug is part of the path? (See b846616#diff-ef10213de38c18dc49c5303d7eea77a4R234)", "author": "wenleix", "createdAt": "2020-03-03T06:20:06Z", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.client.QueryError;\n+import com.facebook.presto.client.QueryResults;\n+import com.facebook.presto.client.StatementStats;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.execution.QueryState;\n+import com.facebook.presto.server.ForStatementResource;\n+import com.facebook.presto.server.HttpRequestSessionContext;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.QueryId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.units.Duration;\n+\n+import javax.annotation.PreDestroy;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.inject.Inject;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.facebook.airlift.concurrent.MoreFutures.addTimeout;\n+import static com.facebook.airlift.concurrent.Threads.threadsNamed;\n+import static com.facebook.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static com.facebook.airlift.http.server.AsyncResponseHandler.bindAsyncResponse;\n+import static com.facebook.presto.execution.QueryState.FAILED;\n+import static com.facebook.presto.execution.QueryState.QUEUED;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.common.net.HttpHeaders.X_FORWARDED_PROTO;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.UUID.randomUUID;\n+import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON;\n+import static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;\n+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n+import static javax.ws.rs.core.Response.Status.NOT_FOUND;\n+\n+@Path(\"/\")\n+public class QueuedStatementResource\n+{\n+    private static final Logger log = Logger.get(QueuedStatementResource.class);\n+    private static final Duration MAX_WAIT_TIME = new Duration(1, SECONDS);\n+    private static final Ordering<Comparable<Duration>> WAIT_ORDERING = Ordering.natural().nullsLast();\n+    private static final Duration NO_DURATION = new Duration(0, MILLISECONDS);\n+\n+    private final DispatchManager dispatchManager;\n+\n+    private final BoundedExecutor responseExecutor;\n+    private final ScheduledExecutorService timeoutExecutor;\n+\n+    private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n+\n+    @Inject\n+    public QueuedStatementResource(\n+            DispatchManager dispatchManager,\n+            @ForStatementResource BoundedExecutor responseExecutor,\n+            @ForStatementResource ScheduledExecutorService timeoutExecutor)\n+    {\n+        this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n+\n+        this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n+        this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");\n+\n+        queryPurger.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        // snapshot the queries before checking states to avoid registration race\n+                        for (Entry<QueryId, Query> entry : ImmutableSet.copyOf(queries.entrySet())) {\n+                            if (!entry.getValue().isSubmissionFinished()) {\n+                                continue;\n+                            }\n+\n+                            // forget about this query if the query manager is no longer tracking it\n+                            if (!dispatchManager.getDispatchInfo(entry.getKey()).isPresent()) {\n+                                queries.remove(entry.getKey());\n+                            }\n+                        }\n+                    }\n+                    catch (Throwable e) {\n+                        log.warn(e, \"Error removing old queries\");\n+                    }\n+                },\n+                200,\n+                200,\n+                MILLISECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        queryPurger.shutdownNow();\n+    }\n+\n+    @POST\n+    @Path(\"/v1/statement\")\n+    @Produces(APPLICATION_JSON)\n+    public Response postStatement(\n+            String statement,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context HttpServletRequest servletRequest,\n+            @Context UriInfo uriInfo)\n+    {\n+        if (isNullOrEmpty(statement)) {\n+            throw badRequest(BAD_REQUEST, \"SQL statement is empty\");\n+        }\n+\n+        SessionContext sessionContext = new HttpRequestSessionContext(servletRequest);\n+        Query query = new Query(statement, sessionContext, dispatchManager);\n+        queries.put(query.getQueryId(), query);\n+\n+        return Response.ok(query.getQueryResults(query.getLastToken(), uriInfo, xForwardedProto)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public void getStatus(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug,\n+            @QueryParam(\"maxWait\") Duration maxWait,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context UriInfo uriInfo,\n+            @Suspended AsyncResponse asyncResponse)\n+    {\n+        Query query = getQuery(queryId, slug);\n+\n+        // wait for query to be dispatched, up to the wait timeout\n+        ListenableFuture<?> futureStateChange = addTimeout(\n+                query.waitForDispatched(),\n+                () -> null,\n+                WAIT_ORDERING.min(MAX_WAIT_TIME, maxWait),\n+                timeoutExecutor);\n+\n+        // when state changes, fetch the next result\n+        ListenableFuture<QueryResults> queryResultsFuture = Futures.transform(\n+                futureStateChange,\n+                ignored -> query.getQueryResults(token, uriInfo, xForwardedProto),\n+                responseExecutor);\n+\n+        // transform to Response\n+        ListenableFuture<Response> response = Futures.transform(\n+                queryResultsFuture,\n+                queryResults -> Response.ok(queryResults).build(),\n+                directExecutor());\n+        bindAsyncResponse(asyncResponse, response, responseExecutor);\n+    }\n+\n+    @DELETE\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public Response cancelQuery(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug)\n+    {\n+        getQuery(queryId, slug)\n+                .cancel();\n+        return Response.noContent().build();\n+    }\n+\n+    private Query getQuery(QueryId queryId, String slug)\n+    {\n+        Query query = queries.get(queryId);\n+        if (query == null || !query.getSlug().equals(slug)) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n+        }\n+        return query;\n+    }\n+\n+    private static URI getQueryHtmlUri(QueryId queryId, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getRequestUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"ui/query.html\")\n+                .replaceQuery(queryId.toString())\n+                .build();\n+    }\n+\n+    private static URI getQueuedUri(QueryId queryId, String slug, long token, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getBaseUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"/v1/statement/queued/\")\n+                .path(queryId.toString())\n+                .path(String.valueOf(token))\n+                .replaceQuery(\"\")\n+                .queryParam(\"slug\", slug)", "originalCommit": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MzQ3OA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389063478", "bodyText": "Yes, I saw from our commit history we did this because our HTTP logging seems to exclude query params from the logs.", "author": "tdcmeehan", "createdAt": "2020-03-06T18:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxODY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java b/presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java\ndeleted file mode 100644\nindex bf90dfd3ad..0000000000\n--- a/presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java\n+++ /dev/null\n\n@@ -1,436 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.dispatcher;\n-\n-import com.facebook.airlift.log.Logger;\n-import com.facebook.presto.client.QueryError;\n-import com.facebook.presto.client.QueryResults;\n-import com.facebook.presto.client.StatementStats;\n-import com.facebook.presto.execution.ExecutionFailureInfo;\n-import com.facebook.presto.execution.QueryState;\n-import com.facebook.presto.server.ForStatementResource;\n-import com.facebook.presto.server.HttpRequestSessionContext;\n-import com.facebook.presto.server.SessionContext;\n-import com.facebook.presto.spi.ErrorCode;\n-import com.facebook.presto.spi.QueryId;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Ordering;\n-import com.google.common.util.concurrent.Futures;\n-import com.google.common.util.concurrent.ListenableFuture;\n-import io.airlift.units.Duration;\n-\n-import javax.annotation.PreDestroy;\n-import javax.annotation.concurrent.GuardedBy;\n-import javax.inject.Inject;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.ws.rs.DELETE;\n-import javax.ws.rs.GET;\n-import javax.ws.rs.HeaderParam;\n-import javax.ws.rs.POST;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.PathParam;\n-import javax.ws.rs.Produces;\n-import javax.ws.rs.QueryParam;\n-import javax.ws.rs.WebApplicationException;\n-import javax.ws.rs.container.AsyncResponse;\n-import javax.ws.rs.container.Suspended;\n-import javax.ws.rs.core.Context;\n-import javax.ws.rs.core.Response;\n-import javax.ws.rs.core.Response.Status;\n-import javax.ws.rs.core.UriInfo;\n-\n-import java.net.URI;\n-import java.util.Map.Entry;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static com.facebook.airlift.concurrent.MoreFutures.addTimeout;\n-import static com.facebook.airlift.concurrent.Threads.threadsNamed;\n-import static com.facebook.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n-import static com.facebook.airlift.http.server.AsyncResponseHandler.bindAsyncResponse;\n-import static com.facebook.presto.execution.QueryState.FAILED;\n-import static com.facebook.presto.execution.QueryState.QUEUED;\n-import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n-import static com.google.common.base.MoreObjects.firstNonNull;\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static com.google.common.net.HttpHeaders.X_FORWARDED_PROTO;\n-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n-import static java.util.Locale.ENGLISH;\n-import static java.util.Objects.requireNonNull;\n-import static java.util.UUID.randomUUID;\n-import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n-import static javax.ws.rs.core.MediaType.APPLICATION_JSON;\n-import static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;\n-import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n-import static javax.ws.rs.core.Response.Status.NOT_FOUND;\n-\n-@Path(\"/\")\n-public class QueuedStatementResource\n-{\n-    private static final Logger log = Logger.get(QueuedStatementResource.class);\n-    private static final Duration MAX_WAIT_TIME = new Duration(1, SECONDS);\n-    private static final Ordering<Comparable<Duration>> WAIT_ORDERING = Ordering.natural().nullsLast();\n-    private static final Duration NO_DURATION = new Duration(0, MILLISECONDS);\n-\n-    private final DispatchManager dispatchManager;\n-\n-    private final BoundedExecutor responseExecutor;\n-    private final ScheduledExecutorService timeoutExecutor;\n-\n-    private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n-    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n-\n-    @Inject\n-    public QueuedStatementResource(\n-            DispatchManager dispatchManager,\n-            @ForStatementResource BoundedExecutor responseExecutor,\n-            @ForStatementResource ScheduledExecutorService timeoutExecutor)\n-    {\n-        this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n-\n-        this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n-        this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");\n-\n-        queryPurger.scheduleWithFixedDelay(\n-                () -> {\n-                    try {\n-                        // snapshot the queries before checking states to avoid registration race\n-                        for (Entry<QueryId, Query> entry : ImmutableSet.copyOf(queries.entrySet())) {\n-                            if (!entry.getValue().isSubmissionFinished()) {\n-                                continue;\n-                            }\n-\n-                            // forget about this query if the query manager is no longer tracking it\n-                            if (!dispatchManager.getDispatchInfo(entry.getKey()).isPresent()) {\n-                                queries.remove(entry.getKey());\n-                            }\n-                        }\n-                    }\n-                    catch (Throwable e) {\n-                        log.warn(e, \"Error removing old queries\");\n-                    }\n-                },\n-                200,\n-                200,\n-                MILLISECONDS);\n-    }\n-\n-    @PreDestroy\n-    public void stop()\n-    {\n-        queryPurger.shutdownNow();\n-    }\n-\n-    @POST\n-    @Path(\"/v1/statement\")\n-    @Produces(APPLICATION_JSON)\n-    public Response postStatement(\n-            String statement,\n-            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n-            @Context HttpServletRequest servletRequest,\n-            @Context UriInfo uriInfo)\n-    {\n-        if (isNullOrEmpty(statement)) {\n-            throw badRequest(BAD_REQUEST, \"SQL statement is empty\");\n-        }\n-\n-        SessionContext sessionContext = new HttpRequestSessionContext(servletRequest);\n-        Query query = new Query(statement, sessionContext, dispatchManager);\n-        queries.put(query.getQueryId(), query);\n-\n-        return Response.ok(query.getQueryResults(query.getLastToken(), uriInfo, xForwardedProto)).build();\n-    }\n-\n-    @GET\n-    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n-    @Produces(APPLICATION_JSON)\n-    public void getStatus(\n-            @PathParam(\"queryId\") QueryId queryId,\n-            @PathParam(\"token\") long token,\n-            @QueryParam(\"slug\") String slug,\n-            @QueryParam(\"maxWait\") Duration maxWait,\n-            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n-            @Context UriInfo uriInfo,\n-            @Suspended AsyncResponse asyncResponse)\n-    {\n-        Query query = getQuery(queryId, slug);\n-\n-        // wait for query to be dispatched, up to the wait timeout\n-        ListenableFuture<?> futureStateChange = addTimeout(\n-                query.waitForDispatched(),\n-                () -> null,\n-                WAIT_ORDERING.min(MAX_WAIT_TIME, maxWait),\n-                timeoutExecutor);\n-\n-        // when state changes, fetch the next result\n-        ListenableFuture<QueryResults> queryResultsFuture = Futures.transform(\n-                futureStateChange,\n-                ignored -> query.getQueryResults(token, uriInfo, xForwardedProto),\n-                responseExecutor);\n-\n-        // transform to Response\n-        ListenableFuture<Response> response = Futures.transform(\n-                queryResultsFuture,\n-                queryResults -> Response.ok(queryResults).build(),\n-                directExecutor());\n-        bindAsyncResponse(asyncResponse, response, responseExecutor);\n-    }\n-\n-    @DELETE\n-    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n-    @Produces(APPLICATION_JSON)\n-    public Response cancelQuery(\n-            @PathParam(\"queryId\") QueryId queryId,\n-            @PathParam(\"token\") long token,\n-            @QueryParam(\"slug\") String slug)\n-    {\n-        getQuery(queryId, slug)\n-                .cancel();\n-        return Response.noContent().build();\n-    }\n-\n-    private Query getQuery(QueryId queryId, String slug)\n-    {\n-        Query query = queries.get(queryId);\n-        if (query == null || !query.getSlug().equals(slug)) {\n-            throw badRequest(NOT_FOUND, \"Query not found\");\n-        }\n-        return query;\n-    }\n-\n-    private static URI getQueryHtmlUri(QueryId queryId, UriInfo uriInfo, String xForwardedProto)\n-    {\n-        return uriInfo.getRequestUriBuilder()\n-                .scheme(getScheme(xForwardedProto, uriInfo))\n-                .replacePath(\"ui/query.html\")\n-                .replaceQuery(queryId.toString())\n-                .build();\n-    }\n-\n-    private static URI getQueuedUri(QueryId queryId, String slug, long token, UriInfo uriInfo, String xForwardedProto)\n-    {\n-        return uriInfo.getBaseUriBuilder()\n-                .scheme(getScheme(xForwardedProto, uriInfo))\n-                .replacePath(\"/v1/statement/queued/\")\n-                .path(queryId.toString())\n-                .path(String.valueOf(token))\n-                .replaceQuery(\"\")\n-                .queryParam(\"slug\", slug)\n-                .build();\n-    }\n-\n-    private static String getScheme(String xForwardedProto, @Context UriInfo uriInfo)\n-    {\n-        return isNullOrEmpty(xForwardedProto) ? uriInfo.getRequestUri().getScheme() : xForwardedProto;\n-    }\n-\n-    private static QueryResults createQueryResults(\n-            QueryId queryId,\n-            URI nextUri,\n-            Optional<QueryError> queryError,\n-            UriInfo uriInfo,\n-            String xForwardedProto,\n-            Duration elapsedTime,\n-            Duration queuedTime)\n-    {\n-        QueryState state = queryError.map(error -> FAILED).orElse(QUEUED);\n-        return new QueryResults(\n-                queryId.toString(),\n-                getQueryHtmlUri(queryId, uriInfo, xForwardedProto),\n-                null,\n-                nextUri,\n-                null,\n-                null,\n-                StatementStats.builder()\n-                        .setState(state.toString())\n-                        .setQueued(state == QUEUED)\n-                        .setElapsedTimeMillis(elapsedTime.toMillis())\n-                        .setQueuedTimeMillis(queuedTime.toMillis())\n-                        .build(),\n-                queryError.orElse(null),\n-                ImmutableList.of(),\n-                null,\n-                null);\n-    }\n-\n-    private static WebApplicationException badRequest(Status status, String message)\n-    {\n-        throw new WebApplicationException(\n-                Response.status(status)\n-                        .type(TEXT_PLAIN_TYPE)\n-                        .entity(message)\n-                        .build());\n-    }\n-\n-    private static final class Query\n-    {\n-        private final String query;\n-        private final SessionContext sessionContext;\n-        private final DispatchManager dispatchManager;\n-        private final QueryId queryId;\n-        private final String slug = \"x\" + randomUUID().toString().toLowerCase(ENGLISH).replace(\"-\", \"\");\n-        private final AtomicLong lastToken = new AtomicLong();\n-\n-        @GuardedBy(\"this\")\n-        private ListenableFuture<?> querySubmissionFuture;\n-\n-        public Query(String query, SessionContext sessionContext, DispatchManager dispatchManager)\n-        {\n-            this.query = requireNonNull(query, \"query is null\");\n-            this.sessionContext = requireNonNull(sessionContext, \"sessionContext is null\");\n-            this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n-            this.queryId = dispatchManager.createQueryId();\n-        }\n-\n-        public QueryId getQueryId()\n-        {\n-            return queryId;\n-        }\n-\n-        public String getSlug()\n-        {\n-            return slug;\n-        }\n-\n-        public long getLastToken()\n-        {\n-            return lastToken.get();\n-        }\n-\n-        public synchronized boolean isSubmissionFinished()\n-        {\n-            return querySubmissionFuture != null && querySubmissionFuture.isDone();\n-        }\n-\n-        private ListenableFuture<?> waitForDispatched()\n-        {\n-            // if query query submission has not finished, wait for it to finish\n-            synchronized (this) {\n-                if (querySubmissionFuture == null) {\n-                    querySubmissionFuture = dispatchManager.createQuery(queryId, slug, sessionContext, query);\n-                }\n-                if (!querySubmissionFuture.isDone()) {\n-                    return querySubmissionFuture;\n-                }\n-            }\n-\n-            // otherwise, wait for the query to finish\n-            return dispatchManager.waitForDispatched(queryId);\n-        }\n-\n-        public QueryResults getQueryResults(long token, UriInfo uriInfo, String xForwardedProto)\n-        {\n-            long lastToken = this.lastToken.get();\n-            // token should be the last token or the next token\n-            if (token != lastToken && token != lastToken + 1) {\n-                throw new WebApplicationException(Response.Status.GONE);\n-            }\n-            // advance (or stay at) the token\n-            this.lastToken.compareAndSet(lastToken, token);\n-\n-            synchronized (this) {\n-                // if query submission has not finished, return simple empty result\n-                if (querySubmissionFuture == null || !querySubmissionFuture.isDone()) {\n-                    return createQueryResults(\n-                            token + 1,\n-                            uriInfo,\n-                            xForwardedProto,\n-                            new DispatchInfo(Optional.empty(), Optional.empty(), NO_DURATION, NO_DURATION));\n-                }\n-            }\n-\n-            Optional<DispatchInfo> dispatchInfo = dispatchManager.getDispatchInfo(queryId);\n-            if (!dispatchInfo.isPresent()) {\n-                // query should always be found, but it may have just been determined to be abandoned\n-                throw new WebApplicationException(Response\n-                        .status(NOT_FOUND)\n-                        .build());\n-            }\n-\n-            return createQueryResults(token + 1, uriInfo, xForwardedProto, dispatchInfo.get());\n-        }\n-\n-        public synchronized void cancel()\n-        {\n-            querySubmissionFuture.addListener(() -> dispatchManager.cancelQuery(queryId), directExecutor());\n-        }\n-\n-        private QueryResults createQueryResults(long token, UriInfo uriInfo, String xForwardedProto, DispatchInfo dispatchInfo)\n-        {\n-            URI nextUri = getNextUri(token, uriInfo, xForwardedProto, dispatchInfo);\n-\n-            Optional<QueryError> queryError = dispatchInfo.getFailureInfo()\n-                    .map(this::toQueryError);\n-\n-            return QueuedStatementResource.createQueryResults(\n-                    queryId,\n-                    nextUri,\n-                    queryError,\n-                    uriInfo,\n-                    xForwardedProto,\n-                    dispatchInfo.getElapsedTime(),\n-                    dispatchInfo.getQueuedTime());\n-        }\n-\n-        private URI getNextUri(long token, UriInfo uriInfo, String xForwardedProto, DispatchInfo dispatchInfo)\n-        {\n-            // if failed, query is complete\n-            if (dispatchInfo.getFailureInfo().isPresent()) {\n-                return null;\n-            }\n-            // if dispatched, redirect to new uri\n-            return dispatchInfo.getCoordinatorLocation()\n-                            .map(coordinatorLocation -> getRedirectUri(coordinatorLocation, uriInfo, xForwardedProto))\n-                            .orElseGet(() -> getQueuedUri(queryId, slug, token, uriInfo, xForwardedProto));\n-        }\n-\n-        private URI getRedirectUri(CoordinatorLocation coordinatorLocation, UriInfo uriInfo, String xForwardedProto)\n-        {\n-            URI coordinatorUri = coordinatorLocation.getUri(getScheme(xForwardedProto, uriInfo));\n-            return uriBuilderFrom(coordinatorUri)\n-                    .appendPath(\"/v1/statement/executing\")\n-                    .appendPath(queryId.toString())\n-                    .appendPath(\"0\")\n-                    .addParameter(\"slug\", slug)\n-                    .build();\n-        }\n-\n-        private QueryError toQueryError(ExecutionFailureInfo executionFailureInfo)\n-        {\n-            ErrorCode errorCode;\n-            if (executionFailureInfo.getErrorCode() != null) {\n-                errorCode = executionFailureInfo.getErrorCode();\n-            }\n-            else {\n-                errorCode = GENERIC_INTERNAL_ERROR.toErrorCode();\n-                log.warn(\"Failed query %s has no error code\", queryId);\n-            }\n-\n-            return new QueryError(\n-                    firstNonNull(executionFailureInfo.getMessage(), \"Internal error\"),\n-                    null,\n-                    errorCode.getCode(),\n-                    errorCode.getName(),\n-                    errorCode.getType().toString(),\n-                    executionFailureInfo.getErrorLocation(),\n-                    executionFailureInfo.toFailureInfo());\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTc1MQ==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386819751", "bodyText": "hmm? :)", "author": "wenleix", "createdAt": "2020-03-03T06:24:27Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "diffHunk": "@@ -210,7 +125,6 @@ public void stop()\n     {\n         queryTracker.stop();\n         queryManagementExecutor.shutdownNow();\n-        unboundedExecutorService.shutdownNow();", "originalCommit": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYyOA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389081628", "bodyText": "This is not just a rebase conflict, looks like all references to unboundedExecutorService (was: queryExecutor) should have been removed entirely.", "author": "tdcmeehan", "createdAt": "2020-03-06T18:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java b/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\nindex 445baa7555..33e311dee4 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java\n\n@@ -125,6 +211,7 @@ public class SqlQueryManager\n     {\n         queryTracker.stop();\n         queryManagementExecutor.shutdownNow();\n+        unboundedExecutorService.shutdownNow();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDcwMg==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386820702", "bodyText": "Didn't see \"slugValid\" related method in this commit? (see b846616#diff-d65ad4547dcbc09fc621ac2ceddce6cdR217)", "author": "wenleix", "createdAt": "2020-03-03T06:28:11Z", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -294,14 +263,12 @@ public synchronized boolean isClearTransactionId()\n         return clearTransactionId;\n     }\n \n-    public synchronized ListenableFuture<QueryResults> waitForResults(OptionalLong token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)\n+    public synchronized ListenableFuture<QueryResults> waitForResults(long token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)", "originalCommit": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MzcyMw==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389083723", "bodyText": "This is because we cherry picked this earlier in #13110", "author": "tdcmeehan", "createdAt": "2020-03-06T18:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDcwMg=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java b/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\nindex adaf4e6040..63670f5cb6 100644\n--- a/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\n+++ b/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\n\n@@ -263,12 +294,14 @@ class Query\n         return clearTransactionId;\n     }\n \n-    public synchronized ListenableFuture<QueryResults> waitForResults(long token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)\n+    public synchronized ListenableFuture<QueryResults> waitForResults(OptionalLong token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)\n     {\n         // before waiting, check if this request has already been processed and cached\n-        Optional<QueryResults> cachedResult = getCachedResult(token, uriInfo);\n-        if (cachedResult.isPresent()) {\n-            return immediateFuture(cachedResult.get());\n+        if (token.isPresent()) {\n+            Optional<QueryResults> cachedResult = getCachedResult(token.getAsLong(), uriInfo);\n+            if (cachedResult.isPresent()) {\n+                return immediateFuture(cachedResult.get());\n+            }\n         }\n \n         // wait for a results data or query to finish, up to the wait timeout\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDkzMA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386820930", "bodyText": "Why change this to nextToken?  :)", "author": "wenleix", "createdAt": "2020-03-03T06:29:13Z", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -570,9 +502,9 @@ private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)\n     {\n         return uriInfo.getBaseUriBuilder()\n                 .scheme(scheme)\n-                .replacePath(\"/v1/statement\")\n+                .replacePath(\"/v1/statement/executing\")\n                 .path(queryId.toString())\n-                .path(String.valueOf(resultId.incrementAndGet()))\n+                .path(String.valueOf(nextToken))", "originalCommit": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Nzc3OQ==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389087779", "bodyText": "This was supposed to happen in a later commit.  Fixed it.", "author": "tdcmeehan", "createdAt": "2020-03-06T19:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDkzMA=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java b/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\nindex adaf4e6040..63670f5cb6 100644\n--- a/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\n+++ b/presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java\n\n@@ -502,9 +570,9 @@ class Query\n     {\n         return uriInfo.getBaseUriBuilder()\n                 .scheme(scheme)\n-                .replacePath(\"/v1/statement/executing\")\n+                .replacePath(\"/v1/statement\")\n                 .path(queryId.toString())\n-                .path(String.valueOf(nextToken))\n+                .path(String.valueOf(resultId.incrementAndGet()))\n                 .replaceQuery(\"\")\n                 .queryParam(\"slug\", slug)\n                 .build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2ODAzNw==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387868037", "bodyText": "Why is this needed? Why not simply Futures.nonCancellationPropagating()?", "author": "arhimondr", "createdAt": "2020-03-04T18:57:31Z", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.QueryIdGenerator;\n+import com.facebook.presto.execution.QueryInfo;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.facebook.presto.execution.QueryPreparer;\n+import com.facebook.presto.execution.QueryPreparer.PreparedQuery;\n+import com.facebook.presto.execution.QueryTracker;\n+import com.facebook.presto.execution.SqlQueryManagerStats;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupManager;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.execution.warnings.WarningCollectorFactory;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.security.AccessControl;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.server.SessionPropertyDefaults;\n+import com.facebook.presto.server.SessionSupplier;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.resourceGroups.QueryType;\n+import com.facebook.presto.spi.resourceGroups.SelectionContext;\n+import com.facebook.presto.spi.resourceGroups.SelectionCriteria;\n+import com.facebook.presto.sql.SqlPath;\n+import com.facebook.presto.transaction.TransactionManager;\n+import com.google.common.util.concurrent.AbstractFuture;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import io.airlift.concurrent.ThreadPoolExecutorMBean;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.presto.spi.StandardErrorCode.QUERY_TEXT_TOO_LARGE;\n+import static com.facebook.presto.util.StatementUtils.getQueryType;\n+import static com.facebook.presto.util.StatementUtils.isTransactionControlStatement;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static io.airlift.concurrent.Threads.threadsNamed;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchManager\n+{\n+    private final QueryIdGenerator queryIdGenerator;\n+    private final QueryPreparer queryPreparer;\n+    private final ResourceGroupManager<?> resourceGroupManager;\n+    private final WarningCollector warningCollector;\n+    private final DispatchQueryFactory dispatchQueryFactory;\n+    private final FailedDispatchQueryFactory failedDispatchQueryFactory;\n+    private final TransactionManager transactionManager;\n+    private final AccessControl accessControl;\n+    private final SessionSupplier sessionSupplier;\n+    private final SessionPropertyDefaults sessionPropertyDefaults;\n+\n+    private final int maxQueryLength;\n+\n+    private final ListeningScheduledExecutorService queryManagementExecutor;\n+    private final ThreadPoolExecutorMBean queryManagementExecutorMBean;\n+\n+    private final QueryTracker<DispatchQuery> queryTracker;\n+\n+    private final SqlQueryManagerStats stats = new SqlQueryManagerStats();\n+\n+    @Inject\n+    public DispatchManager(\n+            QueryIdGenerator queryIdGenerator,\n+            QueryPreparer queryPreparer,\n+            @SuppressWarnings(\"rawtypes\") ResourceGroupManager resourceGroupManager,\n+            WarningCollectorFactory warningCollectorFactory,\n+            DispatchQueryFactory dispatchQueryFactory,\n+            FailedDispatchQueryFactory failedDispatchQueryFactory,\n+            TransactionManager transactionManager,\n+            AccessControl accessControl,\n+            SessionSupplier sessionSupplier,\n+            SessionPropertyDefaults sessionPropertyDefaults,\n+            QueryManagerConfig queryManagerConfig)\n+    {\n+        this.queryIdGenerator = requireNonNull(queryIdGenerator, \"queryIdGenerator is null\");\n+        this.queryPreparer = requireNonNull(queryPreparer, \"queryPreparer is null\");\n+        this.resourceGroupManager = requireNonNull(resourceGroupManager, \"resourceGroupManager is null\");\n+        this.warningCollector = warningCollectorFactory.create();\n+        this.dispatchQueryFactory = requireNonNull(dispatchQueryFactory, \"dispatchQueryFactory is null\");\n+        this.failedDispatchQueryFactory = requireNonNull(failedDispatchQueryFactory, \"failedDispatchQueryFactory is null\");\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.sessionSupplier = requireNonNull(sessionSupplier, \"sessionSupplier is null\");\n+        this.sessionPropertyDefaults = requireNonNull(sessionPropertyDefaults, \"sessionPropertyDefaults is null\");\n+\n+        this.maxQueryLength = queryManagerConfig.getMaxQueryLength();\n+\n+        ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(queryManagerConfig.getQueryManagerExecutorPoolSize(), threadsNamed(\"query-dispatch-%s\"));\n+        queryManagementExecutor = listeningDecorator(scheduledExecutorService);\n+        queryManagementExecutorMBean = new ThreadPoolExecutorMBean((ThreadPoolExecutor) scheduledExecutorService);\n+\n+        this.queryTracker = new QueryTracker<>(queryManagerConfig, queryManagementExecutor);\n+    }\n+\n+    @Managed(description = \"Query dispatch executor\")\n+    @Nested\n+    public ThreadPoolExecutorMBean getExecutor()\n+    {\n+        return queryManagementExecutorMBean;\n+    }\n+\n+    @Managed\n+    @Flatten\n+    public SqlQueryManagerStats getStats()\n+    {\n+        return stats;\n+    }\n+\n+    public QueryId createQueryId()\n+    {\n+        return queryIdGenerator.createNextQueryId();\n+    }\n+\n+    public ListenableFuture<?> createQuery(QueryId queryId, String slug, SessionContext sessionContext, String query)\n+    {\n+        DispatchQueryCreationFuture queryCreationFuture = new DispatchQueryCreationFuture();\n+        queryManagementExecutor.submit(() -> {\n+            try {\n+                createQueryInternal(queryId, slug, sessionContext, query, resourceGroupManager);\n+                queryCreationFuture.set(null);\n+            }\n+            catch (Throwable e) {\n+                queryCreationFuture.setException(e);\n+            }\n+        });\n+        return queryCreationFuture;\n+    }\n+\n+    private <C> void createQueryInternal(QueryId queryId, String slug, SessionContext sessionContext, String query, ResourceGroupManager<C> resourceGroupManager)\n+    {\n+        requireNonNull(queryId, \"queryId is null\");\n+        requireNonNull(sessionContext, \"sessionFactory is null\");\n+        requireNonNull(query, \"query is null\");\n+        checkArgument(!query.isEmpty(), \"query must not be empty string\");\n+        checkArgument(!queryTracker.tryGetQuery(queryId).isPresent(), \"query %s already exists\", queryId);\n+\n+        Session session = null;\n+        SelectionContext<C> selectionContext = null;\n+        PreparedQuery preparedQuery;\n+        DispatchQuery dispatchQuery;\n+        try {\n+            if (query.length() > maxQueryLength) {\n+                int queryLength = query.length();\n+                query = query.substring(0, maxQueryLength);\n+                throw new PrestoException(QUERY_TEXT_TOO_LARGE, format(\"Query text length (%s) exceeds the maximum length (%s)\", queryLength, maxQueryLength));\n+            }\n+\n+            // decode session\n+            session = sessionSupplier.createSession(queryId, sessionContext);\n+\n+            // prepare query\n+            preparedQuery = queryPreparer.prepareQuery(session, query, warningCollector);\n+\n+            // select resource group\n+            Optional<QueryType> queryType = getQueryType(preparedQuery.getStatement().getClass());\n+            selectionContext = resourceGroupManager.selectGroup(new SelectionCriteria(\n+                    sessionContext.getIdentity().getPrincipal().isPresent(),\n+                    sessionContext.getIdentity().getUser(),\n+                    Optional.ofNullable(sessionContext.getSource()),\n+                    sessionContext.getClientTags(),\n+                    sessionContext.getResourceEstimates(),\n+                    queryType.map(Enum::name)));\n+\n+            // apply system default session properties (does not override user set properties)\n+            session = sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType.map(Enum::name), selectionContext.getResourceGroupId());\n+\n+            // mark existing transaction as active\n+            transactionManager.activateTransaction(session, isTransactionControlStatement(preparedQuery.getStatement()), accessControl);\n+\n+            dispatchQuery = dispatchQueryFactory.createDispatchQuery(session, query, preparedQuery, slug, selectionContext.getResourceGroupId(), queryType, warningCollector, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            // This is intentionally not a method, since after the state change listener is registered\n+            // it's not safe to do any of this, and we had bugs before where people reused this code in a method\n+            // if session creation failed, create a minimal session object\n+            if (session == null) {\n+                session = Session.builder(new SessionPropertyManager())\n+                        .setQueryId(queryId)\n+                        .setIdentity(sessionContext.getIdentity())\n+                        .setSource(sessionContext.getSource())\n+                        .setPath(new SqlPath(Optional.empty()))\n+                        .build();\n+            }\n+\n+            // create and immediately fail the query\n+            DispatchQuery failedDispatchQuery = failedDispatchQueryFactory.createFailedDispatchQuery(\n+                    session,\n+                    query,\n+                    Optional.ofNullable(selectionContext).map(SelectionContext::getResourceGroupId),\n+                    e);\n+\n+            try {\n+                queryCreated(failedDispatchQuery);\n+            }\n+            finally {\n+                handleQueryFailure(failedDispatchQuery);\n+            }\n+            return;\n+        }\n+\n+        try {\n+            queryCreated(dispatchQuery);\n+            dispatchQuery.addStateChangeListener(newState -> {\n+                if (newState.isDone()) {\n+                    stats.queryFinished(dispatchQuery.getBasicQueryInfo());\n+                }\n+            });\n+\n+            resourceGroupManager.submit(preparedQuery.getStatement(), dispatchQuery, selectionContext, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            dispatchQuery.fail(e);\n+        }\n+    }\n+\n+    private void queryCreated(DispatchQuery dispatchQuery)\n+    {\n+        queryTracker.addQuery(dispatchQuery);\n+        stats.queryQueued();\n+    }\n+\n+    private void handleQueryFailure(DispatchQuery dispatchQuery)\n+    {\n+        try {\n+            stats.queryStarted();\n+            stats.queryStopped();\n+            BasicQueryInfo queryInfo = dispatchQuery.getBasicQueryInfo();\n+            stats.queuedQueryFailed(queryInfo.getQueryStats().getQueuedTime(), Optional.ofNullable(queryInfo.getErrorCode()));\n+        }\n+        finally {\n+            // execution MUST be added to the expiration queue or there will be a leak\n+            queryTracker.expireQuery(dispatchQuery.getQueryId());\n+        }\n+    }\n+\n+    public ListenableFuture<?> waitForDispatched(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchedFuture();\n+                })\n+                .orElseGet(() -> immediateFuture(null));\n+    }\n+\n+    public List<BasicQueryInfo> getQueries()\n+    {\n+        return queryTracker.getAllQueries().stream()\n+                .map(DispatchQuery::getBasicQueryInfo)\n+                .collect(toImmutableList());\n+    }\n+\n+    public BasicQueryInfo getQueryInfo(QueryId queryId)\n+    {\n+        return queryTracker.getQuery(queryId).getBasicQueryInfo();\n+    }\n+\n+    public Optional<DispatchInfo> getDispatchInfo(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchInfo();\n+                });\n+    }\n+\n+    public void cancelQuery(QueryId queryId)\n+    {\n+        queryTracker.tryGetQuery(queryId)\n+                .ifPresent(DispatchQuery::cancel);\n+    }\n+\n+    private static class DispatchQueryCreationFuture", "originalCommit": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ5MzcyMw==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389493723", "bodyText": "Turns out it's a different semantic.  An attempt to cancel this future has no effect, whereas cancelling the returned future from nonCancellationPropagating may be cancelled (however this will not be propagated to the inner future).", "author": "tdcmeehan", "createdAt": "2020-03-09T07:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2ODAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java b/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java\ndeleted file mode 100644\nindex 613ac9204d..0000000000\n--- a/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java\n+++ /dev/null\n\n@@ -1,323 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.dispatcher;\n-\n-import com.facebook.presto.Session;\n-import com.facebook.presto.execution.QueryIdGenerator;\n-import com.facebook.presto.execution.QueryInfo;\n-import com.facebook.presto.execution.QueryManagerConfig;\n-import com.facebook.presto.execution.QueryPreparer;\n-import com.facebook.presto.execution.QueryPreparer.PreparedQuery;\n-import com.facebook.presto.execution.QueryTracker;\n-import com.facebook.presto.execution.SqlQueryManagerStats;\n-import com.facebook.presto.execution.resourceGroups.ResourceGroupManager;\n-import com.facebook.presto.execution.warnings.WarningCollector;\n-import com.facebook.presto.execution.warnings.WarningCollectorFactory;\n-import com.facebook.presto.metadata.SessionPropertyManager;\n-import com.facebook.presto.security.AccessControl;\n-import com.facebook.presto.server.BasicQueryInfo;\n-import com.facebook.presto.server.SessionContext;\n-import com.facebook.presto.server.SessionPropertyDefaults;\n-import com.facebook.presto.server.SessionSupplier;\n-import com.facebook.presto.spi.PrestoException;\n-import com.facebook.presto.spi.QueryId;\n-import com.facebook.presto.spi.resourceGroups.QueryType;\n-import com.facebook.presto.spi.resourceGroups.SelectionContext;\n-import com.facebook.presto.spi.resourceGroups.SelectionCriteria;\n-import com.facebook.presto.sql.SqlPath;\n-import com.facebook.presto.transaction.TransactionManager;\n-import com.google.common.util.concurrent.AbstractFuture;\n-import com.google.common.util.concurrent.ListenableFuture;\n-import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n-import io.airlift.concurrent.ThreadPoolExecutorMBean;\n-import org.weakref.jmx.Flatten;\n-import org.weakref.jmx.Managed;\n-import org.weakref.jmx.Nested;\n-\n-import javax.inject.Inject;\n-\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ThreadPoolExecutor;\n-\n-import static com.facebook.presto.spi.StandardErrorCode.QUERY_TEXT_TOO_LARGE;\n-import static com.facebook.presto.util.StatementUtils.getQueryType;\n-import static com.facebook.presto.util.StatementUtils.isTransactionControlStatement;\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.collect.ImmutableList.toImmutableList;\n-import static com.google.common.util.concurrent.Futures.immediateFuture;\n-import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n-import static io.airlift.concurrent.Threads.threadsNamed;\n-import static java.lang.String.format;\n-import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newScheduledThreadPool;\n-\n-public class DispatchManager\n-{\n-    private final QueryIdGenerator queryIdGenerator;\n-    private final QueryPreparer queryPreparer;\n-    private final ResourceGroupManager<?> resourceGroupManager;\n-    private final WarningCollector warningCollector;\n-    private final DispatchQueryFactory dispatchQueryFactory;\n-    private final FailedDispatchQueryFactory failedDispatchQueryFactory;\n-    private final TransactionManager transactionManager;\n-    private final AccessControl accessControl;\n-    private final SessionSupplier sessionSupplier;\n-    private final SessionPropertyDefaults sessionPropertyDefaults;\n-\n-    private final int maxQueryLength;\n-\n-    private final ListeningScheduledExecutorService queryManagementExecutor;\n-    private final ThreadPoolExecutorMBean queryManagementExecutorMBean;\n-\n-    private final QueryTracker<DispatchQuery> queryTracker;\n-\n-    private final SqlQueryManagerStats stats = new SqlQueryManagerStats();\n-\n-    @Inject\n-    public DispatchManager(\n-            QueryIdGenerator queryIdGenerator,\n-            QueryPreparer queryPreparer,\n-            @SuppressWarnings(\"rawtypes\") ResourceGroupManager resourceGroupManager,\n-            WarningCollectorFactory warningCollectorFactory,\n-            DispatchQueryFactory dispatchQueryFactory,\n-            FailedDispatchQueryFactory failedDispatchQueryFactory,\n-            TransactionManager transactionManager,\n-            AccessControl accessControl,\n-            SessionSupplier sessionSupplier,\n-            SessionPropertyDefaults sessionPropertyDefaults,\n-            QueryManagerConfig queryManagerConfig)\n-    {\n-        this.queryIdGenerator = requireNonNull(queryIdGenerator, \"queryIdGenerator is null\");\n-        this.queryPreparer = requireNonNull(queryPreparer, \"queryPreparer is null\");\n-        this.resourceGroupManager = requireNonNull(resourceGroupManager, \"resourceGroupManager is null\");\n-        this.warningCollector = warningCollectorFactory.create();\n-        this.dispatchQueryFactory = requireNonNull(dispatchQueryFactory, \"dispatchQueryFactory is null\");\n-        this.failedDispatchQueryFactory = requireNonNull(failedDispatchQueryFactory, \"failedDispatchQueryFactory is null\");\n-        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n-        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n-        this.sessionSupplier = requireNonNull(sessionSupplier, \"sessionSupplier is null\");\n-        this.sessionPropertyDefaults = requireNonNull(sessionPropertyDefaults, \"sessionPropertyDefaults is null\");\n-\n-        this.maxQueryLength = queryManagerConfig.getMaxQueryLength();\n-\n-        ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(queryManagerConfig.getQueryManagerExecutorPoolSize(), threadsNamed(\"query-dispatch-%s\"));\n-        queryManagementExecutor = listeningDecorator(scheduledExecutorService);\n-        queryManagementExecutorMBean = new ThreadPoolExecutorMBean((ThreadPoolExecutor) scheduledExecutorService);\n-\n-        this.queryTracker = new QueryTracker<>(queryManagerConfig, queryManagementExecutor);\n-    }\n-\n-    @Managed(description = \"Query dispatch executor\")\n-    @Nested\n-    public ThreadPoolExecutorMBean getExecutor()\n-    {\n-        return queryManagementExecutorMBean;\n-    }\n-\n-    @Managed\n-    @Flatten\n-    public SqlQueryManagerStats getStats()\n-    {\n-        return stats;\n-    }\n-\n-    public QueryId createQueryId()\n-    {\n-        return queryIdGenerator.createNextQueryId();\n-    }\n-\n-    public ListenableFuture<?> createQuery(QueryId queryId, String slug, SessionContext sessionContext, String query)\n-    {\n-        DispatchQueryCreationFuture queryCreationFuture = new DispatchQueryCreationFuture();\n-        queryManagementExecutor.submit(() -> {\n-            try {\n-                createQueryInternal(queryId, slug, sessionContext, query, resourceGroupManager);\n-                queryCreationFuture.set(null);\n-            }\n-            catch (Throwable e) {\n-                queryCreationFuture.setException(e);\n-            }\n-        });\n-        return queryCreationFuture;\n-    }\n-\n-    private <C> void createQueryInternal(QueryId queryId, String slug, SessionContext sessionContext, String query, ResourceGroupManager<C> resourceGroupManager)\n-    {\n-        requireNonNull(queryId, \"queryId is null\");\n-        requireNonNull(sessionContext, \"sessionFactory is null\");\n-        requireNonNull(query, \"query is null\");\n-        checkArgument(!query.isEmpty(), \"query must not be empty string\");\n-        checkArgument(!queryTracker.tryGetQuery(queryId).isPresent(), \"query %s already exists\", queryId);\n-\n-        Session session = null;\n-        SelectionContext<C> selectionContext = null;\n-        PreparedQuery preparedQuery;\n-        DispatchQuery dispatchQuery;\n-        try {\n-            if (query.length() > maxQueryLength) {\n-                int queryLength = query.length();\n-                query = query.substring(0, maxQueryLength);\n-                throw new PrestoException(QUERY_TEXT_TOO_LARGE, format(\"Query text length (%s) exceeds the maximum length (%s)\", queryLength, maxQueryLength));\n-            }\n-\n-            // decode session\n-            session = sessionSupplier.createSession(queryId, sessionContext);\n-\n-            // prepare query\n-            preparedQuery = queryPreparer.prepareQuery(session, query, warningCollector);\n-\n-            // select resource group\n-            Optional<QueryType> queryType = getQueryType(preparedQuery.getStatement().getClass());\n-            selectionContext = resourceGroupManager.selectGroup(new SelectionCriteria(\n-                    sessionContext.getIdentity().getPrincipal().isPresent(),\n-                    sessionContext.getIdentity().getUser(),\n-                    Optional.ofNullable(sessionContext.getSource()),\n-                    sessionContext.getClientTags(),\n-                    sessionContext.getResourceEstimates(),\n-                    queryType.map(Enum::name)));\n-\n-            // apply system default session properties (does not override user set properties)\n-            session = sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType.map(Enum::name), selectionContext.getResourceGroupId());\n-\n-            // mark existing transaction as active\n-            transactionManager.activateTransaction(session, isTransactionControlStatement(preparedQuery.getStatement()), accessControl);\n-\n-            dispatchQuery = dispatchQueryFactory.createDispatchQuery(session, query, preparedQuery, slug, selectionContext.getResourceGroupId(), queryType, warningCollector, queryManagementExecutor);\n-        }\n-        catch (RuntimeException e) {\n-            // This is intentionally not a method, since after the state change listener is registered\n-            // it's not safe to do any of this, and we had bugs before where people reused this code in a method\n-            // if session creation failed, create a minimal session object\n-            if (session == null) {\n-                session = Session.builder(new SessionPropertyManager())\n-                        .setQueryId(queryId)\n-                        .setIdentity(sessionContext.getIdentity())\n-                        .setSource(sessionContext.getSource())\n-                        .setPath(new SqlPath(Optional.empty()))\n-                        .build();\n-            }\n-\n-            // create and immediately fail the query\n-            DispatchQuery failedDispatchQuery = failedDispatchQueryFactory.createFailedDispatchQuery(\n-                    session,\n-                    query,\n-                    Optional.ofNullable(selectionContext).map(SelectionContext::getResourceGroupId),\n-                    e);\n-\n-            try {\n-                queryCreated(failedDispatchQuery);\n-            }\n-            finally {\n-                handleQueryFailure(failedDispatchQuery);\n-            }\n-            return;\n-        }\n-\n-        try {\n-            queryCreated(dispatchQuery);\n-            dispatchQuery.addStateChangeListener(newState -> {\n-                if (newState.isDone()) {\n-                    stats.queryFinished(dispatchQuery.getBasicQueryInfo());\n-                }\n-            });\n-\n-            resourceGroupManager.submit(preparedQuery.getStatement(), dispatchQuery, selectionContext, queryManagementExecutor);\n-        }\n-        catch (RuntimeException e) {\n-            dispatchQuery.fail(e);\n-        }\n-    }\n-\n-    private void queryCreated(DispatchQuery dispatchQuery)\n-    {\n-        queryTracker.addQuery(dispatchQuery);\n-        stats.queryQueued();\n-    }\n-\n-    private void handleQueryFailure(DispatchQuery dispatchQuery)\n-    {\n-        try {\n-            stats.queryStarted();\n-            stats.queryStopped();\n-            BasicQueryInfo queryInfo = dispatchQuery.getBasicQueryInfo();\n-            stats.queuedQueryFailed(queryInfo.getQueryStats().getQueuedTime(), Optional.ofNullable(queryInfo.getErrorCode()));\n-        }\n-        finally {\n-            // execution MUST be added to the expiration queue or there will be a leak\n-            queryTracker.expireQuery(dispatchQuery.getQueryId());\n-        }\n-    }\n-\n-    public ListenableFuture<?> waitForDispatched(QueryId queryId)\n-    {\n-        return queryTracker.tryGetQuery(queryId)\n-                .map(dispatchQuery -> {\n-                    dispatchQuery.recordHeartbeat();\n-                    return dispatchQuery.getDispatchedFuture();\n-                })\n-                .orElseGet(() -> immediateFuture(null));\n-    }\n-\n-    public List<BasicQueryInfo> getQueries()\n-    {\n-        return queryTracker.getAllQueries().stream()\n-                .map(DispatchQuery::getBasicQueryInfo)\n-                .collect(toImmutableList());\n-    }\n-\n-    public BasicQueryInfo getQueryInfo(QueryId queryId)\n-    {\n-        return queryTracker.getQuery(queryId).getBasicQueryInfo();\n-    }\n-\n-    public Optional<DispatchInfo> getDispatchInfo(QueryId queryId)\n-    {\n-        return queryTracker.tryGetQuery(queryId)\n-                .map(dispatchQuery -> {\n-                    dispatchQuery.recordHeartbeat();\n-                    return dispatchQuery.getDispatchInfo();\n-                });\n-    }\n-\n-    public void cancelQuery(QueryId queryId)\n-    {\n-        queryTracker.tryGetQuery(queryId)\n-                .ifPresent(DispatchQuery::cancel);\n-    }\n-\n-    private static class DispatchQueryCreationFuture\n-            extends AbstractFuture<QueryInfo>\n-    {\n-        @Override\n-        protected boolean set(QueryInfo value)\n-        {\n-            return super.set(value);\n-        }\n-\n-        @Override\n-        protected boolean setException(Throwable throwable)\n-        {\n-            return super.setException(throwable);\n-        }\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning)\n-        {\n-            // query submission can not be canceled\n-            return false;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4NzUxNw==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387887517", "bodyText": "Since PurgeQueriesRunnable is gone who's responsible for cleaning up the queries map?", "author": "arhimondr", "createdAt": "2020-03-04T19:33:10Z", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "diffHunk": "@@ -95,83 +85,30 @@\n     private static final DataSize MAX_TARGET_RESULT_SIZE = new DataSize(128, MEGABYTE);\n \n     private final QueryManager queryManager;\n-    private final SessionPropertyManager sessionPropertyManager;\n     private final ExchangeClientSupplier exchangeClientSupplier;\n     private final BlockEncodingSerde blockEncodingSerde;\n     private final BoundedExecutor responseExecutor;\n     private final ScheduledExecutorService timeoutExecutor;\n \n     private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n-    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n-\n-    private final CounterStat createQueryRequests = new CounterStat();\n \n     @Inject\n-    public StatementResource(\n+    public ExecutingStatementResource(\n             QueryManager queryManager,\n-            SessionPropertyManager sessionPropertyManager,\n             ExchangeClientSupplier exchangeClientSupplier,\n             BlockEncodingSerde blockEncodingSerde,\n             @ForStatementResource BoundedExecutor responseExecutor,\n             @ForStatementResource ScheduledExecutorService timeoutExecutor)\n     {\n         this.queryManager = requireNonNull(queryManager, \"queryManager is null\");\n-        this.sessionPropertyManager = requireNonNull(sessionPropertyManager, \"sessionPropertyManager is null\");\n         this.exchangeClientSupplier = requireNonNull(exchangeClientSupplier, \"exchangeClientSupplier is null\");\n         this.blockEncodingSerde = requireNonNull(blockEncodingSerde, \"blockEncodingSerde is null\");\n         this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n         this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");", "originalCommit": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java b/presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\nsimilarity index 68%\nrename from presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java\nrename to presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\nindex 9b781879bc..9ef4fd145e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java\n+++ b/presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\n\n@@ -85,30 +95,83 @@ public class ExecutingStatementResource\n     private static final DataSize MAX_TARGET_RESULT_SIZE = new DataSize(128, MEGABYTE);\n \n     private final QueryManager queryManager;\n+    private final SessionPropertyManager sessionPropertyManager;\n     private final ExchangeClientSupplier exchangeClientSupplier;\n     private final BlockEncodingSerde blockEncodingSerde;\n     private final BoundedExecutor responseExecutor;\n     private final ScheduledExecutorService timeoutExecutor;\n \n     private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n+\n+    private final CounterStat createQueryRequests = new CounterStat();\n \n     @Inject\n-    public ExecutingStatementResource(\n+    public StatementResource(\n             QueryManager queryManager,\n+            SessionPropertyManager sessionPropertyManager,\n             ExchangeClientSupplier exchangeClientSupplier,\n             BlockEncodingSerde blockEncodingSerde,\n             @ForStatementResource BoundedExecutor responseExecutor,\n             @ForStatementResource ScheduledExecutorService timeoutExecutor)\n     {\n         this.queryManager = requireNonNull(queryManager, \"queryManager is null\");\n+        this.sessionPropertyManager = requireNonNull(sessionPropertyManager, \"sessionPropertyManager is null\");\n         this.exchangeClientSupplier = requireNonNull(exchangeClientSupplier, \"exchangeClientSupplier is null\");\n         this.blockEncodingSerde = requireNonNull(blockEncodingSerde, \"blockEncodingSerde is null\");\n         this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n         this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");\n+\n+        queryPurger.scheduleWithFixedDelay(new PurgeQueriesRunnable(queries, queryManager), 200, 200, MILLISECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        queryPurger.shutdownNow();\n+    }\n+\n+    @POST\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response createQuery(\n+            String statement,\n+            @HeaderParam(X_FORWARDED_PROTO) String proto,\n+            @Context HttpServletRequest servletRequest,\n+            @Context UriInfo uriInfo)\n+    {\n+        createQueryRequests.update(1);\n+\n+        if (isNullOrEmpty(statement)) {\n+            throw new WebApplicationException(Response\n+                    .status(Status.BAD_REQUEST)\n+                    .type(MediaType.TEXT_PLAIN)\n+                    .entity(\"SQL statement is empty\")\n+                    .build());\n+        }\n+        if (isNullOrEmpty(proto)) {\n+            proto = uriInfo.getRequestUri().getScheme();\n+        }\n+\n+        SessionContext sessionContext = new HttpRequestSessionContext(servletRequest);\n+\n+        ExchangeClient exchangeClient = exchangeClientSupplier.get(new SimpleLocalMemoryContext(newSimpleAggregatedMemoryContext(), StatementResource.class.getSimpleName()));\n+        Query query = Query.create(\n+                sessionContext,\n+                statement,\n+                queryManager,\n+                sessionPropertyManager,\n+                exchangeClient,\n+                responseExecutor,\n+                timeoutExecutor,\n+                blockEncodingSerde);\n+        queries.put(query.getQueryId(), query);\n+\n+        QueryResults queryResults = query.getNextResult(OptionalLong.empty(), uriInfo, proto, DEFAULT_TARGET_RESULT_SIZE);\n+        return toResponse(query, queryResults);\n     }\n \n     @GET\n-    @Path(\"/v1/statement/executing/{queryId}/{token}\")\n+    @Path(\"{queryId}/{token}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public void getQueryResults(\n             @PathParam(\"queryId\") QueryId queryId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4ODU1OA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387888558", "bodyText": "How about calling it notFound? badRequest implies 400 status.", "author": "arhimondr", "createdAt": "2020-03-04T19:35:11Z", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "diffHunk": "@@ -273,19 +232,42 @@ private static Response toResponse(Query query, QueryResults queryResults)\n     }\n \n     @DELETE\n-    @Path(\"{queryId}/{token}\")\n+    @Path(\"/v1/statement/executing/{queryId}/{token}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public Response cancelQuery(\n             @PathParam(\"queryId\") QueryId queryId,\n             @PathParam(\"token\") long token,\n             @QueryParam(\"slug\") String slug)\n     {\n-        Query query = getQuery(queryId, slug);\n-        if (query == null) {\n-            return Response.status(Status.NOT_FOUND).build();\n+        Query query = queries.get(queryId);\n+        if (query != null) {\n+            if (!query.isSlugValid(slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            query.cancel();\n+            return Response.noContent().build();\n+        }\n+\n+        // cancel the query execution directly instead of creating the statement client\n+        try {\n+            if (!queryManager.isQuerySlugValid(queryId, slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            queryManager.cancelQuery(queryId);\n+            return Response.noContent().build();\n+        }\n+        catch (NoSuchElementException e) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n         }\n-        query.cancel();\n-        return Response.noContent().build();\n+    }\n+\n+    private static WebApplicationException badRequest(Status status, String message)", "originalCommit": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNjA5OQ==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389136099", "bodyText": "What I'll do is, because every method that calls this passes in NOT_FOUND for the status, is I'll hardcode that NOT_FOUND and rename to notFound.", "author": "tdcmeehan", "createdAt": "2020-03-06T20:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4ODU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java b/presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\nsimilarity index 68%\nrename from presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java\nrename to presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\nindex 9b781879bc..9ef4fd145e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java\n+++ b/presto-main/src/main/java/com/facebook/presto/server/protocol/StatementResource.java\n\n@@ -232,42 +273,19 @@ public class ExecutingStatementResource\n     }\n \n     @DELETE\n-    @Path(\"/v1/statement/executing/{queryId}/{token}\")\n+    @Path(\"{queryId}/{token}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public Response cancelQuery(\n             @PathParam(\"queryId\") QueryId queryId,\n             @PathParam(\"token\") long token,\n             @QueryParam(\"slug\") String slug)\n     {\n-        Query query = queries.get(queryId);\n-        if (query != null) {\n-            if (!query.isSlugValid(slug)) {\n-                throw badRequest(NOT_FOUND, \"Query not found\");\n-            }\n-            query.cancel();\n-            return Response.noContent().build();\n-        }\n-\n-        // cancel the query execution directly instead of creating the statement client\n-        try {\n-            if (!queryManager.isQuerySlugValid(queryId, slug)) {\n-                throw badRequest(NOT_FOUND, \"Query not found\");\n-            }\n-            queryManager.cancelQuery(queryId);\n-            return Response.noContent().build();\n-        }\n-        catch (NoSuchElementException e) {\n-            throw badRequest(NOT_FOUND, \"Query not found\");\n+        Query query = getQuery(queryId, slug);\n+        if (query == null) {\n+            return Response.status(Status.NOT_FOUND).build();\n         }\n-    }\n-\n-    private static WebApplicationException badRequest(Status status, String message)\n-    {\n-        throw new WebApplicationException(\n-                Response.status(status)\n-                        .type(TEXT_PLAIN_TYPE)\n-                        .entity(message)\n-                        .build());\n+        query.cancel();\n+        return Response.noContent().build();\n     }\n \n     private static String urlEncode(String value)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r388645244", "bodyText": "hmm. \ud83d\ude03", "author": "wenleix", "createdAt": "2020-03-06T00:33:54Z", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.concurrent.BoundedExecutor;\n+import com.facebook.airlift.concurrent.ThreadPoolExecutorMBean;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.google.common.io.Closer;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchExecutor\n+{\n+    private final Closer closer = Closer.create();\n+\n+    private final ListeningExecutorService executor;\n+    private final BoundedExecutor boundedExecutor;", "originalCommit": "1eab1523ca0a838052bbd117b21058f1332f60ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxOTE5MA==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r388719190", "bodyText": "Is it possible to also export the number of active threads in BoundedExecutor? -- this has been an operation pain when we want to monitor when BoundedExecutor is full.", "author": "wenleix", "createdAt": "2020-03-06T05:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MjcwMw==", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389192703", "bodyText": "BoundedExecutor does not expose the number of active threads, however the underlying executor itself does export itself as an MBean via ThreadPoolExecutorMBean", "author": "tdcmeehan", "createdAt": "2020-03-06T23:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java b/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java\ndeleted file mode 100644\nindex 5a3f7d1816..0000000000\n--- a/presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java\n+++ /dev/null\n\n@@ -1,120 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.dispatcher;\n-\n-import com.facebook.airlift.concurrent.BoundedExecutor;\n-import com.facebook.airlift.concurrent.ThreadPoolExecutorMBean;\n-import com.facebook.presto.execution.QueryManagerConfig;\n-import com.google.common.io.Closer;\n-import com.google.common.util.concurrent.ListeningExecutorService;\n-import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n-import org.weakref.jmx.Flatten;\n-import org.weakref.jmx.Managed;\n-import org.weakref.jmx.Nested;\n-\n-import javax.annotation.PreDestroy;\n-import javax.inject.Inject;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ThreadPoolExecutor;\n-\n-import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n-import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n-import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newCachedThreadPool;\n-import static java.util.concurrent.Executors.newScheduledThreadPool;\n-\n-public class DispatchExecutor\n-{\n-    private final Closer closer = Closer.create();\n-\n-    private final ListeningExecutorService executor;\n-    private final BoundedExecutor boundedExecutor;\n-    private final ListeningScheduledExecutorService scheduledExecutor;\n-\n-    private final DispatchExecutorMBeans mbeans;\n-\n-    @Inject\n-    public DispatchExecutor(QueryManagerConfig config)\n-    {\n-        ExecutorService coreExecutor = newCachedThreadPool(daemonThreadsNamed(\"dispatcher-query-%s\"));\n-        closer.register(coreExecutor::shutdownNow);\n-        executor = listeningDecorator(coreExecutor);\n-        boundedExecutor = new BoundedExecutor(coreExecutor, config.getQuerySubmissionMaxThreads());\n-\n-        ScheduledExecutorService coreScheduledExecutor = newScheduledThreadPool(config.getQueryManagerExecutorPoolSize(), daemonThreadsNamed(\"dispatch-executor-%s\"));\n-        closer.register(coreScheduledExecutor::shutdownNow);\n-        scheduledExecutor = listeningDecorator(coreScheduledExecutor);\n-\n-        mbeans = new DispatchExecutorMBeans(coreExecutor, coreScheduledExecutor);\n-    }\n-\n-    public ListeningExecutorService getExecutor()\n-    {\n-        return executor;\n-    }\n-\n-    public BoundedExecutor getBoundedExecutor()\n-    {\n-        return boundedExecutor;\n-    }\n-\n-    public ListeningScheduledExecutorService getScheduledExecutor()\n-    {\n-        return scheduledExecutor;\n-    }\n-\n-    @Managed\n-    @Flatten\n-    public DispatchExecutorMBeans getMbeans()\n-    {\n-        return mbeans;\n-    }\n-\n-    @PreDestroy\n-    public void shutdown()\n-            throws Exception\n-    {\n-        closer.close();\n-    }\n-\n-    public class DispatchExecutorMBeans\n-    {\n-        private final ThreadPoolExecutorMBean executor;\n-        private final ThreadPoolExecutorMBean scheduledExecutor;\n-\n-        public DispatchExecutorMBeans(ExecutorService coreExecutor, ScheduledExecutorService coreScheduledExecutor)\n-        {\n-            requireNonNull(coreExecutor, \"coreExecutor is null\");\n-            requireNonNull(coreScheduledExecutor, \"coreScheduledExecutor is null\");\n-            executor = new ThreadPoolExecutorMBean((ThreadPoolExecutor) coreExecutor);\n-            scheduledExecutor = new ThreadPoolExecutorMBean((ThreadPoolExecutor) coreScheduledExecutor);\n-        }\n-\n-        @Managed\n-        @Nested\n-        public ThreadPoolExecutorMBean getExecutor()\n-        {\n-            return executor;\n-        }\n-\n-        @Managed\n-        @Nested\n-        public ThreadPoolExecutorMBean getScheduledExecutor()\n-        {\n-            return scheduledExecutor;\n-        }\n-    }\n-}\n"}}, {"oid": "0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "url": "https://github.com/prestodb/presto/commit/0fb77dcbf57a169b1e3426e32b14b713dfa93ddd", "message": "Add query id to NoSuchElementException\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-06T23:33:11Z", "type": "commit"}, {"oid": "9c42121260e04e0907c5821ec25422a8256035bf", "url": "https://github.com/prestodb/presto/commit/9c42121260e04e0907c5821ec25422a8256035bf", "message": "Remove system startup minimum worker requirement\n\nThe normal minimum worker requirement applied to all queries is\nsufficient to cover this case.\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-06T23:33:11Z", "type": "commit"}, {"oid": "efcdeb234581bb9181fc42d7730f57f542f25c76", "url": "https://github.com/prestodb/presto/commit/efcdeb234581bb9181fc42d7730f57f542f25c76", "message": "Add DISPATCHING query states\n\nA query will be in the DISPATCHING state during handoff to a query\nexecution coordinator.\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-06T23:33:11Z", "type": "commit"}, {"oid": "537402107ba5ff58f867a2aef8bda4b1fdc220ef", "url": "https://github.com/prestodb/presto/commit/537402107ba5ff58f867a2aef8bda4b1fdc220ef", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-06T23:34:05Z", "type": "forcePushed"}, {"oid": "5e1e30f0a760fef3437fd1f6a9887d4195bd273a", "url": "https://github.com/prestodb/presto/commit/5e1e30f0a760fef3437fd1f6a9887d4195bd273a", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-06T23:35:47Z", "type": "forcePushed"}, {"oid": "0a16c9385d7fddb05e5da68d7ad3fba5db57cc05", "url": "https://github.com/prestodb/presto/commit/0a16c9385d7fddb05e5da68d7ad3fba5db57cc05", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-06T23:41:43Z", "type": "forcePushed"}, {"oid": "cf619c65b677d797b68ef7d6e7ea081fa9b846e9", "url": "https://github.com/prestodb/presto/commit/cf619c65b677d797b68ef7d6e7ea081fa9b846e9", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-06T23:58:41Z", "type": "forcePushed"}, {"oid": "32073349631bc5a1f75446ac0f641461629e35c0", "url": "https://github.com/prestodb/presto/commit/32073349631bc5a1f75446ac0f641461629e35c0", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-07T00:11:01Z", "type": "forcePushed"}, {"oid": "669b32a4b55d22708cd4fd1ccc99c4b3cf59ba7d", "url": "https://github.com/prestodb/presto/commit/669b32a4b55d22708cd4fd1ccc99c4b3cf59ba7d", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-07T00:26:06Z", "type": "forcePushed"}, {"oid": "05b68dc3a38cfdf2b4b32e0b14b85c782b84c014", "url": "https://github.com/prestodb/presto/commit/05b68dc3a38cfdf2b4b32e0b14b85c782b84c014", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-07T01:11:42Z", "type": "forcePushed"}, {"oid": "02622876d2f6dbebe678d9e64d81a79e57269fe3", "url": "https://github.com/prestodb/presto/commit/02622876d2f6dbebe678d9e64d81a79e57269fe3", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-07T03:29:19Z", "type": "forcePushed"}, {"oid": "6a2c70cf9c4e82f61d32e72e119d69c7b722e6bb", "url": "https://github.com/prestodb/presto/commit/6a2c70cf9c4e82f61d32e72e119d69c7b722e6bb", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-08T07:04:53Z", "type": "forcePushed"}, {"oid": "2a35115756e3591096d805c49a13cf14166c4f32", "url": "https://github.com/prestodb/presto/commit/2a35115756e3591096d805c49a13cf14166c4f32", "message": "Split out queued phase from QueryManager\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:07Z", "type": "commit"}, {"oid": "1aedb21091ae1b0550b02de4966ab6413eab9fbb", "url": "https://github.com/prestodb/presto/commit/1aedb21091ae1b0550b02de4966ab6413eab9fbb", "message": "Add peak tasks to BasicQueryStats", "committedDate": "2020-03-09T05:25:07Z", "type": "commit"}, {"oid": "75102974fe2436e112c9ac3a47553d55eb4e197e", "url": "https://github.com/prestodb/presto/commit/75102974fe2436e112c9ac3a47553d55eb4e197e", "message": "Add LocalCoordinatorLocation\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:07Z", "type": "commit"}, {"oid": "6329d906a15a43e531c992deaf978e99f74facb8", "url": "https://github.com/prestodb/presto/commit/6329d906a15a43e531c992deaf978e99f74facb8", "message": "Improve query event stats for immediately failed queries\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:07Z", "type": "commit"}, {"oid": "d641e7bddeab1f66bd3fc475777bc85c0e763ae7", "url": "https://github.com/prestodb/presto/commit/d641e7bddeab1f66bd3fc475777bc85c0e763ae7", "message": "Remove Optional from QueryStateMachine resourceGroup\n\nresourceGroup is already required in QueryStateMachine\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:08Z", "type": "commit"}, {"oid": "1c6a43f2b7d375a982b6c317a8c38e9f49a3543a", "url": "https://github.com/prestodb/presto/commit/1c6a43f2b7d375a982b6c317a8c38e9f49a3543a", "message": "Simplify DispatchInfo construction\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:08Z", "type": "commit"}, {"oid": "848f23abe953f358ebee2c15e71a1963c19985b3", "url": "https://github.com/prestodb/presto/commit/848f23abe953f358ebee2c15e71a1963c19985b3", "message": "Rename SqlQueryManagerStats to QueryManagerStats\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:08Z", "type": "commit"}, {"oid": "a4d2f174b5314b58c0307a9924f41c928fdd4a0e", "url": "https://github.com/prestodb/presto/commit/a4d2f174b5314b58c0307a9924f41c928fdd4a0e", "message": "Simplify query manager stats tracking\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:25:08Z", "type": "commit"}, {"oid": "1b91f7a0717eb6264287462336e468ece97b4d17", "url": "https://github.com/prestodb/presto/commit/1b91f7a0717eb6264287462336e468ece97b4d17", "message": "Fix handling of failures during query creation\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:26:55Z", "type": "commit"}, {"oid": "eb07101d60fca16600cc7ac30f3e98dfb0625e4c", "url": "https://github.com/prestodb/presto/commit/eb07101d60fca16600cc7ac30f3e98dfb0625e4c", "message": "Cleanup dispatcher executor management\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:27:40Z", "type": "commit"}, {"oid": "73918d18636d6a3caad22edf68ead0361cea60fa", "url": "https://github.com/prestodb/presto/commit/73918d18636d6a3caad22edf68ead0361cea60fa", "message": "Change local dispatch to finish immediately after query submission\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:27:44Z", "type": "commit"}, {"oid": "1a4ef68f27f8f6a792de33020750dbe5e35ef18c", "url": "https://github.com/prestodb/presto/commit/1a4ef68f27f8f6a792de33020750dbe5e35ef18c", "message": "Catch errors from LocalDispatchQuery querySubmitter\n\nquerySubmitter should never throw, but if it does fail the query immediately\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:27:44Z", "type": "commit"}, {"oid": "a855e13c9528a47b658ee78edfa0c5e4dce97d53", "url": "https://github.com/prestodb/presto/commit/a855e13c9528a47b658ee78edfa0c5e4dce97d53", "message": "Fix result caching in protocol Query\n\nPreviously, the cache was effectively disabled for the first result, so a\nretry on first request resulted in a 410 gone.\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:27:44Z", "type": "commit"}, {"oid": "823a0e5048b269c285550e574afb0ccc9522ef87", "url": "https://github.com/prestodb/presto/commit/823a0e5048b269c285550e574afb0ccc9522ef87", "message": "Simplify token management in protocol Query\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>\nCo-authored-by: Raghav Sethi <raghavsethi.rs@gmail.com>", "committedDate": "2020-03-09T05:27:45Z", "type": "commit"}, {"oid": "95e5b4c2e21d4d1154bbb78ebaa425ca9963ac3e", "url": "https://github.com/prestodb/presto/commit/95e5b4c2e21d4d1154bbb78ebaa425ca9963ac3e", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-09T05:27:45Z", "type": "commit"}, {"oid": "95e5b4c2e21d4d1154bbb78ebaa425ca9963ac3e", "url": "https://github.com/prestodb/presto/commit/95e5b4c2e21d4d1154bbb78ebaa425ca9963ac3e", "message": "Add purger to ExecutingStatementResource\n\nCo-authored-by: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-03-09T05:27:45Z", "type": "forcePushed"}]}