{"pr_number": 14884, "pr_title": "Fix flaky testRuntimeOptimizedStagesCorrectness", "pr_createdAt": "2020-07-24T16:08:45Z", "pr_url": "https://github.com/prestodb/presto/pull/14884", "timeline": [{"oid": "bd55659e7adde48a47d673286240376d891c13c0", "url": "https://github.com/prestodb/presto/commit/bd55659e7adde48a47d673286240376d891c13c0", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness", "committedDate": "2020-07-24T21:41:08Z", "type": "forcePushed"}, {"oid": "04fdff8deb1941e0f870e5c9b999aa527d4275b8", "url": "https://github.com/prestodb/presto/commit/04fdff8deb1941e0f870e5c9b999aa527d4275b8", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness", "committedDate": "2020-07-26T00:10:13Z", "type": "forcePushed"}, {"oid": "a03efffa80471db1e408368c9c9fa463a32b2e91", "url": "https://github.com/prestodb/presto/commit/a03efffa80471db1e408368c9c9fa463a32b2e91", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness", "committedDate": "2020-07-26T01:25:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ==", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460907635", "bodyText": "I worry that this means at some point the test can break and we won't know it because we aren't doing any checks. Is this part necessary for fixing the flakiness?  Is there a way to wait for the correct event instead?", "author": "rschlussel", "createdAt": "2020-07-27T13:55:36Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "diffHunk": "@@ -101,58 +103,67 @@ public void testRuntimeOptimizedStagesCorrectness()\n     {\n         // We expect one runtime optimized stage: 1.\n         int expectedEvents = 2;\n-        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        QueryId queryId = runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n         QueryCreatedEvent queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         QueryCompletedEvent queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         QueryMetadata queryMetadata = queryCompletedEvent.getMetadata();\n         Optional<List<StageId>> runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n+            assertEquals(queryMetadata.getQueryId(), queryId.toString());\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+            assertTrue(runtimeOptimizedStages.isPresent());\n+            assertEquals(runtimeOptimizedStages.get().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                    .map(stageId -> String.valueOf(stageId.getId()))\n+                    .collect(toImmutableList()));\n+        }\n \n         // Now, the following query should not trigger runtime optimizations, so should have empty list of runtime optimized stages.\n-        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n-        assertFalse(runtimeOptimizedStages.isPresent());\n+        if (queryCompletedEvent.getMetadata().getQueryId().equals(queryId.toString())) {\n+            assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n+            assertFalse(runtimeOptimizedStages.isPresent());\n+        }\n \n         // Now, the following query should have two optimized joins in a single stage (both on the same nationkey), therefore expect only one optimized stage: 1.\n-        runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+            assertTrue(runtimeOptimizedStages.isPresent());\n+            assertEquals(runtimeOptimizedStages.get().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                    .map(stageId -> String.valueOf(stageId.getId()))\n+                    .collect(toImmutableList()));\n+        }\n \n         // Now, the following query should have two runtime optimized stages: 1 and 4, corresponding to the two join operations (on regionkey and nationkey respectively).\n-        runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 2);\n-        assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 2);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {", "originalCommit": "a03efffa80471db1e408368c9c9fa463a32b2e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwOTA3Nw==", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460909077", "bodyText": "No, this part is not essential, just for the super extreme case where after waiting 180 seconds, the previous queryCompletedEvent still have not reached.", "author": "pguofb", "createdAt": "2020-07-27T13:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMTk4Nw==", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460911987", "bodyText": "great, can you remove this then? If there's still test flakiness after this, I'd rather add a loop to wait for the correct query id for a certain amount of time.", "author": "rschlussel", "createdAt": "2020-07-27T14:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMjAxOA==", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460912018", "bodyText": "But on the other hand, if the queryIds are different then there is no point to further run assertions because essentially we will be comparing two events from two different queries.", "author": "pguofb", "createdAt": "2020-07-27T14:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMjU2OA==", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460912568", "bodyText": "Sure. I will remove this part.", "author": "pguofb", "createdAt": "2020-07-27T14:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae604efaca53d86bd13fdcd674453380018d5500", "chunk": "diff --git a/presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java b/presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java\nindex f43b9a7a30..fe8a6a040e 100644\n--- a/presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java\n+++ b/presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java\n\n@@ -109,61 +109,53 @@ public class TestEventListenerWithExchangeMaterialization\n         QueryMetadata queryMetadata = queryCompletedEvent.getMetadata();\n         Optional<List<StageId>> runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n-            assertEquals(queryMetadata.getQueryId(), queryId.toString());\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-            assertTrue(runtimeOptimizedStages.isPresent());\n-            assertEquals(runtimeOptimizedStages.get().size(), 1);\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                    .map(stageId -> String.valueOf(stageId.getId()))\n-                    .collect(toImmutableList()));\n-        }\n+        assertEquals(queryMetadata.getQueryId(), queryId.toString());\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+        assertTrue(runtimeOptimizedStages.isPresent());\n+        assertEquals(runtimeOptimizedStages.get().size(), 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n \n         // Now, the following query should not trigger runtime optimizations, so should have empty list of runtime optimized stages.\n-        queryId = runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        if (queryCompletedEvent.getMetadata().getQueryId().equals(queryId.toString())) {\n-            assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n-            assertFalse(runtimeOptimizedStages.isPresent());\n-        }\n+        assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n+        assertFalse(runtimeOptimizedStages.isPresent());\n \n         // Now, the following query should have two optimized joins in a single stage (both on the same nationkey), therefore expect only one optimized stage: 1.\n-        queryId = runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n+        runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-            assertTrue(runtimeOptimizedStages.isPresent());\n-            assertEquals(runtimeOptimizedStages.get().size(), 1);\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                    .map(stageId -> String.valueOf(stageId.getId()))\n-                    .collect(toImmutableList()));\n-        }\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+        assertTrue(runtimeOptimizedStages.isPresent());\n+        assertEquals(runtimeOptimizedStages.get().size(), 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n \n         // Now, the following query should have two runtime optimized stages: 1 and 4, corresponding to the two join operations (on regionkey and nationkey respectively).\n-        queryId = runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n+        runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 2);\n-            assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n-            assertTrue(runtimeOptimizedStages.isPresent());\n-            assertEquals(runtimeOptimizedStages.get().size(), 2);\n-            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                    .map(stageId -> String.valueOf(stageId.getId()))\n-                    .collect(toImmutableList()));\n-        }\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 2);\n+        assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n+        assertTrue(runtimeOptimizedStages.isPresent());\n+        assertEquals(runtimeOptimizedStages.get().size(), 2);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n     }\n \n     static class TestingEventListenerPlugin\n"}}, {"oid": "ae604efaca53d86bd13fdcd674453380018d5500", "url": "https://github.com/prestodb/presto/commit/ae604efaca53d86bd13fdcd674453380018d5500", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness", "committedDate": "2020-07-27T14:12:51Z", "type": "commit"}, {"oid": "ae604efaca53d86bd13fdcd674453380018d5500", "url": "https://github.com/prestodb/presto/commit/ae604efaca53d86bd13fdcd674453380018d5500", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness", "committedDate": "2020-07-27T14:12:51Z", "type": "forcePushed"}]}