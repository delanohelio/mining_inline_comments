{"pr_number": 14224, "pr_title": "Aggregation Pushdown for Druid connector", "pr_createdAt": "2020-03-07T00:27:47Z", "pr_url": "https://github.com/prestodb/presto/pull/14224", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MTk5MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389991990", "bodyText": "not used", "author": "highker", "createdAt": "2020-03-09T22:16:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjA3NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992074", "bodyText": "break a line", "author": "highker", "createdAt": "2020-03-09T22:16:28Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjI4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992283", "bodyText": "nit: replace the space with a period a the end.", "author": "highker", "createdAt": "2020-03-09T22:17:05Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjM5NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992394", "bodyText": "one param per line; same for all other functions in this class.", "author": "highker", "createdAt": "2020-03-09T22:17:28Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3MQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390062371", "bodyText": "yep", "author": "zhenxiao", "createdAt": "2020-03-10T02:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjU4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992583", "bodyText": "Use if", "author": "highker", "createdAt": "2020-03-09T22:18:02Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5Mjg5OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992899", "bodyText": "same nit: .. Druid connector \"; there are many typos in this patch", "author": "highker", "createdAt": "2020-03-09T22:18:53Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {\n+            case FROM_UNIXTIME:\n+                inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n+                inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n+                inputFormat = \"seconds\";\n+                break;\n+            default:\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported time function: \" + timeConversion.getDisplayName() + \" to pushdown for Druid connector \");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MzAxNA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389993014", "bodyText": "if", "author": "highker", "createdAt": "2020-03-09T22:19:13Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {\n+            case FROM_UNIXTIME:\n+                inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n+                inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n+                inputFormat = \"seconds\";\n+                break;\n+            default:\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported time function: \" + timeConversion.getDisplayName() + \" to pushdown for Druid connector \");\n+        }\n+\n+        RowExpression intervalParameter = function.getArguments().get(0);\n+        if (!(intervalParameter instanceof ConstantExpression)) {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported interval unit: \" + intervalParameter + \" to pushdown for Druid connector \");\n+        }\n+\n+        return derived(\"dateTrunc(\" + inputColumn + \",\" + inputFormat + \", \" + inputTimeZone + \", \" + getStringFromConstant(intervalParameter) + \")\");\n+    }\n+\n+    private DruidExpression handleArithmeticExpression(\n+            CallExpression expression,\n+            OperatorType operatorType,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        List<RowExpression> arguments = expression.getArguments();\n+        if (arguments.size() == 1) {\n+            String prefix = operatorType == OperatorType.NEGATION ? \"-\" : \"\";\n+            return derived(prefix + arguments.get(0).accept(this, context).getDefinition());\n+        }\n+        if (arguments.size() == 2) {\n+            DruidExpression left = arguments.get(0).accept(this, context);\n+            DruidExpression right = arguments.get(1).accept(this, context);\n+            String prestoOperator = operatorType.getOperator();\n+            String druidOperator = PRESTO_TO_DRUID_OPERATORS.get(prestoOperator);\n+            if (druidOperator == null) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported binary expression: \" + prestoOperator + \" to pushdown for Druid connector \");\n+            }\n+            return derived(format(\"%s(%s, %s)\", druidOperator, left.getDefinition(), right.getDefinition()));\n+        }\n+        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported arithmetic expression: \" + expression + \" to pushdown for Druid connector \");\n+    }\n+\n+    private DruidExpression handleFunction(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        switch (function.getDisplayName().toLowerCase(ENGLISH)) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex c1799501dc..1b1897430e 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.facebook.presto.druid;\n \n-import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadata;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDU4Ng==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994586", "bodyText": "Having a public enum in a util class doesn't sound good. Can you make AggregationColumnNode a top-level class and call it DruidAggregationColumnNode? Put the enum and two implementations as the inner class of it.", "author": "highker", "createdAt": "2020-03-09T22:23:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java", "diffHunk": "@@ -42,6 +47,106 @@\n {\n     private DruidPushdownUtils() {}\n \n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java\nindex 167498bc7b..bb67410257 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java\n\n@@ -47,95 +48,21 @@ public class DruidPushdownUtils\n {\n     private DruidPushdownUtils() {}\n \n-    public enum ExpressionType\n-    {\n-        GROUP_BY,\n-        AGGREGATE,\n-    }\n-\n-    public static class GroupByColumnNode\n-            extends AggregationColumnNode\n-    {\n-        private final VariableReferenceExpression inputColumn;\n-\n-        public GroupByColumnNode(VariableReferenceExpression inputColumn, VariableReferenceExpression output)\n-        {\n-            super(ExpressionType.GROUP_BY, output);\n-            this.inputColumn = inputColumn;\n-        }\n-\n-        public VariableReferenceExpression getInputColumn()\n-        {\n-            return inputColumn;\n-        }\n-\n-        @Override\n-        public String toString()\n-        {\n-            return inputColumn.toString();\n-        }\n-    }\n-\n-    public static class AggregationFunctionColumnNode\n-            extends AggregationColumnNode\n-    {\n-        private final CallExpression callExpression;\n-\n-        public AggregationFunctionColumnNode(VariableReferenceExpression output, CallExpression callExpression)\n-        {\n-            super(ExpressionType.AGGREGATE, output);\n-            this.callExpression = callExpression;\n-        }\n-\n-        public CallExpression getCallExpression()\n-        {\n-            return callExpression;\n-        }\n-\n-        @Override\n-        public String toString()\n-        {\n-            return callExpression.toString();\n-        }\n-    }\n-\n-    public abstract static class AggregationColumnNode\n-    {\n-        private final ExpressionType expressionType;\n-        private final VariableReferenceExpression outputColumn;\n-\n-        public AggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n-        {\n-            this.expressionType = expressionType;\n-            this.outputColumn = outputColumn;\n-        }\n-\n-        public VariableReferenceExpression getOutputColumn()\n-        {\n-            return outputColumn;\n-        }\n-\n-        public ExpressionType getExpressionType()\n-        {\n-            return expressionType;\n-        }\n-    }\n-\n-    public static List<AggregationColumnNode> computeAggregationNodes(AggregationNode aggregationNode)\n+    public static List<DruidAggregationColumnNode> computeAggregationNodes(AggregationNode aggregationNode)\n     {\n         int groupByKeyIndex = 0;\n-        ImmutableList.Builder<AggregationColumnNode> nodeBuilder = ImmutableList.builder();\n+        ImmutableList.Builder<DruidAggregationColumnNode> nodeBuilder = ImmutableList.builder();\n         for (VariableReferenceExpression outputColumn : aggregationNode.getOutputVariables()) {\n-            AggregationNode.Aggregation agg = aggregationNode.getAggregations().get(outputColumn);\n+            AggregationNode.Aggregation aggregation = aggregationNode.getAggregations().get(outputColumn);\n \n-            if (agg != null) {\n-                if (agg.getFilter().isPresent()\n-                        || agg.isDistinct()\n-                        || agg.getOrderBy().isPresent()\n-                        || agg.getMask().isPresent()) {\n+            if (aggregation != null) {\n+                if (aggregation.getFilter().isPresent()\n+                        || aggregation.isDistinct()\n+                        || aggregation.getOrderBy().isPresent()\n+                        || aggregation.getMask().isPresent()) {\n                     throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported aggregation node \" + aggregationNode);\n                 }\n-                nodeBuilder.add(new AggregationFunctionColumnNode(outputColumn, agg.getCall()));\n+                nodeBuilder.add(new AggregationFunctionColumnNode(outputColumn, aggregation.getCall()));\n             }\n             else {\n                 // group by output\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDg0OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994849", "bodyText": "Move to the end of the class", "author": "highker", "createdAt": "2020-03-09T22:24:38Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex fa1d46d2c6..c911968baf 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -249,37 +250,18 @@ public class DruidQueryGenerator\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n \n-        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n-        {\n-            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n-            List<RowExpression> parameters = aggregation.getArguments();\n-            switch (prestoAggregation) {\n-                case \"count\":\n-                    if (parameters.size() <= 1) {\n-                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-                    break;\n-                default:\n-                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n-                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-            }\n-\n-            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n-        }\n-\n         @Override\n         public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n         {\n-            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n \n-            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n             // And finally, in the second pass actually generate the PQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n-            for (AggregationColumnNode expression : aggregationColumnNodes) {\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n                 switch (expression.getExpressionType()) {\n                     case GROUP_BY: {\n                         GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDg5Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994892", "bodyText": "if", "author": "highker", "createdAt": "2020-03-09T22:24:45Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex fa1d46d2c6..c911968baf 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -249,37 +250,18 @@ public class DruidQueryGenerator\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n \n-        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n-        {\n-            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n-            List<RowExpression> parameters = aggregation.getArguments();\n-            switch (prestoAggregation) {\n-                case \"count\":\n-                    if (parameters.size() <= 1) {\n-                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-                    break;\n-                default:\n-                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n-                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-            }\n-\n-            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n-        }\n-\n         @Override\n         public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n         {\n-            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n \n-            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n             // And finally, in the second pass actually generate the PQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n-            for (AggregationColumnNode expression : aggregationColumnNodes) {\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n                 switch (expression.getExpressionType()) {\n                     case GROUP_BY: {\n                         GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTA1Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389995053", "bodyText": "leave a space after function:", "author": "highker", "createdAt": "2020-03-09T22:25:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {\n+                case \"count\":\n+                    if (parameters.size() <= 1) {\n+                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+                    break;\n+                default:\n+                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n+                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+            }\n+\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex fa1d46d2c6..c911968baf 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -249,37 +250,18 @@ public class DruidQueryGenerator\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n \n-        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n-        {\n-            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n-            List<RowExpression> parameters = aggregation.getArguments();\n-            switch (prestoAggregation) {\n-                case \"count\":\n-                    if (parameters.size() <= 1) {\n-                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-                    break;\n-                default:\n-                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n-                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-            }\n-\n-            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n-        }\n-\n         @Override\n         public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n         {\n-            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n \n-            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n             // And finally, in the second pass actually generate the PQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n-            for (AggregationColumnNode expression : aggregationColumnNodes) {\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n                 switch (expression.getExpressionType()) {\n                     case GROUP_BY: {\n                         GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTE2Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389995163", "bodyText": "typo aggregatin", "author": "highker", "createdAt": "2020-03-09T22:25:29Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {\n+                case \"count\":\n+                    if (parameters.size() <= 1) {\n+                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+                    break;\n+                default:\n+                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n+                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+            }\n+\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex fa1d46d2c6..c911968baf 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -249,37 +250,18 @@ public class DruidQueryGenerator\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n \n-        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n-        {\n-            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n-            List<RowExpression> parameters = aggregation.getArguments();\n-            switch (prestoAggregation) {\n-                case \"count\":\n-                    if (parameters.size() <= 1) {\n-                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-                    break;\n-                default:\n-                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n-                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n-                    }\n-            }\n-\n-            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n-        }\n-\n         @Override\n         public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n         {\n-            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n \n-            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n             // And finally, in the second pass actually generate the PQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n-            for (AggregationColumnNode expression : aggregationColumnNodes) {\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n                 switch (expression.getExpressionType()) {\n                     case GROUP_BY: {\n                         GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n"}}, {"oid": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "url": "https://github.com/prestodb/presto/commit/c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-10T02:27:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MDkxNA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390540914", "bodyText": "so this refers to query without Group By clause?", "author": "luohao", "createdAt": "2020-03-10T18:55:55Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MzY0Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663647", "bodyText": "query with Group By, but no aggregations, e.g. count(*)", "author": "zhenxiao", "createdAt": "2020-03-10T23:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MDkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex c911968baf..781700c0e7 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -257,7 +257,7 @@ public class DruidQueryGenerator\n \n             // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n-            // And finally, in the second pass actually generate the PQL\n+            // And finally, in the second pass actually generate the DQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0Mjg3Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390542872", "bodyText": "Druid seems to support more than just min/max/avg/sum. Some of them should have a mapping to Presto aggreation functions(https://druid.apache.org/docs/latest/querying/sql.html#aggregation-functions), while the others may not apply due to implementation(e.g., need to be careful with HLL).\nDo you plan to add other functions?", "author": "luohao", "createdAt": "2020-03-10T18:59:10Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -19,33 +19,56 @@\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.AggregationNode;\n import com.facebook.presto.spi.plan.FilterNode;\n import com.facebook.presto.spi.plan.LimitNode;\n import com.facebook.presto.spi.plan.PlanNode;\n import com.facebook.presto.spi.plan.PlanVisitor;\n import com.facebook.presto.spi.plan.ProjectNode;\n import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.RowExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.BigintType;\n import com.facebook.presto.spi.type.TypeManager;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n \n import javax.inject.Inject;\n \n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.facebook.presto.druid.DruidAggregationColumnNode.AggregationFunctionColumnNode;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.AGGREGATE;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.GROUP_BY;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.GroupByColumnNode;\n import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidPushdownUtils.computeAggregationNodes;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.DERIVED;\n import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n import static java.util.Objects.requireNonNull;\n \n public class DruidQueryGenerator\n {\n     private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+    private static final Map<String, String> UNARY_AGGREGATION_MAP = ImmutableMap.of(", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MzQ3OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663479", "bodyText": "yep, will add in following PRs. Start with easy ones :)", "author": "zhenxiao", "createdAt": "2020-03-10T23:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0Mjg3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MzE4Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390543187", "bodyText": "what is PQL?", "author": "luohao", "createdAt": "2020-03-10T18:59:44Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex c911968baf..781700c0e7 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -257,7 +257,7 @@ public class DruidQueryGenerator\n \n             // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n-            // And finally, in the second pass actually generate the PQL\n+            // And finally, in the second pass actually generate the DQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0NDM3Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390544372", "bodyText": "Is count the only aggregation function in this case?", "author": "luohao", "createdAt": "2020-03-10T19:01:47Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by\n+            if (groupByExists && aggregations == 0) {\n+                VariableReferenceExpression hidden = new VariableReferenceExpression(UUID.randomUUID().toString(), BigintType.BIGINT);\n+                newSelections.put(hidden, new Selection(\"count(*)\", DERIVED));", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2Mzc1OA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663758", "bodyText": "yep, count(*) is the only case", "author": "zhenxiao", "createdAt": "2020-03-10T23:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0NDM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex c911968baf..781700c0e7 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -257,7 +257,7 @@ public class DruidQueryGenerator\n \n             // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n             // Then pass that context to the source\n-            // And finally, in the second pass actually generate the PQL\n+            // And finally, in the second pass actually generate the DQL\n \n             // 1st pass\n             Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n"}}, {"oid": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "url": "https://github.com/prestodb/presto/commit/d8b92c3527cf1c936be599843e2c54d6a5803e71", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-10T23:11:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE1OTM2Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393159362", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-03-16T16:40:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\nindex f66ae63449..c2b2da63d2 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n\n@@ -16,6 +16,8 @@ package com.facebook.presto.druid;\n import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n \n+import static java.util.Objects.requireNonNull;\n+\n public abstract class DruidAggregationColumnNode\n {\n     private final ExpressionType expressionType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDI1OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393160259", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-03-16T16:41:27Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;\n+        this.outputColumn = outputColumn;\n+    }\n+\n+    public VariableReferenceExpression getOutputColumn()\n+    {\n+        return outputColumn;\n+    }\n+\n+    public ExpressionType getExpressionType()\n+    {\n+        return expressionType;\n+    }\n+\n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final VariableReferenceExpression inputColumn;\n+\n+        public GroupByColumnNode(VariableReferenceExpression inputColumn, VariableReferenceExpression output)\n+        {\n+            super(ExpressionType.GROUP_BY, output);\n+            this.inputColumn = inputColumn;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\nindex f66ae63449..c2b2da63d2 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n\n@@ -16,6 +16,8 @@ package com.facebook.presto.druid;\n import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n \n+import static java.util.Objects.requireNonNull;\n+\n public abstract class DruidAggregationColumnNode\n {\n     private final ExpressionType expressionType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDQ2MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393160460", "bodyText": "same", "author": "highker", "createdAt": "2020-03-16T16:41:40Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;\n+        this.outputColumn = outputColumn;\n+    }\n+\n+    public VariableReferenceExpression getOutputColumn()\n+    {\n+        return outputColumn;\n+    }\n+\n+    public ExpressionType getExpressionType()\n+    {\n+        return expressionType;\n+    }\n+\n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final VariableReferenceExpression inputColumn;\n+\n+        public GroupByColumnNode(VariableReferenceExpression inputColumn, VariableReferenceExpression output)\n+        {\n+            super(ExpressionType.GROUP_BY, output);\n+            this.inputColumn = inputColumn;\n+        }\n+\n+        public VariableReferenceExpression getInputColumn()\n+        {\n+            return inputColumn;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return inputColumn.toString();\n+        }\n+    }\n+\n+    public static class AggregationFunctionColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final CallExpression callExpression;\n+\n+        public AggregationFunctionColumnNode(VariableReferenceExpression output, CallExpression callExpression)\n+        {\n+            super(ExpressionType.AGGREGATE, output);\n+            this.callExpression = callExpression;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\nindex f66ae63449..c2b2da63d2 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java\n\n@@ -16,6 +16,8 @@ package com.facebook.presto.druid;\n import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n \n+import static java.util.Objects.requireNonNull;\n+\n public abstract class DruidAggregationColumnNode\n {\n     private final ExpressionType expressionType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MTkxMg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393161912", "bodyText": "if (!...) {\n    throw new\n}\n\n// remove the `else`", "author": "highker", "createdAt": "2020-03-16T16:43:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+    private static final String DATE_TRUNC = \"date_trunc\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector.\");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        if (timeConversion.getDisplayName().toLowerCase(ENGLISH).equals(FROM_UNIXTIME)) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\nindex 1b1897430e..7cde20c757 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java\n\n@@ -99,15 +99,13 @@ public class DruidAggregationProjectConverter\n         String inputFormat;\n \n         CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n-        if (timeConversion.getDisplayName().toLowerCase(ENGLISH).equals(FROM_UNIXTIME)) {\n-            inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n-            inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n-            inputFormat = \"seconds\";\n-        }\n-        else {\n+        if (!timeConversion.getDisplayName().toLowerCase(ENGLISH).equals(FROM_UNIXTIME)) {\n             throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported time function: \" + timeConversion.getDisplayName() + \" to pushdown for Druid connector.\");\n         }\n \n+        inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n+        inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n+        inputFormat = \"seconds\";\n         RowExpression intervalParameter = function.getArguments().get(0);\n         if (!(intervalParameter instanceof ConstantExpression)) {\n             throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported interval unit: \" + intervalParameter + \" to pushdown for Druid connector.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzU3Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393167577", "bodyText": "unused", "author": "highker", "createdAt": "2020-03-16T16:52:24Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -19,33 +19,56 @@\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.AggregationNode;\n import com.facebook.presto.spi.plan.FilterNode;\n import com.facebook.presto.spi.plan.LimitNode;\n import com.facebook.presto.spi.plan.PlanNode;\n import com.facebook.presto.spi.plan.PlanVisitor;\n import com.facebook.presto.spi.plan.ProjectNode;\n import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.RowExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.BigintType;\n import com.facebook.presto.spi.type.TypeManager;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n \n import javax.inject.Inject;\n \n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.facebook.presto.druid.DruidAggregationColumnNode.AggregationFunctionColumnNode;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.AGGREGATE;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.GROUP_BY;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDg4MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393290880", "bodyText": "? It is used in a few switch cases", "author": "zhenxiao", "createdAt": "2020-03-16T20:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzU3Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3MzIxNg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393173216", "bodyText": "Make it an if/else maybe for readability", "author": "highker", "createdAt": "2020-03-16T16:58:49Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -194,7 +217,8 @@ public DruidQueryGeneratorContext visitProject(ProjectNode node, DruidQueryGener\n             node.getOutputVariables().forEach(variable -> {\n                 RowExpression expression = node.getAssignments().get(variable);\n                 DruidExpression druidExpression = expression.accept(\n-                        druidProjectExpressionConverter,\n+                        contextIn.getVariablesInAggregation().contains(variable) ?", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex 781700c0e7..1fa056d062 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -216,9 +216,12 @@ public class DruidQueryGenerator\n \n             node.getOutputVariables().forEach(variable -> {\n                 RowExpression expression = node.getAssignments().get(variable);\n+                DruidProjectExpressionConverter projectExpressionConverter = druidProjectExpressionConverter;\n+                if (contextIn.getVariablesInAggregation().contains(variable)) {\n+                    projectExpressionConverter = new DruidAggregationProjectConverter(typeManager, functionMetadataManager, standardFunctionResolution);\n+                }\n                 DruidExpression druidExpression = expression.accept(\n-                        contextIn.getVariablesInAggregation().contains(variable) ?\n-                                new DruidAggregationProjectConverter(typeManager, functionMetadataManager, standardFunctionResolution) : druidProjectExpressionConverter,\n+                        projectExpressionConverter,\n                         context.getSelections());\n                 newSelections.put(\n                         variable,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3NTk5Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393175992", "bodyText": "break after .stream()\naggregationNode.getCallExpression().getArguments().stream()\n        .filter(...\n        .map..", "author": "highker", "createdAt": "2020-03-16T17:01:43Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the DQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex 781700c0e7..1fa056d062 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -272,10 +275,7 @@ public class DruidQueryGenerator\n                     case AGGREGATE: {\n                         AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n                         variablesInAggregation.addAll(\n-                                aggregationNode\n-                                        .getCallExpression()\n-                                        .getArguments()\n-                                        .stream()\n+                                aggregationNode.getCallExpression().getArguments().stream()\n                                         .filter(argument -> argument instanceof VariableReferenceExpression)\n                                         .map(argument -> (VariableReferenceExpression) argument)\n                                         .collect(Collectors.toList()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Njg3OA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393176878", "bodyText": "this is always false", "author": "highker", "createdAt": "2020-03-16T17:02:43Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the DQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by\n+            if (groupByExists && aggregations == 0) {\n+                VariableReferenceExpression hidden = new VariableReferenceExpression(UUID.randomUUID().toString(), BigintType.BIGINT);\n+                newSelections.put(hidden, new Selection(\"count(*)\", DERIVED));\n+                hiddenColumnSet.add(hidden);\n+                aggregations++;\n+            }\n+            return context.withAggregation(newSelections, groupByColumns, aggregations, hiddenColumnSet);\n+        }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            if (prestoAggregation.equals(\"count\")) {\n+                if (parameters.size() <= 1) {\n+                    return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                }\n+                else if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NjIzOQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393296239", "bodyText": "oh, my bad. Let me fix it", "author": "zhenxiao", "createdAt": "2020-03-16T20:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Njg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\nindex 781700c0e7..1fa056d062 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java\n\n@@ -272,10 +275,7 @@ public class DruidQueryGenerator\n                     case AGGREGATE: {\n                         AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n                         variablesInAggregation.addAll(\n-                                aggregationNode\n-                                        .getCallExpression()\n-                                        .getArguments()\n-                                        .stream()\n+                                aggregationNode.getCallExpression().getArguments().stream()\n                                         .filter(argument -> argument instanceof VariableReferenceExpression)\n                                         .map(argument -> (VariableReferenceExpression) argument)\n                                         .collect(Collectors.toList()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MDc1MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393180750", "bodyText": "merge this two ifs", "author": "highker", "createdAt": "2020-03-16T17:07:05Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -140,17 +227,25 @@ private boolean hasFilter()\n             pushdown = true;\n         }\n \n-        if (limit.isPresent()) {\n-            query += \" LIMIT \" + limit.getAsLong();\n+        if (!groupByColumns.isEmpty()) {\n+            String groupByExpression = groupByColumns.stream().map(x -> selections.get(x).getDefinition()).collect(Collectors.joining(\", \"));\n+            query = query + \" GROUP BY \" + groupByExpression;\n             pushdown = true;\n         }\n+\n+        if (!hasAggregation()) {\n+            if (limit.isPresent()) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "chunk": "diff --git a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java\nindex beb8b0be70..f685818093 100644\n--- a/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java\n+++ b/presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java\n\n@@ -233,11 +233,9 @@ public class DruidQueryGeneratorContext\n             pushdown = true;\n         }\n \n-        if (!hasAggregation()) {\n-            if (limit.isPresent()) {\n-                query += \" LIMIT \" + limit.getAsLong();\n-                pushdown = true;\n-            }\n+        if (!hasAggregation() && limit.isPresent()) {\n+            query += \" LIMIT \" + limit.getAsLong();\n+            pushdown = true;\n         }\n         return new DruidQueryGenerator.GeneratedDql(tableName, query, pushdown);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393181274", "bodyText": "one param per line", "author": "highker", "createdAt": "2020-03-16T17:07:49Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java", "diffHunk": "@@ -92,4 +93,31 @@ public void testSimpleSelectWithFilterLimit()\n         testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        BiConsumer<PlanBuilder, PlanBuilder.AggregationBuilder> aggregationFunctionBuilder = (planBuilder, aggregationBuilder) -> aggregationBuilder.addAggregation(planBuilder.variable(\"agg\"), getRowExpression(\"count(*)\", defaultSessionHolder));\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        PlanNode filter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"fare > 3\", defaultSessionHolder)));\n+        PlanNode anotherFilter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"secondssinceepoch between 200 and 300 and regionid >= 40\", defaultSessionHolder)));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).globalGrouping())),", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwNDM4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393304383", "bodyText": "yep, just 2 params for testDQL. current format seems OK?", "author": "zhenxiao", "createdAt": "2020-03-16T20:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMzQ2Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393313467", "bodyText": "the first line should be empty; the first param starts at the second line. No param needs to follow right after (", "author": "highker", "createdAt": "2020-03-16T21:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MTIyMA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393371220", "bodyText": "get it. will fix", "author": "zhenxiao", "createdAt": "2020-03-16T23:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "chunk": "diff --git a/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java b/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\nindex 813d631b4e..d80dd3ee85 100644\n--- a/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\n+++ b/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\n\n@@ -81,16 +81,28 @@ public class TestDruidQueryGenerator\n     @Test\n     public void testSimpleSelectStar()\n     {\n-        testDQL(planBuilder -> limit(planBuilder, 50L, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch)),\n+        testDQL(\n+                planBuilder -> limit(planBuilder, 50L, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch)),\n                 \"SELECT regionId, city, fare, secondsSinceEpoch FROM realtimeOnly LIMIT 50\");\n-        testDQL(planBuilder -> limit(planBuilder, 10L, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch)),\n+        testDQL(\n+                planBuilder -> limit(planBuilder, 10L, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch)),\n                 \"SELECT regionId, secondsSinceEpoch FROM realtimeOnly LIMIT 10\");\n     }\n \n     @Test\n     public void testSimpleSelectWithFilterLimit()\n     {\n-        testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n+        testDQL(\n+                planBuilder -> limit(\n+                                    planBuilder,\n+                                    30L,\n+                                    project(\n+                                            planBuilder,\n+                                            filter(\n+                                                    planBuilder,\n+                                                    tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch),\n+                                                    getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)),\n+                                            ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTQxMw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393181413", "bodyText": "same", "author": "highker", "createdAt": "2020-03-16T17:08:03Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java", "diffHunk": "@@ -92,4 +93,31 @@ public void testSimpleSelectWithFilterLimit()\n         testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        BiConsumer<PlanBuilder, PlanBuilder.AggregationBuilder> aggregationFunctionBuilder = (planBuilder, aggregationBuilder) -> aggregationBuilder.addAggregation(planBuilder.variable(\"agg\"), getRowExpression(\"count(*)\", defaultSessionHolder));\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        PlanNode filter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"fare > 3\", defaultSessionHolder)));\n+        PlanNode anotherFilter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"secondssinceepoch between 200 and 300 and regionid >= 40\", defaultSessionHolder)));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).globalGrouping())),\n+                \"SELECT count(*) FROM realtimeOnly\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(filter).globalGrouping())),\n+                \"SELECT count(*) FROM realtimeOnly WHERE (fare > 3)\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(filter).singleGroupingSet(v(\"regionid\")))),\n+                \"SELECT regionId, count(*) FROM realtimeOnly WHERE (fare > 3) GROUP BY regionId\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).singleGroupingSet(v(\"regionid\")))),\n+                \"SELECT regionId, count(*) FROM realtimeOnly GROUP BY regionId\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(anotherFilter).singleGroupingSet(v(\"regionid\"), v(\"city\")))),\n+                \"SELECT regionId, city, count(*) FROM realtimeOnly WHERE ((secondsSinceEpoch BETWEEN 200 AND 300) AND (regionId >= 40)) GROUP BY regionId, city\");\n+    }\n+\n+    @Test\n+    public void testDistinctSelection()\n+    {\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggBuilder.source(justScan).singleGroupingSet(v(\"regionid\"))),", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "chunk": "diff --git a/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java b/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\nindex 813d631b4e..d80dd3ee85 100644\n--- a/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\n+++ b/presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java\n\n@@ -81,16 +81,28 @@ public class TestDruidQueryGenerator\n     @Test\n     public void testSimpleSelectStar()\n     {\n-        testDQL(planBuilder -> limit(planBuilder, 50L, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch)),\n+        testDQL(\n+                planBuilder -> limit(planBuilder, 50L, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch)),\n                 \"SELECT regionId, city, fare, secondsSinceEpoch FROM realtimeOnly LIMIT 50\");\n-        testDQL(planBuilder -> limit(planBuilder, 10L, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch)),\n+        testDQL(\n+                planBuilder -> limit(planBuilder, 10L, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch)),\n                 \"SELECT regionId, secondsSinceEpoch FROM realtimeOnly LIMIT 10\");\n     }\n \n     @Test\n     public void testSimpleSelectWithFilterLimit()\n     {\n-        testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n+        testDQL(\n+                planBuilder -> limit(\n+                                    planBuilder,\n+                                    30L,\n+                                    project(\n+                                            planBuilder,\n+                                            filter(\n+                                                    planBuilder,\n+                                                    tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch),\n+                                                    getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)),\n+                                            ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n \n"}}, {"oid": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "url": "https://github.com/prestodb/presto/commit/d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T20:52:41Z", "type": "forcePushed"}, {"oid": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "url": "https://github.com/prestodb/presto/commit/36a28ed53fda629b614102a18fc6a039a5e1cabf", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T23:45:23Z", "type": "commit"}, {"oid": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "url": "https://github.com/prestodb/presto/commit/36a28ed53fda629b614102a18fc6a039a5e1cabf", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T23:45:23Z", "type": "forcePushed"}]}