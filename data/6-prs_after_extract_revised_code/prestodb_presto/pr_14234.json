{"pr_number": 14234, "pr_title": "Reuse buffers in OptimizedPartitionedOutputOperator - part 1 serializedRowSizes, offsetsCopy, positions, mappedPositions and offsets", "pr_createdAt": "2020-03-10T10:13:13Z", "pr_url": "https://github.com/prestodb/presto/pull/14234", "timeline": [{"oid": "fba950636c6d10b74ed95f800d196da515ae7de9", "url": "https://github.com/prestodb/presto/commit/fba950636c6d10b74ed95f800d196da515ae7de9", "message": "Add GC profile to BenchmarkPartitionedOutputOperator", "committedDate": "2020-03-11T23:54:47Z", "type": "forcePushed"}, {"oid": "c7a467b1327e1d915d0a02d63626bdb1643c145b", "url": "https://github.com/prestodb/presto/commit/c7a467b1327e1d915d0a02d63626bdb1643c145b", "message": "Add GC profile to BenchmarkPartitionedOutputOperator", "committedDate": "2020-03-12T06:48:40Z", "type": "forcePushed"}, {"oid": "8d8308660e87e6fd7f6196e52867b130a696ce57", "url": "https://github.com/prestodb/presto/commit/8d8308660e87e6fd7f6196e52867b130a696ce57", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-16T08:23:14Z", "type": "forcePushed"}, {"oid": "1a4373eaf3c291ce90444c2e8b97b77d331c60ca", "url": "https://github.com/prestodb/presto/commit/1a4373eaf3c291ce90444c2e8b97b77d331c60ca", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-17T10:19:37Z", "type": "forcePushed"}, {"oid": "cd79bc1dd191bacc169ba708458ac08b2a412405", "url": "https://github.com/prestodb/presto/commit/cd79bc1dd191bacc169ba708458ac08b2a412405", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-17T23:29:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTM5OQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395331399", "bodyText": "Math.min(buffer.length, capacity) -> buffer.length since buffer.length is known to be less than capacity", "author": "mbasmanova", "createdAt": "2020-03-19T21:31:35Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -224,6 +226,32 @@ static DecodedBlockNode decodeBlock(BlockFlattener flattener, Closer blockLeaseC\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n+    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)\n+    {\n+        int newCapacity = (int) (capacity * expansionFactor.getExpansionFactor());\n+\n+        int[] newBuffer;\n+        if (buffer == null) {\n+            newBuffer = allocator.borrowIntArray(newCapacity);\n+        }\n+        else if (buffer.length < capacity) {\n+            newBuffer = allocator.borrowIntArray(newCapacity);\n+            if (expansionOption == PRESERVE) {\n+                System.arraycopy(buffer, 0, newBuffer, 0, Math.min(buffer.length, capacity));", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -226,32 +224,6 @@ public class OptimizedPartitionedOutputOperator\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n-    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)\n-    {\n-        int newCapacity = (int) (capacity * expansionFactor.getExpansionFactor());\n-\n-        int[] newBuffer;\n-        if (buffer == null) {\n-            newBuffer = allocator.borrowIntArray(newCapacity);\n-        }\n-        else if (buffer.length < capacity) {\n-            newBuffer = allocator.borrowIntArray(newCapacity);\n-            if (expansionOption == PRESERVE) {\n-                System.arraycopy(buffer, 0, newBuffer, 0, Math.min(buffer.length, capacity));\n-            }\n-            allocator.returnArray(buffer);\n-        }\n-        else {\n-            newBuffer = buffer;\n-        }\n-\n-        if (expansionOption == INITIALIZE) {\n-            java.util.Arrays.fill(newBuffer, 0);\n-        }\n-\n-        return newBuffer;\n-    }\n-\n     public static class OptimizedPartitionedOutputFactory\n             implements OutputFactory\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjQyMw==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395332423", "bodyText": "Any reason not to put this method into Arrays class (and drop WithAllocator suffix)?\n\nstatic import Arrays.ExpansionOption", "author": "mbasmanova", "createdAt": "2020-03-19T21:33:55Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -224,6 +226,32 @@ static DecodedBlockNode decodeBlock(BlockFlattener flattener, Closer blockLeaseC\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n+    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -226,32 +224,6 @@ public class OptimizedPartitionedOutputOperator\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n-    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)\n-    {\n-        int newCapacity = (int) (capacity * expansionFactor.getExpansionFactor());\n-\n-        int[] newBuffer;\n-        if (buffer == null) {\n-            newBuffer = allocator.borrowIntArray(newCapacity);\n-        }\n-        else if (buffer.length < capacity) {\n-            newBuffer = allocator.borrowIntArray(newCapacity);\n-            if (expansionOption == PRESERVE) {\n-                System.arraycopy(buffer, 0, newBuffer, 0, Math.min(buffer.length, capacity));\n-            }\n-            allocator.returnArray(buffer);\n-        }\n-        else {\n-            newBuffer = buffer;\n-        }\n-\n-        if (expansionOption == INITIALIZE) {\n-            java.util.Arrays.fill(newBuffer, 0);\n-        }\n-\n-        return newBuffer;\n-    }\n-\n     public static class OptimizedPartitionedOutputFactory\n             implements OutputFactory\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjc4Mg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395332782", "bodyText": "Would it be possible to reuse existing arrayAllocator ?\n\n10000 -> 10_000 for readability", "author": "mbasmanova", "createdAt": "2020-03-19T21:34:43Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -364,6 +392,7 @@ public OperatorFactory duplicate()\n         private final ArrayAllocator arrayAllocator = new SimpleArrayAllocator(5000);\n         private final BlockFlattener flattener = new BlockFlattener(arrayAllocator);\n         private final Closer blockLeaseCloser = Closer.create();\n+        private final ArrayAllocator bufferAllocator = new SimpleArrayAllocator(10000);", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1ODIxNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396058214", "bodyText": "@mbasmanova The difficulty using existing arrayAllocator is counting memory becomes a bit more difficult. The existing arrayAllocator is only used by BlockFlattener, and this part of memory borrowed would be still counted in DecodedBlock#getRetainedSizeInBytes(). Thus when we add a new bufferAllocator, we can simply add its retained size. If we merge the two allocators, then the counting of the dictionary ids array borrowed by BlockFlattener would be double counted in arrayAllocator and decodedBlocks. How about renaming original arrayAllocator to  blockDecodingAllocator and remain using bufferAllocator for reusing the buffers?", "author": "yingsu00", "createdAt": "2020-03-22T06:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -388,11 +360,14 @@ public class OptimizedPartitionedOutputOperator\n         private final AtomicLong rowsAdded = new AtomicLong();\n         private final AtomicLong pagesAdded = new AtomicLong();\n \n+        // The ArrayAllocator used by BlockFlattener for decoding blocks.\n         // There could be queries that shuffles data with up to 1000 columns so we need to set the maxOutstandingArrays a high number.\n-        private final ArrayAllocator arrayAllocator = new SimpleArrayAllocator(5000);\n-        private final BlockFlattener flattener = new BlockFlattener(arrayAllocator);\n+        private final ArrayAllocator blockDecodingAllocator = new SimpleArrayAllocator(5_000);\n+        private final BlockFlattener flattener = new BlockFlattener(blockDecodingAllocator);\n         private final Closer blockLeaseCloser = Closer.create();\n-        private final ArrayAllocator bufferAllocator = new SimpleArrayAllocator(10000);\n+\n+        // The ArrayAllocator for the buffers used in repartitioning, e.g. PartitionBuffer#serializedRowSizes, BlockEncodingBuffer#mappedPositions.\n+        private final ArrayAllocator bufferAllocator = new SimpleArrayAllocator(10_000);\n \n         private final PartitionBuffer[] partitionBuffers;\n         private final List<Type> sourceTypes;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395333245", "bodyText": "this comment is now confusing (because bufferAllocator is an array allocator)", "author": "mbasmanova", "createdAt": "2020-03-19T21:35:45Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -494,7 +523,7 @@ public long getRetainedSizeInBytes()\n             // When called in addInput(), the arrays have been returned to the arrayAllocator already,\n             // but they're still owned by the decodedBlock which will be counted as part of the decodedBlock.\n             // In both cases, the arrayAllocator doesn't need to be counted.", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1OTExOA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396059118", "bodyText": "@mbasmanova For now I'm using blockDecodingAllocator and bufferAllocator in PagePartitioner, and changed this comment to the following:\n// When called by the operator constructor, the blockDecodingAllocator was empty at the moment.\n            // When called in addInput(), the arrays have been returned to the blockDecodingAllocator already,\n            // but they're still owned by the decodedBlock which will be counted as part of the decodedBlock.\n            // In both cases, the blockDecodingAllocator doesn't need to be counted. But we need to count\n            // bufferAllocator which contains buffers used during partitioning, e.g. serializedRowSizes,\n            // mappedPositions, etc.\n            long size = bufferAllocator.getEstimatedSizeInBytes();\n\nDoes this looks better? Or if you have better idea to count the memory using a single ArrayAllocator, we can remove this comment.", "author": "yingsu00", "createdAt": "2020-03-22T06:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -519,10 +494,12 @@ public class OptimizedPartitionedOutputOperator\n \n         public long getRetainedSizeInBytes()\n         {\n-            // When called by the operator constructor, the arrayAllocator was empty at the moment.\n-            // When called in addInput(), the arrays have been returned to the arrayAllocator already,\n+            // When called by the operator constructor, the blockDecodingAllocator was empty at the moment.\n+            // When called in addInput(), the arrays have been returned to the blockDecodingAllocator already,\n             // but they're still owned by the decodedBlock which will be counted as part of the decodedBlock.\n-            // In both cases, the arrayAllocator doesn't need to be counted.\n+            // In both cases, the blockDecodingAllocator doesn't need to be counted. But we need to count\n+            // bufferAllocator which contains buffers used during partitioning, e.g. serializedRowSizes,\n+            // mappedPositions, etc.\n             long size = bufferAllocator.getEstimatedSizeInBytes();\n \n             for (int i = 0; i < partitionBuffers.length; i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzQwOA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395333408", "bodyText": "allocator -> arrayAllocator", "author": "mbasmanova", "createdAt": "2020-03-19T21:36:08Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -544,6 +573,7 @@ private static int getFixedWidthTypeSize(Type type)\n         private final Lifespan lifespan;\n         private final int capacity;\n         private final int channelCount;\n+        private final ArrayAllocator allocator;", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1OTUzNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396059534", "bodyText": "@mbasmanova I renamed it to bufferAllocator to be consistent with the one in PagePartitioner. Let me know if you prefer other names.", "author": "yingsu00", "createdAt": "2020-03-22T06:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -573,17 +550,16 @@ public class OptimizedPartitionedOutputOperator\n         private final Lifespan lifespan;\n         private final int capacity;\n         private final int channelCount;\n-        private final ArrayAllocator allocator;\n+        private final ArrayAllocator bufferAllocator;\n \n         private int[] positions;   // the default positions array for top level BlockEncodingBuffer\n-        private int[] serializedRowSizes;  // The sizes of the rows in bytes if they were serialized\n         private int positionCount;  // number of positions to be copied for this partition\n         private BlockEncodingBuffer[] blockEncodingBuffers;\n \n         private int bufferedRowCount;\n         private boolean bufferFull;\n \n-        PartitionBuffer(int partition, int channelCount, int capacity, AtomicLong pagesAdded, AtomicLong rowsAdded, PagesSerde serde, Lifespan lifespan, ArrayAllocator allocator)\n+        PartitionBuffer(int partition, int channelCount, int capacity, AtomicLong pagesAdded, AtomicLong rowsAdded, PagesSerde serde, Lifespan lifespan, ArrayAllocator bufferAllocator)\n         {\n             this.partition = partition;\n             this.channelCount = channelCount;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395336596", "bodyText": "This logic is confusing to me. calculateNextBatchSize is called in a do-while loop and therefore it is not clear that it won't be called anymore. I think it would be clearer to move allocation and freeing of the serializedRowSizes into appendData and change serializedRowSizes into a local variable:\n            int[] serializedRowSizes = ensureCapacityWithAllocator(null, positionCount, SMALL, INITIALIZE, allocator);\n            try {\n\n                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels, serializedRowSizes);\n\n                // Due to the limitation of buffer size, we append the data batch by batch\n                int offset = 0;\n                do {\n                    int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n                    boolean lastBatchInPage = offset + batchSize >= positionCount;\n\n                    for (int i = 0; i < channelCount; i++) {\n                        blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                        blockEncodingBuffers[i].appendDataInBatch(lastBatchInPage);\n                    }\n\n                    bufferedRowCount += batchSize;\n                    offset += batchSize;\n\n                    if (bufferFull) {\n                        flush(outputBuffer);\n                        bufferFull = false;\n                    }\n                }\n                while (offset < positionCount);\n            }\n            finally {\n                // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n                // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n                allocator.returnArray(serializedRowSizes);\n            }", "author": "mbasmanova", "createdAt": "2020-03-19T21:43:22Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -675,6 +706,11 @@ private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variable\n                 }\n             }\n \n+            // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n+            // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n+            allocator.returnArray(serializedRowSizes);", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NjQxOQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395946419", "bodyText": "@mbasmanova The original logic was to release the serializedRowSizes after the size of the last batch of the page was calculated. For that purpose the returnArray() happens before the last line of calculateNextBatchSize(). If it's not the last batch in page, the code would have returned before reaching that point. I was doing it this way because I thought serializedRowSizes is an internal thing only used for calculating batchSize, therefore it was better to be confined inside of populateSerializedRowSizes() and calculateNextBatchSize(). As the caller of these two methods, appendData() doesn't need to care about how the serializedRowSizes is used. What's your opinion on this? If you think this is not important, I'll change it the way you suggested. Thanks!", "author": "yingsu00", "createdAt": "2020-03-21T01:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3Mzc1OQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396073759", "bodyText": "Masha, I updated the code as you suggested.", "author": "yingsu00", "createdAt": "2020-03-22T09:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex dbdcc3c22c..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -706,11 +691,6 @@ public class OptimizedPartitionedOutputOperator\n                 }\n             }\n \n-            // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n-            // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n-            allocator.returnArray(serializedRowSizes);\n-            serializedRowSizes = null;\n-\n             return positionCount - startPosition;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzg3MA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395337870", "bodyText": "Make it final and add a constructor that takes ArrayAllocator.", "author": "mbasmanova", "createdAt": "2020-03-19T21:46:22Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java", "diffHunk": "@@ -82,6 +83,9 @@\n     // Whether the positions array has already been mapped to mappedPositions\n     protected boolean positionsMapped;\n \n+    // The allocator for internal buffers\n+    protected ArrayAllocator allocator;", "originalCommit": "222f1b3cceab79a0a71401f91bbbb308018b751d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\nindex 230fab5efe..a66f082ea5 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\n\n@@ -83,9 +90,6 @@ public abstract class AbstractBlockEncodingBuffer\n     // Whether the positions array has already been mapped to mappedPositions\n     protected boolean positionsMapped;\n \n-    // The allocator for internal buffers\n-    protected ArrayAllocator allocator;\n-\n     // The positions (row numbers) of the incoming Block to be copied to this buffer.\n     // All top level AbstractBlockEncodingBuffer for the same partition share the same positions array.\n     private int[] positions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTAzNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395339034", "bodyText": "Make offsetsCopy a local variable:\n        int[] offsetsCopy = ensureCapacityWithAllocator(null, positionCount + 1, SMALL, NONE, allocator);\n        try {\n            System.arraycopy(offsets, 0, offsetsCopy, 0, positionCount + 1);\n\n            ((AbstractBlockEncodingBuffer) valuesBuffers).accumulateSerializedRowSizes(offsetsCopy, positionCount, serializedRowSizes);\n        }\n        finally {\n            allocator.returnArray(offsetsCopy);   \n        }", "author": "mbasmanova", "createdAt": "2020-03-19T21:49:03Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java", "diffHunk": "@@ -83,10 +86,13 @@ public void accumulateSerializedRowSizes(int[] serializedRowSizes)\n             serializedRowSizes[i] += POSITION_SIZE;\n         }\n \n-        offsetsCopy = ensureCapacity(offsetsCopy, positionCount + 1);\n+        offsetsCopy = ensureCapacityWithAllocator(offsetsCopy, positionCount + 1, SMALL, NONE, allocator);", "originalCommit": "7c8fe4bf7cd74e5aa0794bd6a91cdb3b263895ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java\nindex 547bae69dc..cdbdc4dae8 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java\n\n@@ -86,13 +82,14 @@ public class ArrayBlockEncodingBuffer\n             serializedRowSizes[i] += POSITION_SIZE;\n         }\n \n-        offsetsCopy = ensureCapacityWithAllocator(offsetsCopy, positionCount + 1, SMALL, NONE, allocator);\n-        System.arraycopy(offsets, 0, offsetsCopy, 0, positionCount + 1);\n-\n-        ((AbstractBlockEncodingBuffer) valuesBuffers).accumulateSerializedRowSizes(offsetsCopy, positionCount, serializedRowSizes);\n-\n-        allocator.returnArray(offsetsCopy);\n-        offsetsCopy = null;\n+        int[] offsetsCopy = ensureCapacity(null, positionCount + 1, SMALL, NONE, bufferAllocator);\n+        try {\n+            System.arraycopy(offsets, 0, offsetsCopy, 0, positionCount + 1);\n+            ((AbstractBlockEncodingBuffer) valuesBuffers).accumulateSerializedRowSizes(offsetsCopy, positionCount, serializedRowSizes);\n+        }\n+        finally {\n+            bufferAllocator.returnArray(offsetsCopy);\n+        }\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTYyMg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395339622", "bodyText": "Make this final and add constructor that takes isNested flag.", "author": "mbasmanova", "createdAt": "2020-03-19T21:50:29Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java", "diffHunk": "@@ -64,6 +64,9 @@\n public abstract class AbstractBlockEncodingBuffer\n         implements BlockEncodingBuffer\n {\n+    // Boolean indicating whether this is a buffer for a nested level block.\n+    protected boolean isNested;", "originalCommit": "80940bd10dd719d1377f4c7f46d19b699ac9f5f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\nindex 391b75c60d..a66f082ea5 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java\n\n@@ -64,8 +65,11 @@ import static java.util.Objects.requireNonNull;\n public abstract class AbstractBlockEncodingBuffer\n         implements BlockEncodingBuffer\n {\n+    // The allocator for internal buffers\n+    protected final ArrayAllocator bufferAllocator;\n+\n     // Boolean indicating whether this is a buffer for a nested level block.\n-    protected boolean isNested;\n+    protected final boolean isNested;\n \n     // The block after peeling off the Dictionary or RLE wrappings.\n     protected Block decodedBlock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzA1Mg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395343052", "bodyText": "Debugging? Remove.", "author": "mbasmanova", "createdAt": "2020-03-19T21:58:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -171,6 +171,8 @@ public void addInput(Page page)\n         page = pagePreprocessor.apply(page);\n         pagePartitioner.partitionPage(page);\n \n+        System.out.println(pagePartitioner.getRetainedSizeInBytes());", "originalCommit": "cd79bc1dd191bacc169ba708458ac08b2a412405", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex 0ee18ec9d0..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -171,8 +169,6 @@ public class OptimizedPartitionedOutputOperator\n         page = pagePreprocessor.apply(page);\n         pagePartitioner.partitionPage(page);\n \n-        System.out.println(pagePartitioner.getRetainedSizeInBytes());\n-\n         // TODO: PartitionedOutputOperator reports incorrect output data size #11770\n         operatorContext.recordOutput(page.getSizeInBytes(), page.getPositionCount());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTQ2MA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395345460", "bodyText": "I'm wondering if it would be clearer to add separate API to signal that there will be no more batches and call it at the same time you call allocator.returnArray(serializedRowSizes). Also, it would be helpful to update documentation for BlockEncodingBuffer to explain in which order the methods are being called.\nint[] serializedRowSizes = ensureCapacityWithAllocator(null, positionCount, SMALL, INITIALIZE, allocator);\n            try {\n\n                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels, serializedRowSizes);\n\n                // Due to the limitation of buffer size, we append the data batch by batch\n                int offset = 0;\n                do {\n                    int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n\n                    for (int i = 0; i < channelCount; i++) {\n                        blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                        blockEncodingBuffers[i].appendDataInBatch();\n                    }\n\n                    bufferedRowCount += batchSize;\n                    offset += batchSize;\n\n                    if (bufferFull) {\n                        flush(outputBuffer);\n                        bufferFull = false;\n                    }\n                }\n                while (offset < positionCount);\n            }\n            finally {\n                // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n                // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n                allocator.returnArray(serializedRowSizes);\n                for (int i = 0; i < channelCount; i++) {\n                    blockEncodingBuffers[i].noMoreBatches();\n                }\n            }", "author": "mbasmanova", "createdAt": "2020-03-19T22:04:46Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -634,10 +636,11 @@ private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize,\n             int offset = 0;\n             do {\n                 int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);\n+                boolean lastBatchInPage = offset + batchSize >= positionCount;\n \n                 for (int i = 0; i < channelCount; i++) {\n                     blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n-                    blockEncodingBuffers[i].appendDataInBatch();\n+                    blockEncodingBuffers[i].appendDataInBatch(lastBatchInPage);", "originalCommit": "cd79bc1dd191bacc169ba708458ac08b2a412405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3MzcxMQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396073711", "bodyText": "@mbasmanova Masha, thanks for the suggestion. I changed the code as you suggested. If in the future we want to share buffers among blockEncodingBuffers, we will need to do it in the   for (int i = 0; i < channelCount; i++) loop. Related issue #14274", "author": "yingsu00", "createdAt": "2020-03-22T09:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex 0ee18ec9d0..8cfd5b3a80 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -630,28 +604,38 @@ public class OptimizedPartitionedOutputOperator\n                 blockEncodingBuffers[i].setupDecodedBlocksAndPositions(decodedBlocks[i], positions, positionCount);\n             }\n \n-            populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels);\n+            int[] serializedRowSizes = ensureCapacity(null, positionCount, SMALL, INITIALIZE, bufferAllocator);\n+            try {\n+                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels, serializedRowSizes);\n \n-            // Due to the limitation of buffer size, we append the data batch by batch\n-            int offset = 0;\n-            do {\n-                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);\n-                boolean lastBatchInPage = offset + batchSize >= positionCount;\n+                // Due to the limitation of buffer size, we append the data batch by batch\n+                int offset = 0;\n+                do {\n+                    int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n+                    boolean lastBatchInPage = offset + batchSize >= positionCount;\n \n-                for (int i = 0; i < channelCount; i++) {\n-                    blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n-                    blockEncodingBuffers[i].appendDataInBatch(lastBatchInPage);\n-                }\n+                    for (int i = 0; i < channelCount; i++) {\n+                        blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n+                        blockEncodingBuffers[i].appendDataInBatch();\n+                    }\n \n-                bufferedRowCount += batchSize;\n-                offset += batchSize;\n+                    bufferedRowCount += batchSize;\n+                    offset += batchSize;\n \n-                if (bufferFull) {\n-                    flush(outputBuffer);\n-                    bufferFull = false;\n+                    if (bufferFull) {\n+                        flush(outputBuffer);\n+                        bufferFull = false;\n+                    }\n+                }\n+                while (offset < positionCount);\n+            }\n+            finally {\n+                // Return the borrowed array for serializedRowSizes when the current page for the current partition is finished.\n+                bufferAllocator.returnArray(serializedRowSizes);\n+                for (int i = 0; i < channelCount; i++) {\n+                    blockEncodingBuffers[i].noMoreBatches();\n                 }\n             }\n-            while (offset < positionCount);\n         }\n \n         private void initializeBlockEncodingBuffers(DecodedBlockNode[] decodedBlocks)\n"}}, {"oid": "9cd46f7787729826f5b1828a5719bc1e28857a99", "url": "https://github.com/prestodb/presto/commit/9cd46f7787729826f5b1828a5719bc1e28857a99", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-22T09:31:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUzODQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396538495", "bodyText": "Arrays.ExpansionOption -> ExpansionOption", "author": "mbasmanova", "createdAt": "2020-03-23T15:29:28Z", "path": "presto-array/src/main/java/com/facebook/presto/array/Arrays.java", "diffHunk": "@@ -49,6 +51,32 @@ else if (expansionOption == INITIALIZE) {\n         return buffer;\n     }\n \n+    public static int[] ensureCapacity(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)", "originalCommit": "a536e2fcb0479659a1d7e18588a86b86eafd6d09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af751dd2067a72d5c15a90e00ed5432245a0d6ec", "chunk": "diff --git a/presto-array/src/main/java/com/facebook/presto/array/Arrays.java b/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\nindex 28192a3fb4..77d6f1ceef 100644\n--- a/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\n+++ b/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\n\n@@ -51,9 +51,9 @@ public class Arrays\n         return buffer;\n     }\n \n-    public static int[] ensureCapacity(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)\n+    public static int[] ensureCapacity(int[] buffer, int capacity, ExpansionFactor expansionFactor, ExpansionOption expansionOption, ArrayAllocator allocator)\n     {\n-        int newCapacity = (int) (capacity * expansionFactor.getExpansionFactor());\n+        int newCapacity = (int) (capacity * expansionFactor.expansionFactor);\n \n         int[] newBuffer;\n         if (buffer == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUzOTY5MQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396539691", "bodyText": "this method is not needed; just use expansionFactor.expansionFactor", "author": "mbasmanova", "createdAt": "2020-03-23T15:31:00Z", "path": "presto-array/src/main/java/com/facebook/presto/array/Arrays.java", "diffHunk": "@@ -128,6 +156,11 @@ else if (expansionOption == INITIALIZE) {\n         {\n             this.expansionFactor = expansionFactor;\n         }\n+\n+        public double getExpansionFactor()", "originalCommit": "a536e2fcb0479659a1d7e18588a86b86eafd6d09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af751dd2067a72d5c15a90e00ed5432245a0d6ec", "chunk": "diff --git a/presto-array/src/main/java/com/facebook/presto/array/Arrays.java b/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\nindex 28192a3fb4..77d6f1ceef 100644\n--- a/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\n+++ b/presto-array/src/main/java/com/facebook/presto/array/Arrays.java\n\n@@ -156,11 +156,6 @@ public class Arrays\n         {\n             this.expansionFactor = expansionFactor;\n         }\n-\n-        public double getExpansionFactor()\n-        {\n-            return expansionFactor;\n-        }\n     }\n \n     public enum ExpansionOption\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNTQ3NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396615475", "bodyText": "this variable is not used; remove", "author": "mbasmanova", "createdAt": "2020-03-23T17:11:50Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -612,6 +612,7 @@ private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize,\n                 int offset = 0;\n                 do {\n                     int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n+                    boolean lastBatchInPage = offset + batchSize >= positionCount;", "originalCommit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af751dd2067a72d5c15a90e00ed5432245a0d6ec", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\nindex 8cfd5b3a80..cc1de28b8c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java\n\n@@ -612,7 +612,6 @@ public class OptimizedPartitionedOutputOperator\n                 int offset = 0;\n                 do {\n                     int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n-                    boolean lastBatchInPage = offset + batchSize >= positionCount;\n \n                     for (int i = 0; i < channelCount; i++) {\n                         blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n"}}, {"oid": "af751dd2067a72d5c15a90e00ed5432245a0d6ec", "url": "https://github.com/prestodb/presto/commit/af751dd2067a72d5c15a90e00ed5432245a0d6ec", "message": "Reuse serializedRowSizes buffer between different PartitionBuffers", "committedDate": "2020-03-23T18:27:09Z", "type": "commit"}, {"oid": "cdc37ee8b220e97234db8cc2aecb344a1e6bd721", "url": "https://github.com/prestodb/presto/commit/cdc37ee8b220e97234db8cc2aecb344a1e6bd721", "message": "Add ArrayAllocator to BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "2437894fb0cf2744e178461b8856bdcc7d41d75e", "url": "https://github.com/prestodb/presto/commit/2437894fb0cf2744e178461b8856bdcc7d41d75e", "message": "Reuse offsetsCopy in BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "7d4c57cb92bce69690a37fb3d3707240e3fded78", "url": "https://github.com/prestodb/presto/commit/7d4c57cb92bce69690a37fb3d3707240e3fded78", "message": "Add isNested flag to BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "d31e75307b837480c99a0794eec36582f6bd3fa8", "url": "https://github.com/prestodb/presto/commit/d31e75307b837480c99a0794eec36582f6bd3fa8", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-23T18:27:55Z", "type": "commit"}, {"oid": "d31e75307b837480c99a0794eec36582f6bd3fa8", "url": "https://github.com/prestodb/presto/commit/d31e75307b837480c99a0794eec36582f6bd3fa8", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-23T18:27:55Z", "type": "forcePushed"}]}