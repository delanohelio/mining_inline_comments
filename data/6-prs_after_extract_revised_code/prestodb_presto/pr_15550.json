{"pr_number": 15550, "pr_title": "Support driver level plan in fragment result caching", "pr_createdAt": "2020-12-21T18:57:17Z", "pr_url": "https://github.com/prestodb/presto/pull/15550", "timeline": [{"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937", "url": "https://github.com/prestodb/presto/commit/cb062fbbabd87a7437deea5e9c88d6fb0d341937", "message": "Support driver level plan in fragment result caching\n\nThis would enable fragment result caching on the leaf driver when\nthere are multiple drivers in the lifespan introduced by local\nexchange, for example, intermediate aggregation", "committedDate": "2020-12-21T21:30:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg==", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547031622", "bodyText": "Looking at visitFilter, do we need to handle DynamicFilterPlaceholderFunction in this case?", "author": "highker", "createdAt": "2020-12-22T02:28:03Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)", "originalCommit": "cb062fbbabd87a7437deea5e9c88d6fb0d341937", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyOTQ1Mw==", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547429453", "bodyText": "Good catch. I'm not aware of this. I'll put up a different PR for this. I guess the first step is to return Optional.empty() when dynamic filter is enabled :)", "author": "shixuan-fan", "createdAt": "2020-12-22T18:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDkzNDIzNA==", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r564934234", "bodyText": "@highker: I checked how dynamic filter is created in LocalExecutionPlanner, and it seems that it is only used in visitSemiJoin and visitJoin as part of lookup. Current we don't support FRC in those places, so there should not be DynamicFilterPlaceholderFunction in the first place.\nHandling DynamicFilterPlaceholderFunction in RowExpression is not easy as that means we would need a specific visitor to detect it. On the other hand, I think a better approach is that whenever we detect dynamic filters as we are creating drivers, we put empty FRC context in DriverContext.", "author": "shixuan-fan", "createdAt": "2021-01-27T00:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "ff2560073a6273f911f9e3600388ba7f5e8212d0", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\nindex 5f456b5adf..947b07c1d5 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\n\n@@ -52,15 +53,11 @@ public class CanonicalPlanGenerator\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n     {\n         Map<VariableReferenceExpression, VariableReferenceExpression> originalToNewVariableNames = new HashMap<>();\n         Optional<PlanNode> canonicalPlan = root.accept(new CanonicalPlanGenerator(), originalToNewVariableNames);\n-        return canonicalPlan.map(planNode -> new CanonicalPlanFragment(\n-                planNode,\n-                outputLayout.stream()\n-                        .map(originalToNewVariableNames::get)\n-                        .collect(toImmutableList())));\n+        return canonicalPlan.map(planNode -> new CanonicalPlanFragment(planNode, getCanonicalPartitioningScheme(partitioningScheme, originalToNewVariableNames)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzA4Mg==", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547033082", "bodyText": "Could you reminds me a bit on why we need partitioning scheme at the very first place? For outputLayout, would that be the same as canonicalPlan.get().getOutputVariables()?", "author": "highker", "createdAt": "2020-12-22T02:33:48Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)", "originalCommit": "cb062fbbabd87a7437deea5e9c88d6fb0d341937", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNTYzNQ==", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547435635", "bodyText": "We use partitioning scheme because if there is a mismatch between expected output layout and the output of the root node, we will add a layout enforce operation (e.g. \n  \n    \n      presto/presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java\n    \n    \n         Line 551\n      in\n      ab243b6\n    \n    \n    \n    \n\n        \n          \n           Function<Page, Page> pagePreprocessor = enforceLayoutProcessor(outputLayout, physicalOperation.getLayout()); \n        \n    \n  \n\n). If we don't take this into consideration, then there might be channel mismatch which would lead to correctness issue or query failure.\nThis outputLayout is not the same as canonicalPlan.get().getOutputVariables(), but rather the expected layout of the driver. At the beginning we are being conservative to ensure it is correct so we make sure everything in partitioning scheme is compared.\nIn fact, changing to outputLayout is not required for this PR, I could revert these changes and revisit this once we plan to support build side of join. What do you think?", "author": "shixuan-fan", "createdAt": "2020-12-22T18:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ff2560073a6273f911f9e3600388ba7f5e8212d0", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\nindex 5f456b5adf..947b07c1d5 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java\n\n@@ -52,15 +53,11 @@ public class CanonicalPlanGenerator\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n     {\n         Map<VariableReferenceExpression, VariableReferenceExpression> originalToNewVariableNames = new HashMap<>();\n         Optional<PlanNode> canonicalPlan = root.accept(new CanonicalPlanGenerator(), originalToNewVariableNames);\n-        return canonicalPlan.map(planNode -> new CanonicalPlanFragment(\n-                planNode,\n-                outputLayout.stream()\n-                        .map(originalToNewVariableNames::get)\n-                        .collect(toImmutableList())));\n+        return canonicalPlan.map(planNode -> new CanonicalPlanFragment(planNode, getCanonicalPartitioningScheme(partitioningScheme, originalToNewVariableNames)));\n     }\n \n     @Override\n"}}, {"oid": "ff2560073a6273f911f9e3600388ba7f5e8212d0", "url": "https://github.com/prestodb/presto/commit/ff2560073a6273f911f9e3600388ba7f5e8212d0", "message": "Support driver level plan in fragment result caching\n\nThis would enable fragment result caching on the leaf driver when\nthere are multiple drivers in the lifespan introduced by local\nexchange, for example, intermediate aggregation", "committedDate": "2020-12-22T18:44:59Z", "type": "forcePushed"}, {"oid": "5bac5d5b99517ff051f25177bec1df23ee2b71c8", "url": "https://github.com/prestodb/presto/commit/5bac5d5b99517ff051f25177bec1df23ee2b71c8", "message": "Remove unused method in LocalExecutionPlanner", "committedDate": "2020-12-22T19:10:38Z", "type": "commit"}, {"oid": "0262da33011ca48a8776b1415aebe753dcd0ca1c", "url": "https://github.com/prestodb/presto/commit/0262da33011ca48a8776b1415aebe753dcd0ca1c", "message": "Support driver level plan in fragment result caching\n\nThis would enable fragment result caching on the leaf driver when\nthere are multiple drivers in the lifespan introduced by local\nexchange, for example, intermediate aggregation", "committedDate": "2020-12-23T18:55:34Z", "type": "commit"}, {"oid": "0262da33011ca48a8776b1415aebe753dcd0ca1c", "url": "https://github.com/prestodb/presto/commit/0262da33011ca48a8776b1415aebe753dcd0ca1c", "message": "Support driver level plan in fragment result caching\n\nThis would enable fragment result caching on the leaf driver when\nthere are multiple drivers in the lifespan introduced by local\nexchange, for example, intermediate aggregation", "committedDate": "2020-12-23T18:55:34Z", "type": "forcePushed"}]}