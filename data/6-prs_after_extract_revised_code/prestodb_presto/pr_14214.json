{"pr_number": 14214, "pr_title": "Verifier fixes and improvements", "pr_createdAt": "2020-03-05T02:56:04Z", "pr_url": "https://github.com/prestodb/presto/pull/14214", "timeline": [{"oid": "e0702f85d6daf4b35971dc0eb884675c94dd130d", "url": "https://github.com/prestodb/presto/commit/e0702f85d6daf4b35971dc0eb884675c94dd130d", "message": "Use VerificationContext in AbstractVerification", "committedDate": "2020-03-05T04:10:31Z", "type": "forcePushed"}, {"oid": "632723d8600c07bd51579fec11550e89f4508d86", "url": "https://github.com/prestodb/presto/commit/632723d8600c07bd51579fec11550e89f4508d86", "message": "Use VerificationContext in AbstractVerification", "committedDate": "2020-03-05T04:10:42Z", "type": "forcePushed"}, {"oid": "5834d4addd377c64a952428bfff1d1f38abdd36a", "url": "https://github.com/prestodb/presto/commit/5834d4addd377c64a952428bfff1d1f38abdd36a", "message": "Use VerificationContext in AbstractVerification", "committedDate": "2020-03-05T04:16:54Z", "type": "forcePushed"}, {"oid": "453d505cd52ee19367d6584a7e3e3873799572e1", "url": "https://github.com/prestodb/presto/commit/453d505cd52ee19367d6584a7e3e3873799572e1", "message": "Use VerificationContext in AbstractVerification", "committedDate": "2020-03-05T04:21:06Z", "type": "forcePushed"}, {"oid": "fac8548e7479fbf8dcf2991e5b6584f3c88f169b", "url": "https://github.com/prestodb/presto/commit/fac8548e7479fbf8dcf2991e5b6584f3c88f169b", "message": "Expose unexpected exceptions in Verifier", "committedDate": "2020-03-05T04:27:03Z", "type": "forcePushed"}, {"oid": "a329cd118c2e8dfcd461e7c4a7cadef49c4c5ddb", "url": "https://github.com/prestodb/presto/commit/a329cd118c2e8dfcd461e7c4a7cadef49c4c5ddb", "message": "Expose unexpected exceptions in Verifier", "committedDate": "2020-03-05T04:33:40Z", "type": "forcePushed"}, {"oid": "e801490d82ca312b7030bdc5a9a5635824f2ff6b", "url": "https://github.com/prestodb/presto/commit/e801490d82ca312b7030bdc5a9a5635824f2ff6b", "message": "Fix AbstractTestVerifierIntegrationSmokeTest", "committedDate": "2020-03-05T06:11:02Z", "type": "forcePushed"}, {"oid": "1647fb837b92ea459c4ab03aff5f0ec539e35bcc", "url": "https://github.com/prestodb/presto/commit/1647fb837b92ea459c4ab03aff5f0ec539e35bcc", "message": "Fix AbstractTestVerifierIntegrationSmokeTest", "committedDate": "2020-03-05T06:26:06Z", "type": "forcePushed"}, {"oid": "23f3e7e551132967faa3fbf3fe9921620c330c4a", "url": "https://github.com/prestodb/presto/commit/23f3e7e551132967faa3fbf3fe9921620c330c4a", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-05T06:36:10Z", "type": "forcePushed"}, {"oid": "aefe0c539bb786d72364777b76aa181e90887b76", "url": "https://github.com/prestodb/presto/commit/aefe0c539bb786d72364777b76aa181e90887b76", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-05T06:56:47Z", "type": "forcePushed"}, {"oid": "515d93ed52c0779ce9c2f9499ae33a24797b01ad", "url": "https://github.com/prestodb/presto/commit/515d93ed52c0779ce9c2f9499ae33a24797b01ad", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-05T09:00:36Z", "type": "forcePushed"}, {"oid": "b4c534fa853e41ba08b13472a30f113f8bc675fe", "url": "https://github.com/prestodb/presto/commit/b4c534fa853e41ba08b13472a30f113f8bc675fe", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-05T11:37:22Z", "type": "forcePushed"}, {"oid": "2a0a0f361ee4806b44411f855969fb439199a16f", "url": "https://github.com/prestodb/presto/commit/2a0a0f361ee4806b44411f855969fb439199a16f", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-05T20:09:07Z", "type": "forcePushed"}, {"oid": "2066b443dbd3f91a546e2afa519464cbab1c331e", "url": "https://github.com/prestodb/presto/commit/2066b443dbd3f91a546e2afa519464cbab1c331e", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.", "committedDate": "2020-03-07T22:22:59Z", "type": "forcePushed"}, {"oid": "4dabfd01dcbc3ca8b03da32ace9a64f787f0d2e2", "url": "https://github.com/prestodb/presto/commit/4dabfd01dcbc3ca8b03da32ace9a64f787f0d2e2", "message": "Improve teardown skipping\n\nReplace run-teardown-on-result-mismatch with smart-teardown, which\nskips teardown in case control and test queries succeeds but\nverification fails.\n\nThis allows result tables to be perserved in cases like checksum\nquery failures, to ease debugging and investigation.", "committedDate": "2020-03-10T07:27:40Z", "type": "forcePushed"}, {"oid": "6248e6962e526cf3a52657c94548579bf433fed6", "url": "https://github.com/prestodb/presto/commit/6248e6962e526cf3a52657c94548579bf433fed6", "message": "Improve resubmission", "committedDate": "2020-03-10T07:48:39Z", "type": "forcePushed"}, {"oid": "9d46899d292895fa0d2e596a694dff3be7c9fe4a", "url": "https://github.com/prestodb/presto/commit/9d46899d292895fa0d2e596a694dff3be7c9fe4a", "message": "Improve resubmission", "committedDate": "2020-03-10T07:49:44Z", "type": "forcePushed"}, {"oid": "f43b9af6841b908d265d75ebc876f4314172bac2", "url": "https://github.com/prestodb/presto/commit/f43b9af6841b908d265d75ebc876f4314172bac2", "message": "Restart verification if checksum queries complain table alaready exists\n\nWe're seeing test setup query, which creates the target table to\ninset, fails but the table was still created. Therefore, in case\nchecksum queries fail due to table already exists error, we can\nresubmit the verification to mitigate the transient error.", "committedDate": "2020-03-10T19:09:38Z", "type": "forcePushed"}, {"oid": "b1d1d10798fa97ac39fd98504a9d89e5cb65161b", "url": "https://github.com/prestodb/presto/commit/b1d1d10798fa97ac39fd98504a9d89e5cb65161b", "message": "Restart verification if checksum queries complain table already exists\n\nWe're seeing test setup query, which creates the target table to\ninset, fails but the table was still created. Therefore, in case\nchecksum queries fail due to table already exists error, we can\nresubmit the verification to mitigate the transient error.", "committedDate": "2020-03-18T20:33:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3NDEzMg==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r395074132", "bodyText": "It's strange to me that this class is mutable and gets passed around and modified in several places.  Usually we try to limit the use of mutable objects in Presto, especially across different classes.  In my opinion the mutability here makes the lifecycle of each object confusing and makes the code more error prone (e.g. trying to update the same field 2x). The second commit seems like it's fixing a problem that's mostly caused by this being a mutable object.  And then later commits add even more things to this class, which I think just makes it more fragile. I think it would be better to break this class up into a few classes that can each be immutable.\nFor example, you can separate out an object for keeping the data verification info of control and test checksum queries and build that in DataVerfication.verify(), and then have another object that has all the determinism info that.gets built in the DeterminismAnalyzer and have the LimitDeterminismAnalysis also return the queryId, so that part can be immutable to.", "author": "rschlussel", "createdAt": "2020-03-19T14:36:57Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java", "diffHunk": "@@ -13,110 +13,220 @@\n  */\n package com.facebook.presto.verifier.framework;\n \n-import com.facebook.presto.verifier.event.DeterminismAnalysisRun;\n+import com.facebook.presto.jdbc.QueryStats;\n+import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n import com.facebook.presto.verifier.event.QueryFailure;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n+import com.facebook.presto.verifier.event.VerifierQueryEvent;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n+import java.util.Set;\n \n-import static com.facebook.presto.verifier.framework.LimitQueryDeterminismAnalysis.NOT_RUN;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class VerificationContext", "originalCommit": "b1d1d10798fa97ac39fd98504a9d89e5cb65161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0ODQyMg==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r396048422", "bodyText": "@rschlussel Comments addressed.\nInstead of expanding the mutable object VerificationContext, changes were made to make it immutable. Separate checksum-related mutable fields into CheckQueryContext, and use DeterminismAnalysisDetails.Builder to replace determinism analysis related mutable fields.", "author": "caithagoras", "createdAt": "2020-03-22T02:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3NDEzMg=="}], "type": "inlineReview", "revised_code": {"commit": "ae2f0a9c94d81d8b089a25f2424dd003a098b3f1", "chunk": "diff --git a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java\nindex e025873a06..0fdaf78f78 100644\n--- a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java\n+++ b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java\n\n@@ -13,215 +13,33 @@\n  */\n package com.facebook.presto.verifier.framework;\n \n-import com.facebook.presto.jdbc.QueryStats;\n-import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n import com.facebook.presto.verifier.event.QueryFailure;\n-import com.facebook.presto.verifier.event.VerifierQueryEvent;\n \n import java.util.HashSet;\n import java.util.List;\n-import java.util.Optional;\n import java.util.Set;\n \n-import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n-import static java.util.Objects.requireNonNull;\n \n public class VerificationContext\n {\n-    private Optional<QueryBundle> control = Optional.empty();\n-    private Optional<QueryBundle> test = Optional.empty();\n-    private Optional<QueryStats> controlQueryStats = Optional.empty();\n-    private Optional<QueryState> controlState = Optional.empty();\n-    private Optional<QueryStats> testQueryStats = Optional.empty();\n-    private Optional<QueryState> testState = Optional.empty();\n-    private Optional<String> controlChecksumQueryId = Optional.empty();\n-    private Optional<String> controlChecksumQuery = Optional.empty();\n-    private Optional<String> testChecksumQueryId = Optional.empty();\n-    private Optional<String> testChecksumQuery = Optional.empty();\n-    private Optional<MatchResult> matchResult = Optional.empty();\n-    private Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-    private DeterminismAnalysisDetails.Builder determinismAnalysisDetails = DeterminismAnalysisDetails.builder();\n-    private Boolean shouldResubmit;\n-\n-    private Optional<VerifierQueryEvent> event = Optional.empty();\n-\n     private final int resubmissionCount;\n     private final Set<QueryException> queryExceptions;\n \n-    public VerificationContext()\n-    {\n-        this(0, new HashSet<>());\n-    }\n-\n     private VerificationContext(int resubmissionCount, Set<QueryException> queryExceptions)\n     {\n         this.resubmissionCount = resubmissionCount;\n-        this.queryExceptions = requireNonNull(queryExceptions, \"queryExceptions is null\");\n-    }\n-\n-    public static VerificationContext newContextForResubmission(VerificationContext existing)\n-    {\n-        return new VerificationContext(existing.resubmissionCount + 1, existing.queryExceptions);\n-    }\n-\n-    public Optional<QueryBundle> getControl()\n-    {\n-        return control;\n-    }\n-\n-    public void setControl(QueryBundle control)\n-    {\n-        checkState(!this.control.isPresent(), \"control is already set\");\n-        this.control = Optional.of(control);\n-    }\n-\n-    public Optional<QueryBundle> getTest()\n-    {\n-        return test;\n-    }\n-\n-    public void setTest(QueryBundle test)\n-    {\n-        checkState(!this.test.isPresent(), \"test is already set\");\n-        this.test = Optional.of(test);\n-    }\n-\n-    public Optional<QueryStats> getControlQueryStats()\n-    {\n-        return controlQueryStats;\n-    }\n-\n-    public void setControlQueryStats(QueryStats controlQueryStats)\n-    {\n-        checkState(!this.controlQueryStats.isPresent(), \"controlQueryStats is already set\");\n-        this.controlQueryStats = Optional.of(controlQueryStats);\n-    }\n-\n-    public QueryState getControlState()\n-    {\n-        return controlState.orElse(QueryState.NOT_RUN);\n-    }\n-\n-    public void setControlState(QueryState controlState)\n-    {\n-        checkState(!this.controlState.isPresent(), \"controlState is already set\");\n-        this.controlState = Optional.of(controlState);\n+        this.queryExceptions = new HashSet<>(queryExceptions);\n     }\n \n-    public Optional<QueryStats> getTestQueryStats()\n+    public static VerificationContext create()\n     {\n-        return testQueryStats;\n+        return new VerificationContext(0, new HashSet<>());\n     }\n \n-    public void setTestQueryStats(QueryStats testQueryStats)\n+    public static VerificationContext createForResubmission(VerificationContext existing)\n     {\n-        checkState(!this.testQueryStats.isPresent(), \"testQueryStats is already set\");\n-        this.testQueryStats = Optional.of(testQueryStats);\n-    }\n-\n-    public QueryState getTestState()\n-    {\n-        return testState.orElse(QueryState.NOT_RUN);\n-    }\n-\n-    public void setTestState(QueryState testState)\n-    {\n-        checkState(!this.testState.isPresent(), \"testState is already set\");\n-        this.testState = Optional.of(testState);\n-    }\n-\n-    public Optional<String> getControlChecksumQueryId()\n-    {\n-        return controlChecksumQueryId;\n-    }\n-\n-    public void setControlChecksumQueryId(String controlChecksumQueryId)\n-    {\n-        checkState(!this.controlChecksumQueryId.isPresent(), \"controlChecksumQueryId is already set\");\n-        this.controlChecksumQueryId = Optional.of(controlChecksumQueryId);\n-    }\n-\n-    public Optional<String> getControlChecksumQuery()\n-    {\n-        return controlChecksumQuery;\n-    }\n-\n-    public void setControlChecksumQuery(String controlChecksumQuery)\n-    {\n-        checkState(!this.controlChecksumQuery.isPresent(), \"controlChecksumQuery is already set\");\n-        this.controlChecksumQuery = Optional.of(controlChecksumQuery);\n-    }\n-\n-    public Optional<String> getTestChecksumQueryId()\n-    {\n-        return testChecksumQueryId;\n-    }\n-\n-    public void setTestChecksumQueryId(String testChecksumQueryId)\n-    {\n-        checkState(!this.testChecksumQueryId.isPresent(), \"testChecksumQueryId is already set\");\n-        this.testChecksumQueryId = Optional.of(testChecksumQueryId);\n-    }\n-\n-    public Optional<String> getTestChecksumQuery()\n-    {\n-        return testChecksumQuery;\n-    }\n-\n-    public void setTestChecksumQuery(String testChecksumQuery)\n-    {\n-        checkState(!this.testChecksumQuery.isPresent(), \"testChecksumQuery is already set\");\n-        this.testChecksumQuery = Optional.of(testChecksumQuery);\n-    }\n-\n-    public Optional<MatchResult> getMatchResult()\n-    {\n-        return matchResult;\n-    }\n-\n-    public void setMatchResult(MatchResult matchResult)\n-    {\n-        checkState(!this.matchResult.isPresent(), \"matchResult is already set\");\n-        this.matchResult = Optional.of(matchResult);\n-    }\n-\n-    public Optional<DeterminismAnalysis> getDeterminismAnalysis()\n-    {\n-        return determinismAnalysis;\n-    }\n-\n-    public void setDeterminismAnalysis(DeterminismAnalysis determinismAnalysis)\n-    {\n-        checkState(!this.determinismAnalysis.isPresent(), \"determinismAnalysis is already set\");\n-        this.determinismAnalysis = Optional.of(determinismAnalysis);\n-    }\n-\n-    public DeterminismAnalysisDetails.Builder getDeterminismAnalysisDetails()\n-    {\n-        return determinismAnalysisDetails;\n-    }\n-\n-    public boolean shouldResubmit()\n-    {\n-        return shouldResubmit != null && shouldResubmit;\n-    }\n-\n-    public void setShouldResubmit()\n-    {\n-        checkState(this.shouldResubmit == null, \"shouldResubmit is already set\");\n-        this.shouldResubmit = true;\n-    }\n-\n-    public Optional<VerifierQueryEvent> getEvent()\n-    {\n-        return event;\n-    }\n-\n-    public void setEvent(VerifierQueryEvent event)\n-    {\n-        checkState(!this.event.isPresent(), \"event is already set\");\n-        this.event = Optional.of(event);\n+        return new VerificationContext(existing.resubmissionCount + 1, existing.queryExceptions);\n     }\n \n     public int getResubmissionCount()\n"}}, {"oid": "ae2f0a9c94d81d8b089a25f2424dd003a098b3f1", "url": "https://github.com/prestodb/presto/commit/ae2f0a9c94d81d8b089a25f2424dd003a098b3f1", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-22T02:27:48Z", "type": "forcePushed"}, {"oid": "1f6d6d65fa2ac485f320c45c9fec2664adad54cd", "url": "https://github.com/prestodb/presto/commit/1f6d6d65fa2ac485f320c45c9fec2664adad54cd", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-22T02:33:03Z", "type": "forcePushed"}, {"oid": "6fa37f0a785095a8fb0ce0fc57869ffb3460ae25", "url": "https://github.com/prestodb/presto/commit/6fa37f0a785095a8fb0ce0fc57869ffb3460ae25", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-22T02:38:04Z", "type": "forcePushed"}, {"oid": "e2b74165fda5e54506a4059e70ed7da0f86678b2", "url": "https://github.com/prestodb/presto/commit/e2b74165fda5e54506a4059e70ed7da0f86678b2", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-22T02:40:40Z", "type": "forcePushed"}, {"oid": "53277ac8e7fdc1634e0cb982219ccc4739328cfb", "url": "https://github.com/prestodb/presto/commit/53277ac8e7fdc1634e0cb982219ccc4739328cfb", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-22T02:57:12Z", "type": "forcePushed"}, {"oid": "dfd3c4deab07aca88d4ab3c60e3d5da10202bc07", "url": "https://github.com/prestodb/presto/commit/dfd3c4deab07aca88d4ab3c60e3d5da10202bc07", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-23T22:41:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MDc0OQ==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r396780749", "bodyText": "I don't feel the toOptional change helps with readability. Optional.of()/Optional.ofNullable() is already pretty succinct, used frequently throughout the code base, and it's obvious what they do.  The helper function is slightly shorter, but then I need to spend time figuring out if there's custom logic as part of toOptional.", "author": "rschlussel", "createdAt": "2020-03-23T21:56:22Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();\n+        AtomicReference<QueryBundle> test = new AtomicReference<>();\n+        AtomicReference<QueryStats> controlStats = new AtomicReference<>();\n+        AtomicReference<QueryStats> testStats = new AtomicReference<>();\n+        AtomicReference<QueryState> controlState = new AtomicReference<>(NOT_RUN);\n+        AtomicReference<QueryState> testState = new AtomicReference<>(NOT_RUN);\n         ChecksumQueryContext controlChecksumQueryContext = new ChecksumQueryContext();\n         ChecksumQueryContext testChecksumQueryContext = new ChecksumQueryContext();\n+        Optional<MatchResult> matchResult = Optional.empty();\n+        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n         DeterminismAnalysisDetails.Builder determinismAnalysisDetails = DeterminismAnalysisDetails.builder();\n \n         try {\n-            control = queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL);\n-            test = queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST);\n-            controlQueryStats = DataVerificationUtil.setupAndRun(prestoAction, control, false);\n-            testQueryStats = DataVerificationUtil.setupAndRun(prestoAction, test, false);\n-            matchResult = verify(control, test, controlChecksumQueryContext, testChecksumQueryContext);\n-\n-            if (matchResult.isMismatchPossiblyCausedByNonDeterminism()) {\n-                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control, matchResult.getControlChecksum(), determinismAnalysisDetails));\n+            // Rewrite queries\n+            control.set(queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL));\n+            test.set(queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST));\n+\n+            // Run queries\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, control.get(), false),\n+                    controlStats::set,\n+                    e -> controlState.set(getFailingQueryState(e)));\n+            controlState.set(QueryState.SUCCEEDED);\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, test.get(), false),\n+                    testStats::set,\n+                    e -> testState.set(getFailingQueryState(e)));\n+            testState.set(QueryState.SUCCEEDED);\n+\n+            // Verify results\n+            matchResult = Optional.of(verify(control.get(), test.get(), controlChecksumQueryContext, testChecksumQueryContext));\n+\n+            // Determinism analysis\n+            if (matchResult.get().isMismatchPossiblyCausedByNonDeterminism()) {\n+                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control.get(), matchResult.get().getControlChecksum(), determinismAnalysisDetails));\n             }\n             boolean maybeDeterministic = !determinismAnalysis.isPresent() ||\n                     determinismAnalysis.get().isDeterministic() ||\n                     determinismAnalysis.get().isUnknown();\n-            resultMismatched = maybeDeterministic && !matchResult.isMatched();\n+            resultMismatched = maybeDeterministic && !matchResult.get().isMatched();\n \n             return concludeVerification(\n-                    Optional.of(control),\n-                    Optional.of(test),\n-                    Optional.ofNullable(controlQueryStats),\n-                    Optional.ofNullable(testQueryStats),\n-                    Optional.empty(),\n-                    Optional.of(matchResult),\n+                    toOptional(control),", "originalCommit": "d2bc2d5a4e0af661d202a09c04a8bba0379303fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNjU5MQ==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397526591", "bodyText": "Changed to Optional.ofNullable(reference.get())", "author": "caithagoras", "createdAt": "2020-03-24T23:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MDc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "dfd3c4deab07aca88d4ab3c60e3d5da10202bc07", "chunk": "diff --git a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\nindex 771fc27301..1bae1d6343 100644\n--- a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\n+++ b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\n\n@@ -118,8 +118,6 @@ public abstract class AbstractVerification\n     @Override\n     public VerificationResult run()\n     {\n-        boolean resultMismatched = false;\n-\n         AtomicReference<QueryBundle> control = new AtomicReference<>();\n         AtomicReference<QueryBundle> test = new AtomicReference<>();\n         AtomicReference<QueryStats> controlStats = new AtomicReference<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397355807", "bodyText": "What's the purpose of using AtomicReferences?", "author": "rschlussel", "createdAt": "2020-03-24T18:00:45Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "originalCommit": "f214145c10fd320421da86474a9027ad7f93e94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNzkwNQ==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397527905", "bodyText": "In 141 - 150, those variables are used in lambda, and IntelliJ complains about \"Variable used in lambda expression should be final or effectively final\" if they're nullable or Optional.\nInstead, I need a reference to those variables, with setter method for updating the value. AtomicReference seems to be easiest to use although I don't need the atomicity of the update. Otherwise, I'll need create a private static inner class Reference.", "author": "caithagoras", "createdAt": "2020-03-24T23:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzNTQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399535495", "bodyText": "That seems sketchy to me, but I can't tell if it's actually a problem here or just seems bad (https://www.baeldung.com/java-lambda-effectively-final-local-variables is what I read to understand what the problems might be).  I feel it would be better to change it because my general philosophy is it's best if a reader doesn't have to think too hard to understand why code is correct.  However, you could alternatively get a review from someone with deeper Java knowledge to say whether there are any concerns in this case, and then also add a comment about why these use AtomicReference and why it's not a problem.", "author": "rschlussel", "createdAt": "2020-03-27T21:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzODI0Mw==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399538243", "bodyText": "This is an annoying limitation, but I usually create copy variables like so:\nQueryBundle control = null;\n\n        try {\n            // Rewrite queries\n            control = queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL);\n            test.set(queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST));\n\n            // Run queries\n            QueryBundle controlCopy = control;\n            runAndConsume(\n                    () -> setupAndRun(prestoAction, controlCopy, false),\n                    controlStats::set,\n                    e -> controlState.set(getFailingQueryState(e)));", "author": "mbasmanova", "createdAt": "2020-03-27T21:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MDg2Ng==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399540866", "bodyText": "@mbasmanova\nCopy would work only for variables to be read, but I also need values to be set in the the lambda.\ncontrolStats::set,\ne -> controlState.set(getFailingQueryState(e))\ncontrolStats and controlState are used as a 1-field mutable context object.\nIt is similar to creating a private mutable Context object wrapping all those field, define setters on each of them, and supply context::setControlStats and e->context.setControlState(getFailingQueryState(e)).", "author": "caithagoras", "createdAt": "2020-03-27T21:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0NjY3Ng==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399546676", "bodyText": "@caithagoras Thanks for clarifying. I like the solution using Context object better.", "author": "mbasmanova", "createdAt": "2020-03-27T21:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MzE5OA==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399563198", "bodyText": "Done. Since @rschlussel advices against mutable classes, I'm making the mutable context a private static inner class to minimize exposure.", "author": "caithagoras", "createdAt": "2020-03-27T22:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "62b8d2f7a2eb2015ac884bb9f2294e6a445a1a2f", "chunk": "diff --git a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\nindex 771fc27301..709a41abbb 100644\n--- a/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\n+++ b/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java\n\n@@ -118,8 +118,6 @@ public abstract class AbstractVerification\n     @Override\n     public VerificationResult run()\n     {\n-        boolean resultMismatched = false;\n-\n         AtomicReference<QueryBundle> control = new AtomicReference<>();\n         AtomicReference<QueryBundle> test = new AtomicReference<>();\n         AtomicReference<QueryStats> controlStats = new AtomicReference<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NDk5NQ==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397364995", "bodyText": "Does this test that covers the case that was failing before?  Or if not, is there a test that does?", "author": "rschlussel", "createdAt": "2020-03-24T18:15:42Z", "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java", "diffHunk": "@@ -131,30 +131,23 @@ public void setup()\n     }\n \n     @Test\n-    public void testFailureRequeued()\n+    public void testFailureResubmitted()", "originalCommit": "9ce164e93158d2316342c8372634cecfc535346d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMDgxOA==", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399500818", "bodyText": "No it does not, but I manually tested it. Adding that test a bit more complex, and I add a TODO here. Can we proceed with the PR so that we can use it for 0.234 verification? I'll add the test shortly. Thanks!", "author": "caithagoras", "createdAt": "2020-03-27T19:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NDk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6698f35e4b5a63091c18c290796bd43520d0ae0b", "chunk": "diff --git a/presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java b/presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java\nindex e0ac5304fb..a543e0be5c 100644\n--- a/presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java\n+++ b/presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java\n\n@@ -131,23 +131,30 @@ public class TestVerificationManager\n     }\n \n     @Test\n-    public void testFailureResubmitted()\n+    public void testFailureRequeued()\n     {\n         VerificationManager manager = getVerificationManager(ImmutableList.of(SOURCE_QUERY), new MockPrestoAction(HIVE_PARTITION_DROPPED_DURING_QUERY), VERIFIER_CONFIG);\n         manager.start();\n         assertEquals(manager.getQueriesSubmitted().get(), 3);\n-        assertEquals(eventClient.getEvents().size(), 1);\n-        assertEquals(eventClient.getEvents().get(0).getResubmissionCount(), 2);\n     }\n \n     @Test\n-    public void testFailureNotSubmitted()\n+    public void testFailureNotRequeued()\n     {\n         VerificationManager manager = getVerificationManager(ImmutableList.of(SOURCE_QUERY), new MockPrestoAction(GENERIC_INTERNAL_ERROR), VERIFIER_CONFIG);\n         manager.start();\n         assertEquals(manager.getQueriesSubmitted().get(), 1);\n-        assertEquals(eventClient.getEvents().size(), 1);\n-        assertEquals(eventClient.getEvents().get(0).getResubmissionCount(), 0);\n+    }\n+\n+    @Test\n+    public void testFailureRequeueDisabled()\n+    {\n+        VerificationManager manager = getVerificationManager(\n+                ImmutableList.of(SOURCE_QUERY),\n+                new MockPrestoAction(HIVE_PARTITION_DROPPED_DURING_QUERY),\n+                new VerifierConfig().setTestId(\"test\").setVerificationResubmissionLimit(0));\n+        manager.start();\n+        assertEquals(manager.getQueriesSubmitted().get(), 1);\n     }\n \n     @Test\n"}}, {"oid": "62b8d2f7a2eb2015ac884bb9f2294e6a445a1a2f", "url": "https://github.com/prestodb/presto/commit/62b8d2f7a2eb2015ac884bb9f2294e6a445a1a2f", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-24T23:38:37Z", "type": "forcePushed"}, {"oid": "6698f35e4b5a63091c18c290796bd43520d0ae0b", "url": "https://github.com/prestodb/presto/commit/6698f35e4b5a63091c18c290796bd43520d0ae0b", "message": "Improve VerificationContext\n\n- Remove determinismAnalysisDetails from VerificationContext. Use\n  the builder directly.\n- Move check query info to a separate class.\n- Use Optional fields instead of nullable fields.\n- Move getters and setters of DeterminismAnalysisDetails fields into\n  a builder.", "committedDate": "2020-03-27T19:27:34Z", "type": "commit"}, {"oid": "eded1ecea12d3370d7ba97a4fbbeed84062c0a5c", "url": "https://github.com/prestodb/presto/commit/eded1ecea12d3370d7ba97a4fbbeed84062c0a5c", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-27T19:27:34Z", "type": "forcePushed"}, {"oid": "0670311df05b3e589e23999c042f55d33c476b0a", "url": "https://github.com/prestodb/presto/commit/0670311df05b3e589e23999c042f55d33c476b0a", "message": "Fix verification resubmission\n\nVerificationContext contains fields that can be set only once. When\nverification is resubmitted, Verification#run method is called again\non the same object, and in turn, the setters will be called again\nin the new run and throws, potentially causing resubmission to fail.\n\nBreak the circular dependency between DataVerification and\nVerificationManager by performing the actual resubmission in\nVerificationManager.\n\nAdd resubmission count to VerificationContext, each Verification\nmaintains its resubmission count instead of requiring\nVerificationManager to keep track.\n\nAlso, export the resubmission count in the output event.", "committedDate": "2020-03-27T19:42:13Z", "type": "commit"}, {"oid": "65d8935c5b1ab20457a1e04c224106b4f5ae6be8", "url": "https://github.com/prestodb/presto/commit/65d8935c5b1ab20457a1e04c224106b4f5ae6be8", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-27T19:42:14Z", "type": "forcePushed"}, {"oid": "5b38d11194cedaccca109fc59a5b89c469412dce", "url": "https://github.com/prestodb/presto/commit/5b38d11194cedaccca109fc59a5b89c469412dce", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-27T22:16:06Z", "type": "forcePushed"}, {"oid": "2d8d2ab95af3b4942b09c9874b3a9ebcbece434b", "url": "https://github.com/prestodb/presto/commit/2d8d2ab95af3b4942b09c9874b3a9ebcbece434b", "message": "Restart verification if checksum queries fail with table already exist\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-30T04:12:37Z", "type": "forcePushed"}, {"oid": "e8abba52fed701710e33dd6d81b1bd7c568f1e3f", "url": "https://github.com/prestodb/presto/commit/e8abba52fed701710e33dd6d81b1bd7c568f1e3f", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-30T04:12:48Z", "type": "forcePushed"}, {"oid": "5bf83b54549048403ae4468ab759914c1415ece9", "url": "https://github.com/prestodb/presto/commit/5bf83b54549048403ae4468ab759914c1415ece9", "message": "Improve readability in AbstractVerification\n\nRemove the nullable variables.\nRemove FAILED_TO_TEARDOWN from QueryState since it is a impossible\nstate.", "committedDate": "2020-03-30T23:13:04Z", "type": "commit"}, {"oid": "8963e88c1bfb819d095d35c963e12306501ed345", "url": "https://github.com/prestodb/presto/commit/8963e88c1bfb819d095d35c963e12306501ed345", "message": "Expose unexpected exceptions in Verifier\n\nPreviously, Verifier silently ignores exceptions that are not\nQueryException, as they're only loggged but not VerifierQueryEvent\nis exported.\n\nHandle general exception properly so that they can be uncovered and\ninvestigated. Mark them as SKIPPED so that they do cause noise.", "committedDate": "2020-03-30T23:13:05Z", "type": "commit"}, {"oid": "3276ae4c858af603bd5efdf9b00aca85ae8231b8", "url": "https://github.com/prestodb/presto/commit/3276ae4c858af603bd5efdf9b00aca85ae8231b8", "message": "Fix AbstractTestVerifierIntegrationSmokeTest\n\nThe test merely tests injection and continue to succeed even when\nthere are verification failures. Add assertions that the testing\nverification are succeded.\n\nAlso, add missing configuration properties that caused verifications\nin the integration test to fail.", "committedDate": "2020-03-30T23:13:07Z", "type": "commit"}, {"oid": "ba96c132b76cb033616af727025b871130238741", "url": "https://github.com/prestodb/presto/commit/ba96c132b76cb033616af727025b871130238741", "message": "Improve teardown skipping\n\nReplace run-teardown-on-result-mismatch with smart-teardown, which\nskips teardown in case control and test queries succeeds but\nverification fails.\n\nThis allows result tables to be perserved in cases like checksum\nquery failures, to ease debugging and investigation.", "committedDate": "2020-03-30T23:13:08Z", "type": "commit"}, {"oid": "09da0b57884f8e26407150cd65a13907c1143201", "url": "https://github.com/prestodb/presto/commit/09da0b57884f8e26407150cd65a13907c1143201", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to table already exists\nerror, we can resubmit the verification to mitigate the transient\nerror.", "committedDate": "2020-03-30T23:13:09Z", "type": "forcePushed"}, {"oid": "6001b129d26b6245436b1f0f5e271212b7273182", "url": "https://github.com/prestodb/presto/commit/6001b129d26b6245436b1f0f5e271212b7273182", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to the table already\nexists error, we can resubmit the verification to mitigate the\ntransient error.", "committedDate": "2020-03-31T03:39:32Z", "type": "commit"}, {"oid": "6001b129d26b6245436b1f0f5e271212b7273182", "url": "https://github.com/prestodb/presto/commit/6001b129d26b6245436b1f0f5e271212b7273182", "message": "Restart verification if checksum queries fail with table already exists\n\nSetup queries create the target tables for INSERT verification.\nWe're seeing setup queries failing but the table was still created.\nTherefore, in case checksum queries fail due to the table already\nexists error, we can resubmit the verification to mitigate the\ntransient error.", "committedDate": "2020-03-31T03:39:32Z", "type": "forcePushed"}]}