{"pr_number": 14108, "pr_title": "Pass cache info into connectors", "pr_createdAt": "2020-02-15T07:35:59Z", "pr_url": "https://github.com/prestodb/presto/pull/14108", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTAzNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821036", "bodyText": "Make a public static final constant in class SplitContext for new SplitContext(false) and use it everywhere in the codebase when necessary.", "author": "highker", "createdAt": "2020-02-15T09:35:53Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/AbstractTestHiveClient.java", "diffHunk": "@@ -1962,7 +1963,7 @@ private void doTestBucketedTableEvolutionWithDifferentReadCount(HiveStorageForma\n \n             ImmutableList.Builder<MaterializedRow> allRows = ImmutableList.builder();\n             for (ConnectorSplit split : splits) {\n-                try (ConnectorPageSource pageSource = pageSourceProvider.createPageSource(transaction.getTransactionHandle(), session, split, tableHandle.getLayout().get(), columnHandles)) {\n+                try (ConnectorPageSource pageSource = pageSourceProvider.createPageSource(transaction.getTransactionHandle(), session, split, tableHandle.getLayout().get(), columnHandles, new SplitContext(false))) {", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-hive/src/test/java/com/facebook/presto/hive/AbstractTestHiveClient.java b/presto-hive/src/test/java/com/facebook/presto/hive/AbstractTestHiveClient.java\nindex 4f49cae79c..4ece5bfb5b 100644\n--- a/presto-hive/src/test/java/com/facebook/presto/hive/AbstractTestHiveClient.java\n+++ b/presto-hive/src/test/java/com/facebook/presto/hive/AbstractTestHiveClient.java\n\n@@ -1963,7 +1963,7 @@ public abstract class AbstractTestHiveClient\n \n             ImmutableList.Builder<MaterializedRow> allRows = ImmutableList.builder();\n             for (ConnectorSplit split : splits) {\n-                try (ConnectorPageSource pageSource = pageSourceProvider.createPageSource(transaction.getTransactionHandle(), session, split, tableHandle.getLayout().get(), columnHandles, new SplitContext(false))) {\n+                try (ConnectorPageSource pageSource = pageSourceProvider.createPageSource(transaction.getTransactionHandle(), session, split, tableHandle.getLayout().get(), columnHandles, NON_CACHEABLE)) {\n                     MaterializedResult intermediateResult = materializeSourceDataStream(session, pageSource, getTypes(columnHandles));\n                     allRows.addAll(intermediateResult.getMaterializedRows());\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTEzMA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821130", "bodyText": "private", "author": "highker", "createdAt": "2020-02-15T09:37:37Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +210,26 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(node, true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(chosenNode, false);\n+    }\n+\n+    static class NodeResult", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -210,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(node, true);\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTEzMw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821133", "bodyText": "Optional.ofNullable", "author": "highker", "createdAt": "2020-02-15T09:37:45Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +210,26 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(node, true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(chosenNode, false);\n+    }\n+\n+    static class NodeResult\n+    {\n+        private InternalNode node;\n+        boolean shouldCache;\n+\n+        public NodeResult(InternalNode node, boolean shouldCache)\n+        {\n+            this.node = node;", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -210,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(node, true);\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTE0OA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821148", "bodyText": "never access raw members. Use getter and setter", "author": "highker", "createdAt": "2020-02-15T09:38:01Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +150,21 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (chosenNode.node == null) {", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -151,20 +152,20 @@ public class SimpleNodeSelector\n             }\n \n             NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode.node == null) {\n+            if (!chosenNode.getNode().isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode.node != null) {\n+            if (chosenNode.getNode().isPresent()) {\n                 split = new Split(\n                         split.getConnectorId(),\n                         split.getTransactionHandle(),\n                         split.getConnectorSplit(),\n                         split.getLifespan(),\n-                        new SplitContext(chosenNode.shouldCache));\n+                        new SplitContext(chosenNode.ifShouldCache()));\n \n-                assignment.put(chosenNode.node, split);\n-                assignmentStats.addAssignedSplit(chosenNode.node);\n+                assignment.put(chosenNode.getNode().get(), split);\n+                assignmentStats.addAssignedSplit(chosenNode.getNode().get());\n             }\n             else {\n                 if (split.getNodeSelectionStrategy() != HARD_AFFINITY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTIxNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821216", "bodyText": "Optional", "author": "highker", "createdAt": "2020-02-15T09:39:25Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +210,26 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(node, true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(chosenNode, false);\n+    }\n+\n+    static class NodeResult\n+    {\n+        private InternalNode node;", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -210,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(node, true);\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTIyNQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821225", "bodyText": "chosenNode.getNode.isPresent()", "author": "highker", "createdAt": "2020-02-15T09:39:41Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +150,21 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (chosenNode.node == null) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode != null) {\n-                assignment.put(chosenNode, split);\n-                assignmentStats.addAssignedSplit(chosenNode);\n+            if (chosenNode.node != null) {", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -151,20 +152,20 @@ public class SimpleNodeSelector\n             }\n \n             NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode.node == null) {\n+            if (!chosenNode.getNode().isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode.node != null) {\n+            if (chosenNode.getNode().isPresent()) {\n                 split = new Split(\n                         split.getConnectorId(),\n                         split.getTransactionHandle(),\n                         split.getConnectorSplit(),\n                         split.getLifespan(),\n-                        new SplitContext(chosenNode.shouldCache));\n+                        new SplitContext(chosenNode.ifShouldCache()));\n \n-                assignment.put(chosenNode.node, split);\n-                assignmentStats.addAssignedSplit(chosenNode.node);\n+                assignment.put(chosenNode.getNode().get(), split);\n+                assignmentStats.addAssignedSplit(chosenNode.getNode().get());\n             }\n             else {\n                 if (split.getNodeSelectionStrategy() != HARD_AFFINITY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTI2MA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821260", "bodyText": "@Nullable", "author": "highker", "createdAt": "2020-02-15T09:40:36Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +210,26 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(node, true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(chosenNode, false);\n+    }\n+\n+    static class NodeResult\n+    {\n+        private InternalNode node;\n+        boolean shouldCache;\n+\n+        public NodeResult(InternalNode node, boolean shouldCache)", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex d776f2bf15..3afd6656d9 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -210,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(node, true);\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTUxNw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821517", "bodyText": "this is not used anywhere", "author": "highker", "createdAt": "2020-02-15T09:46:03Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/Split.java", "diffHunk": "@@ -33,24 +34,32 @@\n     private final ConnectorTransactionHandle transactionHandle;\n     private final ConnectorSplit connectorSplit;\n     private final Lifespan lifespan;\n+    private final SplitContext splitContext;\n \n     // TODO: inline\n     public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit)\n     {\n-        this(connectorId, transactionHandle, connectorSplit, Lifespan.taskWide());\n+        this(connectorId, transactionHandle, connectorSplit, Lifespan.taskWide(), new SplitContext(false));\n+    }\n+\n+    public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit, SplitContext splitContext)", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\nindex dbe7754779..6f5aa7336a 100644\n--- a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n+++ b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n\n@@ -39,12 +41,7 @@ public final class Split\n     // TODO: inline\n     public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit)\n     {\n-        this(connectorId, transactionHandle, connectorSplit, Lifespan.taskWide(), new SplitContext(false));\n-    }\n-\n-    public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit, SplitContext splitContext)\n-    {\n-        this(connectorId, transactionHandle, connectorSplit, Lifespan.taskWide(), splitContext);\n+        this(connectorId, transactionHandle, connectorSplit, Lifespan.taskWide(), NON_CACHEABLE);\n     }\n \n     @JsonCreator\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTU0NA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821544", "bodyText": "cachable", "author": "highker", "createdAt": "2020-02-15T09:46:40Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spi;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public class SplitContext\n+{\n+    boolean shouldCache;", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java b/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\nindex 237ad10dd3..bbed6c7d5f 100644\n--- a/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\n+++ b/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\n\n@@ -14,21 +14,23 @@\n package com.facebook.presto.spi;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n-import com.fasterxml.jackson.annotation.JsonValue;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n \n public class SplitContext\n {\n-    boolean shouldCache;\n+    public static final SplitContext NON_CACHEABLE = new SplitContext(false);\n+\n+    private final boolean cacheable;\n \n     @JsonCreator\n-    public SplitContext(boolean shouldCache)\n+    public SplitContext(@JsonProperty boolean cacheable)\n     {\n-        this.shouldCache = shouldCache;\n+        this.cacheable = cacheable;\n     }\n \n-    @JsonValue\n-    public boolean isShouldCache()\n+    @JsonProperty\n+    public boolean isCacheable()\n     {\n-        return shouldCache;\n+        return cacheable;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTU2NA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821564", "bodyText": "remove", "author": "highker", "createdAt": "2020-02-15T09:47:04Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java", "diffHunk": "@@ -18,25 +18,39 @@\n import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.ConnectorSplit;\n import com.facebook.presto.spi.ConnectorTableLayoutHandle;\n+import com.facebook.presto.spi.SplitContext;\n \n import java.util.List;\n \n public interface ConnectorPageSourceProvider\n {\n     /**\n      * @param columns columns that should show up in the output page, in this order\n+     * @param splitContext", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java b/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\nindex 0ff4bc5538..dd30d8f901 100644\n--- a/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\n+++ b/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\n\n@@ -26,7 +26,6 @@ public interface ConnectorPageSourceProvider\n {\n     /**\n      * @param columns columns that should show up in the output page, in this order\n-     * @param splitContext\n      */\n     @Deprecated\n     default ConnectorPageSource createPageSource(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyMTU3Mw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379821573", "bodyText": "remove", "author": "highker", "createdAt": "2020-02-15T09:47:16Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java", "diffHunk": "@@ -18,25 +18,39 @@\n import com.facebook.presto.spi.ConnectorSession;\n import com.facebook.presto.spi.ConnectorSplit;\n import com.facebook.presto.spi.ConnectorTableLayoutHandle;\n+import com.facebook.presto.spi.SplitContext;\n \n import java.util.List;\n \n public interface ConnectorPageSourceProvider\n {\n     /**\n      * @param columns columns that should show up in the output page, in this order\n+     * @param splitContext\n      */\n     @Deprecated\n-    default ConnectorPageSource createPageSource(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorSplit split, List<ColumnHandle> columns)\n+    default ConnectorPageSource createPageSource(\n+            ConnectorTransactionHandle transactionHandle,\n+            ConnectorSession session,\n+            ConnectorSplit split,\n+            List<ColumnHandle> columns,\n+            SplitContext splitContext)\n     {\n         throw new UnsupportedOperationException();\n     }\n \n     /**\n      * @param columns columns that should show up in the output page, in this order\n+     * @param splitContext", "originalCommit": "8ae6c198c1a53a7b805dd0f15de211142f1342e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "chunk": "diff --git a/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java b/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\nindex 0ff4bc5538..dd30d8f901 100644\n--- a/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\n+++ b/presto-spi/src/main/java/com/facebook/presto/spi/connector/ConnectorPageSourceProvider.java\n\n@@ -26,7 +26,6 @@ public interface ConnectorPageSourceProvider\n {\n     /**\n      * @param columns columns that should show up in the output page, in this order\n-     * @param splitContext\n      */\n     @Deprecated\n     default ConnectorPageSource createPageSource(\n"}}, {"oid": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "url": "https://github.com/prestodb/presto/commit/8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "message": "Pass cache info into connectors", "committedDate": "2020-02-15T22:15:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NjM0MQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379866341", "bodyText": "code style", "author": "highker", "createdAt": "2020-02-16T00:46:15Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/Split.java", "diffHunk": "@@ -100,6 +112,25 @@ public String toString()\n                 .add(\"transactionHandle\", transactionHandle)\n                 .add(\"connectorSplit\", connectorSplit)\n                 .add(\"lifespan\", lifespan)\n+                .add(\"splitContext\", splitContext)\n                 .toString();\n     }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) { return true; }", "originalCommit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2304f8f17737cae5d08e138fdbc73826d1ecb164", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\nindex 6f5aa7336a..a5ea449ab6 100644\n--- a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n+++ b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n\n@@ -116,21 +117,8 @@ public final class Split\n                 .toString();\n     }\n \n-    @Override\n-    public boolean equals(Object o)\n-    {\n-        if (this == o) { return true; }\n-        if (o == null || getClass() != o.getClass()) { return false; }\n-        Split split = (Split) o;\n-        return connectorId.equals(split.connectorId) &&\n-                transactionHandle.equals(split.transactionHandle) &&\n-                connectorSplit.equals(split.connectorSplit) &&\n-                lifespan.equals(split.lifespan);\n-    }\n-\n-    @Override\n-    public int hashCode()\n+    public void setSplitContext(SplitContext splitContext)\n     {\n-        return Objects.hash(connectorId, transactionHandle, connectorSplit, lifespan);\n+        this.splitContext = splitContext;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NjM4Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379866387", "bodyText": "\"node is null\"", "author": "highker", "createdAt": "2020-02-16T00:47:34Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +211,36 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(Optional.ofNullable(chosenNode), false);\n+    }\n+\n+    private static class NodeResult\n+    {\n+        private Optional<InternalNode> node;\n+        private boolean shouldCache;\n+\n+        public NodeResult(Optional<InternalNode> node, boolean shouldCache)\n+        {\n+            this.node = requireNonNull(node, \"Optional<InternalNode> is null\");", "originalCommit": "8768410a01f7f3ae2bc338e7c65c99256cfdd4ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cf9d54110a31503636029b226f34c18c98fb6509", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 3afd6656d9..5c5ec215ab 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -229,7 +223,7 @@ public class SimpleNodeSelector\n \n         public NodeResult(Optional<InternalNode> node, boolean shouldCache)\n         {\n-            this.node = requireNonNull(node, \"Optional<InternalNode> is null\");\n+            this.node = requireNonNull(node, \"node is null\");\n             this.shouldCache = shouldCache;\n         }\n \n"}}, {"oid": "2304f8f17737cae5d08e138fdbc73826d1ecb164", "url": "https://github.com/prestodb/presto/commit/2304f8f17737cae5d08e138fdbc73826d1ecb164", "message": "Decide cacheable when scheduling unbucketed splits", "committedDate": "2020-02-16T00:52:49Z", "type": "forcePushed"}, {"oid": "f6c27c0b56113ad55b3854ac81008004dff8c4c7", "url": "https://github.com/prestodb/presto/commit/f6c27c0b56113ad55b3854ac81008004dff8c4c7", "message": "Decide cacheable when scheduling unbucketed splits", "committedDate": "2020-02-16T00:55:32Z", "type": "forcePushed"}, {"oid": "cf9d54110a31503636029b226f34c18c98fb6509", "url": "https://github.com/prestodb/presto/commit/cf9d54110a31503636029b226f34c18c98fb6509", "message": "Decide cacheable when scheduling unbucketed splits", "committedDate": "2020-02-16T01:00:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTUxNA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379869514", "bodyText": "you still need to create a new Split; check my comment below", "author": "highker", "createdAt": "2020-02-16T02:11:14Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +151,15 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.getNode().isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode != null) {\n-                assignment.put(chosenNode, split);\n-                assignmentStats.addAssignedSplit(chosenNode);\n+            if (chosenNode.getNode().isPresent()) {\n+                split.setSplitContext(new SplitContext(chosenNode.ifShouldCache()));", "originalCommit": "cf9d54110a31503636029b226f34c18c98fb6509", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 5c5ec215ab..040112d57b 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -157,7 +157,13 @@ public class SimpleNodeSelector\n             }\n \n             if (chosenNode.getNode().isPresent()) {\n-                split.setSplitContext(new SplitContext(chosenNode.ifShouldCache()));\n+                split = new Split(\n+                        split.getConnectorId(),\n+                        split.getTransactionHandle(),\n+                        split.getConnectorSplit(),\n+                        split.getLifespan(),\n+                        new SplitContext(chosenNode.ifShouldCache()));\n+\n                 assignment.put(chosenNode.getNode().get(), split);\n                 assignmentStats.addAssignedSplit(chosenNode.getNode().get());\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTUyOQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379869529", "bodyText": "final", "author": "highker", "createdAt": "2020-02-16T02:11:28Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +205,36 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(Optional.ofNullable(chosenNode), false);\n+    }\n+\n+    private static class NodeResult\n+    {\n+        private Optional<InternalNode> node;", "originalCommit": "cf9d54110a31503636029b226f34c18c98fb6509", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 5c5ec215ab..040112d57b 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -218,12 +224,12 @@ public class SimpleNodeSelector\n \n     private static class NodeResult\n     {\n-        private Optional<InternalNode> node;\n-        private boolean shouldCache;\n+        private final Optional<InternalNode> node;\n+        private final boolean shouldCache;\n \n         public NodeResult(Optional<InternalNode> node, boolean shouldCache)\n         {\n-            this.node = requireNonNull(node, \"node is null\");\n+            this.node = requireNonNull(node, \"Optional<InternalNode> is null\");\n             this.shouldCache = shouldCache;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTU0Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379869547", "bodyText": "final", "author": "highker", "createdAt": "2020-02-16T02:11:45Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/Split.java", "diffHunk": "@@ -34,23 +36,27 @@\n     private final ConnectorSplit connectorSplit;\n     private final Lifespan lifespan;\n \n+    private SplitContext splitContext;", "originalCommit": "cf9d54110a31503636029b226f34c18c98fb6509", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\nindex 58b3d73e1c..649d6d7d7c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n+++ b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n\n@@ -35,8 +36,7 @@ public final class Split\n     private final ConnectorTransactionHandle transactionHandle;\n     private final ConnectorSplit connectorSplit;\n     private final Lifespan lifespan;\n-\n-    private SplitContext splitContext;\n+    private final SplitContext splitContext;\n \n     // TODO: inline\n     public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTU0OA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379869548", "bodyText": "remove this line", "author": "highker", "createdAt": "2020-02-16T02:11:51Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/Split.java", "diffHunk": "@@ -34,23 +36,27 @@\n     private final ConnectorSplit connectorSplit;\n     private final Lifespan lifespan;\n ", "originalCommit": "cf9d54110a31503636029b226f34c18c98fb6509", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\nindex 58b3d73e1c..649d6d7d7c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n+++ b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n\n@@ -35,8 +36,7 @@ public final class Split\n     private final ConnectorTransactionHandle transactionHandle;\n     private final ConnectorSplit connectorSplit;\n     private final Lifespan lifespan;\n-\n-    private SplitContext splitContext;\n+    private final SplitContext splitContext;\n \n     // TODO: inline\n     public Split(ConnectorId connectorId, ConnectorTransactionHandle transactionHandle, ConnectorSplit connectorSplit)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTYxMg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379869612", "bodyText": "You still need equals and hashCode function, so that splitContext can be immutable.", "author": "highker", "createdAt": "2020-02-16T02:13:26Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/Split.java", "diffHunk": "@@ -77,6 +83,17 @@ public Lifespan getLifespan()\n         return lifespan;\n     }\n \n+    @JsonProperty\n+    public SplitContext getSplitContext()\n+    {\n+        return splitContext;\n+    }\n+\n+    public void setSplitContext(SplitContext splitContext)", "originalCommit": "cf9d54110a31503636029b226f34c18c98fb6509", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3OTgzMg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379879832", "bodyText": "So I have these two version of code both ready\n1.Provide SplitContext as a mutable field, as the code above\n2.Use hashCode and equals to indicate if they're the same Split (not include SplitContext)\nkewang1024@376fb8a\n(https://github.com/kewang1024/presto/commits/test_pass_cache)\nWhen SourcePartitionedScheduler use SimpleNodeSelector to do scheduling for pending task, we may change some split's SplitContext to cacheable and return those split back to SourcePartitionedScheduler\nSourcePartitionedScheduler will evict those split from pendingTask (a split Set)\nfor\n\nPro: more straightforward  since we are removing the same split from split set.\nCon: Split not immutable any more\n2.Pro: Split immutable\nCon: seems a little hacky to evict from a set using a different Split (but they're same because we don't include SplitContext in equals and hash method), and possibly cause confusion if we lose context at some point\n\nAlso want to know your opinion on it @shixuan-fan @wenleix", "author": "kewang1024", "createdAt": "2020-02-16T06:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTkyNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r379975926", "bodyText": "We don't use mutable data structure in our codebase. Otherwise, we can avoid creating SplitContext by directly change the context for HiveSplit", "author": "highker", "createdAt": "2020-02-17T03:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NDYyNA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r383444624", "bodyText": "I agree that an immutable class is easier to reason and understand.", "author": "shixuan-fan", "createdAt": "2020-02-24T18:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2OTYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\nindex 58b3d73e1c..649d6d7d7c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n+++ b/presto-main/src/main/java/com/facebook/presto/metadata/Split.java\n\n@@ -89,11 +89,6 @@ public final class Split\n         return splitContext;\n     }\n \n-    public void setSplitContext(SplitContext splitContext)\n-    {\n-        this.splitContext = splitContext;\n-    }\n-\n     public Object getInfo()\n     {\n         return connectorSplit.getInfo();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NTMwNA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r383445304", "bodyText": "nit: maybe we'd want a builder pattern for this class? Even though currently there is only one field, a builder pattern makes future work easier to understand.", "author": "shixuan-fan", "createdAt": "2020-02-24T18:45:37Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spi;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public class SplitContext\n+{\n+    public static final SplitContext NON_CACHEABLE = new SplitContext(false);\n+\n+    private final boolean cacheable;\n+\n+    @JsonCreator\n+    public SplitContext(@JsonProperty boolean cacheable)", "originalCommit": "147543c86f185835f668cab1ca5b7ea8adf545b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxMjM3Mg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r383612372", "bodyText": "Currently I couldn't come up with anything that we may need to add to SplitContext, maybe we can use it when we have additional optional attribute for SplitContext\nthanks for the good advice, left a todo for future change", "author": "kewang1024", "createdAt": "2020-02-25T01:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NTMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "chunk": "diff --git a/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java b/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\nindex bbed6c7d5f..b967e03fd7 100644\n--- a/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\n+++ b/presto-spi/src/main/java/com/facebook/presto/spi/SplitContext.java\n\n@@ -16,6 +16,7 @@ package com.facebook.presto.spi;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n+// TODO: Use builder pattern for SplitContext if we are to add optional field\n public class SplitContext\n {\n     public static final SplitContext NON_CACHEABLE = new SplitContext(false);\n"}}, {"oid": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "url": "https://github.com/prestodb/presto/commit/d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-25T01:27:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNTA4Ng==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384035086", "bodyText": "How about we keep chosenNode to null for this case? I don't know the history of why this is null rather than Optional.empty(), but I personally would prefer the latter..", "author": "shixuan-fan", "createdAt": "2020-02-25T18:10:55Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +151,21 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.getNode().isPresent()) {", "originalCommit": "dae30888267cc9d886657873797282586aa01565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxODc1MA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384218750", "bodyText": "Do you want to keep chosenNode.getNode()  null or Optional.empty()?\nIf it is Optional.empty(), then it should be our current case", "author": "kewang1024", "createdAt": "2020-02-26T00:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNTA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3MDQ1Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384670457", "bodyText": "I don't have strong opinion around null vs empty, but I'd prefer we make decision based on chosenNode being null/empty, instead of chosenNode.getNode() :)", "author": "shixuan-fan", "createdAt": "2020-02-26T18:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNTA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 040112d57b..7a13f82f7e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -151,21 +151,21 @@ public class SimpleNodeSelector\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (!chosenNode.getNode().isPresent()) {\n+            Optional<NodeResult> chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode.getNode().isPresent()) {\n+            if (chosenNode.isPresent()) {\n                 split = new Split(\n                         split.getConnectorId(),\n                         split.getTransactionHandle(),\n                         split.getConnectorSplit(),\n                         split.getLifespan(),\n-                        new SplitContext(chosenNode.ifShouldCache()));\n+                        new SplitContext(chosenNode.get().isCacheable()));\n \n-                assignment.put(chosenNode.getNode().get(), split);\n-                assignmentStats.addAssignedSplit(chosenNode.getNode().get());\n+                assignment.put(chosenNode.get().getInternalNode(), split);\n+                assignmentStats.addAssignedSplit(chosenNode.get().getInternalNode());\n             }\n             else {\n                 if (split.getNodeSelectionStrategy() != HARD_AFFINITY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNjIyNA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384036224", "bodyText": "I remembered @wenleix once mentioned that changing Split in scheduling time might not be respected by Presto-on-Spark. I'll let @wenleix chime in here but would like to call it out so we are aware :)", "author": "shixuan-fan", "createdAt": "2020-02-25T18:13:29Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +151,21 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.getNode().isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode != null) {\n-                assignment.put(chosenNode, split);\n-                assignmentStats.addAssignedSplit(chosenNode);\n+            if (chosenNode.getNode().isPresent()) {\n+                split = new Split(\n+                        split.getConnectorId(),\n+                        split.getTransactionHandle(),\n+                        split.getConnectorSplit(),\n+                        split.getLifespan(),\n+                        new SplitContext(chosenNode.ifShouldCache()));", "originalCommit": "dae30888267cc9d886657873797282586aa01565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMTUxMw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384101513", "bodyText": "@wenleix mentioned to me as well. I vaguely remember this won't affect spark. Will let @wenleix comment.", "author": "highker", "createdAt": "2020-02-25T20:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNjIyNA=="}], "type": "inlineReview", "revised_code": {"commit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 040112d57b..7a13f82f7e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -151,21 +151,21 @@ public class SimpleNodeSelector\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            NodeResult chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (!chosenNode.getNode().isPresent()) {\n+            Optional<NodeResult> chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode.getNode().isPresent()) {\n+            if (chosenNode.isPresent()) {\n                 split = new Split(\n                         split.getConnectorId(),\n                         split.getTransactionHandle(),\n                         split.getConnectorSplit(),\n                         split.getLifespan(),\n-                        new SplitContext(chosenNode.ifShouldCache()));\n+                        new SplitContext(chosenNode.get().isCacheable()));\n \n-                assignment.put(chosenNode.getNode().get(), split);\n-                assignmentStats.addAssignedSplit(chosenNode.getNode().get());\n+                assignment.put(chosenNode.get().getInternalNode(), split);\n+                assignmentStats.addAssignedSplit(chosenNode.get().getInternalNode());\n             }\n             else {\n                 if (split.getNodeSelectionStrategy() != HARD_AFFINITY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAzNzQzMg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384037432", "bodyText": "Let's just make this InternalNode. I think if there is no result, we should mark NodeResult as Optional.empty() or null instead.", "author": "shixuan-fan", "createdAt": "2020-02-25T18:15:51Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +211,36 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(Optional.ofNullable(chosenNode), false);\n+    }\n+\n+    private static class NodeResult\n+    {\n+        private final Optional<InternalNode> node;", "originalCommit": "dae30888267cc9d886657873797282586aa01565", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 040112d57b..7a13f82f7e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -211,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(Optional.of(node), true);\n+                return Optional.of(new NodeResult(node, true));\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0MjgzNw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384042837", "bodyText": "Maybe cachable? I understand why shouldCache was chosen but ifShouldCache seems a bit awkward comparing to isCachable. Open to other suggestions as well.", "author": "shixuan-fan", "createdAt": "2020-02-25T18:25:45Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +211,36 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return node;\n+                return new NodeResult(Optional.of(node), true);\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n                 chosenNode = node;\n                 min = splitCount;\n             }\n         }\n-        return chosenNode;\n+        return new NodeResult(Optional.ofNullable(chosenNode), false);\n+    }\n+\n+    private static class NodeResult\n+    {\n+        private final Optional<InternalNode> node;\n+        private final boolean shouldCache;", "originalCommit": "dae30888267cc9d886657873797282586aa01565", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 040112d57b..7a13f82f7e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -211,7 +211,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return new NodeResult(Optional.of(node), true);\n+                return Optional.of(new NodeResult(node, true));\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NDgxMg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384044812", "bodyText": "Why is cacheable a property for BucketNodeMap? Shouldn't this be a property for a node-bucket pair?", "author": "shixuan-fan", "createdAt": "2020-02-25T18:29:18Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java", "diffHunk": "@@ -39,6 +39,8 @@ public BucketNodeMap(ToIntFunction<Split> splitToBucket)\n \n     public abstract boolean isDynamic();\n \n+    public abstract boolean isCacheable();", "originalCommit": "d5c2473f4ad03d74c8f3bbf12ec4a2e8ecc1b8d1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "863ccc73575f682b9bb788ba0237d9e88daa035d", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\nindex fd9bbce549..74d4203208 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n\n@@ -35,16 +36,21 @@ public abstract class BucketNodeMap\n \n     public abstract Optional<InternalNode> getAssignedNode(int bucketedId);\n \n-    public abstract void assignOrUpdateBucketToNode(int bucketedId, InternalNode node);\n+    public abstract Optional<Boolean> getAssignedNodeCache(int bucketedId);\n \n-    public abstract boolean isDynamic();\n+    public abstract void assignOrUpdateBucketToNode(int bucketedId, InternalNode node, boolean cacheable);\n \n-    public abstract boolean isCacheable();\n+    public abstract boolean isDynamic();\n \n     public final Optional<InternalNode> getAssignedNode(Split split)\n     {\n         return getAssignedNode(splitToBucket.applyAsInt(split));\n     }\n \n+    public final Optional<Boolean> getAssignedNodeCache(Split split)\n+    {\n+        return getAssignedNodeCache(splitToBucket.applyAsInt(split));\n+    }\n+\n     public abstract Optional<List<InternalNode>> getBucketToNode();\n }\n"}}, {"oid": "7d14fe2ee6a569b73f089704eb3d9c1fbe38f3a8", "url": "https://github.com/prestodb/presto/commit/7d14fe2ee6a569b73f089704eb3d9c1fbe38f3a8", "message": "Fix generated nodeList when using DynamicBucketNodeMap\n\nInstead of using random nodes for DynamicBucketNodeMap, when DynamicBucketNodeMap provides node lists, we directly use it", "committedDate": "2020-02-25T19:05:43Z", "type": "forcePushed"}, {"oid": "863ccc73575f682b9bb788ba0237d9e88daa035d", "url": "https://github.com/prestodb/presto/commit/863ccc73575f682b9bb788ba0237d9e88daa035d", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-25T20:00:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDI4Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384100287", "bodyText": "remove", "author": "highker", "createdAt": "2020-02-25T20:12:10Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java", "diffHunk": "@@ -15,7 +15,9 @@\n \n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.Split;\n+import com.sun.javafx.scene.control.behavior.OptionalBoolean;", "originalCommit": "863ccc73575f682b9bb788ba0237d9e88daa035d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14c88dcf062e6bc2a2527d372d497a8d1281153a", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\nindex 74d4203208..5b5b737024 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n\n@@ -15,7 +15,6 @@ package com.facebook.presto.execution.scheduler;\n \n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.Split;\n-import com.sun.javafx.scene.control.behavior.OptionalBoolean;\n \n import java.util.List;\n import java.util.Optional;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDc0OQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384100749", "bodyText": "final", "author": "highker", "createdAt": "2020-02-25T20:13:05Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.facebook.presto.execution.scheduler;\n+\n+import com.facebook.presto.metadata.InternalNode;\n+\n+public class InternalNodeAndCache\n+{\n+    private final InternalNode internalNode;\n+    private boolean cacheable;", "originalCommit": "863ccc73575f682b9bb788ba0237d9e88daa035d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14c88dcf062e6bc2a2527d372d497a8d1281153a", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\nindex 8c5691d9eb..49d747fef3 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\n\n@@ -1,3 +1,16 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.facebook.presto.execution.scheduler;\n \n import com.facebook.presto.metadata.InternalNode;\n"}}, {"oid": "14c88dcf062e6bc2a2527d372d497a8d1281153a", "url": "https://github.com/prestodb/presto/commit/14c88dcf062e6bc2a2527d372d497a8d1281153a", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-25T21:15:38Z", "type": "forcePushed"}, {"oid": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "url": "https://github.com/prestodb/presto/commit/dbec75df1266ef4af3260b16fd2812c80c66a2b5", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-26T01:30:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyOTQ3OA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384229478", "bodyText": "If I read this condition correctly, this will make HARD_AFFINITY to return split that is not cacheable. Can we add tests to verify that?", "author": "highker", "createdAt": "2020-02-26T01:31:53Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -202,14 +211,39 @@ private static InternalNode chooseLeastBusyNode(List<InternalNode> candidateNode\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {", "originalCommit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d59630cc69fae000ef27c4734cd594a2241febcf", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 7a13f82f7e..b0739d54d7 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -211,7 +202,7 @@ public class SimpleNodeSelector\n \n             // choose the preferred node first as long as they're not busy\n             if (preferredNodeCount.isPresent() && i < preferredNodeCount.getAsInt() && splitCount < maxSplitCount) {\n-                return Optional.of(new NodeResult(node, true));\n+                return node;\n             }\n             // fallback to choosing the least busy nodes\n             if (splitCount < min && splitCount < maxSplitCount) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2ODMyNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384668326", "bodyText": "In this case !bucketNodeMap.isDynamic() seems a bit redundant?", "author": "shixuan-fan", "createdAt": "2020-02-26T18:05:43Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java", "diffHunk": "@@ -335,8 +335,8 @@ else if (partitioningHandle.equals(SCALED_WRITER_DISTRIBUTION)) {\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic()) {\n-                        stageNodeList = ((FixedBucketNodeMap) bucketNodeMap).getBucketToNode().stream()\n+                    if (!bucketNodeMap.isDynamic() || bucketNodeMap.getBucketToNode().isPresent()) {", "originalCommit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDIyNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384840226", "bodyText": "In this case !bucketNodeMap.isDynamic() seems a bit redundant?\n\nif we change bucketNodeMap.getBucketToNode().isPresent() to other function, we may need to keep it", "author": "kewang1024", "createdAt": "2020-02-27T00:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2ODMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\nindex 2defdeae9b..7bf71510ba 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n\n@@ -335,7 +336,7 @@ public class SectionExecutionFactory\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic() || bucketNodeMap.getBucketToNode().isPresent()) {\n+                    if (!bucketNodeMap.isDynamic() || ((DynamicBucketNodeMap) bucketNodeMap).ifInitialMapExist()) {\n                         stageNodeList = bucketNodeMap.getBucketToNode().get().stream()\n                                 .distinct()\n                                 .collect(toImmutableList());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Mjk4OA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384672988", "bodyText": "I'm not entirely sure if this is a good predicate since this would cover both of the following cases:\n\nThere is initial preferred mapping\nThere is no initial preferred mapping, but with at least one bucketToNode assignment by calling assignOrUpdateBucketToNode\n\nBased on my understanding on the comment, the second case might not be desired?", "author": "shixuan-fan", "createdAt": "2020-02-26T18:14:12Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -63,16 +77,25 @@ public int getBucketCount()\n     }\n \n     @Override\n-    public void assignOrUpdateBucketToNode(int bucketedId, InternalNode node)\n+    public void assignOrUpdateBucketToNode(int bucketedId, InternalNode node, boolean cacheable)\n     {\n         checkArgument(bucketedId >= 0 && bucketedId < bucketCount);\n         requireNonNull(node, \"node is null\");\n-        bucketToNode.put(bucketedId, node);\n+        bucketToNodeAndCache.put(bucketedId, new InternalNodeAndCache(node, cacheable));\n     }\n \n     @Override\n     public boolean isDynamic()\n     {\n         return true;\n     }\n+\n+    @Override\n+    public Optional<List<InternalNode>> getBucketToNode()\n+    {\n+        if (bucketToNodeAndCache.size() == 0) {", "originalCommit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MDczMQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384690731", "bodyText": "Yes you're right, both situation could happen.\nBy saying \"the second case might not be desired\",  I'm guessing you're referring to the call in SectionExecutionFactory?\nif it's the call in SectionExecutionFactory, I think we should be safe, because we call getBucketToNode right after nodePartitioningManager.getBucketNodeMap, there is no situation for assignOrUpdateBucketToNode to happen.\nBut I understand your concern, maybe your suggestion is to have a different method name to indicate that it's initialized instead of checking the map count?", "author": "kewang1024", "createdAt": "2020-02-26T18:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Mjk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MjI0OQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384692249", "bodyText": "Yeah I think if what we want to check is initial preferred mapping exists, let's make it exclusive and explicit :D. Also, the method name might need to be changed to reflect the fact that we are only returning the mapping when there is initial mapping.", "author": "shixuan-fan", "createdAt": "2020-02-26T18:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Mjk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NjE0Ng==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384696146", "bodyText": "Sounds reasonable! Will do", "author": "kewang1024", "createdAt": "2020-02-26T18:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Mjk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex c33e4d7a41..d51a40cf77 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -98,4 +101,9 @@ public class DynamicBucketNodeMap\n         }\n         return Optional.of(bucketToNodeAndCache.values().stream().map(InternalNodeAndCache::getInternalNode).collect(Collectors.toList()));\n     }\n+\n+    public boolean ifInitialMapExist()\n+    {\n+        return initialMapExist;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NDIxMw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384674213", "bodyText": "Just out of curiosity, what would happen if bucketNodeMap is updated in DynamicBucketNodeMap (thus stageNodeList is not consistent with DynamicBucketNodeMap#getBucketToNode)?", "author": "shixuan-fan", "createdAt": "2020-02-26T18:16:27Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java", "diffHunk": "@@ -335,8 +335,8 @@ else if (partitioningHandle.equals(SCALED_WRITER_DISTRIBUTION)) {\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic()) {\n-                        stageNodeList = ((FixedBucketNodeMap) bucketNodeMap).getBucketToNode().stream()\n+                    if (!bucketNodeMap.isDynamic() || bucketNodeMap.getBucketToNode().isPresent()) {\n+                        stageNodeList = bucketNodeMap.getBucketToNode().get().stream()", "originalCommit": "dbec75df1266ef4af3260b16fd2812c80c66a2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4Njg4NA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384686884", "bodyText": "It would be the same behavior as we assign random stageNodeList, when we do scheduling, we would distribute bucket (the bucket that couldn't find its desired bucket) to a random node.\nbucketNodeMap being updated in DynamicBucketNodeMap would only happen in DynamicLifespanScheduler, which means it happens when some node/task failed and affinity can't be enforced , thus we have to fall back to random choosing.\nSo the difference with random stageNodeList, we try best effort to put bucket to their desired node, then fall back to random if affinity can't be achieved.", "author": "kewang1024", "createdAt": "2020-02-26T18:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NDIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\nindex 2defdeae9b..7bf71510ba 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n\n@@ -335,7 +336,7 @@ public class SectionExecutionFactory\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic() || bucketNodeMap.getBucketToNode().isPresent()) {\n+                    if (!bucketNodeMap.isDynamic() || ((DynamicBucketNodeMap) bucketNodeMap).ifInitialMapExist()) {\n                         stageNodeList = bucketNodeMap.getBucketToNode().get().stream()\n                                 .distinct()\n                                 .collect(toImmutableList());\n"}}, {"oid": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "url": "https://github.com/prestodb/presto/commit/d6ef87f0476585f5a96d1236b6601e6d6542f971", "message": "Fix SimpleNodeSelector node selection for HARD AFFINITY", "committedDate": "2020-02-26T23:59:54Z", "type": "forcePushed"}, {"oid": "9d54b88716ba841a28825d9e1a5e556a51dc652e", "url": "https://github.com/prestodb/presto/commit/9d54b88716ba841a28825d9e1a5e556a51dc652e", "message": "Revert \"Enable failure detector in tests\"\n\nThis reverts commit 3eef1b02da1fd8d09f3992a54f6499695aa6b4cb.", "committedDate": "2020-02-27T07:05:46Z", "type": "forcePushed"}, {"oid": "285f63018021790fb58767b92a14570ab4980628", "url": "https://github.com/prestodb/presto/commit/285f63018021790fb58767b92a14570ab4980628", "message": "Fix SimpleNodeSelector node selection for HARD AFFINITY", "committedDate": "2020-02-27T07:05:45Z", "type": "forcePushed"}, {"oid": "d59630cc69fae000ef27c4734cd594a2241febcf", "url": "https://github.com/prestodb/presto/commit/d59630cc69fae000ef27c4734cd594a2241febcf", "message": "Introduce SPI SplitContext in Split", "committedDate": "2020-02-27T17:10:58Z", "type": "commit"}, {"oid": "63214111bb202d5203e932a8adba11257a3d5022", "url": "https://github.com/prestodb/presto/commit/63214111bb202d5203e932a8adba11257a3d5022", "message": "Add SplitContext in SPI ConnectorPageSourceProvider", "committedDate": "2020-02-27T17:10:58Z", "type": "commit"}, {"oid": "031437fcf79d104655ee64b6f03dac6c73da6fab", "url": "https://github.com/prestodb/presto/commit/031437fcf79d104655ee64b6f03dac6c73da6fab", "message": "Fix SimpleNodeSelector node selection for HARD AFFINITY", "committedDate": "2020-02-27T17:10:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NTYyNw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385275627", "bodyText": "nit: not sure how much value it would add, but maybe have a variable for chosenNode.get().getInternalNode() since it is used twice.", "author": "shixuan-fan", "createdAt": "2020-02-27T17:57:43Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java", "diffHunk": "@@ -149,14 +151,21 @@ public SplitPlacementResult computeAssignments(Set<Split> splits, List<RemoteTas\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            InternalNode chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (chosenNode == null) {\n+            Optional<NodeResult> chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNode.isPresent()) {\n                 chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode != null) {\n-                assignment.put(chosenNode, split);\n-                assignmentStats.addAssignedSplit(chosenNode);\n+            if (chosenNode.isPresent()) {\n+                split = new Split(\n+                        split.getConnectorId(),\n+                        split.getTransactionHandle(),\n+                        split.getConnectorSplit(),\n+                        split.getLifespan(),\n+                        new SplitContext(chosenNode.get().isCacheable()));\n+\n+                assignment.put(chosenNode.get().getInternalNode(), split);", "originalCommit": "d5458310af01500ea1496808f962d76263f6a32b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\nindex 7a13f82f7e..970512e16e 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/nodeSelection/SimpleNodeSelector.java\n\n@@ -151,21 +152,22 @@ public class SimpleNodeSelector\n                 throw new PrestoException(NO_NODES_AVAILABLE, \"No nodes available to run query\");\n             }\n \n-            Optional<NodeResult> chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n-            if (!chosenNode.isPresent()) {\n-                chosenNode = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n+            Optional<InternalNodeInfo> chosenNodeInfo = chooseLeastBusyNode(candidateNodes, assignmentStats::getTotalSplitCount, preferredNodeCount, maxSplitsPerNode);\n+            if (!chosenNodeInfo.isPresent()) {\n+                chosenNodeInfo = chooseLeastBusyNode(candidateNodes, assignmentStats::getQueuedSplitCountForStage, preferredNodeCount, maxPendingSplitsPerTask);\n             }\n \n-            if (chosenNode.isPresent()) {\n+            if (chosenNodeInfo.isPresent()) {\n                 split = new Split(\n                         split.getConnectorId(),\n                         split.getTransactionHandle(),\n                         split.getConnectorSplit(),\n                         split.getLifespan(),\n-                        new SplitContext(chosenNode.get().isCacheable()));\n+                        new SplitContext(chosenNodeInfo.get().isCacheable()));\n \n-                assignment.put(chosenNode.get().getInternalNode(), split);\n-                assignmentStats.addAssignedSplit(chosenNode.get().getInternalNode());\n+                InternalNode chosenNode = chosenNodeInfo.get().getInternalNode();\n+                assignment.put(chosenNode, split);\n+                assignmentStats.addAssignedSplit(chosenNode);\n             }\n             else {\n                 if (split.getNodeSelectionStrategy() != HARD_AFFINITY) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NzU2NA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385277564", "bodyText": "Hmmmm I'm wondering if we could combine this with NodeResult in the previous commit. The content seems to be the same? Also maybe name this InternalNodeInfo(I don't have a very good name) in case we want to put more information/context in this class?", "author": "shixuan-fan", "createdAt": "2020-02-27T18:01:19Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.scheduler;\n+\n+import com.facebook.presto.metadata.InternalNode;\n+\n+public class InternalNodeAndCache", "originalCommit": "af987f18814b2e52af29d01d31d6fffffbcd6a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeInfo.java\nsimilarity index 80%\nrename from presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\nrename to presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeInfo.java\nindex 49d747fef3..6a76d53081 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeInfo.java\n\n@@ -15,14 +15,16 @@ package com.facebook.presto.execution.scheduler;\n \n import com.facebook.presto.metadata.InternalNode;\n \n-public class InternalNodeAndCache\n+import static java.util.Objects.requireNonNull;\n+\n+public class InternalNodeInfo\n {\n     private final InternalNode internalNode;\n     private final boolean cacheable;\n \n-    public InternalNodeAndCache(InternalNode internalNode, boolean cacheable)\n+    public InternalNodeInfo(InternalNode internalNode, boolean cacheable)\n     {\n-        this.internalNode = internalNode;\n+        this.internalNode = requireNonNull(internalNode, \"internalNode is null\");\n         this.cacheable = cacheable;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3ODkxNg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385278916", "bodyText": "Curious: why is this an Optional<Boolean>? I thought whether a split is cacheable should be a boolean instead? In that case we might as well just change the method name to isSplitCacheable. getAssignedNodeCache is a bit confusing because it seems that we are returning a cache.", "author": "shixuan-fan", "createdAt": "2020-02-27T18:03:57Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java", "diffHunk": "@@ -44,5 +46,10 @@ public BucketNodeMap(ToIntFunction<Split> splitToBucket)\n         return getAssignedNode(splitToBucket.applyAsInt(split));\n     }\n \n+    public final Optional<Boolean> getAssignedNodeCache(Split split)", "originalCommit": "af987f18814b2e52af29d01d31d6fffffbcd6a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\nindex 5b5b737024..eb5c8577e7 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/BucketNodeMap.java\n\n@@ -45,11 +42,4 @@ public abstract class BucketNodeMap\n     {\n         return getAssignedNode(splitToBucket.applyAsInt(split));\n     }\n-\n-    public final Optional<Boolean> getAssignedNodeCache(Split split)\n-    {\n-        return getAssignedNodeCache(splitToBucket.applyAsInt(split));\n-    }\n-\n-    public abstract Optional<List<InternalNode>> getBucketToNode();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4MDkyNw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385280927", "bodyText": "It seems that this cacheable solely depends on whether there is bucketToPreferredNode in the argument? Is there a use case where we called the other constructor but set cacheable to false?", "author": "shixuan-fan", "createdAt": "2020-02-27T18:08:02Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -32,24 +32,24 @@\n         extends BucketNodeMap\n {\n     private final int bucketCount;\n-    private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n+    private final Int2ObjectMap<InternalNodeAndCache> bucketToNodeAndCache = new Int2ObjectOpenHashMap<>();\n     private final boolean initialMapExist;\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, boolean cacheable)", "originalCommit": "af987f18814b2e52af29d01d31d6fffffbcd6a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex d51a40cf77..dcd350c743 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -32,45 +30,30 @@ public class DynamicBucketNodeMap\n         extends BucketNodeMap\n {\n     private final int bucketCount;\n-    private final Int2ObjectMap<InternalNodeAndCache> bucketToNodeAndCache = new Int2ObjectOpenHashMap<>();\n-    private final boolean initialMapExist;\n+    private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, boolean cacheable)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         this.bucketCount = bucketCount;\n-        initialMapExist = false;\n     }\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode, boolean cacheable)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         checkArgument(bucketToPreferredNode.size() == bucketCount, \"bucketToPreferredNode size must be equal to bucketCount\");\n         for (int bucketNumber = 0; bucketNumber < bucketCount; bucketNumber++) {\n-            bucketToNodeAndCache.put(bucketNumber, new InternalNodeAndCache(bucketToPreferredNode.get(bucketNumber), cacheable));\n+            bucketToNode.put(bucketNumber, bucketToPreferredNode.get(bucketNumber));\n         }\n         this.bucketCount = bucketCount;\n-        this.initialMapExist = true;\n     }\n \n     @Override\n     public Optional<InternalNode> getAssignedNode(int bucketedId)\n     {\n-        if (!bucketToNodeAndCache.containsKey(bucketedId)) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(bucketToNodeAndCache.get(bucketedId).getInternalNode());\n-    }\n-\n-    @Override\n-    public Optional<Boolean> getAssignedNodeCache(int bucketedId)\n-    {\n-        if (!bucketToNodeAndCache.containsKey(bucketedId)) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(bucketToNodeAndCache.get(bucketedId).isCacheable());\n+        return Optional.ofNullable(bucketToNode.get(bucketedId));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NDk1Mg==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385284952", "bodyText": "Maybe name this isBucketCacheable? Also, if bucket does not exist, I'm guessing we should also return false? An empty result is a bit confusing.", "author": "shixuan-fan", "createdAt": "2020-02-27T18:15:57Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -58,7 +58,19 @@ public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount,\n     @Override\n     public Optional<InternalNode> getAssignedNode(int bucketedId)\n     {\n-        return Optional.ofNullable(bucketToNode.get(bucketedId));\n+        if (!bucketToNodeAndCache.containsKey(bucketedId)) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(bucketToNodeAndCache.get(bucketedId).getInternalNode());\n+    }\n+\n+    @Override\n+    public Optional<Boolean> getAssignedNodeCache(int bucketedId)", "originalCommit": "af987f18814b2e52af29d01d31d6fffffbcd6a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex d51a40cf77..dcd350c743 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -32,45 +30,30 @@ public class DynamicBucketNodeMap\n         extends BucketNodeMap\n {\n     private final int bucketCount;\n-    private final Int2ObjectMap<InternalNodeAndCache> bucketToNodeAndCache = new Int2ObjectOpenHashMap<>();\n-    private final boolean initialMapExist;\n+    private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, boolean cacheable)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         this.bucketCount = bucketCount;\n-        initialMapExist = false;\n     }\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode, boolean cacheable)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         checkArgument(bucketToPreferredNode.size() == bucketCount, \"bucketToPreferredNode size must be equal to bucketCount\");\n         for (int bucketNumber = 0; bucketNumber < bucketCount; bucketNumber++) {\n-            bucketToNodeAndCache.put(bucketNumber, new InternalNodeAndCache(bucketToPreferredNode.get(bucketNumber), cacheable));\n+            bucketToNode.put(bucketNumber, bucketToPreferredNode.get(bucketNumber));\n         }\n         this.bucketCount = bucketCount;\n-        this.initialMapExist = true;\n     }\n \n     @Override\n     public Optional<InternalNode> getAssignedNode(int bucketedId)\n     {\n-        if (!bucketToNodeAndCache.containsKey(bucketedId)) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(bucketToNodeAndCache.get(bucketedId).getInternalNode());\n-    }\n-\n-    @Override\n-    public Optional<Boolean> getAssignedNodeCache(int bucketedId)\n-    {\n-        if (!bucketToNodeAndCache.containsKey(bucketedId)) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(bucketToNodeAndCache.get(bucketedId).isCacheable());\n+        return Optional.ofNullable(bucketToNode.get(bucketedId));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NzUyOQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385287529", "bodyText": "I think this could be an interface method, and for FixedBucketNodeMap just return true. This way we don't need to do downcasting :)\nAlso, maybe name this hasInitialMap?", "author": "shixuan-fan", "createdAt": "2020-02-27T18:20:55Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -75,4 +80,18 @@ public boolean isDynamic()\n     {\n         return true;\n     }\n+\n+    @Override\n+    public Optional<List<InternalNode>> getBucketToNode()\n+    {\n+        if (bucketToNode.size() == 0) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(ImmutableList.copyOf(bucketToNode.values()));\n+    }\n+\n+    public boolean ifInitialMapExist()", "originalCommit": "db0c495b0c0bb5a6ba79485c6c909c8bcf691ea2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex 7040a26a88..dcd350c743 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -80,18 +75,4 @@ public class DynamicBucketNodeMap\n     {\n         return true;\n     }\n-\n-    @Override\n-    public Optional<List<InternalNode>> getBucketToNode()\n-    {\n-        if (bucketToNode.size() == 0) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(ImmutableList.copyOf(bucketToNode.values()));\n-    }\n-\n-    public boolean ifInitialMapExist()\n-    {\n-        return initialMapExist;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NzkwOQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385287909", "bodyText": "If ifInitialMapExist becomes an interface method, then we don't need !bucketNodeMap.isDynamic() anymore.", "author": "shixuan-fan", "createdAt": "2020-02-27T18:21:36Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java", "diffHunk": "@@ -335,8 +336,8 @@ else if (partitioningHandle.equals(SCALED_WRITER_DISTRIBUTION)) {\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic()) {\n-                        stageNodeList = ((FixedBucketNodeMap) bucketNodeMap).getBucketToNode().stream()\n+                    if (!bucketNodeMap.isDynamic() || ((DynamicBucketNodeMap) bucketNodeMap).ifInitialMapExist()) {", "originalCommit": "db0c495b0c0bb5a6ba79485c6c909c8bcf691ea2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee56408ed29c550fba849876647cee8c78ffa7db", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\nindex 7bf71510ba..66b9c298f3 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/SectionExecutionFactory.java\n\n@@ -336,8 +335,8 @@ public class SectionExecutionFactory\n                     // verify execution is consistent with planner's decision on dynamic lifespan schedule\n                     verify(bucketNodeMap.isDynamic() == dynamicLifespanSchedule);\n \n-                    if (!bucketNodeMap.isDynamic() || ((DynamicBucketNodeMap) bucketNodeMap).ifInitialMapExist()) {\n-                        stageNodeList = bucketNodeMap.getBucketToNode().get().stream()\n+                    if (!bucketNodeMap.isDynamic()) {\n+                        stageNodeList = ((FixedBucketNodeMap) bucketNodeMap).getBucketToNode().stream()\n                                 .distinct()\n                                 .collect(toImmutableList());\n                     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMjUwMw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384932503", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-02-27T06:20:56Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.scheduler;\n+\n+import com.facebook.presto.metadata.InternalNode;\n+\n+public class InternalNodeAndCache\n+{\n+    private final InternalNode internalNode;\n+    private final boolean cacheable;\n+\n+    public InternalNodeAndCache(InternalNode internalNode, boolean cacheable)\n+    {\n+        this.internalNode = internalNode;", "originalCommit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d59630cc69fae000ef27c4734cd594a2241febcf", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\ndeleted file mode 100644\nindex 49d747fef3..0000000000\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/InternalNodeAndCache.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.execution.scheduler;\n-\n-import com.facebook.presto.metadata.InternalNode;\n-\n-public class InternalNodeAndCache\n-{\n-    private final InternalNode internalNode;\n-    private final boolean cacheable;\n-\n-    public InternalNodeAndCache(InternalNode internalNode, boolean cacheable)\n-    {\n-        this.internalNode = internalNode;\n-        this.cacheable = cacheable;\n-    }\n-\n-    public InternalNode getInternalNode()\n-    {\n-        return internalNode;\n-    }\n-\n-    public boolean isCacheable()\n-    {\n-        return cacheable;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMzcyOA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384933728", "bodyText": "toImmutableList()", "author": "highker", "createdAt": "2020-02-27T06:25:41Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java", "diffHunk": "@@ -15,40 +15,50 @@\n \n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.Split;\n-import com.google.common.collect.ImmutableList;\n \n import java.util.List;\n import java.util.Optional;\n import java.util.function.ToIntFunction;\n+import java.util.stream.Collectors;\n \n import static java.util.Objects.requireNonNull;\n \n // the bucket to node mapping is fixed and pre-assigned\n public class FixedBucketNodeMap\n         extends BucketNodeMap\n {\n-    private final List<InternalNode> bucketToNode;\n+    private final List<InternalNodeAndCache> bucketToNodeAndCache;\n \n-    public FixedBucketNodeMap(ToIntFunction<Split> splitToBucket, List<InternalNode> bucketToNode)\n+    public FixedBucketNodeMap(ToIntFunction<Split> splitToBucket, List<InternalNode> bucketToNode, boolean cacheable)\n     {\n         super(splitToBucket);\n-        this.bucketToNode = ImmutableList.copyOf(requireNonNull(bucketToNode, \"bucketToNode is null\"));\n+        requireNonNull(bucketToNode, \"bucketToNode is null\");\n+        this.bucketToNodeAndCache = bucketToNode.stream().map(internalNode -> new InternalNodeAndCache(internalNode, cacheable)).collect(Collectors.toList());", "originalCommit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d59630cc69fae000ef27c4734cd594a2241febcf", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\nindex ddc37180f3..fd19469e6b 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\n\n@@ -15,11 +15,11 @@ package com.facebook.presto.execution.scheduler;\n \n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.Split;\n+import com.google.common.collect.ImmutableList;\n \n import java.util.List;\n import java.util.Optional;\n import java.util.function.ToIntFunction;\n-import java.util.stream.Collectors;\n \n import static java.util.Objects.requireNonNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDEwMw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r384934103", "bodyText": "toImmutableList()", "author": "highker", "createdAt": "2020-02-27T06:27:11Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java", "diffHunk": "@@ -59,8 +69,9 @@ public boolean isDynamic()\n         return false;\n     }\n \n-    public List<InternalNode> getBucketToNode()\n+    @Override\n+    public Optional<List<InternalNode>> getBucketToNode()\n     {\n-        return bucketToNode;\n+        return Optional.of(bucketToNodeAndCache.stream().map(InternalNodeAndCache::getInternalNode).collect(Collectors.toList()));", "originalCommit": "d6ef87f0476585f5a96d1236b6601e6d6542f971", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d59630cc69fae000ef27c4734cd594a2241febcf", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\nindex ddc37180f3..fd19469e6b 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java\n\n@@ -69,9 +59,8 @@ public class FixedBucketNodeMap\n         return false;\n     }\n \n-    @Override\n-    public Optional<List<InternalNode>> getBucketToNode()\n+    public List<InternalNode> getBucketToNode()\n     {\n-        return Optional.of(bucketToNodeAndCache.stream().map(InternalNodeAndCache::getInternalNode).collect(Collectors.toList()));\n+        return bucketToNode;\n     }\n }\n"}}, {"oid": "ee56408ed29c550fba849876647cee8c78ffa7db", "url": "https://github.com/prestodb/presto/commit/ee56408ed29c550fba849876647cee8c78ffa7db", "message": "Decide cacheable when scheduling unbucketed splits", "committedDate": "2020-02-27T19:19:04Z", "type": "commit"}, {"oid": "a3d1710aab857bb4db4b2b44de227e93abc010fd", "url": "https://github.com/prestodb/presto/commit/a3d1710aab857bb4db4b2b44de227e93abc010fd", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-27T19:19:05Z", "type": "forcePushed"}, {"oid": "cca8a6660848cc15e013bee8ce8af92d428c4cc9", "url": "https://github.com/prestodb/presto/commit/cca8a6660848cc15e013bee8ce8af92d428c4cc9", "message": "Fix generated nodeList when using DynamicBucketNodeMap\n\nInstead of using random nodes for DynamicBucketNodeMap,\nwhen DynamicBucketNodeMap provides node lists, we directly use it", "committedDate": "2020-02-27T19:39:19Z", "type": "commit"}, {"oid": "2dbf3cd5472c49703fac972d73c936e609d4941f", "url": "https://github.com/prestodb/presto/commit/2dbf3cd5472c49703fac972d73c936e609d4941f", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-27T19:39:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMjI5Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385412297", "bodyText": "bucketToNodeInfo.isEmpty()", "author": "highker", "createdAt": "2020-02-27T22:37:46Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -63,16 +80,31 @@ public int getBucketCount()\n     }\n \n     @Override\n-    public void assignOrUpdateBucketToNode(int bucketedId, InternalNode node)\n+    public void assignOrUpdateBucketToNode(int bucketedId, InternalNode node, boolean cacheable)\n     {\n         checkArgument(bucketedId >= 0 && bucketedId < bucketCount);\n         requireNonNull(node, \"node is null\");\n-        bucketToNode.put(bucketedId, node);\n+        bucketToNodeInfo.put(bucketedId, new InternalNodeInfo(node, cacheable));\n     }\n \n     @Override\n     public boolean isDynamic()\n     {\n         return true;\n     }\n+\n+    @Override\n+    public boolean hasInitialMap()\n+    {\n+        return hasInitialMap;\n+    }\n+\n+    @Override\n+    public Optional<List<InternalNode>> getBucketToNode()\n+    {\n+        if (bucketToNodeInfo.size() == 0) {", "originalCommit": "2dbf3cd5472c49703fac972d73c936e609d4941f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c58c9c12f7a5fc4fdaafb2c01b0432162a20af5f", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex 28018c89da..894b378949 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -102,7 +102,7 @@ public class DynamicBucketNodeMap\n     @Override\n     public Optional<List<InternalNode>> getBucketToNode()\n     {\n-        if (bucketToNodeInfo.size() == 0) {\n+        if (bucketToNodeInfo.isEmpty()) {\n             return Optional.empty();\n         }\n         return Optional.of(bucketToNodeInfo.values().stream().map(InternalNodeInfo::getInternalNode).collect(Collectors.toList()));\n"}}, {"oid": "c58c9c12f7a5fc4fdaafb2c01b0432162a20af5f", "url": "https://github.com/prestodb/presto/commit/c58c9c12f7a5fc4fdaafb2c01b0432162a20af5f", "message": "Introduce cacheable for bucketed splits", "committedDate": "2020-02-28T00:13:09Z", "type": "commit"}, {"oid": "684bf8de98df7b9023a8bdf597c6c85df0370f2f", "url": "https://github.com/prestodb/presto/commit/684bf8de98df7b9023a8bdf597c6c85df0370f2f", "message": "Fix SimpleNodeSelector node selection for HARD AFFINITY", "committedDate": "2020-02-28T00:13:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2MzM1MA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385463350", "bodyText": "fix this and all other places", "author": "highker", "createdAt": "2020-02-28T01:25:53Z", "path": "presto-raptor/src/main/java/com/facebook/presto/raptor/RaptorPageSourceProvider.java", "diffHunk": "@@ -53,7 +54,12 @@ public RaptorPageSourceProvider(StorageManager storageManager)\n     }\n \n     @Override\n-    public ConnectorPageSource createPageSource(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorSplit split, List<ColumnHandle> columns)\n+    public ConnectorPageSource createPageSource(\n+            ConnectorTransactionHandle transactionHandle,\n+            ConnectorSession session,\n+            ConnectorSplit split,\n+            List<ColumnHandle> columns,\n+            SplitContext splitContext)\n     {\n         RaptorSplit raptorSplit = (RaptorSplit) split;\n         HiveFileContext hiveFileContext = DEFAULT_HIVE_FILE_CONTEXT; // TODO: adjust cacheable accordingly", "originalCommit": "684bf8de98df7b9023a8bdf597c6c85df0370f2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29355ca9fa92db264c5ea808be454ea030d8bca0", "chunk": "diff --git a/presto-raptor/src/main/java/com/facebook/presto/raptor/RaptorPageSourceProvider.java b/presto-raptor/src/main/java/com/facebook/presto/raptor/RaptorPageSourceProvider.java\nindex 71c92fd4d5..82711ab0d4 100644\n--- a/presto-raptor/src/main/java/com/facebook/presto/raptor/RaptorPageSourceProvider.java\n+++ b/presto-raptor/src/main/java/com/facebook/presto/raptor/RaptorPageSourceProvider.java\n\n@@ -62,7 +61,7 @@ public class RaptorPageSourceProvider\n             SplitContext splitContext)\n     {\n         RaptorSplit raptorSplit = (RaptorSplit) split;\n-        HiveFileContext hiveFileContext = DEFAULT_HIVE_FILE_CONTEXT; // TODO: adjust cacheable accordingly\n+        HiveFileContext hiveFileContext = new HiveFileContext(splitContext.isCacheable(), Optional.empty());\n         OptionalInt bucketNumber = raptorSplit.getBucketNumber();\n         TupleDomain<RaptorColumnHandle> predicate = raptorSplit.getEffectivePredicate();\n         ReaderAttributes attributes = ReaderAttributes.from(session);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3MDUxNQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385470515", "bodyText": "remove commemt", "author": "highker", "createdAt": "2020-02-28T01:53:50Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java", "diffHunk": "@@ -233,7 +251,7 @@ public ConnectorPageSource createPageSource(ConnectorTransactionHandle transacti\n                     layout.getDomainPredicate(),\n                     optimizedRemainingPredicate,\n                     hiveStorageTimeZone,\n-                    new HiveFileContext(true, split.getExtraFileInfo().map(BinaryExtraHiveFileInfo::new)));  // TODO: adjust cacheable accordingly\n+                    new HiveFileContext(splitContext.isCacheable(), split.getExtraFileInfo().map(BinaryExtraHiveFileInfo::new)));  // TODO: adjust cacheable accordingly", "originalCommit": "d71c78c8a817c3ac2ca51c44c235bfc3aca622f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29355ca9fa92db264c5ea808be454ea030d8bca0", "chunk": "diff --git a/presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java b/presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java\nindex 6686b8f8fc..c226b49dc5 100644\n--- a/presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java\n+++ b/presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java\n\n@@ -251,7 +251,7 @@ public class HivePageSourceProvider\n                     layout.getDomainPredicate(),\n                     optimizedRemainingPredicate,\n                     hiveStorageTimeZone,\n-                    new HiveFileContext(splitContext.isCacheable(), split.getExtraFileInfo().map(BinaryExtraHiveFileInfo::new)));  // TODO: adjust cacheable accordingly\n+                    new HiveFileContext(splitContext.isCacheable(), split.getExtraFileInfo().map(BinaryExtraHiveFileInfo::new)));\n             if (pageSource.isPresent()) {\n                 return Optional.of(pageSource.get());\n             }\n"}}, {"oid": "29355ca9fa92db264c5ea808be454ea030d8bca0", "url": "https://github.com/prestodb/presto/commit/29355ca9fa92db264c5ea808be454ea030d8bca0", "message": "Assign HiveFileContext values from splitContext", "committedDate": "2020-02-28T02:45:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NDUxMQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385494511", "bodyText": "this won't pass style check", "author": "highker", "createdAt": "2020-02-28T03:44:38Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "diffHunk": "@@ -353,6 +354,32 @@ public void testAffinityAssignment()\n         assertEquals(splitPlacementResult.getAssignments().keySet().size(), 3);\n     }\n \n+    @Test\n+    public void testHardAffinityAssignment()\n+    {\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        TestingTransactionHandle transactionHandle = TestingTransactionHandle.create();\n+        NodeSchedulerConfig nodeSchedulerConfig = new NodeSchedulerConfig()\n+                .setMaxSplitsPerNode(20)\n+                .setIncludeCoordinator(false)\n+                .setMaxPendingSplitsPerTask(10);\n+\n+        NodeScheduler nodeScheduler = new NodeScheduler(new LegacyNetworkTopology(), nodeManager, nodeSchedulerConfig, nodeTaskMap);\n+        NodeSelector nodeSelector = nodeScheduler.createNodeSelector(CONNECTOR_ID, 3);\n+\n+        Set<Split> splits = new HashSet<>();\n+\n+        // Adding one more split (1 % 3 = 1), 1 splits will be distributed to 1 nodes\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        SplitPlacementResult splitPlacementResult = nodeSelector.computeAssignments(splits, ImmutableList.of());\n+        for (Split split : splitPlacementResult.getAssignments().values())\n+        {", "originalCommit": "29355ca9fa92db264c5ea808be454ea030d8bca0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "acf58c293c169d6dc787feae17d7477b38b6fd9e", "chunk": "diff --git a/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java b/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\nindex 8baa833f04..effe091e20 100644\n--- a/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\n+++ b/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\n\n@@ -374,9 +374,8 @@ public class TestNodeScheduler\n         splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n         splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n         SplitPlacementResult splitPlacementResult = nodeSelector.computeAssignments(splits, ImmutableList.of());\n-        for (Split split : splitPlacementResult.getAssignments().values())\n-        {\n-            assertEquals(split.getSplitContext().isCacheable(), true);\n+        for (Split split : splitPlacementResult.getAssignments().values()) {\n+            assertTrue(split.getSplitContext().isCacheable());\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NDU1MA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385494550", "bodyText": "assertTrue", "author": "highker", "createdAt": "2020-02-28T03:44:55Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "diffHunk": "@@ -353,6 +354,32 @@ public void testAffinityAssignment()\n         assertEquals(splitPlacementResult.getAssignments().keySet().size(), 3);\n     }\n \n+    @Test\n+    public void testHardAffinityAssignment()\n+    {\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        TestingTransactionHandle transactionHandle = TestingTransactionHandle.create();\n+        NodeSchedulerConfig nodeSchedulerConfig = new NodeSchedulerConfig()\n+                .setMaxSplitsPerNode(20)\n+                .setIncludeCoordinator(false)\n+                .setMaxPendingSplitsPerTask(10);\n+\n+        NodeScheduler nodeScheduler = new NodeScheduler(new LegacyNetworkTopology(), nodeManager, nodeSchedulerConfig, nodeTaskMap);\n+        NodeSelector nodeSelector = nodeScheduler.createNodeSelector(CONNECTOR_ID, 3);\n+\n+        Set<Split> splits = new HashSet<>();\n+\n+        // Adding one more split (1 % 3 = 1), 1 splits will be distributed to 1 nodes\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n+        SplitPlacementResult splitPlacementResult = nodeSelector.computeAssignments(splits, ImmutableList.of());\n+        for (Split split : splitPlacementResult.getAssignments().values())\n+        {\n+            assertEquals(split.getSplitContext().isCacheable(), true);", "originalCommit": "29355ca9fa92db264c5ea808be454ea030d8bca0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "acf58c293c169d6dc787feae17d7477b38b6fd9e", "chunk": "diff --git a/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java b/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\nindex 8baa833f04..effe091e20 100644\n--- a/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\n+++ b/presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java\n\n@@ -374,9 +374,8 @@ public class TestNodeScheduler\n         splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n         splits.add(new Split(CONNECTOR_ID, transactionHandle, new TestHardAffinitySplitRemote()));\n         SplitPlacementResult splitPlacementResult = nodeSelector.computeAssignments(splits, ImmutableList.of());\n-        for (Split split : splitPlacementResult.getAssignments().values())\n-        {\n-            assertEquals(split.getSplitContext().isCacheable(), true);\n+        for (Split split : splitPlacementResult.getAssignments().values()) {\n+            assertTrue(split.getSplitContext().isCacheable());\n         }\n     }\n \n"}}, {"oid": "acf58c293c169d6dc787feae17d7477b38b6fd9e", "url": "https://github.com/prestodb/presto/commit/acf58c293c169d6dc787feae17d7477b38b6fd9e", "message": "Fix SimpleNodeSelector node selection for HARD AFFINITY", "committedDate": "2020-02-28T17:48:14Z", "type": "commit"}, {"oid": "80ebf0eef85d69fa34a23d9cd039eae528ba100e", "url": "https://github.com/prestodb/presto/commit/80ebf0eef85d69fa34a23d9cd039eae528ba100e", "message": "Assign HiveFileContext values from splitContext", "committedDate": "2020-02-28T17:48:14Z", "type": "commit"}, {"oid": "80ebf0eef85d69fa34a23d9cd039eae528ba100e", "url": "https://github.com/prestodb/presto/commit/80ebf0eef85d69fa34a23d9cd039eae528ba100e", "message": "Assign HiveFileContext values from splitContext", "committedDate": "2020-02-28T17:48:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDk5NQ==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385850995", "bodyText": "I somehow feel this cacheable is not needed because everything in fixed map should be cacheable?", "author": "shixuan-fan", "createdAt": "2020-02-28T18:24:33Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/FixedBucketNodeMap.java", "diffHunk": "@@ -15,40 +15,50 @@\n \n import com.facebook.presto.metadata.InternalNode;\n import com.facebook.presto.metadata.Split;\n-import com.google.common.collect.ImmutableList;\n \n import java.util.List;\n import java.util.Optional;\n import java.util.function.ToIntFunction;\n \n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n // the bucket to node mapping is fixed and pre-assigned\n public class FixedBucketNodeMap\n         extends BucketNodeMap\n {\n-    private final List<InternalNode> bucketToNode;\n+    private final List<InternalNodeInfo> bucketToNodeInfo;\n \n-    public FixedBucketNodeMap(ToIntFunction<Split> splitToBucket, List<InternalNode> bucketToNode)\n+    public FixedBucketNodeMap(ToIntFunction<Split> splitToBucket, List<InternalNode> bucketToNode, boolean cacheable)", "originalCommit": "80ebf0eef85d69fa34a23d9cd039eae528ba100e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MDI5Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385870297", "bodyText": "for a FixedBucketNodeMap, there are situations of HARD_AFFINITY and NO_PREFERENCE, they both use FixedBucketNodeMap, but cacheable for NO_PREFERENCE is false, cacheable for HARD_AFFINITY is true", "author": "kewang1024", "createdAt": "2020-02-28T19:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MTM0Nw==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385871347", "bodyText": "Aha! Thanks for explaining. So I guess in FixedBucketNodeMap it might be reasonable to make cacheable a bucket node map level property then, since there won't be update in the mapping.", "author": "shixuan-fan", "createdAt": "2020-02-28T19:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4MDIyNA==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385880224", "bodyText": "But as you suggested, storing the cacheable info in InternalNodeInfo would be a more general way, since DynamicBucketNodeMap could have a mixed List of InternalNodeInfo, we still need to iterate through the list", "author": "kewang1024", "createdAt": "2020-02-28T19:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MDk5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MjM5Ng==", "url": "https://github.com/prestodb/presto/pull/14108#discussion_r385852396", "bodyText": "ditto, I'm not sure if this cacheable is useful. Bucket is initialized to preferred node, so they should be cacheable?", "author": "shixuan-fan", "createdAt": "2020-02-28T18:27:32Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -30,30 +32,45 @@\n         extends BucketNodeMap\n {\n     private final int bucketCount;\n-    private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n+    private final Int2ObjectMap<InternalNodeInfo> bucketToNodeInfo = new Int2ObjectOpenHashMap<>();\n+    private final boolean hasInitialMap;\n \n     public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         this.bucketCount = bucketCount;\n+        hasInitialMap = false;\n     }\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode, boolean cacheable)", "originalCommit": "80ebf0eef85d69fa34a23d9cd039eae528ba100e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}