{"pr_number": 14906, "pr_title": "Add a fast path using totalSize to plan join swapping", "pr_createdAt": "2020-07-28T15:02:14Z", "pr_url": "https://github.com/prestodb/presto/pull/14906", "timeline": [{"oid": "44a1258fb7653ac211a97130e2642d4fa6526059", "url": "https://github.com/prestodb/presto/commit/44a1258fb7653ac211a97130e2642d4fa6526059", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T15:02:30Z", "type": "forcePushed"}, {"oid": "4aa4bb1e21284f4d0cc814795bc7a88b52abe50d", "url": "https://github.com/prestodb/presto/commit/4aa4bb1e21284f4d0cc814795bc7a88b52abe50d", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T16:10:30Z", "type": "forcePushed"}, {"oid": "028e1479681ac19acded752d6616845ea72fb94c", "url": "https://github.com/prestodb/presto/commit/028e1479681ac19acded752d6616845ea72fb94c", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T19:58:39Z", "type": "forcePushed"}, {"oid": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "url": "https://github.com/prestodb/presto/commit/dc5b8128a7ef8f39512216ec45bc50f466e5881d", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T20:08:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzk2OQ==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462573969", "bodyText": "I would create a method isUnmodifiedTableScan(PlanNode node) (or some other name that makes sense) that traverses the tree with a visitor and returns true if the only nodes it encounters are exchange and TableScan node (and maybe project node that doesn't reduce the number of columns).  then change the condition to\nif(isUnmodifiedScan(left) && isUnmodifiedScan(right))\n{\nleftScan = getLeftScan(left)\nrightScan = getRightScan (right)\n}\nthat way we keep our conditions to what we need and don't rely on the plan looking a particular way (e.g. what if there was an extra local exchange or something).", "author": "rschlussel", "createdAt": "2020-07-29T20:38:40Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java", "diffHunk": "@@ -66,9 +76,35 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n             return Result.empty();\n         }\n \n-        StatsProvider statsProvider = context.getStatsProvider();\n-        double leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n-        double rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n+        double leftOutputSizeInBytes = Double.NaN;\n+        double rightOutputSizeInBytes = Double.NaN;\n+        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n+        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n+        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1", "originalCommit": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNjcwMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462606700", "bodyText": "I guess how to refactor this part depends on our decision of the other comment.", "author": "pguofb", "createdAt": "2020-07-29T21:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "baa51984a88f88096663cefdae3e9b4d6c8f311b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\nindex 72a7d5dcd5..b0fbd81cd7 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\n\n@@ -78,29 +68,19 @@ public class RuntimeReorderJoinSides\n \n         double leftOutputSizeInBytes = Double.NaN;\n         double rightOutputSizeInBytes = Double.NaN;\n-        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n-        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n-        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1\n-                && context.getLookup().resolve(actualRight.getSources().get(0)) instanceof TableScanNode) {\n-            // Simple plan is characterized as Join[leftSrc: TableScan, rightSrc: Exchange[src: TableScan]].\n+        StatsProvider statsProvider = context.getStatsProvider();\n+        if (searchFrom(joinNode, context.getLookup())\n+                .where(node -> !(node instanceof TableScanNode) && !(node instanceof ExchangeNode))\n+                .findAll().size() == 1) {\n+            // Simple plan is characterized as Join directly on tableScanNodes only with exchangeNode in between.\n             // For simple plans, directly fetch the overall table sizes as the size of the join sides to have\n             // accurate input bytes statistics and meanwhile avoid non-negligible cost of collecting and processing\n             // per-column statistics.\n-            TableScanNode leftScan = (TableScanNode) actualLeft;\n-            TableScanNode rightScan = (TableScanNode) context.getLookup().resolve(actualRight.getSources().get(0));\n-            leftOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n-                    leftScan.getTable(),\n-                    ImmutableList.copyOf(leftScan.getAssignments().values()),\n-                    new Constraint<>(leftScan.getCurrentConstraint())).getTotalSize().getValue();\n-            rightOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n-                    rightScan.getTable(),\n-                    ImmutableList.copyOf(rightScan.getAssignments().values()),\n-                    new Constraint<>(rightScan.getCurrentConstraint())).getTotalSize().getValue();\n+            leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes();\n+            rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes();\n         }\n-\n-        // Fall back using statsProvider to estimate left and right output size.\n         if (Double.isNaN(leftOutputSizeInBytes) || Double.isNaN(rightOutputSizeInBytes)) {\n-            StatsProvider statsProvider = context.getStatsProvider();\n+            // Per-column estimate left and right output size for complex plans or when size statistics is unavailable.\n             leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n             rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462576207", "bodyText": "what if instead of having these two separate paths, we just use the regular stats calculator path, but added an Optional totalSize (or NaN for absent cases) to PlanNodeStatsEstimate.  then if we call getOutputsizeInBytes()with all of the input variables, then we return that number, and otherwise we calculate as usual per-column. We'd have to handle it correctly in the stats calculators to populate it correctly.  But it would also allow non-materialized queries to benefit from this change.\n@arhimondr what do you think?", "author": "rschlussel", "createdAt": "2020-07-29T20:42:51Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java", "diffHunk": "@@ -66,9 +76,35 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n             return Result.empty();\n         }\n \n-        StatsProvider statsProvider = context.getStatsProvider();\n-        double leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n-        double rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n+        double leftOutputSizeInBytes = Double.NaN;\n+        double rightOutputSizeInBytes = Double.NaN;\n+        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n+        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n+        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1\n+                && context.getLookup().resolve(actualRight.getSources().get(0)) instanceof TableScanNode) {\n+            // Simple plan is characterized as Join[leftSrc: TableScan, rightSrc: Exchange[src: TableScan]].\n+            // For simple plans, directly fetch the overall table sizes as the size of the join sides to have\n+            // accurate input bytes statistics and meanwhile avoid non-negligible cost of collecting and processing\n+            // per-column statistics.\n+            TableScanNode leftScan = (TableScanNode) actualLeft;\n+            TableScanNode rightScan = (TableScanNode) context.getLookup().resolve(actualRight.getSources().get(0));\n+            leftOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n+                    leftScan.getTable(),\n+                    ImmutableList.copyOf(leftScan.getAssignments().values()),\n+                    new Constraint<>(leftScan.getCurrentConstraint())).getTotalSize().getValue();\n+            rightOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n+                    rightScan.getTable(),\n+                    ImmutableList.copyOf(rightScan.getAssignments().values()),\n+                    new Constraint<>(rightScan.getCurrentConstraint())).getTotalSize().getValue();\n+        }\n+\n+        // Fall back using statsProvider to estimate left and right output size.\n+        if (Double.isNaN(leftOutputSizeInBytes) || Double.isNaN(rightOutputSizeInBytes)) {", "originalCommit": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNTc5MA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462605790", "bodyText": "Yeah, adding totalSize field also in PlanNodeStatsEstimate will merge the current \"fast-path\" into the regular statsCalculator path.\nMy only concern is whether it worth adding the field. The downside is only a small portion will have actual values because operations like Aggregate, Join, Project, ... will easily make it NaN. Meanwhile, the advantage seems quite narrow, because for non-materialized queries it will only be effective for directly joining two actual tables. This seems a bit too-good-to-be-true because the optimizer tends to pushdown whatever filter/projection/otherOps possible below the join right?", "author": "pguofb", "createdAt": "2020-07-29T21:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MDY2Mw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465350663", "bodyText": "It also feels to me that it should be the responsibility of the getOutputSizeInBytes method to return the size based on the column size information if the totalSize is not set. That will effectively merge these two paths and make the code a bit cleaner.\nI'm a little confused why do we think this approach is not preferred? Could you please elaborate a little bit more on that?", "author": "arhimondr", "createdAt": "2020-08-04T21:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1NzMwOA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465357308", "bodyText": "@arhimondr it's not possible (or at least easy) to compute stats based on columns if you don't have a list of columns because you won't know how many columns don't have stats that you need to account for.  In order to handle this, we'd need to change the StatsNormalizer not to remove unknown stats from the list of variable statistics. This is what i was asking about before.", "author": "rschlussel", "createdAt": "2020-08-04T22:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "baa51984a88f88096663cefdae3e9b4d6c8f311b", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\nindex 72a7d5dcd5..b0fbd81cd7 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java\n\n@@ -78,29 +68,19 @@ public class RuntimeReorderJoinSides\n \n         double leftOutputSizeInBytes = Double.NaN;\n         double rightOutputSizeInBytes = Double.NaN;\n-        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n-        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n-        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1\n-                && context.getLookup().resolve(actualRight.getSources().get(0)) instanceof TableScanNode) {\n-            // Simple plan is characterized as Join[leftSrc: TableScan, rightSrc: Exchange[src: TableScan]].\n+        StatsProvider statsProvider = context.getStatsProvider();\n+        if (searchFrom(joinNode, context.getLookup())\n+                .where(node -> !(node instanceof TableScanNode) && !(node instanceof ExchangeNode))\n+                .findAll().size() == 1) {\n+            // Simple plan is characterized as Join directly on tableScanNodes only with exchangeNode in between.\n             // For simple plans, directly fetch the overall table sizes as the size of the join sides to have\n             // accurate input bytes statistics and meanwhile avoid non-negligible cost of collecting and processing\n             // per-column statistics.\n-            TableScanNode leftScan = (TableScanNode) actualLeft;\n-            TableScanNode rightScan = (TableScanNode) context.getLookup().resolve(actualRight.getSources().get(0));\n-            leftOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n-                    leftScan.getTable(),\n-                    ImmutableList.copyOf(leftScan.getAssignments().values()),\n-                    new Constraint<>(leftScan.getCurrentConstraint())).getTotalSize().getValue();\n-            rightOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n-                    rightScan.getTable(),\n-                    ImmutableList.copyOf(rightScan.getAssignments().values()),\n-                    new Constraint<>(rightScan.getCurrentConstraint())).getTotalSize().getValue();\n+            leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes();\n+            rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes();\n         }\n-\n-        // Fall back using statsProvider to estimate left and right output size.\n         if (Double.isNaN(leftOutputSizeInBytes) || Double.isNaN(rightOutputSizeInBytes)) {\n-            StatsProvider statsProvider = context.getStatsProvider();\n+            // Per-column estimate left and right output size for complex plans or when size statistics is unavailable.\n             leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n             rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n         }\n"}}, {"oid": "baa51984a88f88096663cefdae3e9b4d6c8f311b", "url": "https://github.com/prestodb/presto/commit/baa51984a88f88096663cefdae3e9b4d6c8f311b", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-07-31T18:11:37Z", "type": "forcePushed"}, {"oid": "7e2d6eff89e9a748b76196096262bd3738a5c49e", "url": "https://github.com/prestodb/presto/commit/7e2d6eff89e9a748b76196096262bd3738a5c49e", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-07-31T19:35:42Z", "type": "forcePushed"}, {"oid": "2e0d27f5a897105fd13eebbdefe481261b537ff6", "url": "https://github.com/prestodb/presto/commit/2e0d27f5a897105fd13eebbdefe481261b537ff6", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-03T14:14:21Z", "type": "forcePushed"}, {"oid": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "url": "https://github.com/prestodb/presto/commit/6e6e09222c9d3dcbf8503743fc3f97858ccff883", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-03T18:33:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r464577848", "bodyText": "buildFrom() should also set the total size", "author": "rschlussel", "createdAt": "2020-08-03T18:06:25Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java", "diffHunk": "@@ -170,38 +189,42 @@ public boolean equals(Object o)\n         }\n         PlanNodeStatsEstimate that = (PlanNodeStatsEstimate) o;\n         return Double.compare(outputRowCount, that.outputRowCount) == 0 &&\n+                Double.compare(totalSize, that.totalSize) == 0 &&\n                 Objects.equals(variableStatistics, that.variableStatistics);\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        return Objects.hash(outputRowCount, variableStatistics);\n+        return Objects.hash(outputRowCount, totalSize, variableStatistics);\n     }\n \n     public static Builder builder()\n     {\n         return new Builder();\n     }\n \n+    // Do not inherit totalSize statistics by default. Only explicitly set\n     public static Builder buildFrom(PlanNodeStatsEstimate other)\n     {\n-        return new Builder(other.getOutputRowCount(), other.variableStatistics);\n+        return new Builder(other.getOutputRowCount(), NaN, other.variableStatistics);", "originalCommit": "2e0d27f5a897105fd13eebbdefe481261b537ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTMzOA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465149338", "bodyText": "I'm a bit against propagating the totalSize by default for the current scope of this PR, because people have to explicitly set it to NaN or otherwise a not NaN but possibly wrong totalSize value is carried. Given that we are only using this field for \"leaf\" simple join plans for now, it is safer to set it NaN by default to so that if people \"accidentally\" fetch the totalSize at other places they can tell that it is not usable via isNaN().\nIdeally, when we have implemented how to handle the totalSize field for all types of operator rules, we could set propagate as default to simply the relevant operations in those rules that won't change this field.\nWhat do you think?", "author": "pguofb", "createdAt": "2020-08-04T15:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDA0MA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465154040", "bodyText": "that makes sense to me", "author": "rschlussel", "createdAt": "2020-08-04T15:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjgyMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465342820", "bodyText": "Could you please include this explanation in the comment?", "author": "arhimondr", "createdAt": "2020-08-04T21:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java b/presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java\nindex 60a818b4d9..d333007c2c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java\n+++ b/presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java\n\n@@ -204,7 +204,10 @@ public class PlanNodeStatsEstimate\n         return new Builder();\n     }\n \n-    // Do not inherit totalSize statistics by default. Only explicitly set\n+    // Do not propagate the totalSize by default, because otherwise people have to explicitly set it to NaN or a not NaN but possibly wrong totalSize value is carried.\n+    // Given that we are only using this field for \"leaf\" simple join plans for now, it is safer to set it NaN by default so that if \"accidentally\" fetch the totalSize\n+    // at other places we can tell that it is not usable via isNaN(). Ideally, when we have implemented how to handle the totalSize field for all types of operator rules,\n+    // we should propagate totalSize as default to simplify the relevant operations in rules that do not change this field.\n     public static Builder buildFrom(PlanNodeStatsEstimate other)\n     {\n         return new Builder(other.getOutputRowCount(), NaN, other.variableStatistics);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzMjg2Mw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465332863", "bodyText": "count -> size", "author": "arhimondr", "createdAt": "2020-08-04T21:11:29Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java", "diffHunk": "@@ -432,6 +442,18 @@ static OptionalDouble calculateAverageRowsPerPartition(Collection<PartitionStati\n                 .average();\n     }\n \n+    @VisibleForTesting\n+    static OptionalDouble calculateAverageSizePerPartition(Collection<PartitionStatistics> statistics)\n+    {\n+        return statistics.stream()\n+                .map(PartitionStatistics::getBasicStatistics)\n+                .map(HiveBasicStatistics::getInMemoryDataSizeInBytes)\n+                .filter(OptionalLong::isPresent)\n+                .mapToLong(OptionalLong::getAsLong)\n+                .peek(count -> verify(count >= 0, \"count must be greater than or equal to zero\"))", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "chunk": "diff --git a/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java b/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\nindex 4c2c1f4b14..83746c04c3 100644\n--- a/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\n+++ b/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\n\n@@ -450,7 +450,7 @@ public class MetastoreHiveStatisticsProvider\n                 .map(HiveBasicStatistics::getInMemoryDataSizeInBytes)\n                 .filter(OptionalLong::isPresent)\n                 .mapToLong(OptionalLong::getAsLong)\n-                .peek(count -> verify(count >= 0, \"count must be greater than or equal to zero\"))\n+                .peek(size -> verify(size >= 0, \"size must be greater than or equal to zero\"))\n                 .average();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzMzExMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465333110", "bodyText": "nit: include the actual value into the error message in case it ever fails\ne.g.: verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero: %s\", averageSizePerPartition)", "author": "arhimondr", "createdAt": "2020-08-04T21:12:01Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java", "diffHunk": "@@ -404,6 +405,15 @@ private static TableStatistics getTableStatistics(\n \n         TableStatistics.Builder result = TableStatistics.builder();\n         result.setRowCount(Estimate.of(rowCount));\n+\n+        OptionalDouble optionalAverageSizePerPartition = calculateAverageSizePerPartition(statistics.values());\n+        if (optionalAverageSizePerPartition.isPresent()) {\n+            double averageSizePerPartition = optionalAverageSizePerPartition.getAsDouble();\n+            verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero\");", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "chunk": "diff --git a/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java b/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\nindex 4c2c1f4b14..83746c04c3 100644\n--- a/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\n+++ b/presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java\n\n@@ -409,7 +409,7 @@ public class MetastoreHiveStatisticsProvider\n         OptionalDouble optionalAverageSizePerPartition = calculateAverageSizePerPartition(statistics.values());\n         if (optionalAverageSizePerPartition.isPresent()) {\n             double averageSizePerPartition = optionalAverageSizePerPartition.getAsDouble();\n-            verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero\");\n+            verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero: %s\", averageSizePerPartition);\n             double totalSize = averageSizePerPartition * queriedPartitionsCount;\n             result.setTotalSize(Estimate.of(totalSize));\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465342186", "bodyText": "What if totalSize is not set? Should we try to compute it based on the column statistics?", "author": "arhimondr", "createdAt": "2020-08-04T21:31:45Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java", "diffHunk": "@@ -74,6 +77,21 @@ public double getOutputRowCount()\n         return outputRowCount;\n     }\n \n+    @JsonProperty\n+    public double getTotalSize()\n+    {\n+        return totalSize;\n+    }\n+\n+    /**\n+     * Only use when getting all columns and meanwhile do not want to\n+     * do per-column estimation.\n+     */\n+    public double getOutputSizeInBytes()", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2Mjg1MQ==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465362851", "bodyText": "It is tricky to compute based on current column statistics because suppose now there are three columns A,B,C and only column A has known statistics, we are only able to estimate the size of column A, because statsNormalizer has removed B and C from the PlanNodeStatsEstimate where nothing can be estimated.", "author": "pguofb", "createdAt": "2020-08-04T22:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzODQ4NA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465438484", "bodyText": "I see. Now I undestand the problem.", "author": "arhimondr", "createdAt": "2020-08-05T02:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDQyNA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465344424", "bodyText": "nit: it can be safely simplified to totalSize += sourceStats.getOutputSizeInBytes() (anything + NaN is NaN)", "author": "arhimondr", "createdAt": "2020-08-04T21:36:50Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java", "diffHunk": "@@ -49,9 +52,11 @@ public ExchangeStatsRule(StatsNormalizer normalizer)\n     protected Optional<PlanNodeStatsEstimate> doCalculate(ExchangeNode node, StatsProvider statsProvider, Lookup lookup, Session session, TypeProvider types)\n     {\n         Optional<PlanNodeStatsEstimate> estimate = Optional.empty();\n+        double totalSize = 0;\n         for (int i = 0; i < node.getSources().size(); i++) {\n             PlanNode source = node.getSources().get(i);\n             PlanNodeStatsEstimate sourceStats = statsProvider.getStats(source);\n+            totalSize = (!isNaN(sourceStats.getOutputSizeInBytes()) && !isNaN(totalSize)) ? totalSize + sourceStats.getOutputSizeInBytes() : NaN;", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java b/presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java\nindex 40ea9d9519..9f9e45b5d7 100644\n--- a/presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java\n+++ b/presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java\n\n@@ -56,7 +56,7 @@ public class ExchangeStatsRule\n         for (int i = 0; i < node.getSources().size(); i++) {\n             PlanNode source = node.getSources().get(i);\n             PlanNodeStatsEstimate sourceStats = statsProvider.getStats(source);\n-            totalSize = (!isNaN(sourceStats.getOutputSizeInBytes()) && !isNaN(totalSize)) ? totalSize + sourceStats.getOutputSizeInBytes() : NaN;\n+            totalSize += sourceStats.getOutputSizeInBytes();\n \n             PlanNodeStatsEstimate sourceStatsWithMappedSymbols = mapToOutputVariables(sourceStats, node.getInputs().get(i), node.getOutputVariables());\n \n"}}, {"oid": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "url": "https://github.com/prestodb/presto/commit/a2f7e21a372e6210f78fe54130f45b023ae7d156", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-04T22:34:11Z", "type": "forcePushed"}, {"oid": "9c1706fa0102a1a1bff774ff8375395827554c78", "url": "https://github.com/prestodb/presto/commit/9c1706fa0102a1a1bff774ff8375395827554c78", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-04T22:53:37Z", "type": "forcePushed"}, {"oid": "f32cd86461aba17dffa6cedc406a1dbae3712bf7", "url": "https://github.com/prestodb/presto/commit/f32cd86461aba17dffa6cedc406a1dbae3712bf7", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.", "committedDate": "2020-08-05T13:38:23Z", "type": "commit"}, {"oid": "f32cd86461aba17dffa6cedc406a1dbae3712bf7", "url": "https://github.com/prestodb/presto/commit/f32cd86461aba17dffa6cedc406a1dbae3712bf7", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.", "committedDate": "2020-08-05T13:38:23Z", "type": "forcePushed"}]}