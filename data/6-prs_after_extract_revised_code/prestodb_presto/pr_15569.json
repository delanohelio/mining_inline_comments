{"pr_number": 15569, "pr_title": "Fix memory revoking accounting", "pr_createdAt": "2020-12-29T15:27:49Z", "pr_url": "https://github.com/prestodb/presto/pull/15569", "timeline": [{"oid": "63ef64ca352ef0f20f7748c3793889d33f368665", "url": "https://github.com/prestodb/presto/commit/63ef64ca352ef0f20f7748c3793889d33f368665", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2020-12-29T16:00:58Z", "type": "forcePushed"}, {"oid": "9d26bdf8e9098174a5f66756a70d1ff6dbadcac4", "url": "https://github.com/prestodb/presto/commit/9d26bdf8e9098174a5f66756a70d1ff6dbadcac4", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2020-12-29T17:10:03Z", "type": "forcePushed"}, {"oid": "e1112aeee6826fe08acac1f09b5035b582e51c86", "url": "https://github.com/prestodb/presto/commit/e1112aeee6826fe08acac1f09b5035b582e51c86", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-04T14:14:58Z", "type": "forcePushed"}, {"oid": "9c6c9606baf7176edffd053b2e8150b3f99fbe1b", "url": "https://github.com/prestodb/presto/commit/9c6c9606baf7176edffd053b2e8150b3f99fbe1b", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-04T19:40:07Z", "type": "forcePushed"}, {"oid": "2748e99e4576894afea6124ea72ca3d7e83a7e41", "url": "https://github.com/prestodb/presto/commit/2748e99e4576894afea6124ea72ca3d7e83a7e41", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-07T14:20:08Z", "type": "forcePushed"}, {"oid": "05da68e375d3e0ebfc4155cf11faa2f183aaf113", "url": "https://github.com/prestodb/presto/commit/05da68e375d3e0ebfc4155cf11faa2f183aaf113", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-08T14:47:01Z", "type": "forcePushed"}, {"oid": "a9e5298175ffed69f3630394a4786a5f0cca20fe", "url": "https://github.com/prestodb/presto/commit/a9e5298175ffed69f3630394a4786a5f0cca20fe", "message": "Add SqlTask#getTaskState() and SqlTask#getTaskCreateTime()\n\nAvoids using comparatively more expensive methods like getTaskStats()\nor getTaskStatus() when only these specific fields are required and\nno particular synchronization order is being enforced.", "committedDate": "2021-01-08T21:09:21Z", "type": "commit"}, {"oid": "2305f97e8f60ff083902546768185a67156e3c77", "url": "https://github.com/prestodb/presto/commit/2305f97e8f60ff083902546768185a67156e3c77", "message": "Use cheaper SqlTask#getTaskId() in TaskThresholdMemoryRevokingScheduler", "committedDate": "2021-01-08T21:09:37Z", "type": "commit"}, {"oid": "835ad33828f17ba3c0528ab0096d0939ca152cb0", "url": "https://github.com/prestodb/presto/commit/835ad33828f17ba3c0528ab0096d0939ca152cb0", "message": "Refactor MemoryRevokingScheduler to avoid redundant work\n\nAvoids repeatedly traversing the tasks collection to filter running\ntasks for the given memory pool and sorting them between summing the\nin progress revoking and initiating subsequent revoking actions on\noperators", "committedDate": "2021-01-08T21:11:46Z", "type": "commit"}, {"oid": "e06a278bcd9ebc352963d324ca70bafa704794fa", "url": "https://github.com/prestodb/presto/commit/e06a278bcd9ebc352963d324ca70bafa704794fa", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-08T21:12:00Z", "type": "forcePushed"}, {"oid": "3190e1306d3b8e2e5e32a516ca5b98ff52916e47", "url": "https://github.com/prestodb/presto/commit/3190e1306d3b8e2e5e32a516ca5b98ff52916e47", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-08T21:13:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2NTgxMw==", "url": "https://github.com/prestodb/presto/pull/15569#discussion_r555265813", "bodyText": "@pettyjamesm  can you add a simple test which tests specifically the change made by this PR? I.e. something that catches the original bug that would fail without this PR.", "author": "sachdevs", "createdAt": "2021-01-11T18:50:36Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestMemoryRevokingScheduler.java", "diffHunk": "@@ -553,31 +557,47 @@ private void assertMemoryRevokingNotRequested()\n         assertMemoryRevokingRequestedFor();\n     }\n \n-    private SqlTask newSqlTask()\n+    private SqlTask newSqlTask(QueryId queryId)\n     {\n-        TaskId taskId = new TaskId(\"query\", 0, 0, idGeneator.incrementAndGet());\n+        QueryContext queryContext = getOrCreateQueryContext(queryId);\n+\n+        TaskId taskId = new TaskId(queryId.getId(), 0, 0, idGeneator.incrementAndGet());\n         URI location = URI.create(\"fake://task/\" + taskId);\n \n         return createSqlTask(\n                 taskId,\n                 location,\n                 \"fake\",\n-                new QueryContext(new QueryId(\"query\"),\n-                        new DataSize(1, MEGABYTE),\n-                        new DataSize(2, MEGABYTE),\n-                        new DataSize(1, MEGABYTE),\n-                        new DataSize(1, GIGABYTE),\n-                        memoryPool,\n-                        new TestingGcMonitor(),\n-                        executor,\n-                        scheduledExecutor,\n-                        new DataSize(1, GIGABYTE),\n-                        spillSpaceTracker),\n+                queryContext,\n                 sqlTaskExecutionFactory,\n                 new MockExchangeClientSupplier(),\n                 executor,\n                 Functions.identity(),\n                 new DataSize(32, MEGABYTE),\n                 new CounterStat());\n     }\n+", "originalCommit": "3190e1306d3b8e2e5e32a516ca5b98ff52916e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NTY4Mw==", "url": "https://github.com/prestodb/presto/pull/15569#discussion_r555295683", "bodyText": "If the refactors to the test class are applied but the fixes in MemoryRevokingScheduler are not (ie: tasks created in tests are assigned to the same real QueryContext instance) then almost all tests will fail because of the over-counting tasks within the same query bug.", "author": "pettyjamesm", "createdAt": "2021-01-11T19:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2NTgxMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2NzYzNw==", "url": "https://github.com/prestodb/presto/pull/15569#discussion_r555267637", "bodyText": "nit: functional style instead\nreturn taskContext.filter(context -> context.getTaskMemoryContext().getRevocableMemory() >= maxRevocableMemoryPerTask).isPresent();", "author": "sachdevs", "createdAt": "2021-01-11T18:53:57Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -167,41 +168,38 @@ private void scheduleRevoking()\n \n     private boolean memoryRevokingNeeded(SqlTask task)\n     {\n-        return task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes() >= maxRevocableMemoryPerTask;\n+        Optional<TaskContext> taskContext = task.getTaskContext();\n+        if (taskContext.isPresent()) {", "originalCommit": "3190e1306d3b8e2e5e32a516ca5b98ff52916e47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NzQ5OA==", "url": "https://github.com/prestodb/presto/pull/15569#discussion_r555297498", "bodyText": "Changed", "author": "pettyjamesm", "createdAt": "2021-01-11T19:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2NzYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "089f92bc9545c56ea58b1c8167c3596304e6b35f", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java\nindex fee8f60dc4..b4896fab8c 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java\n\n@@ -168,11 +168,7 @@ public class TaskThresholdMemoryRevokingScheduler\n \n     private boolean memoryRevokingNeeded(SqlTask task)\n     {\n-        Optional<TaskContext> taskContext = task.getTaskContext();\n-        if (taskContext.isPresent()) {\n-            return taskContext.get().getTaskMemoryContext().getRevocableMemory() >= maxRevocableMemoryPerTask;\n-        }\n-        return false;\n+        return task.getTaskContext().filter(taskContext -> taskContext.getTaskMemoryContext().getRevocableMemory() >= maxRevocableMemoryPerTask).isPresent();\n     }\n \n     private synchronized void revokeHighMemoryTasks()\n"}}, {"oid": "089f92bc9545c56ea58b1c8167c3596304e6b35f", "url": "https://github.com/prestodb/presto/commit/089f92bc9545c56ea58b1c8167c3596304e6b35f", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-11T19:48:42Z", "type": "commit"}, {"oid": "089f92bc9545c56ea58b1c8167c3596304e6b35f", "url": "https://github.com/prestodb/presto/commit/089f92bc9545c56ea58b1c8167c3596304e6b35f", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler (and its task-threshold flavored\ncounterpart) would find running tasks but then operate on them by\ntraversing their QueryContext. This led to two significant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query from all other tasks in that query.\n- Both flavors of memory revoking scheduler would repeatedly perform\n  the same traversals and attempt to revoke memory from the same tasks\n  and operators based on the number of tasks a given query had", "committedDate": "2021-01-11T19:48:42Z", "type": "forcePushed"}]}