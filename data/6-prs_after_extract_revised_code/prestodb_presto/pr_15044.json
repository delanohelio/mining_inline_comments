{"pr_number": 15044, "pr_title": "Add support for versioning metastore API", "pr_createdAt": "2020-08-17T18:31:09Z", "pr_url": "https://github.com/prestodb/presto/pull/15044", "timeline": [{"oid": "c48de09fc2ad57b69f872ec5ef850102b7184380", "url": "https://github.com/prestodb/presto/commit/c48de09fc2ad57b69f872ec5ef850102b7184380", "message": "Add support for versioning metastore API", "committedDate": "2020-08-18T19:58:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxNTAyOQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r473215029", "bodyText": "I have a concern about the following scenario:\nQuery A fetched partition 'foo' but has not added to cache -> partition 'foo' was updated -> Query B called getPartitionNames and saw version change, thus invalidate the cache -> Query A put the old partition into cache -> Query B would read old partition\nTo be fair, this might be okay because it will be invalidated again when next similar query came in, and I don't think guava would fix this (google/guava#1881 has been opened for years). Is partition version an ever-increasing integer? If so, we might be able to guard against this. Otherwise this does not seem solvable because we cannot tell which version is the latest (which might still be okay).", "author": "shixuan-fan", "createdAt": "2020-08-19T17:48:09Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -530,6 +559,18 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (isPartitionVersioningEnabled) {\n+            List<String> result = new ArrayList<>();\n+            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n+                result.add(partitionName.getPartitionName());\n+                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n+                if (partitionVersionMap.containsKey(hivePartitionName) && partitionVersionMap.get(hivePartitionName) != partitionName.getPartitionVersion()) {", "originalCommit": "c48de09fc2ad57b69f872ec5ef850102b7184380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2ed3c4595fe26c44bcbbee5e58beb91aeb9894a2", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex bfd022fd6d..ac7979276c 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -564,10 +578,20 @@ public class CachingHiveMetastore\n             delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n                 result.add(partitionName.getPartitionName());\n                 HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n-                if (partitionVersionMap.containsKey(hivePartitionName) && partitionVersionMap.get(hivePartitionName) != partitionName.getPartitionVersion()) {\n-                    partitionCache.invalidate(hivePartitionName);\n+                try {\n+                    Optional<Partition> metastorePartition = partitionCache.getUnchecked(hivePartitionName);\n+                    metastorePartition.ifPresent(partition -> {\n+                        if (partition.getParameters().containsKey(\"PARTITION_VERSION\") &&\n+                                Integer.valueOf(partition.getParameters().get(\"PARTITION_VERSION\")) < partitionName.getPartitionVersion()) {\n+                            partitionCache.invalidate(hivePartitionName);\n+                            partitionStatisticsCache.invalidate(hivePartitionName);\n+                        }\n+                    });\n+                }\n+                catch (UncheckedExecutionException e) {\n+                    throwIfInstanceOf(e.getCause(), PrestoException.class);\n+                    throw e;\n                 }\n-                partitionVersionMap.put(hivePartitionName, partitionName.getPartitionVersion());\n             });\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyMzkyOA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r473223928", "bodyText": "I'm a bit hesitated about this approach because this method is not compatible with open source hive metastore, but adding as a default method might be okay.\nOne other option is to add cache functionality in our internal Hive metastore extension. The pro is that everything is hidden under the hood so we likely need zero changes in open source, but the con is that there would be a bit of logic duplication around caching, and we won't be able to pass version information around if needed.", "author": "shixuan-fan", "createdAt": "2020-08-19T18:03:30Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/HiveMetastore.java", "diffHunk": "@@ -72,6 +73,11 @@\n \n     List<String> getPartitionNamesByFilter(String databaseName, String tableName, Map<Column, Domain> partitionPredicates);\n \n+    default List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(String databaseName, String tableName, Map<Column, Domain> partitionPredicates)", "originalCommit": "c48de09fc2ad57b69f872ec5ef850102b7184380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/HiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/HiveMetastore.java\nindex b70c3bb028..30171339e7 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/HiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/HiveMetastore.java\n\n@@ -73,11 +72,6 @@ public interface HiveMetastore\n \n     List<String> getPartitionNamesByFilter(String databaseName, String tableName, Map<Column, Domain> partitionPredicates);\n \n-    default List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(String databaseName, String tableName, Map<Column, Domain> partitionPredicates)\n-    {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     Optional<Partition> getPartition(String databaseName, String tableName, List<String> partitionValues);\n \n     List<Partition> getPartitionsByNames(String databaseName, String tableName, List<String> partitionNames);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDkyMA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r473230920", "bodyText": "Given partition cache is a loading cache, this map might be outdated. Could we store this information in partition cache and use getIfPresent? They might achieve similar goal.", "author": "shixuan-fan", "createdAt": "2020-08-19T18:16:26Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -87,6 +88,9 @@\n     private final LoadingCache<String, Set<String>> rolesCache;\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n+    private boolean isPartitionVersioningEnabled;\n+    private Map<HivePartitionName, Integer> partitionVersionMap;", "originalCommit": "c48de09fc2ad57b69f872ec5ef850102b7184380", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2ed3c4595fe26c44bcbbee5e58beb91aeb9894a2", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex bfd022fd6d..ac7979276c 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -89,7 +88,6 @@ public class CachingHiveMetastore\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n     private boolean isPartitionVersioningEnabled;\n-    private Map<HivePartitionName, Integer> partitionVersionMap;\n \n     @Inject\n     public CachingHiveMetastore(@ForCachingHiveMetastore ExtendedHiveMetastore delegate, @ForCachingHiveMetastore ExecutorService executor, MetastoreClientConfig metastoreClientConfig)\n"}}, {"oid": "2ed3c4595fe26c44bcbbee5e58beb91aeb9894a2", "url": "https://github.com/prestodb/presto/commit/2ed3c4595fe26c44bcbbee5e58beb91aeb9894a2", "message": "Add version to Partition parameters", "committedDate": "2020-08-27T07:45:47Z", "type": "forcePushed"}, {"oid": "e031a29a6ec1df453527e314831a5a9c10c5fc1a", "url": "https://github.com/prestodb/presto/commit/e031a29a6ec1df453527e314831a5a9c10c5fc1a", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-08T19:35:16Z", "type": "forcePushed"}, {"oid": "b44ed03b4718bd82d809acc9a7b9a37f1f79b96a", "url": "https://github.com/prestodb/presto/commit/b44ed03b4718bd82d809acc9a7b9a37f1f79b96a", "message": "Add CachingHiveMetastoreConfig to manage metastore cache parameters", "committedDate": "2020-09-09T07:42:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NjI2Nw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487156267", "bodyText": "nit: EXTRA_INFO", "author": "shixuan-fan", "createdAt": "2020-09-11T16:28:38Z", "path": "presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestHiveMetastoreUtil.java", "diffHunk": "@@ -118,6 +119,7 @@\n             1234567893,\n             TEST_STORAGE_DESCRIPTOR_WITH_UNSUPPORTED_FIELDS,\n             ImmutableMap.of(\"k1\", \"v1\", \"k2\", \"v2\", \"k3\", \"v3\"));\n+    private static final PartitionExtraInfoFetcher TEST_PARTITION_EXTRAINFO_FETCHER = new HivePartitionExtraInfoFetcher();", "originalCommit": "b19e3b19f26e2ac96a44d349e5245c6d61b3d4f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestHiveMetastoreUtil.java b/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestHiveMetastoreUtil.java\nindex 4278225e24..e85931efe1 100644\n--- a/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestHiveMetastoreUtil.java\n+++ b/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestHiveMetastoreUtil.java\n\n@@ -119,7 +119,7 @@ public class TestHiveMetastoreUtil\n             1234567893,\n             TEST_STORAGE_DESCRIPTOR_WITH_UNSUPPORTED_FIELDS,\n             ImmutableMap.of(\"k1\", \"v1\", \"k2\", \"v2\", \"k3\", \"v3\"));\n-    private static final PartitionExtraInfoFetcher TEST_PARTITION_EXTRAINFO_FETCHER = new HivePartitionExtraInfoFetcher();\n+    private static final PartitionExtraInfoFetcher TEST_PARTITION_EXTRA_INFO_FETCHER = new HivePartitionExtraInfoFetcher();\n \n     static {\n         TEST_STORAGE_DESCRIPTOR_WITH_UNSUPPORTED_FIELDS.setSkewedInfo(new SkewedInfo(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NzI0Nw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487157247", "bodyText": "We don't have to make this a default method since the Hive implementation would be the default :)", "author": "shixuan-fan", "createdAt": "2020-09-11T16:30:24Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+\n+import java.util.Optional;\n+\n+public interface PartitionExtraInfoFetcher\n+{\n+    default Optional<Integer> getPartitionVersion(Partition partition)", "originalCommit": "b19e3b19f26e2ac96a44d349e5245c6d61b3d4f9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\nindex 89fc4459d5..1b7ae8b609 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\n\n@@ -19,8 +19,5 @@ import java.util.Optional;\n \n public interface PartitionExtraInfoFetcher\n {\n-    default Optional<Integer> getPartitionVersion(Partition partition)\n-    {\n-        return Optional.empty();\n-    }\n+    Optional<Integer> getPartitionVersion(Partition partition);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTg3OA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487159878", "bodyText": "Should we just name this PartitionVersionFetcher?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:35:31Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+\n+import java.util.Optional;\n+\n+public interface PartitionExtraInfoFetcher", "originalCommit": "b19e3b19f26e2ac96a44d349e5245c6d61b3d4f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzYzOQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487173639", "bodyText": "I kept the name generic so that we can add more methods to it in future. Like methods that may combine multiple values from Partition parameters and return. WDYT ?", "author": "NikhilCollooru", "createdAt": "2020-09-11T17:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzMzMxOQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487233319", "bodyText": "Maybe we should keep it simple at the beginning and change it once it's needed. Being generic could also mean being a little big vague :p", "author": "shixuan-fan", "createdAt": "2020-09-11T19:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMDg3Mw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487320873", "bodyText": "Haha no issues. i will rename it to PartitionVersionFetcher.", "author": "NikhilCollooru", "createdAt": "2020-09-11T22:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\nindex 89fc4459d5..1b7ae8b609 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionExtraInfoFetcher.java\n\n@@ -19,8 +19,5 @@ import java.util.Optional;\n \n public interface PartitionExtraInfoFetcher\n {\n-    default Optional<Integer> getPartitionVersion(Partition partition)\n-    {\n-        return Optional.empty();\n-    }\n+    Optional<Integer> getPartitionVersion(Partition partition);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MDQzMA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487160430", "bodyText": "nit: Let's keep it consistent and name this hive.partition-versioning-enabled", "author": "shixuan-fan", "createdAt": "2020-09-11T16:36:39Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/MetastoreClientConfig.java", "diffHunk": "@@ -194,4 +195,16 @@ public MetastoreClientConfig setRequireHadoopNative(boolean requireHadoopNative)\n         this.requireHadoopNative = requireHadoopNative;\n         return this;\n     }\n+\n+    public boolean isPartitionVersioningEnabled()\n+    {\n+        return partitionVersioningEnabled;\n+    }\n+\n+    @Config(\"hive.metastore-partition-versioning-enabled\")", "originalCommit": "a89082d7964e30071fdc4f55191f82ad9344d07c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/MetastoreClientConfig.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/MetastoreClientConfig.java\nindex 1ebf68b373..d85a521a21 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/MetastoreClientConfig.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/MetastoreClientConfig.java\n\n@@ -201,10 +203,23 @@ public class MetastoreClientConfig\n         return partitionVersioningEnabled;\n     }\n \n-    @Config(\"hive.metastore-partition-versioning-enabled\")\n+    @Config(\"hive.partition-versioning-enabled\")\n     public MetastoreClientConfig setPartitionVersioningEnabled(boolean partitionVersioningEnabled)\n     {\n         this.partitionVersioningEnabled = partitionVersioningEnabled;\n         return this;\n     }\n+\n+    @NotNull\n+    public MetastoreCacheScope getMetastoreCacheScope()\n+    {\n+        return metastoreCacheScope;\n+    }\n+\n+    @Config(\"hive.metastore-cache-scope\")\n+    public MetastoreClientConfig setMetastoreCacheScope(MetastoreCacheScope metastoreCacheScope)\n+    {\n+        this.metastoreCacheScope = metastoreCacheScope;\n+        return this;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTQ1NQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487161455", "bodyText": "I guess this is test code and we should actually go with config?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:38:29Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -170,21 +174,75 @@ public PartitionStatistics load(HivePartitionName key)\n         partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                {\n-                    @Override\n-                    public Optional<Partition> load(HivePartitionName partitionName)\n-                    {\n-                        return loadPartitionByName(partitionName);\n-                    }\n+        if (isPartitioningEnabled) {\n+            this.isPartitionVersioningEnabled = true;\n+            long expire = 86400000;", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -162,95 +183,57 @@ public class CachingHiveMetastore\n                     }\n                 }, executor));\n \n-        tableCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionStatisticsCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n+                {\n+                    @Override\n+                    public PartitionStatistics load(HivePartitionName key)\n+                    {\n+                        return loadPartitionColumnStatistics(key);\n+                    }\n+\n+                    @Override\n+                    public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n+                    {\n+                        return loadPartitionColumnStatistics(keys);\n+                    }\n+                }, executor));\n+\n+        tableCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadTable), executor));\n \n-        viewNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        viewNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllViews), executor));\n \n-        partitionNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNames), executor));\n \n-        partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionFilterCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        if (isPartitioningEnabled) {\n-            this.isPartitionVersioningEnabled = true;\n-            long expire = 86400000;\n-\n-            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                    {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n-        else {\n-            partitionStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+        partitionCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+                {\n+                    @Override\n+                    public Optional<Partition> load(HivePartitionName partitionName)\n                     {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n+                        return loadPartitionByName(partitionName);\n+                    }\n \n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n+                    @Override\n+                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+                    {\n+                        return loadPartitionsByNames(partitionNames);\n+                    }\n+                }, executor));\n \n-        tablePrivilegesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        tablePrivilegesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(key -> loadTablePrivileges(key.getDatabase(), key.getTable(), key.getPrincipal())), executor));\n \n-        rolesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        rolesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(() -> loadRoles()), executor));\n \n-        roleGrantsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        roleGrantsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadRoleGrants), executor));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTY5Mw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487161693", "bodyText": "nit: partitionVersioningEnabled", "author": "shixuan-fan", "createdAt": "2020-09-11T16:38:59Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -87,25 +87,38 @@\n     private final LoadingCache<String, Set<String>> rolesCache;\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n+    private boolean isPartitionVersioningEnabled;\n+\n     @Inject\n-    public CachingHiveMetastore(@ForCachingHiveMetastore ExtendedHiveMetastore delegate, @ForCachingHiveMetastore ExecutorService executor, MetastoreClientConfig metastoreClientConfig)\n+    public CachingHiveMetastore(\n+            @ForCachingHiveMetastore ExtendedHiveMetastore delegate,\n+            @ForCachingHiveMetastore ExecutorService executor,\n+            MetastoreClientConfig metastoreClientConfig)\n     {\n         this(\n                 delegate,\n                 executor,\n                 metastoreClientConfig.getMetastoreCacheTtl(),\n                 metastoreClientConfig.getMetastoreRefreshInterval(),\n-                metastoreClientConfig.getMetastoreCacheMaximumSize());\n+                metastoreClientConfig.getMetastoreCacheMaximumSize(),\n+                metastoreClientConfig.isPartitionVersioningEnabled());\n     }\n \n-    public CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, Duration cacheTtl, Duration refreshInterval, long maximumSize)\n+    public CachingHiveMetastore(\n+            ExtendedHiveMetastore delegate,\n+            ExecutorService executor,\n+            Duration cacheTtl,\n+            Duration refreshInterval,\n+            long maximumSize,\n+            boolean isPartitioningEnabled)", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -87,7 +94,7 @@ public class CachingHiveMetastore\n     private final LoadingCache<String, Set<String>> rolesCache;\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n-    private boolean isPartitionVersioningEnabled;\n+    private final boolean isPartitionVersioningEnabled;\n \n     @Inject\n     public CachingHiveMetastore(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MzE3NQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487163175", "bodyText": "I'm a bit confused, why do we set this to true here? If isPartitioningEnabled is renamed per the above comment, I think we could just say this.partitionVersioningEnabled = partitionVersioningEnabled outside of this if-block?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:41:47Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -170,21 +174,75 @@ public PartitionStatistics load(HivePartitionName key)\n         partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                {\n-                    @Override\n-                    public Optional<Partition> load(HivePartitionName partitionName)\n-                    {\n-                        return loadPartitionByName(partitionName);\n-                    }\n+        if (isPartitioningEnabled) {\n+            this.isPartitionVersioningEnabled = true;", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -162,95 +183,57 @@ public class CachingHiveMetastore\n                     }\n                 }, executor));\n \n-        tableCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionStatisticsCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n+                {\n+                    @Override\n+                    public PartitionStatistics load(HivePartitionName key)\n+                    {\n+                        return loadPartitionColumnStatistics(key);\n+                    }\n+\n+                    @Override\n+                    public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n+                    {\n+                        return loadPartitionColumnStatistics(keys);\n+                    }\n+                }, executor));\n+\n+        tableCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadTable), executor));\n \n-        viewNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        viewNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllViews), executor));\n \n-        partitionNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNames), executor));\n \n-        partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionFilterCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        if (isPartitioningEnabled) {\n-            this.isPartitionVersioningEnabled = true;\n-            long expire = 86400000;\n-\n-            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                    {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n-        else {\n-            partitionStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+        partitionCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+                {\n+                    @Override\n+                    public Optional<Partition> load(HivePartitionName partitionName)\n                     {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n+                        return loadPartitionByName(partitionName);\n+                    }\n \n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n+                    @Override\n+                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+                    {\n+                        return loadPartitionsByNames(partitionNames);\n+                    }\n+                }, executor));\n \n-        tablePrivilegesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        tablePrivilegesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(key -> loadTablePrivileges(key.getDatabase(), key.getTable(), key.getPrincipal())), executor));\n \n-        rolesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        rolesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(() -> loadRoles()), executor));\n \n-        roleGrantsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        roleGrantsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadRoleGrants), executor));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDAzMg==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487164032", "bodyText": "nit: 10000000 is also some left-over test code I suppose", "author": "shixuan-fan", "createdAt": "2020-09-11T16:43:26Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -170,21 +174,75 @@ public PartitionStatistics load(HivePartitionName key)\n         partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                {\n-                    @Override\n-                    public Optional<Partition> load(HivePartitionName partitionName)\n-                    {\n-                        return loadPartitionByName(partitionName);\n-                    }\n+        if (isPartitioningEnabled) {\n+            this.isPartitionVersioningEnabled = true;\n+            long expire = 86400000;\n \n-                    @Override\n-                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -162,95 +183,57 @@ public class CachingHiveMetastore\n                     }\n                 }, executor));\n \n-        tableCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionStatisticsCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n+                {\n+                    @Override\n+                    public PartitionStatistics load(HivePartitionName key)\n+                    {\n+                        return loadPartitionColumnStatistics(key);\n+                    }\n+\n+                    @Override\n+                    public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n+                    {\n+                        return loadPartitionColumnStatistics(keys);\n+                    }\n+                }, executor));\n+\n+        tableCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadTable), executor));\n \n-        viewNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        viewNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllViews), executor));\n \n-        partitionNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNames), executor));\n \n-        partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionFilterCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        if (isPartitioningEnabled) {\n-            this.isPartitionVersioningEnabled = true;\n-            long expire = 86400000;\n-\n-            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                    {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n-        else {\n-            partitionStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+        partitionCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+                {\n+                    @Override\n+                    public Optional<Partition> load(HivePartitionName partitionName)\n                     {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n+                        return loadPartitionByName(partitionName);\n+                    }\n \n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n+                    @Override\n+                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+                    {\n+                        return loadPartitionsByNames(partitionNames);\n+                    }\n+                }, executor));\n \n-        tablePrivilegesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        tablePrivilegesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(key -> loadTablePrivileges(key.getDatabase(), key.getTable(), key.getPrincipal())), executor));\n \n-        rolesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        rolesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(() -> loadRoles()), executor));\n \n-        roleGrantsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        roleGrantsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadRoleGrants), executor));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDY5Mw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487164693", "bodyText": "I might have missed something, but what is the difference between the cache builders of these two branches?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:44:43Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -170,21 +174,75 @@ public PartitionStatistics load(HivePartitionName key)\n         partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                {\n-                    @Override\n-                    public Optional<Partition> load(HivePartitionName partitionName)\n-                    {\n-                        return loadPartitionByName(partitionName);\n-                    }\n+        if (isPartitioningEnabled) {\n+            this.isPartitionVersioningEnabled = true;\n+            long expire = 86400000;\n \n-                    @Override\n-                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n+                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n                     {\n-                        return loadPartitionsByNames(partitionNames);\n-                    }\n-                }, executor));\n+                        @Override\n+                        public PartitionStatistics load(HivePartitionName key)\n+                        {\n+                            return loadPartitionColumnStatistics(key);\n+                        }\n+\n+                        @Override\n+                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n+                        {\n+                            return loadPartitionColumnStatistics(keys);\n+                        }\n+                    }, executor));\n+\n+            partitionCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n+                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+                    {\n+                        @Override\n+                        public Optional<Partition> load(HivePartitionName partitionName)\n+                        {\n+                            return loadPartitionByName(partitionName);\n+                        }\n+\n+                        @Override\n+                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+                        {\n+                            return loadPartitionsByNames(partitionNames);\n+                        }\n+                    }, executor));\n+        }\n+        else {", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -162,95 +183,57 @@ public class CachingHiveMetastore\n                     }\n                 }, executor));\n \n-        tableCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionStatisticsCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n+                {\n+                    @Override\n+                    public PartitionStatistics load(HivePartitionName key)\n+                    {\n+                        return loadPartitionColumnStatistics(key);\n+                    }\n+\n+                    @Override\n+                    public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n+                    {\n+                        return loadPartitionColumnStatistics(keys);\n+                    }\n+                }, executor));\n+\n+        tableCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadTable), executor));\n \n-        viewNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        viewNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllViews), executor));\n \n-        partitionNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNames), executor));\n \n-        partitionFilterCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        partitionFilterCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadPartitionNamesByFilter), executor));\n \n-        if (isPartitioningEnabled) {\n-            this.isPartitionVersioningEnabled = true;\n-            long expire = 86400000;\n-\n-            partitionStatisticsCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(OptionalLong.of(expire), OptionalLong.empty(), 10000000)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n-                    {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n-        else {\n-            partitionStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, PartitionStatistics>()\n-                    {\n-                        @Override\n-                        public PartitionStatistics load(HivePartitionName key)\n-                        {\n-                            return loadPartitionColumnStatistics(key);\n-                        }\n-\n-                        @Override\n-                        public Map<HivePartitionName, PartitionStatistics> loadAll(Iterable<? extends HivePartitionName> keys)\n-                        {\n-                            return loadPartitionColumnStatistics(keys);\n-                        }\n-                    }, executor));\n-\n-            partitionCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n-                    .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+        partitionCache = newCacheBuilder(partitionExpiresAfterWriteMillis, partitionRefreshMills, partitionCacheMaxSize)\n+                .build(asyncReloading(new CacheLoader<HivePartitionName, Optional<Partition>>()\n+                {\n+                    @Override\n+                    public Optional<Partition> load(HivePartitionName partitionName)\n                     {\n-                        @Override\n-                        public Optional<Partition> load(HivePartitionName partitionName)\n-                        {\n-                            return loadPartitionByName(partitionName);\n-                        }\n+                        return loadPartitionByName(partitionName);\n+                    }\n \n-                        @Override\n-                        public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n-                        {\n-                            return loadPartitionsByNames(partitionNames);\n-                        }\n-                    }, executor));\n-        }\n+                    @Override\n+                    public Map<HivePartitionName, Optional<Partition>> loadAll(Iterable<? extends HivePartitionName> partitionNames)\n+                    {\n+                        return loadPartitionsByNames(partitionNames);\n+                    }\n+                }, executor));\n \n-        tablePrivilegesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        tablePrivilegesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(key -> loadTablePrivileges(key.getDatabase(), key.getTable(), key.getPrincipal())), executor));\n \n-        rolesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        rolesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(() -> loadRoles()), executor));\n \n-        roleGrantsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        roleGrantsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadRoleGrants), executor));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NTcxNQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487165715", "bodyText": "Let's use ImmutableList.Builder", "author": "shixuan-fan", "createdAt": "2020-09-11T16:46:34Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -530,6 +588,30 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (isPartitionVersioningEnabled) {\n+            List<String> result = new ArrayList<>();", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -589,27 +572,9 @@ public class CachingHiveMetastore\n             Map<Column, Domain> partitionPredicates)\n     {\n         if (isPartitionVersioningEnabled) {\n-            List<String> result = new ArrayList<>();\n-            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n-                result.add(partitionName.getPartitionName());\n-                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n-                try {\n-                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());\n-                    metastorePartition.ifPresent(partition -> {\n-                        Optional<Integer> partitionVersion = partition.getPartitionVersion();\n-                        if (partitionVersion.isPresent() && partitionVersion.get() < partitionName.getPartitionVersion()) {\n-                            partitionCache.invalidate(hivePartitionName);\n-                            if (partitionStatisticsCache.getIfPresent(hivePartitionName) != null) {\n-                                partitionStatisticsCache.invalidate(hivePartitionName);\n-                            }\n-                        }\n-                    });\n-                }\n-                catch (UncheckedExecutionException e) {\n-                    throwIfInstanceOf(e.getCause(), PrestoException.class);\n-                    throw e;\n-                }\n-            });\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n             return result;\n         }\n         return get(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjQyNg==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487166426", "bodyText": "nit: .orElse(Optional.empty()) seems a bit redundant", "author": "shixuan-fan", "createdAt": "2020-09-11T16:47:53Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -530,6 +588,30 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (isPartitionVersioningEnabled) {\n+            List<String> result = new ArrayList<>();\n+            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n+                result.add(partitionName.getPartitionName());\n+                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n+                try {\n+                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -589,27 +572,9 @@ public class CachingHiveMetastore\n             Map<Column, Domain> partitionPredicates)\n     {\n         if (isPartitionVersioningEnabled) {\n-            List<String> result = new ArrayList<>();\n-            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n-                result.add(partitionName.getPartitionName());\n-                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n-                try {\n-                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());\n-                    metastorePartition.ifPresent(partition -> {\n-                        Optional<Integer> partitionVersion = partition.getPartitionVersion();\n-                        if (partitionVersion.isPresent() && partitionVersion.get() < partitionName.getPartitionVersion()) {\n-                            partitionCache.invalidate(hivePartitionName);\n-                            if (partitionStatisticsCache.getIfPresent(hivePartitionName) != null) {\n-                                partitionStatisticsCache.invalidate(hivePartitionName);\n-                            }\n-                        }\n-                    });\n-                }\n-                catch (UncheckedExecutionException e) {\n-                    throwIfInstanceOf(e.getCause(), PrestoException.class);\n-                    throw e;\n-                }\n-            });\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n             return result;\n         }\n         return get(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzY4Mw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487167683", "bodyText": "We should probably just invalidate it without this check?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:50:19Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -530,6 +588,30 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (isPartitionVersioningEnabled) {\n+            List<String> result = new ArrayList<>();\n+            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n+                result.add(partitionName.getPartitionName());\n+                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n+                try {\n+                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());\n+                    metastorePartition.ifPresent(partition -> {\n+                        Optional<Integer> partitionVersion = partition.getPartitionVersion();\n+                        if (partitionVersion.isPresent() && partitionVersion.get() < partitionName.getPartitionVersion()) {\n+                            partitionCache.invalidate(hivePartitionName);\n+                            if (partitionStatisticsCache.getIfPresent(hivePartitionName) != null) {", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -589,27 +572,9 @@ public class CachingHiveMetastore\n             Map<Column, Domain> partitionPredicates)\n     {\n         if (isPartitionVersioningEnabled) {\n-            List<String> result = new ArrayList<>();\n-            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n-                result.add(partitionName.getPartitionName());\n-                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n-                try {\n-                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());\n-                    metastorePartition.ifPresent(partition -> {\n-                        Optional<Integer> partitionVersion = partition.getPartitionVersion();\n-                        if (partitionVersion.isPresent() && partitionVersion.get() < partitionName.getPartitionVersion()) {\n-                            partitionCache.invalidate(hivePartitionName);\n-                            if (partitionStatisticsCache.getIfPresent(hivePartitionName) != null) {\n-                                partitionStatisticsCache.invalidate(hivePartitionName);\n-                            }\n-                        }\n-                    });\n-                }\n-                catch (UncheckedExecutionException e) {\n-                    throwIfInstanceOf(e.getCause(), PrestoException.class);\n-                    throw e;\n-                }\n-            });\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n             return result;\n         }\n         return get(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MTM0Ng==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487171346", "bodyText": "Why do we need this factory method?", "author": "shixuan-fan", "createdAt": "2020-09-11T16:56:55Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/PartitionNameWithVersion.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.metastore;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class PartitionNameWithVersion\n+{\n+    private final String partitionName;\n+    private final int partitionVersion;\n+\n+    public static PartitionNameWithVersion partitionNameWithVersion(String partitionName, int partitionVersion)", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/PartitionNameWithVersion.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/PartitionNameWithVersion.java\nindex 7e27deae5b..7b6d61ecd7 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/PartitionNameWithVersion.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/PartitionNameWithVersion.java\n\n@@ -20,12 +20,7 @@ public class PartitionNameWithVersion\n     private final String partitionName;\n     private final int partitionVersion;\n \n-    public static PartitionNameWithVersion partitionNameWithVersion(String partitionName, int partitionVersion)\n-    {\n-        return new PartitionNameWithVersion(partitionName, partitionVersion);\n-    }\n-\n-    private PartitionNameWithVersion(String partitionName, int partitionVersion)\n+    public PartitionNameWithVersion(String partitionName, int partitionVersion)\n     {\n         this.partitionName = requireNonNull(partitionName, \"partitionName is null\");\n         this.partitionVersion = partitionVersion;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MTgyNw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487171827", "bodyText": "Overall I find this forEach a bit too complicated. Maybe something like the following might be better:\nList<PartitionNameWithVersion> partitionNamesWithVersion = delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\nList<String> result = partitionNamesWithVersion....collect(...);\npartitionNamesWithVersion.forEach(this::invalidateStalePartition); // Or invalidateStalePartitions(partitionNamesWithVersion)\n\nOtherwise, we should probably just use a for loop.", "author": "shixuan-fan", "createdAt": "2020-09-11T16:57:50Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -530,6 +588,30 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (isPartitionVersioningEnabled) {\n+            List<String> result = new ArrayList<>();\n+            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {", "originalCommit": "5ba31b71c2cefd22e6673e353ac485333b183a02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 14e23c84f0..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -589,27 +572,9 @@ public class CachingHiveMetastore\n             Map<Column, Domain> partitionPredicates)\n     {\n         if (isPartitionVersioningEnabled) {\n-            List<String> result = new ArrayList<>();\n-            delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates).forEach(partitionName -> {\n-                result.add(partitionName.getPartitionName());\n-                HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionName.getPartitionName());\n-                try {\n-                    Optional<Partition> metastorePartition = Optional.ofNullable(partitionCache.getIfPresent(hivePartitionName)).orElse(Optional.empty());\n-                    metastorePartition.ifPresent(partition -> {\n-                        Optional<Integer> partitionVersion = partition.getPartitionVersion();\n-                        if (partitionVersion.isPresent() && partitionVersion.get() < partitionName.getPartitionVersion()) {\n-                            partitionCache.invalidate(hivePartitionName);\n-                            if (partitionStatisticsCache.getIfPresent(hivePartitionName) != null) {\n-                                partitionStatisticsCache.invalidate(hivePartitionName);\n-                            }\n-                        }\n-                    });\n-                }\n-                catch (UncheckedExecutionException e) {\n-                    throwIfInstanceOf(e.getCause(), PrestoException.class);\n-                    throw e;\n-                }\n-            });\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n             return result;\n         }\n         return get(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5NjQ0MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487196440", "bodyText": "I think we should just call cacheConfig. getPartitionCacheTtl() regardless of isPartitionVersioningEnabled?", "author": "shixuan-fan", "createdAt": "2020-09-11T17:46:14Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -98,50 +97,40 @@ public CachingHiveMetastore(\n         this(\n                 delegate,\n                 executor,\n-                metastoreClientConfig.getMetastoreCacheTtl(),\n-                metastoreClientConfig.getMetastoreRefreshInterval(),\n-                metastoreClientConfig.getMetastoreCacheMaximumSize(),\n-                metastoreClientConfig.isPartitionVersioningEnabled());\n-    }\n-\n-    public CachingHiveMetastore(\n-            ExtendedHiveMetastore delegate,\n-            ExecutorService executor,\n-            Duration cacheTtl,\n-            Duration refreshInterval,\n-            long maximumSize,\n-            boolean isPartitioningEnabled)\n-    {\n-        this(\n-                delegate,\n-                executor,\n-                OptionalLong.of(cacheTtl.toMillis()),\n-                refreshInterval.toMillis() >= cacheTtl.toMillis() ? OptionalLong.empty() : OptionalLong.of(refreshInterval.toMillis()),\n-                maximumSize,\n-                isPartitioningEnabled);\n+                CachingHiveMetastoreConfig.builder()\n+                        .setAllCacheTtl(metastoreClientConfig.getMetastoreCacheTtl())\n+                        .setAllCacheRefreshInterval(metastoreClientConfig.getMetastoreRefreshInterval())\n+                        .setAllCacheMaxSize(metastoreClientConfig.getMetastoreCacheMaximumSize())\n+                        .setPartitionVersioningEnabled(metastoreClientConfig.isPartitionVersioningEnabled())\n+                        .setPartitionCacheTtl(metastoreClientConfig.getMetastorePartitionCacheTtl())\n+                        .setPartitionCacheRefreshInterval(metastoreClientConfig.getMetastorePartitionRefreshInterval())\n+                        .setPartitionCacheMaxSize(metastoreClientConfig.getMetastorePartitionCacheMaximumSize())\n+                        .build());\n     }\n \n     public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delegate, long maximumSize)\n     {\n         return new CachingHiveMetastore(\n                 delegate,\n                 newDirectExecutorService(),\n-                OptionalLong.empty(),\n-                OptionalLong.empty(),\n-                maximumSize,\n-                false);\n+                CachingHiveMetastoreConfig.builder().setAllCacheMaxSize(maximumSize).setPartitionVersioningEnabled(false).build());\n     }\n \n-    private CachingHiveMetastore(\n+    public CachingHiveMetastore(\n             ExtendedHiveMetastore delegate,\n             ExecutorService executor,\n-            OptionalLong expiresAfterWriteMillis,\n-            OptionalLong refreshMills,\n-            long maximumSize,\n-            boolean isPartitioningEnabled)\n+            CachingHiveMetastoreConfig cacheConfig)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n+        requireNonNull(cacheConfig, \"cacheConfig is null\");\n+        this.isPartitionVersioningEnabled = cacheConfig.isPartitionVersioningEnabled();\n+        OptionalLong expiresAfterWriteMillis = cacheConfig.getAllCacheTtl();\n+        OptionalLong refreshMills = cacheConfig.getAllCacheRefreshInterval();\n+        long maximumSize = cacheConfig.getAllCacheMaxSize();\n+        OptionalLong partitionExpireAfterWriteMillis = isPartitionVersioningEnabled ? cacheConfig.getPartitionCacheTtl() : expiresAfterWriteMillis;", "originalCommit": "b44ed03b4718bd82d809acc9a7b9a37f1f79b96a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex 41b78333c3..ff0e9d011b 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -97,15 +105,30 @@ public class CachingHiveMetastore\n         this(\n                 delegate,\n                 executor,\n-                CachingHiveMetastoreConfig.builder()\n-                        .setAllCacheTtl(metastoreClientConfig.getMetastoreCacheTtl())\n-                        .setAllCacheRefreshInterval(metastoreClientConfig.getMetastoreRefreshInterval())\n-                        .setAllCacheMaxSize(metastoreClientConfig.getMetastoreCacheMaximumSize())\n-                        .setPartitionVersioningEnabled(metastoreClientConfig.isPartitionVersioningEnabled())\n-                        .setPartitionCacheTtl(metastoreClientConfig.getMetastorePartitionCacheTtl())\n-                        .setPartitionCacheRefreshInterval(metastoreClientConfig.getMetastorePartitionRefreshInterval())\n-                        .setPartitionCacheMaxSize(metastoreClientConfig.getMetastorePartitionCacheMaximumSize())\n-                        .build());\n+                metastoreClientConfig.getMetastoreCacheTtl(),\n+                metastoreClientConfig.getMetastoreRefreshInterval(),\n+                metastoreClientConfig.getMetastoreCacheMaximumSize(),\n+                metastoreClientConfig.isPartitionVersioningEnabled(),\n+                metastoreClientConfig.getMetastoreCacheScope());\n+    }\n+\n+    public CachingHiveMetastore(\n+            ExtendedHiveMetastore delegate,\n+            ExecutorService executor,\n+            Duration cacheTtl,\n+            Duration refreshInterval,\n+            long maximumSize,\n+            boolean isPartitionVersioningEnabled,\n+            MetastoreCacheScope metastoreCacheScope)\n+    {\n+        this(\n+                delegate,\n+                executor,\n+                OptionalLong.of(cacheTtl.toMillis()),\n+                refreshInterval.toMillis() >= cacheTtl.toMillis() ? OptionalLong.empty() : OptionalLong.of(refreshInterval.toMillis()),\n+                maximumSize,\n+                isPartitionVersioningEnabled,\n+                metastoreCacheScope);\n     }\n \n     public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delegate, long maximumSize)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMjc1OQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487202759", "bodyText": "I feel this might be an overkill. Currently, we could only enable cache in an all-or-nothing fashion, and essentially we want to introduce a mode where we only enable cache for partitions. We are not really targeting a different caching strategy (ttl, refresh, size) for partitions.\nMaybe we should introduce an Enum that is MetastoreCacheScope and have ALL and PARTITION in there, so that we could reuse the existing cache config.", "author": "shixuan-fan", "createdAt": "2020-09-11T17:58:52Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastoreConfig.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.metastore;\n+\n+import io.airlift.units.Duration;\n+\n+import java.util.OptionalLong;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class CachingHiveMetastoreConfig\n+{\n+    private final OptionalLong allCacheTtl;\n+    private final OptionalLong allCacheRefreshInterval;\n+    private final long allCacheMaxSize;\n+\n+    private final boolean isPartitionVersioningEnabled;\n+    private final OptionalLong partitionCacheTtl;\n+    private final OptionalLong partitionCacheRefreshInterval;\n+    private final long partitionCacheMaxSize;\n+\n+    private CachingHiveMetastoreConfig(", "originalCommit": "b44ed03b4718bd82d809acc9a7b9a37f1f79b96a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMDU4Mw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r487320583", "bodyText": "Yeah having a Enum will be simpler.", "author": "NikhilCollooru", "createdAt": "2020-09-11T22:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMjc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "022a427a5bff93052fca81980d63c73f503aa836", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastoreConfig.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastoreConfig.java\ndeleted file mode 100644\nindex c78986afdc..0000000000\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastoreConfig.java\n+++ /dev/null\n\n@@ -1,169 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.hive.metastore;\n-\n-import io.airlift.units.Duration;\n-\n-import java.util.OptionalLong;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-public class CachingHiveMetastoreConfig\n-{\n-    private final OptionalLong allCacheTtl;\n-    private final OptionalLong allCacheRefreshInterval;\n-    private final long allCacheMaxSize;\n-\n-    private final boolean isPartitionVersioningEnabled;\n-    private final OptionalLong partitionCacheTtl;\n-    private final OptionalLong partitionCacheRefreshInterval;\n-    private final long partitionCacheMaxSize;\n-\n-    private CachingHiveMetastoreConfig(\n-            OptionalLong allCacheTtl,\n-            OptionalLong allCacheRefreshInterval,\n-            long allCacheMaxSize,\n-            boolean isPartitionVersioningEnabled,\n-            OptionalLong partitionCacheTtl,\n-            OptionalLong partitionCacheRefreshInterval,\n-            long partitionCacheMaxSize)\n-    {\n-        this.allCacheTtl = requireNonNull(allCacheTtl, \"allCacheTtl is null\");\n-        this.allCacheRefreshInterval = requireNonNull(allCacheRefreshInterval, \"allCacheRefreshInterval is null\");\n-        this.allCacheMaxSize = allCacheMaxSize;\n-\n-        this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n-        this.partitionCacheTtl = requireNonNull(partitionCacheTtl, \"partitionCacheTtl is null\");\n-        this.partitionCacheRefreshInterval = requireNonNull(partitionCacheRefreshInterval, \"partitionCacheRefreshInterval is null\");\n-        this.partitionCacheMaxSize = partitionCacheMaxSize;\n-    }\n-\n-    public OptionalLong getAllCacheTtl()\n-    {\n-        return allCacheTtl;\n-    }\n-\n-    public OptionalLong getAllCacheRefreshInterval()\n-    {\n-        return allCacheRefreshInterval;\n-    }\n-\n-    public long getAllCacheMaxSize()\n-    {\n-        return allCacheMaxSize;\n-    }\n-\n-    public boolean isPartitionVersioningEnabled()\n-    {\n-        return isPartitionVersioningEnabled;\n-    }\n-\n-    public OptionalLong getPartitionCacheTtl()\n-    {\n-        return partitionCacheTtl;\n-    }\n-\n-    public OptionalLong getPartitionCacheRefreshInterval()\n-    {\n-        return partitionCacheRefreshInterval;\n-    }\n-\n-    public long getPartitionCacheMaxSize()\n-    {\n-        return partitionCacheMaxSize;\n-    }\n-\n-    public static Builder builder()\n-    {\n-        return new Builder();\n-    }\n-\n-    public static final class Builder\n-    {\n-        private OptionalLong allCacheTtl = OptionalLong.empty();\n-        private OptionalLong allCacheRefreshInterval = OptionalLong.empty();\n-        private long allCacheMaxSize = 10000;\n-\n-        private boolean isPartitionVersioningEnabled;\n-        private OptionalLong partitionCacheTtl = OptionalLong.empty();\n-        private OptionalLong partitionCacheRefreshInterval = OptionalLong.empty();\n-        private long partitionCacheMaxSize = 10000;\n-\n-        public Builder setAllCacheTtl(Duration cacheTtl)\n-        {\n-            this.allCacheTtl = OptionalLong.of(cacheTtl.toMillis());\n-            return this;\n-        }\n-\n-        public Builder setAllCacheRefreshInterval(Duration refreshInterval)\n-        {\n-            if (allCacheTtl.isPresent()) {\n-                long cacheTtl = allCacheTtl.getAsLong();\n-                this.allCacheRefreshInterval = refreshInterval.toMillis() >= cacheTtl ? OptionalLong.empty() : OptionalLong.of(refreshInterval.toMillis());\n-                return this;\n-            }\n-\n-            this.allCacheRefreshInterval = OptionalLong.of(refreshInterval.toMillis());\n-            return this;\n-        }\n-\n-        public Builder setAllCacheMaxSize(long cacheMaxSize)\n-        {\n-            this.allCacheMaxSize = cacheMaxSize;\n-            return this;\n-        }\n-\n-        public Builder setPartitionVersioningEnabled(boolean isPartitionVersioningEnabled)\n-        {\n-            this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n-            return this;\n-        }\n-\n-        public Builder setPartitionCacheTtl(Duration cacheTtl)\n-        {\n-            this.partitionCacheTtl = OptionalLong.of(cacheTtl.toMillis());\n-            return this;\n-        }\n-\n-        public Builder setPartitionCacheRefreshInterval(Duration refreshInterval)\n-        {\n-            if (partitionCacheTtl.isPresent()) {\n-                long cacheTtl = partitionCacheTtl.getAsLong();\n-                this.partitionCacheRefreshInterval = refreshInterval.toMillis() >= cacheTtl ? OptionalLong.empty() : OptionalLong.of(refreshInterval.toMillis());\n-                return this;\n-            }\n-\n-            this.partitionCacheRefreshInterval = OptionalLong.of(refreshInterval.toMillis());\n-            return this;\n-        }\n-\n-        public Builder setPartitionCacheMaxSize(long cacheMaxSize)\n-        {\n-            this.partitionCacheMaxSize = cacheMaxSize;\n-            return this;\n-        }\n-\n-        public CachingHiveMetastoreConfig build()\n-        {\n-            return new CachingHiveMetastoreConfig(\n-                    allCacheTtl,\n-                    allCacheRefreshInterval,\n-                    allCacheMaxSize,\n-                    isPartitionVersioningEnabled,\n-                    partitionCacheTtl,\n-                    partitionCacheRefreshInterval,\n-                    partitionCacheMaxSize);\n-        }\n-    }\n-}\n"}}, {"oid": "022a427a5bff93052fca81980d63c73f503aa836", "url": "https://github.com/prestodb/presto/commit/022a427a5bff93052fca81980d63c73f503aa836", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-11T21:29:06Z", "type": "forcePushed"}, {"oid": "c3ca89087ac77136c3b0cf4ca2f986effe6ca347", "url": "https://github.com/prestodb/presto/commit/c3ca89087ac77136c3b0cf4ca2f986effe6ca347", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-11T22:37:40Z", "type": "forcePushed"}, {"oid": "90a8347876fd06cf657da35379631748cdec0fd8", "url": "https://github.com/prestodb/presto/commit/90a8347876fd06cf657da35379631748cdec0fd8", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-11T22:49:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxNDY0Nw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488814647", "bodyText": "nit: partitionExtraInfoFetcher -> partitionVersionFetcher", "author": "shixuan-fan", "createdAt": "2020-09-15T16:49:23Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/BridgingHiveMetastore.java", "diffHunk": "@@ -60,11 +62,13 @@\n         implements ExtendedHiveMetastore\n {\n     private final HiveMetastore delegate;\n+    private final PartitionVersionFetcher partitionExtraInfoFetcher;\n \n     @Inject\n-    public BridgingHiveMetastore(HiveMetastore delegate)\n+    public BridgingHiveMetastore(HiveMetastore delegate, PartitionVersionFetcher partitionExtraInfoFetcher)", "originalCommit": "c3a6d448a4a6d74d119647fbce8fcf3e4559839e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/BridgingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/BridgingHiveMetastore.java\nindex 0d1f692510..3b6d9163c1 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/BridgingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/BridgingHiveMetastore.java\n\n@@ -62,13 +62,13 @@ public class BridgingHiveMetastore\n         implements ExtendedHiveMetastore\n {\n     private final HiveMetastore delegate;\n-    private final PartitionVersionFetcher partitionExtraInfoFetcher;\n+    private final PartitionVersionFetcher partitionVersionFetcher;\n \n     @Inject\n-    public BridgingHiveMetastore(HiveMetastore delegate, PartitionVersionFetcher partitionExtraInfoFetcher)\n+    public BridgingHiveMetastore(HiveMetastore delegate, PartitionVersionFetcher partitionVersionFetcher)\n     {\n         this.delegate = delegate;\n-        this.partitionExtraInfoFetcher = partitionExtraInfoFetcher;\n+        this.partitionVersionFetcher = partitionVersionFetcher;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxNTI3MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488815270", "bodyText": "nit: partitionExtraInfoFetcher -> partitionVersionFetcher", "author": "shixuan-fan", "createdAt": "2020-09-15T16:50:27Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/ThriftMetastoreUtil.java", "diffHunk": "@@ -436,7 +437,7 @@ public static boolean isAvroTableWithSchemaSet(org.apache.hadoop.hive.metastore.\n                 serdeInfo.getSerializationLib().equals(AVRO.getSerDe());\n     }\n \n-    public static Partition fromMetastoreApiPartition(org.apache.hadoop.hive.metastore.api.Partition partition)\n+    public static Partition fromMetastoreApiPartition(org.apache.hadoop.hive.metastore.api.Partition partition, PartitionVersionFetcher partitionExtraInfoFetcher)", "originalCommit": "c3a6d448a4a6d74d119647fbce8fcf3e4559839e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/ThriftMetastoreUtil.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/ThriftMetastoreUtil.java\nindex 0e1b577a8b..cc50c4f748 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/ThriftMetastoreUtil.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/thrift/ThriftMetastoreUtil.java\n\n@@ -437,7 +437,7 @@ public final class ThriftMetastoreUtil\n                 serdeInfo.getSerializationLib().equals(AVRO.getSerDe());\n     }\n \n-    public static Partition fromMetastoreApiPartition(org.apache.hadoop.hive.metastore.api.Partition partition, PartitionVersionFetcher partitionExtraInfoFetcher)\n+    public static Partition fromMetastoreApiPartition(org.apache.hadoop.hive.metastore.api.Partition partition, PartitionVersionFetcher partitionVersionFetcher)\n     {\n         StorageDescriptor storageDescriptor = partition.getSd();\n         if (storageDescriptor == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxNzAzMw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488817033", "bodyText": "nit: partitionExtraInfoFetcher -> partitionVersionFetcher", "author": "shixuan-fan", "createdAt": "2020-09-15T16:53:21Z", "path": "presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestCachingHiveMetastore.java", "diffHunk": "@@ -59,8 +60,9 @@ public void setUp()\n         MockHiveCluster mockHiveCluster = new MockHiveCluster(mockClient);\n         ListeningExecutorService executor = listeningDecorator(newCachedThreadPool(daemonThreadsNamed(\"test-%s\")));\n         ThriftHiveMetastore thriftHiveMetastore = new ThriftHiveMetastore(mockHiveCluster);\n+        PartitionVersionFetcher hivePartitionExtraInfoFetcher = new HivePartitionVersionFetcher();", "originalCommit": "c3a6d448a4a6d74d119647fbce8fcf3e4559839e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestCachingHiveMetastore.java b/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestCachingHiveMetastore.java\nindex e18727ac17..9813696966 100644\n--- a/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestCachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/test/java/com/facebook/presto/hive/metastore/TestCachingHiveMetastore.java\n\n@@ -60,9 +60,9 @@ public class TestCachingHiveMetastore\n         MockHiveCluster mockHiveCluster = new MockHiveCluster(mockClient);\n         ListeningExecutorService executor = listeningDecorator(newCachedThreadPool(daemonThreadsNamed(\"test-%s\")));\n         ThriftHiveMetastore thriftHiveMetastore = new ThriftHiveMetastore(mockHiveCluster);\n-        PartitionVersionFetcher hivePartitionExtraInfoFetcher = new HivePartitionVersionFetcher();\n+        PartitionVersionFetcher hivePartitionVersionFetcher = new HivePartitionVersionFetcher();\n         metastore = new CachingHiveMetastore(\n-                new BridgingHiveMetastore(thriftHiveMetastore, hivePartitionExtraInfoFetcher),\n+                new BridgingHiveMetastore(thriftHiveMetastore, hivePartitionVersionFetcher),\n                 executor,\n                 new Duration(5, TimeUnit.MINUTES),\n                 new Duration(1, TimeUnit.MINUTES),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxOTM3MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488819370", "bodyText": "nit: partitionVersioningEnabled", "author": "shixuan-fan", "createdAt": "2020-09-15T16:57:15Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -92,25 +94,41 @@\n     private final LoadingCache<String, Set<String>> rolesCache;\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n+    private final boolean isPartitionVersioningEnabled;", "originalCommit": "90a8347876fd06cf657da35379631748cdec0fd8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex ff0e9d011b..924b272f15 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -94,41 +87,25 @@ public class CachingHiveMetastore\n     private final LoadingCache<String, Set<String>> rolesCache;\n     private final LoadingCache<PrestoPrincipal, Set<RoleGrant>> roleGrantsCache;\n \n-    private final boolean isPartitionVersioningEnabled;\n-\n     @Inject\n-    public CachingHiveMetastore(\n-            @ForCachingHiveMetastore ExtendedHiveMetastore delegate,\n-            @ForCachingHiveMetastore ExecutorService executor,\n-            MetastoreClientConfig metastoreClientConfig)\n+    public CachingHiveMetastore(@ForCachingHiveMetastore ExtendedHiveMetastore delegate, @ForCachingHiveMetastore ExecutorService executor, MetastoreClientConfig metastoreClientConfig)\n     {\n         this(\n                 delegate,\n                 executor,\n                 metastoreClientConfig.getMetastoreCacheTtl(),\n                 metastoreClientConfig.getMetastoreRefreshInterval(),\n-                metastoreClientConfig.getMetastoreCacheMaximumSize(),\n-                metastoreClientConfig.isPartitionVersioningEnabled(),\n-                metastoreClientConfig.getMetastoreCacheScope());\n+                metastoreClientConfig.getMetastoreCacheMaximumSize());\n     }\n \n-    public CachingHiveMetastore(\n-            ExtendedHiveMetastore delegate,\n-            ExecutorService executor,\n-            Duration cacheTtl,\n-            Duration refreshInterval,\n-            long maximumSize,\n-            boolean isPartitionVersioningEnabled,\n-            MetastoreCacheScope metastoreCacheScope)\n+    public CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, Duration cacheTtl, Duration refreshInterval, long maximumSize)\n     {\n         this(\n                 delegate,\n                 executor,\n                 OptionalLong.of(cacheTtl.toMillis()),\n                 refreshInterval.toMillis() >= cacheTtl.toMillis() ? OptionalLong.empty() : OptionalLong.of(refreshInterval.toMillis()),\n-                maximumSize,\n-                isPartitionVersioningEnabled,\n-                metastoreCacheScope);\n+                maximumSize);\n     }\n \n     public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delegate, long maximumSize)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyMzk0MQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488823941", "bodyText": "It might be easier if we set all these caches in a switch statement based on cache scope. It might be easier to understand logically, but I acknowledge there would be a lot of redundancy.\nOtherwise, we could use switch statement to set these values instead of a lot of ternary expressions.", "author": "shixuan-fan", "createdAt": "2020-09-15T17:04:42Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -120,24 +138,42 @@ public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delega\n                 newDirectExecutorService(),\n                 OptionalLong.empty(),\n                 OptionalLong.empty(),\n-                maximumSize);\n+                maximumSize,\n+                false,\n+                ALL);\n     }\n \n-    private CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, OptionalLong expiresAfterWriteMillis, OptionalLong refreshMills, long maximumSize)\n+    private CachingHiveMetastore(\n+            ExtendedHiveMetastore delegate,\n+            ExecutorService executor,\n+            OptionalLong expiresAfterWriteMillis,\n+            OptionalLong refreshMills,\n+            long maximumSize,\n+            boolean isPartitionVersioningEnabled,\n+            MetastoreCacheScope metastoreCacheScope)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n+        this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n+\n+        OptionalLong genExpiresAfterWriteMillis = metastoreCacheScope == ALL ? expiresAfterWriteMillis : OptionalLong.of(0);", "originalCommit": "90a8347876fd06cf657da35379631748cdec0fd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjA3NQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488912075", "bodyText": "Added a switch statement to set the cache configs.", "author": "NikhilCollooru", "createdAt": "2020-09-15T19:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyMzk0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex ff0e9d011b..924b272f15 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -138,42 +115,24 @@ public class CachingHiveMetastore\n                 newDirectExecutorService(),\n                 OptionalLong.empty(),\n                 OptionalLong.empty(),\n-                maximumSize,\n-                false,\n-                ALL);\n+                maximumSize);\n     }\n \n-    private CachingHiveMetastore(\n-            ExtendedHiveMetastore delegate,\n-            ExecutorService executor,\n-            OptionalLong expiresAfterWriteMillis,\n-            OptionalLong refreshMills,\n-            long maximumSize,\n-            boolean isPartitionVersioningEnabled,\n-            MetastoreCacheScope metastoreCacheScope)\n+    private CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, OptionalLong expiresAfterWriteMillis, OptionalLong refreshMills, long maximumSize)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n-        this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n-\n-        OptionalLong genExpiresAfterWriteMillis = metastoreCacheScope == ALL ? expiresAfterWriteMillis : OptionalLong.of(0);\n-        OptionalLong genRefreshMills = metastoreCacheScope == ALL ? refreshMills : OptionalLong.of(0);\n-        long genMaxSize = metastoreCacheScope == ALL ? maximumSize : 0;\n-\n-        OptionalLong partitionExpiresAfterWriteMillis = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? expiresAfterWriteMillis : OptionalLong.of(0);\n-        OptionalLong partitionRefreshMills = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? refreshMills : OptionalLong.of(0);\n-        long partitionCacheMaxSize = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? maximumSize : 0;\n \n-        databaseNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        databaseNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllDatabases), executor));\n \n-        databaseCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        databaseCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadDatabase), executor));\n \n-        tableNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        tableNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllTables), executor));\n \n-        tableStatisticsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        tableStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(new CacheLoader<HiveTableName, PartitionStatistics>()\n                 {\n                     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDAzMw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488824033", "bodyText": "What is gen?", "author": "shixuan-fan", "createdAt": "2020-09-15T17:04:53Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -120,24 +138,42 @@ public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delega\n                 newDirectExecutorService(),\n                 OptionalLong.empty(),\n                 OptionalLong.empty(),\n-                maximumSize);\n+                maximumSize,\n+                false,\n+                ALL);\n     }\n \n-    private CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, OptionalLong expiresAfterWriteMillis, OptionalLong refreshMills, long maximumSize)\n+    private CachingHiveMetastore(\n+            ExtendedHiveMetastore delegate,\n+            ExecutorService executor,\n+            OptionalLong expiresAfterWriteMillis,\n+            OptionalLong refreshMills,\n+            long maximumSize,\n+            boolean isPartitionVersioningEnabled,\n+            MetastoreCacheScope metastoreCacheScope)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n+        this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n+\n+        OptionalLong genExpiresAfterWriteMillis = metastoreCacheScope == ALL ? expiresAfterWriteMillis : OptionalLong.of(0);\n+        OptionalLong genRefreshMills = metastoreCacheScope == ALL ? refreshMills : OptionalLong.of(0);", "originalCommit": "90a8347876fd06cf657da35379631748cdec0fd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjUzOQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488912539", "bodyText": "I meant general. Renamed to cacheExpiresAfterWriteMillis", "author": "NikhilCollooru", "createdAt": "2020-09-15T19:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNDc2MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488914760", "bodyText": "I see. We use gen for async php code and I guess my mind just drifts to the wrong side \ud83d\ude02", "author": "shixuan-fan", "createdAt": "2020-09-15T19:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex ff0e9d011b..924b272f15 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -138,42 +115,24 @@ public class CachingHiveMetastore\n                 newDirectExecutorService(),\n                 OptionalLong.empty(),\n                 OptionalLong.empty(),\n-                maximumSize,\n-                false,\n-                ALL);\n+                maximumSize);\n     }\n \n-    private CachingHiveMetastore(\n-            ExtendedHiveMetastore delegate,\n-            ExecutorService executor,\n-            OptionalLong expiresAfterWriteMillis,\n-            OptionalLong refreshMills,\n-            long maximumSize,\n-            boolean isPartitionVersioningEnabled,\n-            MetastoreCacheScope metastoreCacheScope)\n+    private CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, OptionalLong expiresAfterWriteMillis, OptionalLong refreshMills, long maximumSize)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n-        this.isPartitionVersioningEnabled = isPartitionVersioningEnabled;\n-\n-        OptionalLong genExpiresAfterWriteMillis = metastoreCacheScope == ALL ? expiresAfterWriteMillis : OptionalLong.of(0);\n-        OptionalLong genRefreshMills = metastoreCacheScope == ALL ? refreshMills : OptionalLong.of(0);\n-        long genMaxSize = metastoreCacheScope == ALL ? maximumSize : 0;\n-\n-        OptionalLong partitionExpiresAfterWriteMillis = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? expiresAfterWriteMillis : OptionalLong.of(0);\n-        OptionalLong partitionRefreshMills = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? refreshMills : OptionalLong.of(0);\n-        long partitionCacheMaxSize = (metastoreCacheScope == ALL || metastoreCacheScope == PARTITION) ? maximumSize : 0;\n \n-        databaseNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        databaseNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllDatabases), executor));\n \n-        databaseCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        databaseCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadDatabase), executor));\n \n-        tableNamesCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        tableNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(CacheLoader.from(this::loadAllTables), executor));\n \n-        tableStatisticsCache = newCacheBuilder(genExpiresAfterWriteMillis, genRefreshMills, genMaxSize)\n+        tableStatisticsCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n                 .build(asyncReloading(new CacheLoader<HiveTableName, PartitionStatistics>()\n                 {\n                     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzQ1OQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r488827459", "bodyText": "For ExtendedHiveMetastore, we might be able to make it non-default and actually implement them (throw unsupported) in the implementations?", "author": "shixuan-fan", "createdAt": "2020-09-15T17:10:56Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/ExtendedHiveMetastore.java", "diffHunk": "@@ -82,6 +82,14 @@\n             String tableName,\n             Map<Column, Domain> partitionPredicates);\n \n+    default List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(", "originalCommit": "90a8347876fd06cf657da35379631748cdec0fd8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/ExtendedHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/ExtendedHiveMetastore.java\nindex 214b94debc..5a053a83bd 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/ExtendedHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/ExtendedHiveMetastore.java\n\n@@ -82,14 +82,6 @@ public interface ExtendedHiveMetastore\n             String tableName,\n             Map<Column, Domain> partitionPredicates);\n \n-    default List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(\n-            String databaseName,\n-            String tableName,\n-            Map<Column, Domain> partitionPredicates)\n-    {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     Map<String, Optional<Partition>> getPartitionsByNames(String databaseName, String tableName, List<String> partitionNames);\n \n     void addPartitions(String databaseName, String tableName, List<PartitionWithStatistics> partitions);\n"}}, {"oid": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "url": "https://github.com/prestodb/presto/commit/363e5ab86ac68077f95f35a05a6b82d2844ce797", "message": "Add optional version parameter to metastore Partition", "committedDate": "2020-09-15T19:03:19Z", "type": "commit"}, {"oid": "11c7199a1c35a959009a62207c16ccc14ae78e2a", "url": "https://github.com/prestodb/presto/commit/11c7199a1c35a959009a62207c16ccc14ae78e2a", "message": "Add config to enable Partition versioning", "committedDate": "2020-09-15T19:03:19Z", "type": "commit"}, {"oid": "8a94c2d2dc239f774a17530c21218a74bb558ce9", "url": "https://github.com/prestodb/presto/commit/8a94c2d2dc239f774a17530c21218a74bb558ce9", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-15T19:03:19Z", "type": "forcePushed"}, {"oid": "4bfaf38413ad9205e1c8dc3a152660fb56c31203", "url": "https://github.com/prestodb/presto/commit/4bfaf38413ad9205e1c8dc3a152660fb56c31203", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-16T03:06:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzMjMyMw==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r489632323", "bodyText": "nit: how about moving the following assignments under case ALL, and throw for default?", "author": "shixuan-fan", "createdAt": "2020-09-16T18:19:35Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -120,24 +137,63 @@ public static CachingHiveMetastore memoizeMetastore(ExtendedHiveMetastore delega\n                 newDirectExecutorService(),\n                 OptionalLong.empty(),\n                 OptionalLong.empty(),\n-                maximumSize);\n+                maximumSize,\n+                false,\n+                ALL);\n     }\n \n-    private CachingHiveMetastore(ExtendedHiveMetastore delegate, ExecutorService executor, OptionalLong expiresAfterWriteMillis, OptionalLong refreshMills, long maximumSize)\n+    private CachingHiveMetastore(\n+            ExtendedHiveMetastore delegate,\n+            ExecutorService executor,\n+            OptionalLong expiresAfterWriteMillis,\n+            OptionalLong refreshMills,\n+            long maximumSize,\n+            boolean partitionVersioningEnabled,\n+            MetastoreCacheScope metastoreCacheScope)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n         requireNonNull(executor, \"executor is null\");\n-\n-        databaseNamesCache = newCacheBuilder(expiresAfterWriteMillis, refreshMills, maximumSize)\n+        this.partitionVersioningEnabled = partitionVersioningEnabled;\n+\n+        OptionalLong cacheExpiresAfterWriteMillis;\n+        OptionalLong cacheRefreshMills;\n+        long cacheMaxSize;\n+\n+        OptionalLong partitionCacheExpiresAfterWriteMillis;\n+        OptionalLong partitionCacheRefreshMills;\n+        long partitionCacheMaxSize;\n+\n+        switch (metastoreCacheScope) {\n+            case PARTITION:\n+                partitionCacheExpiresAfterWriteMillis = expiresAfterWriteMillis;\n+                partitionCacheRefreshMills = refreshMills;\n+                partitionCacheMaxSize = maximumSize;\n+                cacheExpiresAfterWriteMillis = OptionalLong.of(0);\n+                cacheRefreshMills = OptionalLong.of(0);\n+                cacheMaxSize = 0;\n+                break;\n+\n+            case ALL:\n+            default:", "originalCommit": "4bfaf38413ad9205e1c8dc3a152660fb56c31203", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1532679db09564fb0259af2e2aef39da677be4c", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex f52ce7412b..bb6bb224b3 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -174,7 +174,6 @@ public class CachingHiveMetastore\n                 break;\n \n             case ALL:\n-            default:\n                 partitionCacheExpiresAfterWriteMillis = expiresAfterWriteMillis;\n                 partitionCacheRefreshMills = refreshMills;\n                 partitionCacheMaxSize = maximumSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzNDY4OA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r489634688", "bodyText": "This function is only called when partitionVersioningEnabled is true, so I'm wondering if we should actually treat version not existing as stale? I don't have preference, just a random thought.", "author": "shixuan-fan", "createdAt": "2020-09-16T18:23:58Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -535,11 +591,39 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (partitionVersioningEnabled) {\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n+            return result;\n+        }\n         return get(\n                 partitionFilterCache,\n                 partitionFilter(databaseName, tableName, partitionPredicates));\n     }\n \n+    @Override\n+    public List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(\n+            String databaseName,\n+            String tableName,\n+            Map<Column, Domain> partitionPredicates)\n+    {\n+        return delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+    }\n+\n+    private void invalidateStalePartition(PartitionNameWithVersion partitionNameWithVersion, String databaseName, String tableName)\n+    {\n+        HivePartitionName hivePartitionName = hivePartitionName(databaseName, tableName, partitionNameWithVersion.getPartitionName());\n+        Optional<Partition> partition = partitionCache.getIfPresent(hivePartitionName);\n+        if (partition != null && partition.isPresent()) {\n+            Optional<Integer> partitionVersion = partition.get().getPartitionVersion();\n+            if (partitionVersion.isPresent() && partitionVersion.get() < partitionNameWithVersion.getPartitionVersion()) {", "originalCommit": "4bfaf38413ad9205e1c8dc3a152660fb56c31203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0NDk5OQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r490044999", "bodyText": "I made changes to consider the partition stale if the version is empty. This will also help testing.", "author": "NikhilCollooru", "createdAt": "2020-09-17T07:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzNDY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d1532679db09564fb0259af2e2aef39da677be4c", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex f52ce7412b..bb6bb224b3 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -617,7 +619,7 @@ public class CachingHiveMetastore\n         Optional<Partition> partition = partitionCache.getIfPresent(hivePartitionName);\n         if (partition != null && partition.isPresent()) {\n             Optional<Integer> partitionVersion = partition.get().getPartitionVersion();\n-            if (partitionVersion.isPresent() && partitionVersion.get() < partitionNameWithVersion.getPartitionVersion()) {\n+            if (!partitionVersion.isPresent() || partitionVersion.get() < partitionNameWithVersion.getPartitionVersion()) {\n                 partitionCache.invalidate(hivePartitionName);\n                 partitionStatisticsCache.invalidate(hivePartitionName);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzODcxNQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r489638715", "bodyText": "We probably could add some unit tests for this by calling getPartitionNamesByFilter in TestCachingHiveMetastore since this is the core logic for this feature.", "author": "shixuan-fan", "createdAt": "2020-09-16T18:28:11Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java", "diffHunk": "@@ -535,11 +591,39 @@ protected void invalidateTable(String databaseName, String tableName)\n             String tableName,\n             Map<Column, Domain> partitionPredicates)\n     {\n+        if (partitionVersioningEnabled) {\n+            List<PartitionNameWithVersion> partitionNamesWithVersion = getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+            List<String> result = partitionNamesWithVersion.stream().map(PartitionNameWithVersion::getPartitionName).collect(toImmutableList());\n+            partitionNamesWithVersion.forEach(partitionNameWithVersion -> invalidateStalePartition(partitionNameWithVersion, databaseName, tableName));\n+            return result;\n+        }\n         return get(\n                 partitionFilterCache,\n                 partitionFilter(databaseName, tableName, partitionPredicates));\n     }\n \n+    @Override\n+    public List<PartitionNameWithVersion> getPartitionNamesWithVersionByFilter(\n+            String databaseName,\n+            String tableName,\n+            Map<Column, Domain> partitionPredicates)\n+    {\n+        return delegate.getPartitionNamesWithVersionByFilter(databaseName, tableName, partitionPredicates);\n+    }\n+\n+    private void invalidateStalePartition(PartitionNameWithVersion partitionNameWithVersion, String databaseName, String tableName)", "originalCommit": "4bfaf38413ad9205e1c8dc3a152660fb56c31203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0NTk5MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r490045990", "bodyText": "Added testCachingWithPartitionVersioning() to TestCachingHiveMetastore", "author": "NikhilCollooru", "createdAt": "2020-09-17T07:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYzODcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d1532679db09564fb0259af2e2aef39da677be4c", "chunk": "diff --git a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\nindex f52ce7412b..bb6bb224b3 100644\n--- a/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n+++ b/presto-hive-metastore/src/main/java/com/facebook/presto/hive/metastore/CachingHiveMetastore.java\n\n@@ -617,7 +619,7 @@ public class CachingHiveMetastore\n         Optional<Partition> partition = partitionCache.getIfPresent(hivePartitionName);\n         if (partition != null && partition.isPresent()) {\n             Optional<Integer> partitionVersion = partition.get().getPartitionVersion();\n-            if (partitionVersion.isPresent() && partitionVersion.get() < partitionNameWithVersion.getPartitionVersion()) {\n+            if (!partitionVersion.isPresent() || partitionVersion.get() < partitionNameWithVersion.getPartitionVersion()) {\n                 partitionCache.invalidate(hivePartitionName);\n                 partitionStatisticsCache.invalidate(hivePartitionName);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY0NDU4MA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r489644580", "bodyText": "Not high priority for this PR, but might worth thinking about how to handle open partitions (where data is still actively being ingested to the partition, internally known as NRT). These partitions might not be cacheable across queries, especially partition stats.", "author": "shixuan-fan", "createdAt": "2020-09-16T18:32:58Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/PartitionVersionFetcher.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+\n+import java.util.Optional;\n+\n+public interface PartitionVersionFetcher\n+{\n+    Optional<Integer> getPartitionVersion(Partition partition);", "originalCommit": "363e5ab86ac68077f95f35a05a6b82d2844ce797", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5NTI1Mg==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r490495252", "bodyText": "This is a very good point !. Looks like we have a enum in the FB Partition metadata that tells us if the partition in APPENDABLE or FINALIZED. Will send out another PR to fix the caching in such case.", "author": "NikhilCollooru", "createdAt": "2020-09-17T19:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY0NDU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwNDk1OQ==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r490504959", "bodyText": "Yeah, we should not cache the in progress partitions.", "author": "jainxrohit", "createdAt": "2020-09-17T19:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY0NDU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMzA4OA==", "url": "https://github.com/prestodb/presto/pull/15044#discussion_r490513088", "bodyText": "Looks like we could just skip providing versions for in progress partitions so we would always treat it as stale :D Let's have a follow up PR for this in the internal repo.", "author": "shixuan-fan", "createdAt": "2020-09-17T19:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY0NDU4MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "d1532679db09564fb0259af2e2aef39da677be4c", "url": "https://github.com/prestodb/presto/commit/d1532679db09564fb0259af2e2aef39da677be4c", "message": "Add new getPartitionNamesWithVersionByFilter metastore api", "committedDate": "2020-09-17T07:20:39Z", "type": "commit"}, {"oid": "8fb17fcbff686faa878eb6b73eac8707cee4125a", "url": "https://github.com/prestodb/presto/commit/8fb17fcbff686faa878eb6b73eac8707cee4125a", "message": "Add unit tests for partition versioning enabled Metastore", "committedDate": "2020-09-17T07:50:17Z", "type": "forcePushed"}, {"oid": "e80b7a85dc257ebbe2508f0e114399d8f1413a05", "url": "https://github.com/prestodb/presto/commit/e80b7a85dc257ebbe2508f0e114399d8f1413a05", "message": "Add unit tests for partition versioning enabled Metastore", "committedDate": "2020-09-17T16:41:07Z", "type": "commit"}, {"oid": "e80b7a85dc257ebbe2508f0e114399d8f1413a05", "url": "https://github.com/prestodb/presto/commit/e80b7a85dc257ebbe2508f0e114399d8f1413a05", "message": "Add unit tests for partition versioning enabled Metastore", "committedDate": "2020-09-17T16:41:07Z", "type": "forcePushed"}]}