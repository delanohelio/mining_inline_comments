{"pr_number": 14095, "pr_title": "Add soft affinity in scheduling bucketed split for Hive Connector", "pr_createdAt": "2020-02-13T08:45:08Z", "pr_url": "https://github.com/prestodb/presto/pull/14095", "timeline": [{"oid": "7200e44e194304de3864d1315b273a846c95c788", "url": "https://github.com/prestodb/presto/commit/7200e44e194304de3864d1315b273a846c95c788", "message": "Add SoftAffinityNodeSelection ability for bucketed splits", "committedDate": "2020-02-14T02:39:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIyNzc0OA==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r379227748", "bodyText": "break a line", "author": "highker", "createdAt": "2020-02-14T02:49:28Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotNodePartitioningProvider.java", "diffHunk": "@@ -32,7 +33,7 @@\n     public ConnectorBucketNodeMap getBucketNodeMap(\n             ConnectorTransactionHandle transactionHandle,\n             ConnectorSession session,\n-            ConnectorPartitioningHandle partitioningHandle)\n+            ConnectorPartitioningHandle partitioningHandle, List<Node> sortedNodes)", "originalCommit": "7200e44e194304de3864d1315b273a846c95c788", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "chunk": "diff --git a/presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotNodePartitioningProvider.java b/presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotNodePartitioningProvider.java\nindex 7e0b68f1dd..a7500a4d8f 100644\n--- a/presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotNodePartitioningProvider.java\n+++ b/presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotNodePartitioningProvider.java\n\n@@ -33,7 +33,8 @@ public class PinotNodePartitioningProvider\n     public ConnectorBucketNodeMap getBucketNodeMap(\n             ConnectorTransactionHandle transactionHandle,\n             ConnectorSession session,\n-            ConnectorPartitioningHandle partitioningHandle, List<Node> sortedNodes)\n+            ConnectorPartitioningHandle partitioningHandle,\n+            List<Node> sortedNodes)\n     {\n         return ConnectorBucketNodeMap.createBucketNodeMap(1);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1MzE1MQ==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r379553151", "bodyText": "Since we are already splitting this from the #13966 , let's make sure we don't create a FixedBucketNodeMap for SOFT_AFFINITY so it would play well with DynamicLifespanScheduler, and thus this pull request is self-consistent. Basically we need the functionality in DynamicBucketNodeMap to be able to accept a map as initial state and allow further updates to the map as scheduler sees fit.", "author": "shixuan-fan", "createdAt": "2020-02-14T17:26:31Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/NodePartitioningManager.java", "diffHunk": "@@ -151,21 +165,30 @@ public NodePartitionMap getNodePartitioningMap(Session session, PartitioningHand\n \n     public BucketNodeMap getBucketNodeMap(Session session, PartitioningHandle partitioningHandle, boolean preferDynamic)\n     {\n-        ConnectorBucketNodeMap connectorBucketNodeMap = getConnectorBucketNodeMap(session, partitioningHandle);\n-\n-        if (connectorBucketNodeMap.hasFixedMapping()) {\n-            return new FixedBucketNodeMap(getSplitToBucket(session, partitioningHandle), getFixedMapping(connectorBucketNodeMap));\n-        }\n-\n-        if (preferDynamic) {\n-            return new DynamicBucketNodeMap(getSplitToBucket(session, partitioningHandle), connectorBucketNodeMap.getBucketCount());\n+        ConnectorId connectorId = partitioningHandle.getConnectorId()\n+                .orElseThrow(() -> new IllegalArgumentException(\"No connector ID for partitioning handle: \" + partitioningHandle));\n+        List<Node> sortedNodes = sortedNodes(connectorId);\n+\n+        ConnectorBucketNodeMap connectorBucketNodeMap = getConnectorBucketNodeMap(session, partitioningHandle, sortedNodes);\n+\n+        NodeSelectionStrategy nodeSelectionStrategy = connectorBucketNodeMap.getNodeSelectionStrategy();\n+        switch (nodeSelectionStrategy) {\n+            case HARD_AFFINITY:\n+            case SOFT_AFFINITY:\n+                // todo for soft affinity, we need to add logic if preferDynamic is true", "originalCommit": "7200e44e194304de3864d1315b273a846c95c788", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyODQwMQ==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382728401", "bodyText": "Consider removing TODO here assuming it is supported in the following commit?", "author": "shixuan-fan", "createdAt": "2020-02-21T18:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1MzE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/sql/planner/NodePartitioningManager.java b/presto-main/src/main/java/com/facebook/presto/sql/planner/NodePartitioningManager.java\nindex 7a50b6b922..b994742e90 100644\n--- a/presto-main/src/main/java/com/facebook/presto/sql/planner/NodePartitioningManager.java\n+++ b/presto-main/src/main/java/com/facebook/presto/sql/planner/NodePartitioningManager.java\n\n@@ -165,17 +163,16 @@ public class NodePartitioningManager\n \n     public BucketNodeMap getBucketNodeMap(Session session, PartitioningHandle partitioningHandle, boolean preferDynamic)\n     {\n-        ConnectorId connectorId = partitioningHandle.getConnectorId()\n-                .orElseThrow(() -> new IllegalArgumentException(\"No connector ID for partitioning handle: \" + partitioningHandle));\n-        List<Node> sortedNodes = sortedNodes(connectorId);\n-\n-        ConnectorBucketNodeMap connectorBucketNodeMap = getConnectorBucketNodeMap(session, partitioningHandle, sortedNodes);\n+        ConnectorBucketNodeMap connectorBucketNodeMap = getConnectorBucketNodeMap(session, partitioningHandle);\n \n         NodeSelectionStrategy nodeSelectionStrategy = connectorBucketNodeMap.getNodeSelectionStrategy();\n         switch (nodeSelectionStrategy) {\n             case HARD_AFFINITY:\n+                return new FixedBucketNodeMap(getSplitToBucket(session, partitioningHandle), getFixedMapping(connectorBucketNodeMap));\n             case SOFT_AFFINITY:\n-                // todo for soft affinity, we need to add logic if preferDynamic is true\n+                if (preferDynamic) {\n+                    return new DynamicBucketNodeMap(getSplitToBucket(session, partitioningHandle), connectorBucketNodeMap.getBucketCount(), getFixedMapping(connectorBucketNodeMap));\n+                }\n                 return new FixedBucketNodeMap(getSplitToBucket(session, partitioningHandle), getFixedMapping(connectorBucketNodeMap));\n             case NO_PREFERENCE:\n                 if (preferDynamic) {\n"}}, {"oid": "6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "url": "https://github.com/prestodb/presto/commit/6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "message": "Add dynamic schedule logic in soft affinity for bucketed splits", "committedDate": "2020-02-18T07:12:59Z", "type": "forcePushed"}, {"oid": "586776b22c337a768e330278538b44907e48f018", "url": "https://github.com/prestodb/presto/commit/586776b22c337a768e330278538b44907e48f018", "message": "Add dynamic schedule logic in soft affinity for bucketed splits", "committedDate": "2020-02-18T20:48:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2NzE4Mg==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r380867182", "bodyText": "nit: this.fixedMappingNodes = Optional.of(requireNonNull(fixedMappingNodes, \"fixedMappingNodes is null\"));", "author": "shixuan-fan", "createdAt": "2020-02-18T18:52:09Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -30,12 +32,23 @@\n {\n     private final int bucketCount;\n     private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n+    private final Optional<List<InternalNode>> fixedMappingNodes;\n \n     public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         this.bucketCount = bucketCount;\n+        this.fixedMappingNodes = Optional.empty();\n+    }\n+\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> fixedMappingNodes)\n+    {\n+        super(splitToBucket);\n+        checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n+        this.bucketCount = bucketCount;\n+        requireNonNull(fixedMappingNodes, \"fixedMappingNodes is null\");\n+        this.fixedMappingNodes = Optional.of(fixedMappingNodes);", "originalCommit": "6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c07b2c397314df3a5cd76920934328d84b0c783", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex 00bb681222..781a6afe33 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -32,23 +30,12 @@ public class DynamicBucketNodeMap\n {\n     private final int bucketCount;\n     private final Int2ObjectMap<InternalNode> bucketToNode = new Int2ObjectOpenHashMap<>();\n-    private final Optional<List<InternalNode>> fixedMappingNodes;\n \n     public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n         this.bucketCount = bucketCount;\n-        this.fixedMappingNodes = Optional.empty();\n-    }\n-\n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> fixedMappingNodes)\n-    {\n-        super(splitToBucket);\n-        checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n-        this.bucketCount = bucketCount;\n-        requireNonNull(fixedMappingNodes, \"fixedMappingNodes is null\");\n-        this.fixedMappingNodes = Optional.of(fixedMappingNodes);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg3MDY0Mg==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r380870642", "bodyText": "I don't think this is correct because nodeByTaskId is mapped by task id, yet bucketToNode is mapped by buckets. In most cases one task would handle multiple buckets sequentially, at least in facebook's setup.\nThe expected changes should happen in scheduleInitial and schedule. Basically when try to assign a driverGroup (i.e. worker concept of hive bucket), try to first check bucketNodeMap to find a preferred node. If the task on that node failed, then just select a random node.", "author": "shixuan-fan", "createdAt": "2020-02-18T18:58:25Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -73,7 +73,12 @@ public DynamicLifespanScheduler(\n             OptionalInt concurrentLifespansPerTask)\n     {\n         this.bucketNodeMap = requireNonNull(bucketNodeMap, \"bucketNodeMap is null\");\n-        this.nodeByTaskId = requireNonNull(nodeByTaskId, \"nodeByTaskId is null\");\n+        if (bucketNodeMap.isDynamic() && bucketNodeMap.getBucketToNode().size() != 0) {", "originalCommit": "6fc2e1734ef97a1966d6fb74a40dde2221b4d986", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c07b2c397314df3a5cd76920934328d84b0c783", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex 232c8cfe15..01b29e8209 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -73,12 +73,7 @@ public class DynamicLifespanScheduler\n             OptionalInt concurrentLifespansPerTask)\n     {\n         this.bucketNodeMap = requireNonNull(bucketNodeMap, \"bucketNodeMap is null\");\n-        if (bucketNodeMap.isDynamic() && bucketNodeMap.getBucketToNode().size() != 0) {\n-            this.nodeByTaskId = bucketNodeMap.getBucketToNode();\n-        }\n-        else {\n-            this.nodeByTaskId = requireNonNull(nodeByTaskId, \"nodeByTaskId is null\");\n-        }\n+        this.nodeByTaskId = requireNonNull(nodeByTaskId, \"nodeByTaskId is null\");\n         this.partitionHandles = unmodifiableList(new ArrayList<>(\n                 requireNonNull(partitionHandles, \"partitionHandles is null\")));\n \n"}}, {"oid": "8c07b2c397314df3a5cd76920934328d84b0c783", "url": "https://github.com/prestodb/presto/commit/8c07b2c397314df3a5cd76920934328d84b0c783", "message": "Add SoftAffinity ability for bucketed splits on engine side", "committedDate": "2020-02-18T20:48:54Z", "type": "forcePushed"}, {"oid": "bf37435a828a645e2b4bf2b3fc1f9c5fc6c9084d", "url": "https://github.com/prestodb/presto/commit/bf37435a828a645e2b4bf2b3fc1f9c5fc6c9084d", "message": "Add dynamic schedule logic in soft affinity for bucketed splits", "committedDate": "2020-02-21T00:27:20Z", "type": "forcePushed"}, {"oid": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "url": "https://github.com/prestodb/presto/commit/daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "message": "Add dynamic schedule logic in soft affinity for bucketed splits", "committedDate": "2020-02-21T00:38:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMjkyNA==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382732924", "bodyText": "nit: bucketToNodeList is a bit ambiguous given we already have bucketToNode. How about BucketToPreferredNode?", "author": "shixuan-fan", "createdAt": "2020-02-21T18:19:41Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java", "diffHunk": "@@ -38,6 +39,17 @@ public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount)\n         this.bucketCount = bucketCount;\n     }\n \n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToNodeList)", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\nindex 411cf77121..dcd350c743 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicBucketNodeMap.java\n\n@@ -39,13 +39,13 @@ public class DynamicBucketNodeMap\n         this.bucketCount = bucketCount;\n     }\n \n-    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToNodeList)\n+    public DynamicBucketNodeMap(ToIntFunction<Split> splitToBucket, int bucketCount, List<InternalNode> bucketToPreferredNode)\n     {\n         super(splitToBucket);\n         checkArgument(bucketCount > 0, \"bucketCount must be positive\");\n-        checkArgument(bucketToNodeList.size() == bucketCount, \"bucketToNodeList size must be equal to bucketCount\");\n+        checkArgument(bucketToPreferredNode.size() == bucketCount, \"bucketToPreferredNode size must be equal to bucketCount\");\n         for (int bucketNumber = 0; bucketNumber < bucketCount; bucketNumber++) {\n-            bucketToNode.put(bucketNumber, bucketToNodeList.get(bucketNumber));\n+            bucketToNode.put(bucketNumber, bucketToPreferredNode.get(bucketNumber));\n         }\n         this.bucketCount = bucketCount;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNDA1Mg==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382734052", "bodyText": "Maybe this should be a local variable?", "author": "shixuan-fan", "createdAt": "2020-02-21T18:22:03Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -45,12 +49,14 @@\n \n     private final BucketNodeMap bucketNodeMap;\n     private final List<InternalNode> nodeByTaskId;\n+    private final Set<InternalNode> nodeSet;", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -49,14 +49,13 @@ public class DynamicLifespanScheduler\n \n     private final BucketNodeMap bucketNodeMap;\n     private final List<InternalNode> nodeByTaskId;\n-    private final Set<InternalNode> nodeSet;\n     private final List<ConnectorPartitionHandle> partitionHandles;\n     private final OptionalInt concurrentLifespansPerTask;\n \n     private final IntSet[] runningDriverGroupIdsByTask;\n     private final int[] taskByDriverGroup;\n-    private final IntArrayFIFOQueue driverGroupNoPreferenceQueue;\n-    private final Map<InternalNode, IntArrayFIFOQueue> driverGroupWithPreferenceMapQueue;\n+    private final IntArrayFIFOQueue noPreferenceDriverGroups;\n+    private final Map<InternalNode, IntArrayFIFOQueue> nodeToPreferredDriverGroups;\n     private final IntSet failedTasks;\n \n     // initialScheduled does not need to be guarded because this object\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNDQ0Mw==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382734443", "bodyText": "How about nodeToPreferredDriverGroupQueue?", "author": "shixuan-fan", "createdAt": "2020-02-21T18:22:59Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -45,12 +49,14 @@\n \n     private final BucketNodeMap bucketNodeMap;\n     private final List<InternalNode> nodeByTaskId;\n+    private final Set<InternalNode> nodeSet;\n     private final List<ConnectorPartitionHandle> partitionHandles;\n     private final OptionalInt concurrentLifespansPerTask;\n \n     private final IntSet[] runningDriverGroupIdsByTask;\n     private final int[] taskByDriverGroup;\n-    private final IntArrayFIFOQueue driverGroupQueue;\n+    private final IntArrayFIFOQueue driverGroupNoPreferenceQueue;\n+    private final Map<InternalNode, IntArrayFIFOQueue> driverGroupWithPreferenceMapQueue;", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -49,14 +49,13 @@ public class DynamicLifespanScheduler\n \n     private final BucketNodeMap bucketNodeMap;\n     private final List<InternalNode> nodeByTaskId;\n-    private final Set<InternalNode> nodeSet;\n     private final List<ConnectorPartitionHandle> partitionHandles;\n     private final OptionalInt concurrentLifespansPerTask;\n \n     private final IntSet[] runningDriverGroupIdsByTask;\n     private final int[] taskByDriverGroup;\n-    private final IntArrayFIFOQueue driverGroupNoPreferenceQueue;\n-    private final Map<InternalNode, IntArrayFIFOQueue> driverGroupWithPreferenceMapQueue;\n+    private final IntArrayFIFOQueue noPreferenceDriverGroups;\n+    private final Map<InternalNode, IntArrayFIFOQueue> nodeToPreferredDriverGroups;\n     private final IntSet failedTasks;\n \n     // initialScheduled does not need to be guarded because this object\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczOTE1Mg==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382739152", "bodyText": "This seems to be a bit inefficient when there is no preferredNodes, which is the default setting. Could we instead iterate on nodes? We probably would need to have a reverse mapping (node -> buckets) in DynamicBucketNodeMap.", "author": "shixuan-fan", "createdAt": "2020-02-21T18:33:04Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -87,11 +94,23 @@ public DynamicLifespanScheduler(\n             runningDriverGroupIdsByTask[i] = new IntOpenHashSet();\n         }\n         this.taskByDriverGroup = new int[bucketCount];\n-        this.driverGroupQueue = new IntArrayFIFOQueue(bucketCount);\n         for (int i = 0; i < bucketCount; i++) {\n             taskByDriverGroup[i] = NOT_ASSIGNED;\n-            driverGroupQueue.enqueue(i);\n         }\n+\n+        this.driverGroupNoPreferenceQueue = new IntArrayFIFOQueue();\n+        this.driverGroupWithPreferenceMapQueue = new HashMap<>();\n+        for (int driverGroup = 0; driverGroup < bucketCount; driverGroup++) {", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -94,23 +92,20 @@ public class DynamicLifespanScheduler\n             runningDriverGroupIdsByTask[i] = new IntOpenHashSet();\n         }\n         this.taskByDriverGroup = new int[bucketCount];\n+        this.noPreferenceDriverGroups = new IntArrayFIFOQueue();\n+        this.nodeToPreferredDriverGroups = new HashMap<>();\n+        Set<InternalNode> nodeSet = ImmutableSet.copyOf(nodeByTaskId);\n         for (int i = 0; i < bucketCount; i++) {\n             taskByDriverGroup[i] = NOT_ASSIGNED;\n-        }\n-\n-        this.driverGroupNoPreferenceQueue = new IntArrayFIFOQueue();\n-        this.driverGroupWithPreferenceMapQueue = new HashMap<>();\n-        for (int driverGroup = 0; driverGroup < bucketCount; driverGroup++) {\n-            if (bucketNodeMap.getAssignedNode(driverGroup).isPresent() && nodeSet.contains(bucketNodeMap.getAssignedNode(driverGroup).get())) {\n-                InternalNode preferredNode = bucketNodeMap.getAssignedNode(driverGroup).get();\n-                driverGroupWithPreferenceMapQueue.computeIfAbsent(preferredNode, k -> new IntArrayFIFOQueue());\n-                driverGroupWithPreferenceMapQueue.get(preferredNode).enqueue(driverGroup);\n+            if (bucketNodeMap.getAssignedNode(i).isPresent() && nodeSet.contains(bucketNodeMap.getAssignedNode(i).get())) {\n+                InternalNode preferredNode = bucketNodeMap.getAssignedNode(i).get();\n+                nodeToPreferredDriverGroups.computeIfAbsent(preferredNode, k -> new IntArrayFIFOQueue());\n+                nodeToPreferredDriverGroups.get(preferredNode).enqueue(i);\n             }\n             else {\n-                driverGroupNoPreferenceQueue.enqueue(driverGroup);\n+                noPreferenceDriverGroups.enqueue(i);\n             }\n         }\n-\n         this.failedTasks = new IntOpenHashSet();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MDcwMg==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382740702", "bodyText": "Instead of magical -1, how about returning OptionalInt?", "author": "shixuan-fan", "createdAt": "2020-02-21T18:36:34Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -102,14 +121,16 @@ public void scheduleInitial(SourceScheduler scheduler)\n \n         int driverGroupsScheduledPerTask = 0;\n         synchronized (this) {\n-            while (!driverGroupQueue.isEmpty()) {\n-                for (int i = 0; i < nodeByTaskId.size() && !driverGroupQueue.isEmpty(); i++) {\n-                    int driverGroupId = driverGroupQueue.dequeueInt();\n-                    checkState(!bucketNodeMap.getAssignedNode(driverGroupId).isPresent());\n-                    bucketNodeMap.assignOrUpdateBucketToNode(driverGroupId, nodeByTaskId.get(i));\n+            while (!driverGroupNoPreferenceQueue.isEmpty() || !driverGroupWithPreferenceMapQueue.isEmpty()) {\n+                for (int taskId = 0; taskId < nodeByTaskId.size() && (!driverGroupNoPreferenceQueue.isEmpty() || !driverGroupWithPreferenceMapQueue.isEmpty()); taskId++) {\n+                    InternalNode node = nodeByTaskId.get(taskId);\n+                    int driverGroupId = pickDriverGroupForNode(node);\n+                    if (driverGroupId == -1) {", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -121,16 +116,16 @@ public class DynamicLifespanScheduler\n \n         int driverGroupsScheduledPerTask = 0;\n         synchronized (this) {\n-            while (!driverGroupNoPreferenceQueue.isEmpty() || !driverGroupWithPreferenceMapQueue.isEmpty()) {\n-                for (int taskId = 0; taskId < nodeByTaskId.size() && (!driverGroupNoPreferenceQueue.isEmpty() || !driverGroupWithPreferenceMapQueue.isEmpty()); taskId++) {\n+            while (!noPreferenceDriverGroups.isEmpty() || !nodeToPreferredDriverGroups.isEmpty()) {\n+                for (int taskId = 0; taskId < nodeByTaskId.size() && (!noPreferenceDriverGroups.isEmpty() || !nodeToPreferredDriverGroups.isEmpty()); taskId++) {\n                     InternalNode node = nodeByTaskId.get(taskId);\n-                    int driverGroupId = pickDriverGroupForNode(node);\n-                    if (driverGroupId == -1) {\n+                    OptionalInt driverGroupId = getNextDriverGroup(node);\n+                    if (!driverGroupId.isPresent()) {\n                         continue;\n                     }\n-                    scheduler.startLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId));\n-                    taskByDriverGroup[driverGroupId] = taskId;\n-                    runningDriverGroupIdsByTask[taskId].add(driverGroupId);\n+                    scheduler.startLifespan(Lifespan.driverGroup(driverGroupId.getAsInt()), partitionHandles.get(driverGroupId.getAsInt()));\n+                    taskByDriverGroup[driverGroupId.getAsInt()] = taskId;\n+                    runningDriverGroupIdsByTask[taskId].add(driverGroupId.getAsInt());\n                 }\n \n                 driverGroupsScheduledPerTask++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MzI0MQ==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382743241", "bodyText": "Let's write it in this way:\nif (nodeToPreferredDriverGroupQueue.containsKey(nodeByTaskId.get(taskId)) {\n  Queue<...> preferredDriverGroupQueue = nodeToPreferredDriverGroupQueue.get(...);\n  while (!preferredDriverGroupQueue.isEmpty()) {\n    driverGroupNoPreferenceQueue.enqueue(preferredDriverGroupQueue.deque());\n  }\n}\n\nAlso add a comment explaining what the purpose is for this piece of code :)", "author": "shixuan-fan", "createdAt": "2020-02-21T18:42:13Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -151,8 +172,12 @@ public void onTaskFailed(int taskId, List<SourceScheduler> sourceSchedulers)\n                 for (SourceScheduler sourceScheduler : sourceSchedulers) {\n                     sourceScheduler.rewindLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId));\n                 }\n-                driverGroupQueue.enqueue(driverGroupId);\n+                driverGroupNoPreferenceQueue.enqueue(driverGroupId);\n+            }\n+            while (driverGroupWithPreferenceMapQueue.get(nodeByTaskId.get(taskId)) != null && !driverGroupWithPreferenceMapQueue.get(nodeByTaskId.get(taskId)).isEmpty()) {", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -172,12 +167,19 @@ public class DynamicLifespanScheduler\n                 for (SourceScheduler sourceScheduler : sourceSchedulers) {\n                     sourceScheduler.rewindLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId));\n                 }\n-                driverGroupNoPreferenceQueue.enqueue(driverGroupId);\n+                noPreferenceDriverGroups.enqueue(driverGroupId);\n             }\n-            while (driverGroupWithPreferenceMapQueue.get(nodeByTaskId.get(taskId)) != null && !driverGroupWithPreferenceMapQueue.get(nodeByTaskId.get(taskId)).isEmpty()) {\n-                driverGroupNoPreferenceQueue.enqueue(driverGroupWithPreferenceMapQueue.get(nodeByTaskId.get(taskId)).dequeueInt());\n+\n+            // when a task fails, all driverGroups that prefer this task/node would be not able to execute\n+            // thus they should be relocated to driverGroupNoPreferenceQueue\n+            if (nodeToPreferredDriverGroups.containsKey(nodeByTaskId.get(taskId))) {\n+                IntArrayFIFOQueue preferredDriverGroupQueue = nodeToPreferredDriverGroups.get(nodeByTaskId.get(taskId));\n+                while (!preferredDriverGroupQueue.isEmpty()) {\n+                    noPreferenceDriverGroups.enqueue(preferredDriverGroupQueue.dequeueInt());\n+                }\n+                nodeToPreferredDriverGroups.remove(nodeByTaskId.get(taskId));\n             }\n-            driverGroupWithPreferenceMapQueue.remove(nodeByTaskId.get(taskId));\n+\n             runningDriverGroupIdsByTask[taskId].clear();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4ODM2Nw==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382788367", "bodyText": "Let's make it clearer, for example:\nTODO: After initial scheduling, tasks would only be available after they finished at least one bucket. This is not necessarily the case if the initial scheduling covered all buckets and the available slots is not fully utilized (concurrentLifespansPerTask is large or infinite). In this case if a task failed, the recovered driver groups have to wait for tasks to be available again after finishing at least one bucket, even though by definition of concurrentLifespansPerTask they are already available.", "author": "shixuan-fan", "createdAt": "2020-02-21T20:23:06Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -162,20 +187,23 @@ public SettableFuture schedule(SourceScheduler scheduler)\n     {\n         // Return a new future even if newDriverGroupReady has not finished.\n         // Returning the same SettableFuture instance could lead to ListenableFuture retaining too many listener objects.\n+        // todo resolve availableTasks being limited for unlimited execution", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -187,26 +189,31 @@ public class DynamicLifespanScheduler\n     {\n         // Return a new future even if newDriverGroupReady has not finished.\n         // Returning the same SettableFuture instance could lead to ListenableFuture retaining too many listener objects.\n-        // todo resolve availableTasks being limited for unlimited execution\n+\n+        // TODO: After initial scheduling, tasks would only be available after they finished at least one bucket.\n+        //  This is not necessarily the case if the initial scheduling covered all buckets and\n+        //  the available slots is not fully utilized (concurrentLifespansPerTask is large or infinite).\n+        //  In this case if a task failed, the recovered driver groups have to wait for tasks to be available again after finishing at least one bucket,\n+        //  even though by definition of concurrentLifespansPerTask they are already available.\n \n         checkState(initialScheduled, \"schedule should only be called after initial scheduling finished\");\n         checkState(failedTasks.size() < nodeByTaskId.size(), \"All tasks have failed\");\n \n         synchronized (this) {\n             newDriverGroupReady = SettableFuture.create();\n-            while (!availableTasks.isEmpty() && (!driverGroupNoPreferenceQueue.isEmpty() || !driverGroupWithPreferenceMapQueue.isEmpty())) {\n+            while (!availableTasks.isEmpty() && (!noPreferenceDriverGroups.isEmpty() || !nodeToPreferredDriverGroups.isEmpty())) {\n                 int taskId = availableTasks.dequeueInt();\n                 if (failedTasks.contains(taskId)) {\n                     continue;\n                 }\n \n-                int nextDriverGroupId = pickDriverGroupForNode(nodeByTaskId.get(taskId));\n-                if (nextDriverGroupId == -1) {\n+                OptionalInt nextDriverGroupId = getNextDriverGroup(nodeByTaskId.get(taskId));\n+                if (!nextDriverGroupId.isPresent()) {\n                     continue;\n                 }\n-                scheduler.startLifespan(Lifespan.driverGroup(nextDriverGroupId), partitionHandles.get(nextDriverGroupId));\n-                taskByDriverGroup[nextDriverGroupId] = taskId;\n-                runningDriverGroupIdsByTask[taskId].add(nextDriverGroupId);\n+                scheduler.startLifespan(Lifespan.driverGroup(nextDriverGroupId.getAsInt()), partitionHandles.get(nextDriverGroupId.getAsInt()));\n+                taskByDriverGroup[nextDriverGroupId.getAsInt()] = taskId;\n+                runningDriverGroupIdsByTask[taskId].add(nextDriverGroupId.getAsInt());\n             }\n         }\n         return newDriverGroupReady;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MTAwMQ==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382791001", "bodyText": "How about naming this getNextDriverGroup?", "author": "shixuan-fan", "createdAt": "2020-02-21T20:29:42Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -189,4 +217,23 @@ public synchronized boolean allLifespanExecutionFinished()\n     {\n         return totalLifespanExecutionFinished == partitionHandles.size();\n     }\n+\n+    private int pickDriverGroupForNode(InternalNode node)", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex e912eb5784..38ecdd4e7f 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -218,21 +225,18 @@ public class DynamicLifespanScheduler\n         return totalLifespanExecutionFinished == partitionHandles.size();\n     }\n \n-    private int pickDriverGroupForNode(InternalNode node)\n+    private OptionalInt getNextDriverGroup(InternalNode node)\n     {\n-        int driverGroupId;\n-        if ((driverGroupWithPreferenceMapQueue.get(node) != null) && !driverGroupWithPreferenceMapQueue.get(node).isEmpty()) {\n-            driverGroupId = driverGroupWithPreferenceMapQueue.get(node).dequeueInt();\n-            if (driverGroupWithPreferenceMapQueue.get(node).isEmpty()) {\n-                driverGroupWithPreferenceMapQueue.remove(node);\n+        OptionalInt driverGroupId = OptionalInt.empty();\n+        if ((nodeToPreferredDriverGroups.get(node) != null) && !nodeToPreferredDriverGroups.get(node).isEmpty()) {\n+            driverGroupId = OptionalInt.of(nodeToPreferredDriverGroups.get(node).dequeueInt());\n+            if (nodeToPreferredDriverGroups.get(node).isEmpty()) {\n+                nodeToPreferredDriverGroups.remove(node);\n             }\n         }\n-        else if (!driverGroupNoPreferenceQueue.isEmpty()) {\n-            driverGroupId = driverGroupNoPreferenceQueue.dequeueInt();\n-            bucketNodeMap.assignOrUpdateBucketToNode(driverGroupId, node);\n-        }\n-        else {\n-            driverGroupId = -1;\n+        else if (!noPreferenceDriverGroups.isEmpty()) {\n+            driverGroupId = OptionalInt.of(noPreferenceDriverGroups.dequeueInt());\n+            bucketNodeMap.assignOrUpdateBucketToNode(driverGroupId.getAsInt(), node);\n         }\n         return driverGroupId;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MjYwNA==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r382792604", "bodyText": "Let's just put test introduced here into TestDynamicLifespanScheduler.", "author": "shixuan-fan", "createdAt": "2020-02-21T20:33:44Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/scheduler/group/TestAffinityDynamicLifespanScheduler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.scheduler.group;\n+\n+import com.facebook.presto.client.NodeVersion;\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.scheduler.BucketNodeMap;\n+import com.facebook.presto.execution.scheduler.ScheduleResult;\n+import com.facebook.presto.execution.scheduler.SourceScheduler;\n+import com.facebook.presto.metadata.InternalNode;\n+import com.facebook.presto.spi.ConnectorSplit;\n+import com.facebook.presto.spi.HostAddress;\n+import com.facebook.presto.spi.connector.ConnectorPartitionHandle;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.spi.schedule.NodeSelectionStrategy;\n+import com.google.common.collect.ImmutableList;\n+import org.testng.annotations.Test;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalInt;\n+import java.util.stream.IntStream;\n+\n+import static com.facebook.presto.spi.schedule.NodeSelectionStrategy.SOFT_AFFINITY;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestAffinityDynamicLifespanScheduler", "originalCommit": "daa9c786e6fd3d0e3545d507797f90f8b69e5a6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "chunk": "diff --git a/presto-main/src/test/java/com/facebook/presto/execution/scheduler/group/TestAffinityDynamicLifespanScheduler.java b/presto-main/src/test/java/com/facebook/presto/execution/scheduler/group/TestAffinityDynamicLifespanScheduler.java\ndeleted file mode 100644\nindex 0de44e85b5..0000000000\n--- a/presto-main/src/test/java/com/facebook/presto/execution/scheduler/group/TestAffinityDynamicLifespanScheduler.java\n+++ /dev/null\n\n@@ -1,319 +0,0 @@\n-/*\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.facebook.presto.execution.scheduler.group;\n-\n-import com.facebook.presto.client.NodeVersion;\n-import com.facebook.presto.execution.Lifespan;\n-import com.facebook.presto.execution.scheduler.BucketNodeMap;\n-import com.facebook.presto.execution.scheduler.ScheduleResult;\n-import com.facebook.presto.execution.scheduler.SourceScheduler;\n-import com.facebook.presto.metadata.InternalNode;\n-import com.facebook.presto.spi.ConnectorSplit;\n-import com.facebook.presto.spi.HostAddress;\n-import com.facebook.presto.spi.connector.ConnectorPartitionHandle;\n-import com.facebook.presto.spi.plan.PlanNodeId;\n-import com.facebook.presto.spi.schedule.NodeSelectionStrategy;\n-import com.google.common.collect.ImmutableList;\n-import org.testng.annotations.Test;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.OptionalInt;\n-import java.util.stream.IntStream;\n-\n-import static com.facebook.presto.spi.schedule.NodeSelectionStrategy.SOFT_AFFINITY;\n-import static com.google.common.collect.ImmutableList.toImmutableList;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestAffinityDynamicLifespanScheduler\n-{\n-    private static final int BUCKET_COUNT = 10;\n-    private static final InternalNode node1 = getInternalNode(\"1\");\n-    private static final InternalNode node2 = getInternalNode(\"2\");\n-    private static final InternalNode node3 = getInternalNode(\"3\");\n-\n-    @Test\n-    public void testSchedule()\n-    {\n-        BucketNodeMap bucketNodeMap = new DynamicBucketNodeMap(\n-                split -> ((TestAffinityDynamicLifespanScheduler.TestAffinitySplit) split.getConnectorSplit()).getBucketNumber(),\n-                BUCKET_COUNT,\n-                ImmutableList.of(node1, node2, node1, node2, node1, node2, node1, node2, node1, node2));\n-        LifespanScheduler lifespanScheduler = getAffinityLifespanScheduler(bucketNodeMap);\n-        TestAffinityDynamicLifespanScheduler.TestingSourceScheduler sourceScheduler = new TestAffinityDynamicLifespanScheduler.TestingSourceScheduler();\n-        lifespanScheduler.scheduleInitial(sourceScheduler);\n-        lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-        assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-        sourceScheduler.getLastStartedLifespans().clear();\n-\n-        while (!lifespanScheduler.allLifespanExecutionFinished()) {\n-            lifespanScheduler.schedule(sourceScheduler);\n-            lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-            assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-            sourceScheduler.getLastStartedLifespans().clear();\n-        }\n-    }\n-\n-    @Test\n-    public void testRetry()\n-    {\n-        BucketNodeMap bucketNodeMap = new DynamicBucketNodeMap(\n-                split -> ((TestAffinityDynamicLifespanScheduler.TestAffinitySplit) split.getConnectorSplit()).getBucketNumber(),\n-                BUCKET_COUNT,\n-                ImmutableList.of(node1, node2, node1, node2, node1, node2, node1, node2, node1, node2));\n-        LifespanScheduler lifespanScheduler = getAffinityLifespanScheduler(bucketNodeMap);\n-        TestAffinityDynamicLifespanScheduler.TestingSourceScheduler sourceScheduler = new TestAffinityDynamicLifespanScheduler.TestingSourceScheduler();\n-        lifespanScheduler.scheduleInitial(sourceScheduler);\n-\n-        lifespanScheduler.onLifespanExecutionFinished(ImmutableList.of(sourceScheduler.getLastStartedLifespans().get(1)));\n-        assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-        sourceScheduler.getLastStartedLifespans().clear();\n-\n-        lifespanScheduler.onTaskFailed(0, ImmutableList.of(sourceScheduler));\n-        assertEquals(sourceScheduler.getLastRewoundLifespans().size(), 1);\n-        sourceScheduler.getLastRewoundLifespans().clear();\n-\n-        while (!lifespanScheduler.allLifespanExecutionFinished()) {\n-            lifespanScheduler.schedule(sourceScheduler);\n-            lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-            assertEquals(sourceScheduler.getLastStartedLifespans().size(), 1);\n-            sourceScheduler.getLastStartedLifespans().clear();\n-        }\n-    }\n-\n-    @Test\n-    public void testScheduleLocality()\n-    {\n-        BucketNodeMap bucketNodeMap = new DynamicBucketNodeMap(\n-                split -> ((TestAffinityDynamicLifespanScheduler.TestAffinitySplit) split.getConnectorSplit()).getBucketNumber(),\n-                BUCKET_COUNT,\n-                ImmutableList.of(node1, node3, node1, node3, node1, node3, node1, node3, node1, node3));\n-        LifespanScheduler lifespanScheduler = getAffinityLifespanScheduler(bucketNodeMap);\n-        TestAffinityDynamicLifespanScheduler.TestingSourceScheduler sourceScheduler = new TestAffinityDynamicLifespanScheduler.TestingSourceScheduler();\n-        lifespanScheduler.scheduleInitial(sourceScheduler);\n-        assertEquals(bucketNodeMap.getAssignedNode(0).get(), node1);\n-        // bucket 1 is already scheduled, thus its assignedNode is changed\n-        assertEquals(bucketNodeMap.getAssignedNode(1).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(2).get(), node1);\n-        // bucket 3 is not scheduled yet, thus its assignedNode remains\n-        assertEquals(bucketNodeMap.getAssignedNode(3).get(), node3);\n-        assertEquals(bucketNodeMap.getAssignedNode(4).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(5).get(), node3);\n-        assertEquals(bucketNodeMap.getAssignedNode(6).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(7).get(), node3);\n-        assertEquals(bucketNodeMap.getAssignedNode(8).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(9).get(), node3);\n-\n-        lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-        assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-        sourceScheduler.getLastStartedLifespans().clear();\n-\n-        while (!lifespanScheduler.allLifespanExecutionFinished()) {\n-            lifespanScheduler.schedule(sourceScheduler);\n-            lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-            assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-            sourceScheduler.getLastStartedLifespans().clear();\n-        }\n-        assertEquals(bucketNodeMap.getAssignedNode(0).get(), node1);\n-        // bucket 1 is already scheduled, thus its assignedNode is changed\n-        assertEquals(bucketNodeMap.getAssignedNode(1).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(2).get(), node1);\n-        // bucket 3 is not scheduled yet, thus its assignedNode remains\n-        assertEquals(bucketNodeMap.getAssignedNode(3).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(4).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(5).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(6).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(7).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(8).get(), node1);\n-        assertEquals(bucketNodeMap.getAssignedNode(9).get(), node2);\n-    }\n-\n-    @Test\n-    public void testScheduleFailedLocality()\n-    {\n-        BucketNodeMap bucketNodeMap = new DynamicBucketNodeMap(\n-                split -> ((TestAffinityDynamicLifespanScheduler.TestAffinitySplit) split.getConnectorSplit()).getBucketNumber(),\n-                BUCKET_COUNT,\n-                ImmutableList.of(node1, node2, node1, node2, node1, node2, node1, node2, node1, node2));\n-        LifespanScheduler lifespanScheduler = getAffinityLifespanScheduler(bucketNodeMap);\n-        TestAffinityDynamicLifespanScheduler.TestingSourceScheduler sourceScheduler = new TestAffinityDynamicLifespanScheduler.TestingSourceScheduler();\n-        lifespanScheduler.scheduleInitial(sourceScheduler);\n-\n-        lifespanScheduler.onLifespanExecutionFinished(ImmutableList.of(sourceScheduler.getLastStartedLifespans().get(1)));\n-        assertEquals(sourceScheduler.getLastStartedLifespans().size(), 2);\n-        sourceScheduler.getLastStartedLifespans().clear();\n-\n-        lifespanScheduler.onTaskFailed(0, ImmutableList.of(sourceScheduler));\n-        assertEquals(sourceScheduler.getLastRewoundLifespans().size(), 1);\n-        sourceScheduler.getLastRewoundLifespans().clear();\n-\n-        while (!lifespanScheduler.allLifespanExecutionFinished()) {\n-            lifespanScheduler.schedule(sourceScheduler);\n-            lifespanScheduler.onLifespanExecutionFinished(sourceScheduler.getLastStartedLifespans());\n-            assertEquals(sourceScheduler.getLastStartedLifespans().size(), 1);\n-            sourceScheduler.getLastStartedLifespans().clear();\n-        }\n-\n-        assertEquals(bucketNodeMap.getAssignedNode(0).get(), node2);\n-        // bucket 1 is already scheduled, thus its assignedNode is changed\n-        assertEquals(bucketNodeMap.getAssignedNode(1).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(2).get(), node2);\n-        // bucket 3 is not scheduled yet, thus its assignedNode remains\n-        assertEquals(bucketNodeMap.getAssignedNode(3).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(4).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(5).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(6).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(7).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(8).get(), node2);\n-        assertEquals(bucketNodeMap.getAssignedNode(9).get(), node2);\n-    }\n-\n-    private static LifespanScheduler getAffinityLifespanScheduler(BucketNodeMap bucketNodeMap)\n-    {\n-        return new DynamicLifespanScheduler(\n-                bucketNodeMap,\n-                ImmutableList.of(node1, node2),\n-                IntStream.range(0, 10).mapToObj(TestAffinityDynamicLifespanScheduler.TestPartitionHandle::new).collect(toImmutableList()),\n-                OptionalInt.of(1));\n-    }\n-\n-    private static InternalNode getInternalNode(String id)\n-    {\n-        return new InternalNode(id, URI.create(id), new NodeVersion(\"test\"), false);\n-    }\n-\n-    private static class TestAffinitySplit\n-            implements ConnectorSplit\n-    {\n-        private final int bucketNumber;\n-\n-        private TestAffinitySplit(int bucketNumber)\n-        {\n-            this.bucketNumber = bucketNumber;\n-        }\n-\n-        public int getBucketNumber()\n-        {\n-            return bucketNumber;\n-        }\n-\n-        @Override\n-        public NodeSelectionStrategy getNodeSelectionStrategy()\n-        {\n-            return SOFT_AFFINITY;\n-        }\n-\n-        @Override\n-        public List<HostAddress> getPreferredNodes(List<HostAddress> sortedCandidates)\n-        {\n-            return ImmutableList.of();\n-        }\n-\n-        @Override\n-        public Object getInfo()\n-        {\n-            return this;\n-        }\n-    }\n-\n-    private static class TestPartitionHandle\n-            extends ConnectorPartitionHandle\n-    {\n-        private final int bucket;\n-\n-        public TestPartitionHandle(int bucket)\n-        {\n-            this.bucket = bucket;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o)\n-        {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (!(o instanceof TestAffinityDynamicLifespanScheduler.TestPartitionHandle)) {\n-                return false;\n-            }\n-            TestAffinityDynamicLifespanScheduler.TestPartitionHandle that = (TestAffinityDynamicLifespanScheduler.TestPartitionHandle) o;\n-            return bucket == that.bucket;\n-        }\n-\n-        @Override\n-        public int hashCode()\n-        {\n-            return Objects.hash(bucket);\n-        }\n-    }\n-\n-    public class TestingSourceScheduler\n-            implements SourceScheduler\n-    {\n-        private final List<Lifespan> lastStartedLifespans = new ArrayList<>();\n-        private final List<Lifespan> lastRewoundLifespans = new ArrayList<>();\n-\n-        public ScheduleResult schedule()\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public void close()\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public PlanNodeId getPlanNodeId()\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public void startLifespan(Lifespan lifespan, ConnectorPartitionHandle partitionHandle)\n-        {\n-            lastStartedLifespans.add(lifespan);\n-        }\n-\n-        @Override\n-        public void rewindLifespan(Lifespan lifespan, ConnectorPartitionHandle partitionHandle)\n-        {\n-            lastRewoundLifespans.add(lifespan);\n-        }\n-\n-        @Override\n-        public List<Lifespan> drainCompletelyScheduledLifespans()\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public void notifyAllLifespansFinishedExecution()\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public List<Lifespan> getLastStartedLifespans()\n-        {\n-            return lastStartedLifespans;\n-        }\n-\n-        public List<Lifespan> getLastRewoundLifespans()\n-        {\n-            return lastRewoundLifespans;\n-        }\n-    }\n-}\n"}}, {"oid": "84ae8566d709c15f89d24a39ebc8a8a6360b027c", "url": "https://github.com/prestodb/presto/commit/84ae8566d709c15f89d24a39ebc8a8a6360b027c", "message": "Support sort affinity in DynamicLifespanScheduler", "committedDate": "2020-02-21T23:38:47Z", "type": "forcePushed"}, {"oid": "be7ccae82d0674e4f3a7905d03959b804ffef355", "url": "https://github.com/prestodb/presto/commit/be7ccae82d0674e4f3a7905d03959b804ffef355", "message": "Support sort affinity in DynamicLifespanScheduler", "committedDate": "2020-02-21T23:43:30Z", "type": "forcePushed"}, {"oid": "6d1908f0da88dd572989fb025281663e908d296e", "url": "https://github.com/prestodb/presto/commit/6d1908f0da88dd572989fb025281663e908d296e", "message": "Support soft affinity for bucketed splits", "committedDate": "2020-02-21T23:44:53Z", "type": "commit"}, {"oid": "4616b0f42e82132d66e96c17365e2dbbc1570a0c", "url": "https://github.com/prestodb/presto/commit/4616b0f42e82132d66e96c17365e2dbbc1570a0c", "message": "Support sort affinity in DynamicLifespanScheduler", "committedDate": "2020-02-21T23:45:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MDQ4OA==", "url": "https://github.com/prestodb/presto/pull/14095#discussion_r383440488", "bodyText": "nit: Let's follow the other comments' pattern and capitalize the first character of the sentence :)", "author": "shixuan-fan", "createdAt": "2020-02-24T18:36:08Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java", "diffHunk": "@@ -151,8 +167,19 @@ public void onTaskFailed(int taskId, List<SourceScheduler> sourceSchedulers)\n                 for (SourceScheduler sourceScheduler : sourceSchedulers) {\n                     sourceScheduler.rewindLifespan(Lifespan.driverGroup(driverGroupId), partitionHandles.get(driverGroupId));\n                 }\n-                driverGroupQueue.enqueue(driverGroupId);\n+                noPreferenceDriverGroups.enqueue(driverGroupId);\n+            }\n+\n+            // when a task fails, all driverGroups that prefer this task/node would be not able to execute", "originalCommit": "4616b0f42e82132d66e96c17365e2dbbc1570a0c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9fcd9430a8c086bdc88d37ebd8cbbd83e3932bce", "chunk": "diff --git a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\nindex 38ecdd4e7f..e339a217fa 100644\n--- a/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n+++ b/presto-main/src/main/java/com/facebook/presto/execution/scheduler/group/DynamicLifespanScheduler.java\n\n@@ -170,8 +170,8 @@ public class DynamicLifespanScheduler\n                 noPreferenceDriverGroups.enqueue(driverGroupId);\n             }\n \n-            // when a task fails, all driverGroups that prefer this task/node would be not able to execute\n-            // thus they should be relocated to driverGroupNoPreferenceQueue\n+            // When a task fails, all driverGroups that prefer this task/node would be not able to execute\n+            // Thus they should be relocated to driverGroupNoPreferenceQueue\n             if (nodeToPreferredDriverGroups.containsKey(nodeByTaskId.get(taskId))) {\n                 IntArrayFIFOQueue preferredDriverGroupQueue = nodeToPreferredDriverGroups.get(nodeByTaskId.get(taskId));\n                 while (!preferredDriverGroupQueue.isEmpty()) {\n"}}, {"oid": "9fcd9430a8c086bdc88d37ebd8cbbd83e3932bce", "url": "https://github.com/prestodb/presto/commit/9fcd9430a8c086bdc88d37ebd8cbbd83e3932bce", "message": "Support soft affinity in DynamicLifespanScheduler", "committedDate": "2020-02-24T18:44:35Z", "type": "commit"}, {"oid": "9fcd9430a8c086bdc88d37ebd8cbbd83e3932bce", "url": "https://github.com/prestodb/presto/commit/9fcd9430a8c086bdc88d37ebd8cbbd83e3932bce", "message": "Support soft affinity in DynamicLifespanScheduler", "committedDate": "2020-02-24T18:44:35Z", "type": "forcePushed"}]}