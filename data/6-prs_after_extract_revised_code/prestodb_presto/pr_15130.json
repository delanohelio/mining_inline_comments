{"pr_number": 15130, "pr_title": "GC issue fixes in SliceDictionarySelectiveReader", "pr_createdAt": "2020-09-07T23:38:29Z", "pr_url": "https://github.com/prestodb/presto/pull/15130", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDY3Ng==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485270676", "bodyText": "nit: can we give it a more meaningful name?", "author": "sujay-jain", "createdAt": "2020-09-09T00:41:20Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -87,16 +92,17 @@\n     private final int maxCodePointCount;\n     private final boolean isCharType;\n \n-    private byte[] stripeDictionaryData = EMPTY_DICTIONARY_DATA;\n-    private int[] stripeDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n-    private byte[] currentDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private byte[] dictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] dictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n     private int[] stripeDictionaryLength = new int[0];\n     private int[] rowGroupDictionaryLength = new int[0];\n     private byte[] evaluationStatus;\n+    private byte[] tempValue;", "originalCommit": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxNzU2Ng==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485417566", "bodyText": "Renamed it to valueWithPadding", "author": "yingsu00", "createdAt": "2020-09-09T08:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fc597169ff1e05022e177ccafc2c7af513dba414", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 9478a55ecd..978a9fed15 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -97,7 +99,7 @@ public class SliceDictionarySelectiveReader\n     private int[] stripeDictionaryLength = new int[0];\n     private int[] rowGroupDictionaryLength = new int[0];\n     private byte[] evaluationStatus;\n-    private byte[] tempValue;\n+    private byte[] valueWithPadding;\n \n     private int readOffset;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDg3Mw==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485270873", "bodyText": "Could you elaborate on where the numbers came from? Is this something that's standard and well known?", "author": "sujay-jain", "createdAt": "2020-09-09T00:42:06Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -78,6 +79,10 @@\n     // add one extra entry for null after stripe/rowGroup dictionary\n     private static final int[] EMPTY_DICTIONARY_OFFSETS = new int[2];\n \n+    // Each rowgroup has roughly 10K rows, and each batch reads 1K rows. So there're about 10 batches in a rowgroup.\n+    private static final int BATCHES_PER_ROWGROUP = 10;\n+    private static final float MATERIALIZATION_RATIO = 2.0f;\n+", "originalCommit": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3Njg1MQ==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485376851", "bodyText": "https://orc.apache.org/specification/ORCv1/ states that the default row group has 10,000 rows. Since each batch has at most 1024 rows, the BATCHES_PER_ROWGROUP is roughly 10.\nMATERIALIZATION_RATIO should be a value greater than 1.0f to account for extra CPU required to materialize the VariableWidthBlock. I picked 2.0f here which is a safe choice, so that it doesn't over-radically materialize blocks. This value can be adjusted in the future, but I think it's over-kill to introduce configuration properties because this is too technical and users won't know how to configure it.", "author": "yingsu00", "createdAt": "2020-09-09T06:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyNTcxNg==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485425716", "bodyText": "I added the following comments\n// MATERIALIZATION_RATIO should be greater than or equal to 1.0f to compensate the extra CPU to materialize blocks.", "author": "yingsu00", "createdAt": "2020-09-09T08:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDg3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fc597169ff1e05022e177ccafc2c7af513dba414", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 9478a55ecd..978a9fed15 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -81,6 +82,7 @@ public class SliceDictionarySelectiveReader\n \n     // Each rowgroup has roughly 10K rows, and each batch reads 1K rows. So there're about 10 batches in a rowgroup.\n     private static final int BATCHES_PER_ROWGROUP = 10;\n+    // MATERIALIZATION_RATIO should be greater than or equal to 1.0f to compensate the extra CPU to materialize blocks.\n     private static final float MATERIALIZATION_RATIO = 2.0f;\n \n     private final TupleDomainFilter filter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MDQ4MA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485280480", "bodyText": "curious why just allNulls check won't be sufficient here", "author": "sujay-jain", "createdAt": "2020-09-09T01:18:06Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -365,33 +386,69 @@ public Block getBlock(int[] positions, int positionCount)\n         checkState(positionCount <= outputPositionCount, \"Not enough values\");\n         checkState(!valuesInUse, \"BlockLease hasn't been closed yet\");\n \n-        if (allNulls) {\n+        if (allNulls || nullsCount == outputPositionCount) {", "originalCommit": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTM3MQ==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485379371", "bodyText": "allNulls is set true when dataStream == null && presentStream != null. When this condition is false, it's still possible that all the selected positions after read() is finished are null. Think of the starting batches where batchSize == 1 or some small numbers. It's possible this value is null.", "author": "yingsu00", "createdAt": "2020-09-09T06:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MDQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "fc597169ff1e05022e177ccafc2c7af513dba414", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 9478a55ecd..978a9fed15 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -405,7 +407,7 @@ public class SliceDictionarySelectiveReader\n             values[i] = id;\n \n             blockSizeInBytes += dictionaryOffsetVector[id + 1] - dictionaryOffsetVector[id];\n-            nullsCount += id == currentDictionarySize - 1 ? 1 : 0;\n+            nullsCount += (id == currentDictionarySize - 1 ? 1 : 0);\n \n             i++;\n             j++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MjExMA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485282110", "bodyText": "do you think we could extract some of this into functions and have some unit tests for them? there's a lot going on and it is easy to make mistake. Extracting into a function whose name describes what we're doing would also make it more readable :) What do you think? (L394- L411, and L422-L32.. etc)", "author": "sujay-jain", "createdAt": "2020-09-09T01:24:15Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -365,33 +386,69 @@ public Block getBlock(int[] positions, int positionCount)\n         checkState(positionCount <= outputPositionCount, \"Not enough values\");\n         checkState(!valuesInUse, \"BlockLease hasn't been closed yet\");\n \n-        if (allNulls) {\n+        if (allNulls || nullsCount == outputPositionCount) {\n             return new RunLengthEncodedBlock(outputType.createBlockBuilder(null, 1).appendNull().build(), positionCount);\n         }\n \n-        if (positionCount == outputPositionCount) {\n-            DictionaryBlock block = new DictionaryBlock(positionCount, dictionary, values);\n-            values = null;\n-            return block;\n+        // compact values(ids) array, and calculate 1) the slice sizeInBytes if materialized, and 2) number of nulls\n+        long blockSizeInBytes = 0;\n+        int nullsCount = 0;  // the nulls count for selected positions\n+        int i = 0;\n+        int j = 0;\n+        while (i < positionCount && j < outputPositionCount) {\n+            if (positions[i] != outputPositions[j]) {\n+                j++;\n+                continue;\n+            }\n+\n+            int id = this.values[j];\n+            values[i] = id;\n+\n+            blockSizeInBytes += dictionaryOffsetVector[id + 1] - dictionaryOffsetVector[id];\n+            nullsCount += id == currentDictionarySize - 1 ? 1 : 0;\n+\n+            i++;\n+            j++;\n         }\n \n-        int[] valuesCopy = new int[positionCount];\n+        // If all selected positions are null, just return RLE block.\n+        if (nullsCount == outputPositionCount) {\n+            return new RunLengthEncodedBlock(outputType.createBlockBuilder(null, 1).appendNull().build(), positionCount);\n+        }\n \n-        int positionIndex = 0;\n-        int nextPosition = positions[positionIndex];\n-        for (int i = 0; i < outputPositionCount; i++) {\n-            if (outputPositions[i] < nextPosition) {\n-                continue;\n+        // If the expected materialized size of the output block is smaller than a certain ratio of the dictionary size, we will materialize the values\n+        int dictionarySizeInBytes = dictionaryOffsetVector[currentDictionarySize - 1];\n+        if (blockSizeInBytes * BATCHES_PER_ROWGROUP < dictionarySizeInBytes / MATERIALIZATION_RATIO) {\n+            byte[] sliceData = new byte[toIntExact(blockSizeInBytes)];\n+            int[] offsetVector = new int[positionCount + 1];\n+            int currentOffset = 0;\n+            for (int k = 0; k < positionCount; k++) {\n+                int id = values[k];\n+                int offset = dictionaryOffsetVector[id];\n+                int length = dictionaryOffsetVector[id + 1] - offset;\n+                System.arraycopy(dictionaryData, offset, sliceData, currentOffset, length);\n+\n+                currentOffset += length;\n+                offsetVector[k + 1] = currentOffset;\n             }\n-            assert outputPositions[i] == nextPosition;\n-            valuesCopy[positionIndex] = this.values[i];\n-            positionIndex++;\n-            if (positionIndex >= positionCount) {\n-                break;\n+\n+            if (nullsCount > 0) {\n+                boolean[] isNullVector = new boolean[positionCount];\n+                for (int k = 0; k < positionCount; k++) {\n+                    if (values[k] == currentDictionarySize - 1) {\n+                        isNullVector[k] = true;\n+                    }\n+                }", "originalCommit": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxNzQ3OA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485417478", "bodyText": "@sujay-jain Thanks for the suggestion. I extracted getMaterializedBlock() since it's a relatively self-explanatory unit. L394- L411 was just a rewrite of original L380-L393 which was inlined in getBlock(). I think it's easier for readers to understand if we keep it that way. This piece is not as isolated as getMaterializedBlock(), and jumping between the methods would make readers have context switches back and forth.\nOur testing framework uses OrcTester and tests round trips and match the input and output. The new code logic is already covered in TestSelectiveOrcReader. I updated the comments in testVarchars() there. There is no testing framework that can test each individual functions and building one from ground is beyond this PR. We can't just call getBlock() by itself without first calling read(). And if we call both, it's the same as what the current OrcTester does.", "author": "yingsu00", "createdAt": "2020-09-09T08:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MjExMA=="}], "type": "inlineReview", "revised_code": {"commit": "fc597169ff1e05022e177ccafc2c7af513dba414", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 9478a55ecd..978a9fed15 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -405,7 +407,7 @@ public class SliceDictionarySelectiveReader\n             values[i] = id;\n \n             blockSizeInBytes += dictionaryOffsetVector[id + 1] - dictionaryOffsetVector[id];\n-            nullsCount += id == currentDictionarySize - 1 ? 1 : 0;\n+            nullsCount += (id == currentDictionarySize - 1 ? 1 : 0);\n \n             i++;\n             j++;\n"}}, {"oid": "fc597169ff1e05022e177ccafc2c7af513dba414", "url": "https://github.com/prestodb/presto/commit/fc597169ff1e05022e177ccafc2c7af513dba414", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan.", "committedDate": "2020-09-09T08:15:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzODI5MA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485838290", "bodyText": "Should probably be a checkState and not an assert", "author": "sachdevs", "createdAt": "2020-09-09T18:48:35Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -286,12 +294,21 @@ private int readWithFilter(int[] positions, int positionCount)\n     private byte evaluateFilter(int position, int index, int length)\n     {\n         if (filter.testLength(length)) {\n-            int currentLength = dictionary.getSliceLength(index);\n-            Slice data = dictionary.getSlice(index, 0, currentLength);\n+            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n+\n+            boolean pass;\n             if (isCharType && length != currentLength) {\n-                data = Chars.padSpaces(data, maxCodePointCount);\n+                assert currentLength <= length;\n+                assert valueWithPadding != null;", "originalCommit": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MTkwNw==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r486191907", "bodyText": "This is in performance critical loops. Asserts doesn't execute in production. I would rather remove the asserts than changing it to checkState.", "author": "yingsu00", "createdAt": "2020-09-10T09:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzODI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 55f957cf4b..58457761c0 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -293,31 +298,28 @@ public class SliceDictionarySelectiveReader\n \n     private byte evaluateFilter(int position, int index, int length)\n     {\n-        if (filter.testLength(length)) {\n-            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n-\n-            boolean pass;\n-            if (isCharType && length != currentLength) {\n-                assert currentLength <= length;\n-                assert valueWithPadding != null;\n-                System.arraycopy(currentDictionaryData, currentDictionaryOffsetVector[index], valueWithPadding, 0, currentLength);\n-                Arrays.fill(valueWithPadding, currentLength, length, (byte) ' ');\n-                pass = filter.testBytes(valueWithPadding, 0, length);\n-            }\n-            else {\n-                pass = filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length);\n-            }\n+        if (!filter.testLength(length)) {\n+            return FILTER_FAILED;\n+        }\n \n-            if (pass) {\n-                if (outputRequired) {\n-                    values[outputPositionCount] = index;\n-                }\n-                outputPositions[outputPositionCount] = position;\n-                outputPositionCount++;\n-                return FILTER_PASSED;\n+        int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n+        if (isCharType && length != currentLength) {\n+            System.arraycopy(currentDictionaryData, currentDictionaryOffsetVector[index], valueWithPadding, 0, currentLength);\n+            Arrays.fill(valueWithPadding, currentLength, length, (byte) ' ');\n+            if (!filter.testBytes(valueWithPadding, 0, length)) {\n+                return FILTER_FAILED;\n             }\n         }\n-        return FILTER_FAILED;\n+        else if (!filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length)) {\n+            return FILTER_FAILED;\n+        }\n+\n+        if (outputRequired) {\n+            values[outputPositionCount] = index;\n+        }\n+        outputPositions[outputPositionCount] = position;\n+        outputPositionCount++;\n+        return FILTER_PASSED;\n     }\n \n     private int readAllNulls(int[] positions, int positionCount)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0Mjc5OA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485842798", "bodyText": "nit: if (dictionaryWrapped) return;, bring the rest out of the if block.", "author": "sachdevs", "createdAt": "2020-09-09T18:56:54Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -409,9 +429,26 @@ public BlockLease getBlockView(int[] positions, int positionCount)\n         if (positionCount < outputPositionCount) {\n             compactValues(positions, positionCount);\n         }\n+        wrapDictionaryIfNecessary();\n         return newLease(new DictionaryBlock(positionCount, dictionary, values));\n     }\n \n+    private void wrapDictionaryIfNecessary()\n+    {\n+        if (!dictionaryWrapped) {", "originalCommit": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 55f957cf4b..58457761c0 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -435,18 +437,18 @@ public class SliceDictionarySelectiveReader\n \n     private void wrapDictionaryIfNecessary()\n     {\n-        if (!dictionaryWrapped) {\n-            boolean[] isNullVector = new boolean[currentDictionarySize];\n-            isNullVector[currentDictionarySize - 1] = true;\n+        if (dictionaryWrapped) {\n+            return;\n+        }\n \n-            currentDictionaryOffsetVector[currentDictionarySize] = currentDictionaryOffsetVector[currentDictionarySize - 1];\n+        boolean[] isNullVector = new boolean[currentDictionarySize];\n+        isNullVector[currentDictionarySize - 1] = true;\n \n-            byte[] dictionaryDataCopy = Arrays.copyOf(currentDictionaryData, currentDictionaryOffsetVector[currentDictionarySize]);\n-            int[] dictionaryOffsetVectorCopy = Arrays.copyOf(currentDictionaryOffsetVector, currentDictionarySize + 1);\n-            dictionary = new VariableWidthBlock(currentDictionarySize, wrappedBuffer(dictionaryDataCopy), dictionaryOffsetVectorCopy, Optional.of(isNullVector));\n+        byte[] dictionaryDataCopy = Arrays.copyOf(currentDictionaryData, currentDictionaryOffsetVector[currentDictionarySize]);\n+        int[] dictionaryOffsetVectorCopy = Arrays.copyOf(currentDictionaryOffsetVector, currentDictionarySize + 1);\n+        dictionary = new VariableWidthBlock(currentDictionarySize, wrappedBuffer(dictionaryDataCopy), dictionaryOffsetVectorCopy, Optional.of(isNullVector));\n \n-            dictionaryWrapped = true;\n-        }\n+        dictionaryWrapped = true;\n     }\n \n     private void compactValues(int[] positions, int positionCount)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NzQzNQ==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485847435", "bodyText": "This logic needs some refactoring in order to be easier to read. We are making 3 different tests here:\n\nfilter.testLength(length)\nfilter.testBytes(valueWithPadding, 0, length); in the case of charType\nfilter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length); in case of non-charType\n\nIf any of these filters fail, we return FILTER_FAILED and in case of pass we return FILTER_PASSED. Using this information we can flatten this logic as follows:\nif (!filter.testLength(length))\n    return FILTER_FAILED;\nif (isCharType && length != currentLength) {\n    //...\n    if (!filter.testBytes(valueWithPadding, 0, length))\n        return FILTER_FAILED;\n} else if (!filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length)) {\n    return FILTER_FAILED;\n}\n\n// the stuff you do once if(pass) {...}.\n\n\nNow we don't need the pass state variable and branches are clearer.", "author": "sachdevs", "createdAt": "2020-09-09T19:05:40Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -286,12 +294,21 @@ private int readWithFilter(int[] positions, int positionCount)\n     private byte evaluateFilter(int position, int index, int length)\n     {\n         if (filter.testLength(length)) {\n-            int currentLength = dictionary.getSliceLength(index);\n-            Slice data = dictionary.getSlice(index, 0, currentLength);\n+            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];", "originalCommit": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 55f957cf4b..58457761c0 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -293,31 +298,28 @@ public class SliceDictionarySelectiveReader\n \n     private byte evaluateFilter(int position, int index, int length)\n     {\n-        if (filter.testLength(length)) {\n-            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n-\n-            boolean pass;\n-            if (isCharType && length != currentLength) {\n-                assert currentLength <= length;\n-                assert valueWithPadding != null;\n-                System.arraycopy(currentDictionaryData, currentDictionaryOffsetVector[index], valueWithPadding, 0, currentLength);\n-                Arrays.fill(valueWithPadding, currentLength, length, (byte) ' ');\n-                pass = filter.testBytes(valueWithPadding, 0, length);\n-            }\n-            else {\n-                pass = filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length);\n-            }\n+        if (!filter.testLength(length)) {\n+            return FILTER_FAILED;\n+        }\n \n-            if (pass) {\n-                if (outputRequired) {\n-                    values[outputPositionCount] = index;\n-                }\n-                outputPositions[outputPositionCount] = position;\n-                outputPositionCount++;\n-                return FILTER_PASSED;\n+        int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n+        if (isCharType && length != currentLength) {\n+            System.arraycopy(currentDictionaryData, currentDictionaryOffsetVector[index], valueWithPadding, 0, currentLength);\n+            Arrays.fill(valueWithPadding, currentLength, length, (byte) ' ');\n+            if (!filter.testBytes(valueWithPadding, 0, length)) {\n+                return FILTER_FAILED;\n             }\n         }\n-        return FILTER_FAILED;\n+        else if (!filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length)) {\n+            return FILTER_FAILED;\n+        }\n+\n+        if (outputRequired) {\n+            values[outputPositionCount] = index;\n+        }\n+        outputPositions[outputPositionCount] = position;\n+        outputPositionCount++;\n+        return FILTER_PASSED;\n     }\n \n     private int readAllNulls(int[] positions, int positionCount)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODUzOQ==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485848539", "bodyText": "Not a huge fan of this dictionaryWrapped state variable. Makes this hard to read and we now need to account manually when we create the dictionary and it is not wrapped. This makes it prone to future bugs if devs don't know when this var is required to be updated. We already have a flag for stripeDictionaryOpen and this adds extra states. Let's put this beside the currentDictionarySize variable and add a comment for when to update this variable?", "author": "sachdevs", "createdAt": "2020-09-09T19:07:37Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -89,14 +90,19 @@\n \n     private byte[] stripeDictionaryData = EMPTY_DICTIONARY_DATA;\n     private int[] stripeDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n+    private byte[] rowGroupDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] rowGroupDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n     private byte[] currentDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] currentDictionaryOffsetVector;\n     private int[] stripeDictionaryLength = new int[0];\n     private int[] rowGroupDictionaryLength = new int[0];\n     private byte[] evaluationStatus;\n+    private byte[] valueWithPadding;\n \n     private int readOffset;\n \n     private VariableWidthBlock dictionary = new VariableWidthBlock(1, wrappedBuffer(EMPTY_DICTIONARY_DATA), EMPTY_DICTIONARY_OFFSETS, Optional.of(new boolean[] {true}));\n+    private boolean dictionaryWrapped;", "originalCommit": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxNjA0NA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r486716044", "bodyText": "@sachdevs I added the following comments:\n private boolean stripeDictionaryOpen;\n    // The dictionaries will be wrapped in getBlock(). It's set to false when opening a new dictionary (be it stripe dictionary or rowgroup dictionary). When there is only stripe\n    // dictionary but no rowgroup dictionaries, we shall set it to false only when opening the stripe dictionary while not for every rowgroup. It is set to true when the dictionary\n    // is wrapped up in wrapDictionaryIfNecessary().\n    private boolean dictionaryWrapped;\n\n\nMakes this hard to read and we now need to account manually when we create the dictionary and it is not wrapped.\n\nCorrection: It's not \" when we create the dictionary\". The dictionary was not created but just read from the input streams in openRowGroup().\nThis variable is required because we don't want to do memory allocation for every rowgroup unless absolutely required(ie. if no rows are selected for the current block then no need to create the dictionary). Furthermore, it needs to be set false explicitly because we don't want to allocate memory for each row group when there is no rowgroup dictionary but only stripe dictionary. A stripe contains multiple rowgroups, and a rowgroup can produce multiple blocks. Dictionaries are only read once from the input streams, but we don't want to copy the read data into a real dictionary for every block/rowgroup. There has to be a state telling us if the DictionaryBlock has been constructed or not for the current output block. The idea is like a state flag: when a new dictionary data is read, set to false; At the first time of DictionaryBlock creation, set it to true. Do you have better idea to not use the state variable without refactoring the whole class too much?", "author": "yingsu00", "createdAt": "2020-09-11T01:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMDE0OA==", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r488100148", "bodyText": "Thanks for the detailed explanation.\n\nThis variable is required because we don't want to do memory allocation for every rowgroup unless absolutely required\n\nYeah I agree that it is necessary. Without refactoring it's hard to get rid of this (I would refactor this into two separate classes probably, no other way to get rid of the var) - which is why I think adding a comment is sufficient for now.", "author": "sachdevs", "createdAt": "2020-09-14T17:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "chunk": "diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\nindex 55f957cf4b..58457761c0 100644\n--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java\n\n@@ -102,7 +103,6 @@ public class SliceDictionarySelectiveReader\n     private int readOffset;\n \n     private VariableWidthBlock dictionary = new VariableWidthBlock(1, wrappedBuffer(EMPTY_DICTIONARY_DATA), EMPTY_DICTIONARY_OFFSETS, Optional.of(new boolean[] {true}));\n-    private boolean dictionaryWrapped;\n \n     private InputStreamSource<BooleanInputStream> presentStreamSource = missingStreamSource(BooleanInputStream.class);\n     private BooleanInputStream presentStream;\n"}}, {"oid": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "url": "https://github.com/prestodb/presto/commit/26c21fc325c1c36c563dcf4136ecc486454bfeb3", "message": "Defer the creation of dictionary in SliceDictionarySelectiveReader\n\nPreviously the dicitonary data byte arrays were allocated as soon as a\nstripe or a rowgroup is open during read(). This commit persists them\nas local buffers, and only copies them to create the dictionary until\ngetBlock() is called. This way the expensive allocations can be avoided\nif a lazyBlock doesn't need to be read.\n\nMoreover, this commit avoids creating Slices when evaluating the\nfilters, which was also another source of big  memory allocations.", "committedDate": "2020-09-11T00:46:01Z", "type": "commit"}, {"oid": "2c25f40100c56cf2e66abf95d6eb7fcafe4a8088", "url": "https://github.com/prestodb/presto/commit/2c25f40100c56cf2e66abf95d6eb7fcafe4a8088", "message": "Remove stripeDictionaryData buffer in SliceDictionarySelectiveReader\n\nIn the past two buffers were needed to store the dictionaries:\nstripeDictionaryData and rowgroupDictionaryData. The stripeDictionaryData\nis unnecessary because we can just use rowgroupDictionaryData. This\ncommit removes stripeDictionaryData and its offsets vector and renames\nthe rowgroupDictionaryData to dictionaryData. currentDicionaryData is\nalso removed since there is only one buffer now.", "committedDate": "2020-09-11T00:46:01Z", "type": "commit"}, {"oid": "4e705248144080bdf198d877f8cfdb0bbc06a02c", "url": "https://github.com/prestodb/presto/commit/4e705248144080bdf198d877f8cfdb0bbc06a02c", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan.", "committedDate": "2020-09-11T00:46:01Z", "type": "commit"}, {"oid": "4e705248144080bdf198d877f8cfdb0bbc06a02c", "url": "https://github.com/prestodb/presto/commit/4e705248144080bdf198d877f8cfdb0bbc06a02c", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan.", "committedDate": "2020-09-11T00:46:01Z", "type": "forcePushed"}]}