{"pr_number": 4220, "pr_title": "sniffer processing profile task and report status and snapshot", "pr_createdAt": "2020-01-12T13:55:56Z", "pr_url": "https://github.com/apache/skywalking/pull/4220", "timeline": [{"oid": "5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "url": "https://github.com/apache/skywalking/commit/5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "message": "sniffer processing profile task and report status and snapshot", "committedDate": "2020-01-12T13:46:02Z", "type": "commit"}, {"oid": "a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "url": "https://github.com/apache/skywalking/commit/a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-12T13:56:11Z", "type": "commit"}, {"oid": "28b26712fd8b7415fd0b1f928de4fe313278c84c", "url": "https://github.com/apache/skywalking/commit/28b26712fd8b7415fd0b1f928de4fe313278c84c", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-12T14:14:14Z", "type": "commit"}, {"oid": "617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "url": "https://github.com/apache/skywalking/commit/617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T00:59:32Z", "type": "commit"}, {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "url": "https://github.com/apache/skywalking/commit/3b051f5c72119fffaad513e0d6c07b787cc2f447", "message": "resolve testServiceDependencies test case error, use same register with `TraceSegmentServiceClient`", "committedDate": "2020-01-13T05:03:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NzU1Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365697557", "bodyText": "MAX_MONITOR_TIME -> MAX_DURATION", "author": "wu-sheng", "createdAt": "2020-01-13T09:09:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\nindex 642710b4c4..a3f7d2a0ac 100755\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n\n@@ -150,29 +150,29 @@ public class Config {\n         public static boolean ACTIVE = true;\n \n         /**\n-         * Parallel monitor segment thread count\n+         * Parallel monitor segment count\n          */\n-        public static int PARALLELS_THREAD_COUNT = 5;\n+        public static int MAX_PARALLEL = 5;\n \n         /**\n          * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n          */\n-        public static int MAX_MONITOR_TIME = 10;\n+        public static int MAX_DURATION = 10;\n \n         /**\n          * Max dump thread stack depth\n          */\n-        public static int MAX_DUMP_STACK_DEPTH = 500;\n+        public static int DUMP_MAX_STACK_DEPTH = 500;\n \n         /**\n-         * Snapshot send to backend channel size\n+         * Snapshot transport to backend channel size\n          */\n-        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+        public static int SNAPSHOT_TRANSPORT_CHANNEL_SIZE = 2;\n \n         /**\n-         * Snapshot send to backend buffer size\n+         * Snapshot transport to backend buffer size\n          */\n-        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;\n+        public static int SNAPSHOT_TRANSPORT_BUFFER_SIZE = 50;\n     }\n \n     public static class Jvm {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODA1NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698054", "bodyText": "MAX_DUMP_STACK_DEPTH -> DUMP_MAX_STACK_DEPTH", "author": "wu-sheng", "createdAt": "2020-01-13T09:10:28Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\nindex 642710b4c4..a3f7d2a0ac 100755\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n\n@@ -150,29 +150,29 @@ public class Config {\n         public static boolean ACTIVE = true;\n \n         /**\n-         * Parallel monitor segment thread count\n+         * Parallel monitor segment count\n          */\n-        public static int PARALLELS_THREAD_COUNT = 5;\n+        public static int MAX_PARALLEL = 5;\n \n         /**\n          * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n          */\n-        public static int MAX_MONITOR_TIME = 10;\n+        public static int MAX_DURATION = 10;\n \n         /**\n          * Max dump thread stack depth\n          */\n-        public static int MAX_DUMP_STACK_DEPTH = 500;\n+        public static int DUMP_MAX_STACK_DEPTH = 500;\n \n         /**\n-         * Snapshot send to backend channel size\n+         * Snapshot transport to backend channel size\n          */\n-        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+        public static int SNAPSHOT_TRANSPORT_CHANNEL_SIZE = 2;\n \n         /**\n-         * Snapshot send to backend buffer size\n+         * Snapshot transport to backend buffer size\n          */\n-        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;\n+        public static int SNAPSHOT_TRANSPORT_BUFFER_SIZE = 50;\n     }\n \n     public static class Jvm {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODU4Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698587", "bodyText": "SEND -> TRANSPORT", "author": "wu-sheng", "createdAt": "2020-01-13T09:11:47Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\nindex 642710b4c4..a3f7d2a0ac 100755\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n\n@@ -150,29 +150,29 @@ public class Config {\n         public static boolean ACTIVE = true;\n \n         /**\n-         * Parallel monitor segment thread count\n+         * Parallel monitor segment count\n          */\n-        public static int PARALLELS_THREAD_COUNT = 5;\n+        public static int MAX_PARALLEL = 5;\n \n         /**\n          * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n          */\n-        public static int MAX_MONITOR_TIME = 10;\n+        public static int MAX_DURATION = 10;\n \n         /**\n          * Max dump thread stack depth\n          */\n-        public static int MAX_DUMP_STACK_DEPTH = 500;\n+        public static int DUMP_MAX_STACK_DEPTH = 500;\n \n         /**\n-         * Snapshot send to backend channel size\n+         * Snapshot transport to backend channel size\n          */\n-        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+        public static int SNAPSHOT_TRANSPORT_CHANNEL_SIZE = 2;\n \n         /**\n-         * Snapshot send to backend buffer size\n+         * Snapshot transport to backend buffer size\n          */\n-        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;\n+        public static int SNAPSHOT_TRANSPORT_BUFFER_SIZE = 50;\n     }\n \n     public static class Jvm {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDcwOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365700708", "bodyText": "Same about the name. And is 50 enough? From my understanding, we do thread dump every 10ms, then we could have 100 in one second. I think as we could collect 5 parallel, you will highly trigger queue abandon mode easily.\nI suggest at least 5 * 500. @kezhenxu94 What do you think?", "author": "wu-sheng", "createdAt": "2020-01-13T09:17:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+\n+        /**\n+         * Snapshot send to backend buffer size\n+         */\n+        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwMTY2Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365901662", "bodyText": "Change to only one thread to process the profile task. So don't use DataCarrier anymore. Change to using LinkedBlockingQueue such as sniffer JVMService. using buffer size 500.", "author": "mrproliu", "createdAt": "2020-01-13T16:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\nindex 642710b4c4..a3f7d2a0ac 100755\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n\n@@ -150,29 +150,29 @@ public class Config {\n         public static boolean ACTIVE = true;\n \n         /**\n-         * Parallel monitor segment thread count\n+         * Parallel monitor segment count\n          */\n-        public static int PARALLELS_THREAD_COUNT = 5;\n+        public static int MAX_PARALLEL = 5;\n \n         /**\n          * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n          */\n-        public static int MAX_MONITOR_TIME = 10;\n+        public static int MAX_DURATION = 10;\n \n         /**\n          * Max dump thread stack depth\n          */\n-        public static int MAX_DUMP_STACK_DEPTH = 500;\n+        public static int DUMP_MAX_STACK_DEPTH = 500;\n \n         /**\n-         * Snapshot send to backend channel size\n+         * Snapshot transport to backend channel size\n          */\n-        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+        public static int SNAPSHOT_TRANSPORT_CHANNEL_SIZE = 2;\n \n         /**\n-         * Snapshot send to backend buffer size\n+         * Snapshot transport to backend buffer size\n          */\n-        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;\n+        public static int SNAPSHOT_TRANSPORT_BUFFER_SIZE = 50;\n     }\n \n     public static class Jvm {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMzMxNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365703315", "bodyText": "-> Check whether the new segment suitable for profiling.", "author": "wu-sheng", "createdAt": "2020-01-13T09:24:16Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\nindex 59b43fcdc9..b1f4a0e7ef 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\n\n@@ -117,8 +117,8 @@ public interface AbstractTracerContext {\n     void asyncStop(AsyncSpan span);\n \n     /**\n-     * Check current creating operation can add profiling, if true, it will start profiling\n-     * @param operationName\n+     * Check whether the new segment suitable for profiling.\n+     * @param firstSpanOPName\n      */\n-    void checkAndAddProfiling(String operationName);\n+    void prepareProfiling(String firstSpanOPName);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNDEwOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365704109", "bodyText": "Rename to prepareProfiling(String firstSpanOPName)", "author": "wu-sheng", "createdAt": "2020-01-13T09:26:05Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling\n+     * @param operationName\n+     */\n+    void checkAndAddProfiling(String operationName);", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\nindex 59b43fcdc9..b1f4a0e7ef 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java\n\n@@ -117,8 +117,8 @@ public interface AbstractTracerContext {\n     void asyncStop(AsyncSpan span);\n \n     /**\n-     * Check current creating operation can add profiling, if true, it will start profiling\n-     * @param operationName\n+     * Check whether the new segment suitable for profiling.\n+     * @param firstSpanOPName\n      */\n-    void checkAndAddProfiling(String operationName);\n+    void prepareProfiling(String firstSpanOPName);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNjIyMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365706220", "bodyText": "PARALLELS_THREAD_COUNT -> MAX_PARALLEL", "author": "wu-sheng", "createdAt": "2020-01-13T09:30:41Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\nindex 642710b4c4..a3f7d2a0ac 100755\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java\n\n@@ -150,29 +150,29 @@ public class Config {\n         public static boolean ACTIVE = true;\n \n         /**\n-         * Parallel monitor segment thread count\n+         * Parallel monitor segment count\n          */\n-        public static int PARALLELS_THREAD_COUNT = 5;\n+        public static int MAX_PARALLEL = 5;\n \n         /**\n          * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n          */\n-        public static int MAX_MONITOR_TIME = 10;\n+        public static int MAX_DURATION = 10;\n \n         /**\n          * Max dump thread stack depth\n          */\n-        public static int MAX_DUMP_STACK_DEPTH = 500;\n+        public static int DUMP_MAX_STACK_DEPTH = 500;\n \n         /**\n-         * Snapshot send to backend channel size\n+         * Snapshot transport to backend channel size\n          */\n-        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+        public static int SNAPSHOT_TRANSPORT_CHANNEL_SIZE = 2;\n \n         /**\n-         * Snapshot send to backend buffer size\n+         * Snapshot transport to backend buffer size\n          */\n-        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;\n+        public static int SNAPSHOT_TRANSPORT_BUFFER_SIZE = 50;\n     }\n \n     public static class Jvm {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwODk4NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365708985", "bodyText": "Using PROFILING_THREAD_SELECTOR as index, I assume there is out of bound risk.", "author": "wu-sheng", "createdAt": "2020-01-13T09:37:22Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +95,33 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {\n+            return false;\n+        }\n+\n+        // check has slot to add\n+        final ProfilingThread profilingThread = PROFILING_THREADS[PROFILING_THREAD_SELECTOR.getAndIncrement()];", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex a2a783c5b9..2f596d2b3a 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -111,15 +108,9 @@ public class ProfileTaskExecutionService implements BootService, TracingContextL\n             return false;\n         }\n \n-        // check has slot to add\n-        final ProfilingThread profilingThread = PROFILING_THREADS[PROFILING_THREAD_SELECTOR.getAndIncrement()];\n-        final ProfilingSegmentContext profilingSegmentContext = profilingThread.checkAndAddSegmentContext(segment, executionContext);\n-        if (profilingSegmentContext == null) {\n-            // current profile thread is running\n-            return false;\n-        }\n-\n-        return true;\n+        // add to profile monitor\n+        // if return not null means add to profiling success\n+        return profileThread.checkAndAddSegmentContext(segment, executionContext) != null;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMDcwNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365710705", "bodyText": "Are you creating so many threads for profiling tasks? I prefer to do this by using only one thread only. And don't create and dispose the thread every time. This is dangerous for JVM from my understanding. @kezhenxu94 @arugal what do you think?", "author": "wu-sheng", "createdAt": "2020-01-13T09:41:19Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -38,13 +45,17 @@\n  * @author MrPro\n  */\n @DefaultImplementor\n-public class ProfileTaskExecutionService implements BootService {\n+public class ProfileTaskExecutionService implements BootService, TracingContextListener {\n \n     private static final ILog logger = LogManager.getLogger(ProfileTaskExecutionService.class);\n \n     // add a schedule while waiting for the task to start or finish\n     private final static ScheduledExecutorService PROFILE_TASK_SCHEDULE = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"PROFILE-TASK-SCHEDULE\"));\n \n+    // profiling segment thread array, Config.Profile.PARALLELS_THREAD_COUNT\n+    private final static ProfilingThread[] PROFILING_THREADS = new ProfilingThread[Config.Profile.PARALLELS_THREAD_COUNT];", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5OTkxOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365899918", "bodyText": "Change profile using the single one thread to process. Please check.", "author": "mrproliu", "createdAt": "2020-01-13T16:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMDcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a4eee23662706757ca46d0ce0837677b93251da", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex a2a783c5b9..4a46dd092a 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -52,9 +52,9 @@ public class ProfileTaskExecutionService implements BootService, TracingContextL\n     // add a schedule while waiting for the task to start or finish\n     private final static ScheduledExecutorService PROFILE_TASK_SCHEDULE = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"PROFILE-TASK-SCHEDULE\"));\n \n-    // profiling segment thread array, Config.Profile.PARALLELS_THREAD_COUNT\n-    private final static ProfilingThread[] PROFILING_THREADS = new ProfilingThread[Config.Profile.PARALLELS_THREAD_COUNT];\n-    private final static AtomicRangeInteger PROFILING_THREAD_SELECTOR = new AtomicRangeInteger(0, Config.Profile.PARALLELS_THREAD_COUNT);\n+    // profiling segment array, Config.Profile.MAX_PARALLEL\n+    private final static ProfilingThread[] PROFILING_THREADS = new ProfilingThread[Config.Profile.MAX_PARALLEL];\n+    private final static AtomicRangeInteger PROFILING_THREAD_SELECTOR = new AtomicRangeInteger(0, Config.Profile.MAX_PARALLEL);\n \n     // last command create time, use to next query task list\n     private volatile long lastCommandCreateTime = -1;\n"}}, {"oid": "078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "url": "https://github.com/apache/skywalking/commit/078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T10:51:18Z", "type": "commit"}, {"oid": "2a4eee23662706757ca46d0ce0837677b93251da", "url": "https://github.com/apache/skywalking/commit/2a4eee23662706757ca46d0ce0837677b93251da", "message": "resolve names", "committedDate": "2020-01-13T12:14:07Z", "type": "commit"}, {"oid": "44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "url": "https://github.com/apache/skywalking/commit/44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T12:15:21Z", "type": "commit"}, {"oid": "286d221ea2b54023798ae863a0222cc7f28ad865", "url": "https://github.com/apache/skywalking/commit/286d221ea2b54023798ae863a0222cc7f28ad865", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T13:33:28Z", "type": "commit"}, {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "url": "https://github.com/apache/skywalking/commit/4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "message": "change profile to single one thread run.", "committedDate": "2020-01-13T16:28:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzgzMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317830", "bodyText": "Why use full class name?", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:03Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\nindex 3e792d5147..cf118725ad 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n\n@@ -40,7 +40,7 @@ import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishRepor\n import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n \n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzk1Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317953", "bodyText": "Same here.", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {\n+                            @Override\n+                            public void onNext(Downstream downstream) {\n+                            }\n+\n+                            @Override\n+                            public void onError(Throwable throwable) {\n+                                status.finished();\n+                                if (logger.isErrorEnable()) {\n+                                    logger.error(throwable, \"Send profile segment snapshot to collector fail with a grpc internal exception.\");\n+                                }\n+                                ServiceManager.INSTANCE.findService(GRPCChannelManager.class).reportError(throwable);\n+                            }\n+\n+                            @Override\n+                            public void onCompleted() {\n+                                status.finished();\n+                            }\n+                        });\n+                        for (ProfileTaskSegmentSnapshot snapshot : buffer) {\n+                            final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transformSnapshot = snapshot.transform();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\nindex 3e792d5147..cf118725ad 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n\n@@ -40,7 +40,7 @@ import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishRepor\n import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n \n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxODEzNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366318135", "bodyText": "You have known the max size, using ArrayList please.", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:49Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\nindex 3e792d5147..cf118725ad 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java\n\n@@ -40,7 +40,7 @@ import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishRepor\n import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n \n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzE3Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323173", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "author": "wu-sheng", "createdAt": "2020-01-14T12:58:51Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzQ4NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323485", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "author": "wu-sheng", "createdAt": "2020-01-14T12:59:38Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDMxOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324319", "bodyText": "PROFILE-MONITOR-THREAD -> PROFILING-THREAD . We don't use the word monitor, because SkyWalking is monitoring many places :)", "author": "wu-sheng", "createdAt": "2020-01-14T13:01:41Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -108,36 +139,49 @@ public void run() {\n     /**\n      * stop profile task, remove context data\n      */\n-    private synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n+    synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n         // stop same context only\n         if (needToStop == null || !taskExecutionContext.compareAndSet(needToStop, null)) {\n             return;\n         }\n \n+        // current execution stop running\n+        needToStop.setRunning(false);\n+\n         // remove task\n         profileTaskList.remove(needToStop.getTask());\n \n-        // TODO notify OAP current profile task execute finish\n+        // notify profiling task has finished\n+        ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class).notifyProfileTaskFinish(needToStop.getTask());\n     }\n \n     @Override\n     public void prepare() throws Throwable {\n-\n     }\n \n     @Override\n     public void boot() throws Throwable {\n-\n+        // init PROFILE_THREAD and start\n+        profileThread = new ProfileThread();\n+        profileThread.setDaemon(true);\n+        profileThread.setName(\"PROFILE-MONITOR-THREAD\");", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex 2f596d2b3a..d937202b09 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -162,9 +163,9 @@ public class ProfileTaskExecutionService implements BootService, TracingContextL\n     @Override\n     public void boot() throws Throwable {\n         // init PROFILE_THREAD and start\n-        profileThread = new ProfileThread();\n+        profileThread = new ProfileThread(TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION));\n         profileThread.setDaemon(true);\n-        profileThread.setName(\"PROFILE-MONITOR-THREAD\");\n+        profileThread.setName(\"PROFILING-THREAD\");\n         profileThread.start();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDkyNg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324926", "bodyText": "checkSegmentProfilingCanContinue -> isSegmentProfilingContinuable. Let's reduce the usage of check.", "author": "wu-sheng", "createdAt": "2020-01-14T13:03:06Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNzYzOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366327638", "bodyText": "Why all these are full names?", "author": "wu-sheng", "createdAt": "2020-01-14T13:09:20Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentStack;\n+\n+import java.util.List;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfileTaskSegmentSnapshot {\n+\n+    // profiling segment context\n+    private final ProfilingSegmentContext segmentContext;\n+\n+    // dump info\n+    private final int sequence;\n+    private final long time;\n+    private final List<String> stackList;\n+\n+    public ProfileTaskSegmentSnapshot(ProfilingSegmentContext segmentContext, int sequence, long time, List<String> stackList) {\n+        this.segmentContext = segmentContext;\n+        this.sequence = sequence;\n+        this.time = time;\n+        this.stackList = stackList;\n+    }\n+\n+    /**\n+     * transform to gRPC data\n+     * @return\n+     */\n+    public org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transform() {\n+        final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.Builder builder = org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.newBuilder();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/TracingThreadSnapshot.java\nsimilarity index 83%\nrename from apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java\nrename to apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/TracingThreadSnapshot.java\nindex a8c1cc831d..aceb3c0678 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/TracingThreadSnapshot.java\n\n@@ -25,18 +25,18 @@ import java.util.List;\n /**\n  * @author MrPro\n  */\n-public class ProfileTaskSegmentSnapshot {\n+public class TracingThreadSnapshot {\n \n-    // profiling segment context\n-    private final ProfilingSegmentContext segmentContext;\n+    // thread profiler\n+    private final ThreadProfiler threadProfiler;\n \n     // dump info\n     private final int sequence;\n     private final long time;\n     private final List<String> stackList;\n \n-    public ProfileTaskSegmentSnapshot(ProfilingSegmentContext segmentContext, int sequence, long time, List<String> stackList) {\n-        this.segmentContext = segmentContext;\n+    public TracingThreadSnapshot(ThreadProfiler threadProfiler, int sequence, long time, List<String> stackList) {\n+        this.threadProfiler = threadProfiler;\n         this.sequence = sequence;\n         this.time = time;\n         this.stackList = stackList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyODMwMw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366328303", "bodyText": "#profiling is inside #run, why check this again?", "author": "wu-sheng", "createdAt": "2020-01-14T13:10:50Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyOTI0Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366329242", "bodyText": "TracingContext#finish has a listener mechanism, you don't need to check every time, you should set up a listener, then you could remove when you get the notification.\nBut you should notice, there is a segment finish event right now, but tracing context has an async mode today, so you need to add a notification, named as notifyAfterMainThreadFinish.", "author": "wu-sheng", "createdAt": "2020-01-14T13:12:43Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzMDg0Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366330846", "bodyText": "Don't check this every time, once you don't get the notification event(notifyAfterMainThreadFinish), it is safe to continue.", "author": "wu-sheng", "createdAt": "2020-01-14T13:16:18Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {\n+            return false;\n+        }\n+\n+        // check is out of limit monitor time\n+        if (System.currentTimeMillis() - context.getProfilingStartTime() > MAX_PROFILING_TIME_MILLS) {\n+            return false;\n+        }\n+\n+        // check segment executing thread is still running\n+        if (!context.getProfilingThread().isAlive()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjIxNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336214", "bodyText": "Renaming to ThreadProfiler. Don't use context always. You need to avoid two similar names in one place, it is very confusing when reading the codes.", "author": "wu-sheng", "createdAt": "2020-01-14T13:27:52Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nsimilarity index 92%\nrename from apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\nrename to apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex d5bb78c25a..d1d7a2ac94 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n /**\n  * @author MrPro\n  */\n-public class ProfilingSegmentContext {\n+public class ThreadProfiler {\n \n     // current segment id\n     private final TraceSegment segment;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjMwNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336305", "bodyText": "Rename to nextSeq", "author": "wu-sheng", "createdAt": "2020-01-14T13:28:05Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {\n+        this.startDump = startDump;\n+    }\n+\n+    /**\n+     * get current sequence then increment it\n+     * @return\n+     */\n+    public int getCurrentAndIncrementSequence() {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nsimilarity index 92%\nrename from apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\nrename to apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex d5bb78c25a..d1d7a2ac94 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n /**\n  * @author MrPro\n  */\n-public class ProfilingSegmentContext {\n+public class ThreadProfiler {\n \n     // current segment id\n     private final TraceSegment segment;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzUyMQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337521", "bodyText": "You should be able to use segment#equal, right? Also, you should begin to move the logic method into the entity.\nThis should be profilingSegmentSlot[slot].matchWith(segment.", "author": "wu-sheng", "createdAt": "2020-01-14T13:30:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzk3Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337976", "bodyText": "What is segmentIsRunning=false?", "author": "wu-sheng", "createdAt": "2020-01-14T13:31:25Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzODc0NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366338744", "bodyText": "No matter how many times you check the thread#isAlive, you still could face the thread is not inactive or dead at here. Try/catch this, and remove all unnecessary check.", "author": "wu-sheng", "createdAt": "2020-01-14T13:33:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTM1Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339357", "bodyText": "This doesn't match the profilingStartTime. Is that a bug?", "author": "wu-sheng", "createdAt": "2020-01-14T13:34:15Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nsimilarity index 92%\nrename from apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\nrename to apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex d5bb78c25a..d1d7a2ac94 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n /**\n  * @author MrPro\n  */\n-public class ProfilingSegmentContext {\n+public class ThreadProfiler {\n \n     // current segment id\n     private final TraceSegment segment;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTgxNg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339816", "bodyText": "This should compare to segment startTime. slot#startTIme is not necessary.", "author": "wu-sheng", "createdAt": "2020-01-14T13:35:16Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDQwMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340402", "bodyText": "startDump -> enum profilingStatus, which has values(READY/PROFILING/STOPPED)", "author": "wu-sheng", "createdAt": "2020-01-14T13:36:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nsimilarity index 92%\nrename from apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\nrename to apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex d5bb78c25a..d1d7a2ac94 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n /**\n  * @author MrPro\n  */\n-public class ProfilingSegmentContext {\n+public class ThreadProfiler {\n \n     // current segment id\n     private final TraceSegment segment;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDk2NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340964", "bodyText": "checkAndAddSegmentContext -> attempProfiling", "author": "wu-sheng", "createdAt": "2020-01-14T13:37:30Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 91dae92169..f3e96de634 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -27,7 +27,6 @@ import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n import java.util.ArrayList;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTY5OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341699", "bodyText": "You should use TracingContext rather than segment as the parameter. segment is a collection of spans, only tracingContext has status.", "author": "wu-sheng", "createdAt": "2020-01-14T13:38:57Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {\n+            return;\n+        }\n+\n+        // update profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex 923590455d..100498b1a1 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -463,20 +475,9 @@ public class TracingContext implements AbstractTracerContext {\n         finish();\n     }\n \n-    @Override\n-    public void prepareProfiling(String firstSpanOPName) {\n-        if (segment.getProfiling()) {\n-            return;\n-        }\n-\n-        // update profiling status\n-        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n-        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));\n-    }\n-\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTk1OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341959", "bodyText": "Why need this check?", "author": "wu-sheng", "createdAt": "2020-01-14T13:39:29Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex 923590455d..100498b1a1 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -463,20 +475,9 @@ public class TracingContext implements AbstractTracerContext {\n         finish();\n     }\n \n-    @Override\n-    public void prepareProfiling(String firstSpanOPName) {\n-        if (segment.getProfiling()) {\n-            return;\n-        }\n-\n-        // update profiling status\n-        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n-        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));\n-    }\n-\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDA3MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344070", "bodyText": "Why need this method? I think we just need to add a parameter in the TracingContext constructor.", "author": "wu-sheng", "createdAt": "2020-01-14T13:43:28Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex 923590455d..100498b1a1 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -463,20 +475,9 @@ public class TracingContext implements AbstractTracerContext {\n         finish();\n     }\n \n-    @Override\n-    public void prepareProfiling(String firstSpanOPName) {\n-        if (segment.getProfiling()) {\n-            return;\n-        }\n-\n-        // update profiling status\n-        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n-        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));\n-    }\n-\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344597", "bodyText": "If no available slot, you don't need the following steps.", "author": "wu-sheng", "createdAt": "2020-01-14T13:44:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +92,27 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDg0Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344843", "bodyText": "This is not must be endpoint name. This is only first span OP name.", "author": "wu-sheng", "createdAt": "2020-01-14T13:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex 2f596d2b3a..d937202b09 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -110,7 +111,7 @@ public class ProfileTaskExecutionService implements BootService, TracingContextL\n \n         // add to profile monitor\n         // if return not null means add to profiling success\n-        return profileThread.checkAndAddSegmentContext(segment, executionContext) != null;\n+        return profileThread.attemptProfiling(segment, executionContext) != null;\n     }\n \n     /**\n"}}, {"oid": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "url": "https://github.com/apache/skywalking/commit/12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "message": "1. change to the ArrayList, because known the max size\n2. rename issue resolved", "committedDate": "2020-01-15T02:14:05Z", "type": "commit"}, {"oid": "40aaf568a866786d171915baf59f53ed688d6ea4", "url": "https://github.com/apache/skywalking/commit/40aaf568a866786d171915baf59f53ed688d6ea4", "message": "add profiling status enum", "committedDate": "2020-01-15T02:37:36Z", "type": "commit"}, {"oid": "3f1d8fcca5b8091cee094b6cc59400713960491b", "url": "https://github.com/apache/skywalking/commit/3f1d8fcca5b8091cee094b6cc59400713960491b", "message": "change sniffer use full name issue", "committedDate": "2020-01-15T02:54:19Z", "type": "commit"}, {"oid": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "url": "https://github.com/apache/skywalking/commit/c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "message": "1. remove `prepareProfiling` method, build profiling status when construct `TracingContext`\n2. add `TracingThreadListenerManager`, notify when tracing main thread finish\n3. change ProfileThread start when process new profile task", "committedDate": "2020-01-15T09:15:37Z", "type": "commit"}, {"oid": "1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "url": "https://github.com/apache/skywalking/commit/1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "message": "remove unnecessary getter", "committedDate": "2020-01-15T09:31:26Z", "type": "commit"}, {"oid": "98dca63fd760af13060c8c36aaa4505330c80dd6", "url": "https://github.com/apache/skywalking/commit/98dca63fd760af13060c8c36aaa4505330c80dd6", "message": "add test assert error message", "committedDate": "2020-01-15T09:52:44Z", "type": "commit"}, {"oid": "e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "url": "https://github.com/apache/skywalking/commit/e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "message": "adding `AgentServiceRule`", "committedDate": "2020-01-15T10:09:48Z", "type": "commit"}, {"oid": "39a8b2eac33fc27007aed11ffee529143928de16", "url": "https://github.com/apache/skywalking/commit/39a8b2eac33fc27007aed11ffee529143928de16", "message": "revert original assert", "committedDate": "2020-01-15T10:21:12Z", "type": "commit"}, {"oid": "c2275c99449726366732c65c1444f996796bc32b", "url": "https://github.com/apache/skywalking/commit/c2275c99449726366732c65c1444f996796bc32b", "message": "remove unnecessary getter", "committedDate": "2020-01-15T12:16:20Z", "type": "commit"}, {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913", "url": "https://github.com/apache/skywalking/commit/ff34355adf6cbb90b444a8543be816c55d3da913", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-15T12:25:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1Mzk0OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366853949", "bodyText": "You don't need to findService every time. Please add a field to hold the ref.", "author": "wu-sheng", "createdAt": "2020-01-15T12:40:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -92,15 +93,27 @@\n \n     private volatile boolean running;\n \n+    private final long createTime;\n+\n+    /**\n+     * profiling status\n+     */\n+    private final boolean profiling;\n+\n     /**\n      * Initialize all fields with default value.\n      */\n-    TracingContext() {\n+    TracingContext(String firstOPName) {\n         this.segment = new TraceSegment();\n         this.spanIdGenerator = 0;\n         samplingService = ServiceManager.INSTANCE.findService(SamplingService.class);\n         isRunningInAsyncMode = false;\n+        createTime = System.currentTimeMillis();\n         running = true;\n+\n+        // profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex 100498b1a1..ed5d51f036 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -112,7 +117,9 @@ public class TracingContext implements AbstractTracerContext {\n         running = true;\n \n         // profiling status\n-        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        if (profileTaskExecutionService == null) {\n+            profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        }\n         this.profiling = profileTaskExecutionService.addProfiling(this, segment.getTraceSegmentId(), firstOPName);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854422", "bodyText": "Notify current tracing context main thread has already execute finished. -> Notify after tracing finished in the main thread.", "author": "wu-sheng", "createdAt": "2020-01-15T12:41:42Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -497,6 +510,11 @@ private void finish() {\n                 TracingContext.ListenerManager.notifyFinish(finishedSegment);\n \n                 running = false;\n+\n+                /**\n+                 * Notify current tracing context main thread has already execute finished.", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDg1MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854851", "bodyText": "This notification should not be in (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)). The condition means async finished.  You just need activeSpanStack.isEmpty() && running.", "author": "wu-sheng", "createdAt": "2020-01-15T12:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex 100498b1a1..ed5d51f036 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -510,11 +525,6 @@ public class TracingContext implements AbstractTracerContext {\n                 TracingContext.ListenerManager.notifyFinish(finishedSegment);\n \n                 running = false;\n-\n-                /**\n-                 * Notify current tracing context main thread has already execute finished.\n-                 */\n-                TracingThreadListenerManager.notifyFinish(this);\n             }\n         } finally {\n             if (isRunningInAsyncMode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTMwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366855307", "bodyText": "Why does the segment still need this? This should be moved into TracingContext.", "author": "wu-sheng", "createdAt": "2020-01-15T12:44:10Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java", "diffHunk": "@@ -74,6 +74,9 @@\n \n     private final long createTime;\n \n+    // segment is profiling\n+    private volatile boolean profiling;", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java\nindex d1bfa20f3d..aef5a5936b 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java\n\n@@ -74,9 +74,6 @@ public class TraceSegment {\n \n     private final long createTime;\n \n-    // segment is profiling\n-    private volatile boolean profiling;\n-\n     /**\n      * Create a default/empty trace segment, with current time as start time, and generate a new segment id.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2MjEyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862127", "bodyText": "threadProfilerSlot  -> threadProfilerSlots", "author": "wu-sheng", "createdAt": "2020-01-15T13:00:55Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex 7d14546dfd..0cc9534afe 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2Mjg3Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862873", "bodyText": "Why don't move this into L118, then you don't need find flag and related codes.", "author": "wu-sheng", "createdAt": "2020-01-15T13:02:38Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentProfiler.stopProfiling();\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentProfilingCount.addAndGet(-1);", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex 7d14546dfd..0cc9534afe 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NDIyOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366864228", "bodyText": "As this method could be called in another thread, you need to set the whole array again, and add volatile, read solution 2, https://www.javamex.com/tutorials/volatile_arrays.shtml", "author": "wu-sheng", "createdAt": "2020-01-15T13:05:51Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex 7d14546dfd..0cc9534afe 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NzU3NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366867575", "bodyText": "segment should not exist. Dump the executing thread stack.", "author": "wu-sheng", "createdAt": "2020-01-15T13:13:39Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 3cf0e8ccf6..f236149b53 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n /**\n- * Profile task process thread, dump segment executing thread stack.\n+ * Profile task process thread, dump the executing thread stack.\n  *\n  * @author MrPro\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MjUyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366872527", "bodyText": "Is this for shutdown process only?", "author": "wu-sheng", "createdAt": "2020-01-15T13:25:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread implements Runnable {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // profiling task context\n+    private final ProfileTaskExecutionContext taskExecutionContext;\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread(ProfileTaskExecutionContext taskExecutionContext) {\n+        this.taskExecutionContext = taskExecutionContext;\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            profiling(taskExecutionContext);\n+        } catch (InterruptedException e) {\n+            // ignore interrupted\n+            // means current task has stopped", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA2NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367195064", "bodyText": "Yes, I think it will only end when other threads notify him, unless he actively raises an exception.", "author": "mrproliu", "createdAt": "2020-01-16T01:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MjUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\nindex 3cf0e8ccf6..f236149b53 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java\n\n@@ -23,7 +23,7 @@ import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n \n /**\n- * Profile task process thread, dump segment executing thread stack.\n+ * Profile task process thread, dump the executing thread stack.\n  *\n  * @author MrPro\n  */\n"}}, {"oid": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "url": "https://github.com/apache/skywalking/commit/88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "message": "resolve issues", "committedDate": "2020-01-16T02:13:29Z", "type": "commit"}, {"oid": "089245dedac4311d02abb431f9bd8a4224f88beb", "url": "https://github.com/apache/skywalking/commit/089245dedac4311d02abb431f9bd8a4224f88beb", "message": "reduce findService invoke", "committedDate": "2020-01-16T02:15:47Z", "type": "commit"}, {"oid": "901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "url": "https://github.com/apache/skywalking/commit/901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "message": "resolve style error", "committedDate": "2020-01-16T02:25:21Z", "type": "commit"}, {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "url": "https://github.com/apache/skywalking/commit/5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "message": "recheck profiling when change first span operatin name", "committedDate": "2020-01-16T06:07:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NTA3MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367265071", "bodyText": "tracingFinishInMainThread -> isFinishedInMainThread", "author": "wu-sheng", "createdAt": "2020-01-16T07:26:25Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,16 +485,34 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void profilingRecheck(AbstractSpan span, String operationName) {\n+        // only recheck first span\n+        if (span.getSpanId() != 0) {\n+            return;\n+        }\n+\n+        profiling = PROFILE_TASK_EXECUTION_SERVICE.profilingRecheck(this, segment.getTraceSegmentId(), operationName);\n+    }\n+\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n             asyncFinishLock.lock();\n         }\n         try {\n-            if (activeSpanStack.isEmpty() && running && (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)) {\n+            boolean tracingFinishInMainThread = activeSpanStack.isEmpty() && running;", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\nindex e1883d6c0c..9a9ccd5eea 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java\n\n@@ -485,7 +487,12 @@ public class TracingContext implements AbstractTracerContext {\n         finish();\n     }\n \n-    @Override\n+    /**\n+     * Re-check current trace need profiling, encase third part plugin change the operation name.\n+     *\n+     * @param span current modify span\n+     * @param operationName change to operation name\n+     */\n     public void profilingRecheck(AbstractSpan span, String operationName) {\n         // only recheck first span\n         if (span.getSpanId() != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NjAxMQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367266011", "bodyText": "I think we don't need ContextManager#profilingRecheck. There is a ref of tracingContext in the span, check AbstractTracingSpan. You should use it, it is better to keep profilingRecheck in private, right?", "author": "wu-sheng", "createdAt": "2020-01-16T07:29:43Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java", "diffHunk": "@@ -203,6 +203,9 @@ public AbstractTracingSpan errorOccurred() {\n     public AbstractTracingSpan setOperationName(String operationName) {\n         this.operationName = operationName;\n         this.operationId = DictionaryUtil.nullValue();\n+\n+        // recheck profiling status\n+        ContextManager.profilingRecheck(this, operationName);", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java\nindex d39780bcde..4eec0676f3 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java\n\n@@ -205,7 +211,7 @@ public abstract class AbstractTracingSpan implements AbstractSpan {\n         this.operationId = DictionaryUtil.nullValue();\n \n         // recheck profiling status\n-        ContextManager.profilingRecheck(this, operationName);\n+        owner.profilingRecheck(this, operationName);\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3MjIzMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367272230", "bodyText": "I think you missed the profilingSegmentSlots resign to make volatile works.", "author": "wu-sheng", "createdAt": "2020-01-16T07:50:27Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +163,20 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex aca2430e03..5e224af82f 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -174,6 +174,9 @@ public class ProfileTaskExecutionContext {\n         for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n             if (profilingSegmentSlots[slot] == null) {\n                 profilingSegmentSlots[slot] = segmentContext;\n+\n+                // see https://www.javamex.com/tutorials/volatile_arrays.shtml, solution 2\n+                profilingSegmentSlots = profilingSegmentSlots;\n                 break;\n             }\n         }\n"}}, {"oid": "2eb35150e7e9b12b5db8da725b547ea805a66b10", "url": "https://github.com/apache/skywalking/commit/2eb35150e7e9b12b5db8da725b547ea805a66b10", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-16T08:36:59Z", "type": "commit"}, {"oid": "9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "url": "https://github.com/apache/skywalking/commit/9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-16T13:10:19Z", "type": "commit"}, {"oid": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "url": "https://github.com/apache/skywalking/commit/b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "message": "resolve issues\n1. remove `ContextManager#profilingRecheck`, only check on `TracingContext`\n2. rename comments\n3. resolve volatile array setting", "committedDate": "2020-01-17T02:41:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NzEyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367747127", "bodyText": "Don't put the link here. The article is just reference, we don't have the license to broadcast it.", "author": "wu-sheng", "createdAt": "2020-01-17T02:47:37Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -174,6 +174,9 @@ private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSeg\n         for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n             if (profilingSegmentSlots[slot] == null) {\n                 profilingSegmentSlots[slot] = segmentContext;\n+\n+                // see https://www.javamex.com/tutorials/volatile_arrays.shtml, solution 2", "originalCommit": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex 5e224af82f..628b719dc1 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -175,7 +174,6 @@ public class ProfileTaskExecutionContext {\n             if (profilingSegmentSlots[slot] == null) {\n                 profilingSegmentSlots[slot] = segmentContext;\n \n-                // see https://www.javamex.com/tutorials/volatile_arrays.shtml, solution 2\n                 profilingSegmentSlots = profilingSegmentSlots;\n                 break;\n             }\n"}}, {"oid": "8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "url": "https://github.com/apache/skywalking/commit/8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "message": "remove article link", "committedDate": "2020-01-17T02:50:02Z", "type": "commit"}, {"oid": "5945c884724387215f5d417e4763aa4c8dc61812", "url": "https://github.com/apache/skywalking/commit/5945c884724387215f5d417e4763aa4c8dc61812", "message": "add `ProfileTask#maxSamplingCount` check", "committedDate": "2020-01-17T03:49:02Z", "type": "commit"}, {"oid": "5279c53b8eb6770c2e9b557f2257370fb3e37267", "url": "https://github.com/apache/skywalking/commit/5279c53b8eb6770c2e9b557f2257370fb3e37267", "message": "resolve conflict (Downstream -> Commands)", "committedDate": "2020-01-17T12:52:51Z", "type": "commit"}, {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713", "url": "https://github.com/apache/skywalking/commit/ec08e2648fef30ccb477d72619fdcd787eaec713", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-17T12:53:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxODE1Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367918152", "bodyText": "Same as before, don't use Config in the field initialization. Use it in the constructor.", "author": "wu-sheng", "createdAt": "2020-01-17T12:45:47Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "originalCommit": "5945c884724387215f5d417e4763aa4c8dc61812", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots;\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNDc5Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367924796", "bodyText": "Merge tryToAttemptProfiling -> attemptProfiling. Similar name, always use in the same time.", "author": "wu-sheng", "createdAt": "2020-01-17T13:03:35Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -182,27 +180,4 @@ public class ProfileTaskExecutionContext {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n-\n-    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n-        // if out limit started profiling count then stop add profiling\n-        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n-            return false;\n-        }\n-\n-        // try to occupy slot\n-        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n-            return false;\n-        }\n-\n-        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n-        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n-            if (profilingSegmentSlots[slot] == null) {\n-                profilingSegmentSlots[slot] = segmentContext;\n-\n-                profilingSegmentSlots = profilingSegmentSlots;\n-                break;\n-            }\n-        }\n-        return true;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTkwMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367929902", "bodyText": "Why does this check happen at the start stage? I think when totalStartedProfilingCount reaches max count, this profile should be at the profiling stage. Do I miss anything?", "author": "wu-sheng", "createdAt": "2020-01-17T13:16:58Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;\n+                break;\n+            }\n+        }\n+\n+        return isProfilingStarted;\n     }\n \n     public ProfileTask getTask() {\n         return task;\n     }\n \n-    public long getStartTime() {\n-        return startTime;\n+    public ThreadProfiler[] threadProfilerSlots() {\n+        return profilingSegmentSlots;\n     }\n \n+    public boolean isStartProfileable(ThreadProfiler profiler) {\n+        // check is out of max sampling count check\n+        if (totalStartedProfilingCount.incrementAndGet() > task.getMaxSamplingCount()) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDM4MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367954380", "bodyText": "You are right, the check happens on the profiling stage. Maybe name as you feel confused, I change the name to isProfileable. It will invoke on ThreadProfiler#startProfilingIfNeed. When the tracing context starts time bigger than profile task minDurationThresold, It will have a check.", "author": "mrproliu", "createdAt": "2020-01-17T14:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots;\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930307", "bodyText": "Once the profile starts, it should not stop.", "author": "wu-sheng", "createdAt": "2020-01-17T13:18:02Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDU1Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930556", "bodyText": "Otherwise, if I set a profiling task targeting a Tomcat endpoint name, it will never execute as SpringMVC must override it", "author": "wu-sheng", "createdAt": "2020-01-17T13:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw=="}], "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots;\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMzUxMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367933510", "bodyText": "This isn't segmentContext, please rename.", "author": "wu-sheng", "createdAt": "2020-01-17T13:26:22Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -182,27 +180,4 @@ public class ProfileTaskExecutionContext {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n-\n-    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n-        // if out limit started profiling count then stop add profiling\n-        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n-            return false;\n-        }\n-\n-        // try to occupy slot\n-        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n-            return false;\n-        }\n-\n-        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n-        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n-            if (profilingSegmentSlots[slot] == null) {\n-                profilingSegmentSlots[slot] = segmentContext;\n-\n-                profilingSegmentSlots = profilingSegmentSlots;\n-                break;\n-            }\n-        }\n-        return true;\n-    }\n }\n"}}, {"oid": "dc86d725a8ea60be80e9b579c6e451ae50244933", "url": "https://github.com/apache/skywalking/commit/dc86d725a8ea60be80e9b579c6e451ae50244933", "message": "1. change profilingSegmentSlots init on construct\n2. if is profiling, recheck dont need to stop\n3. total profiling count increment on first dump", "committedDate": "2020-01-17T14:44:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367943992", "bodyText": "This line is really confusing, what does it do?", "author": "kezhenxu94", "createdAt": "2020-01-17T13:50:44Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3OTY4Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367979687", "bodyText": "You need to follow prefer review comments :) This is for activating volatile :P", "author": "wu-sheng", "createdAt": "2020-01-17T15:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDc2MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367980760", "bodyText": "You are changing the element of an array, the volatile would work unless we do this.", "author": "wu-sheng", "createdAt": "2020-01-17T15:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5NjUwOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367996509", "bodyText": "You need to follow prefer review comments :) This is for activating volatile :P\nYou are changing the element of an array, the volatile would work unless we do this.\n\nWell sorry I indeed lose the context here, but why not simply use java.util.concurrent.atomic.AtomicReferenceArray, it does the same thing, even if we cannot use this class, for some reasons, it should be documented, later contributors may be hard to follow the review comments, especially when this gets merged, and people like you and me may forget the reason in some day, and the IDE is \"too enthusiastic\u201c to hint that one should remove it:", "author": "kezhenxu94", "createdAt": "2020-01-17T15:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNTA1MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368015051", "bodyText": "I remember that did this in different way. Can't remember the detail.Personally, I just use the easy way.\n@mrproliu you could add doc, but don't use the link to that blog.", "author": "wu-sheng", "createdAt": "2020-01-17T16:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjE3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368032172", "bodyText": "I just use the easy way.\n\nIMHO, your meaning by saying \"easy\" is the data structure (array) itself, but in this case, we're tackling the thread-visibilities, I'd say it would be much more straightforward to use java.util.concurrent.atomic.AtomicReferenceArray than assigning the field to it self, Java programmers should be familiar with the former after all, my personal thought;\nAnd you just brought me the interest to do a benchmark on the two solutions, in terms of the performance, check the following benchmark and results:\nBenchmark Codes\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.apm.plugin.dubbo;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.OutputTimeUnit;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.RunnerException;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\n\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Thread)\n@Fork(2)\n@Warmup(iterations = 4)\n@Measurement(iterations = 5)\npublic class AtomicArrayBenchmarkTest {\n    final int arraySize = 50;\n    final AtomicReferenceArray<Object> atomicReferenceArray = new AtomicReferenceArray<>(arraySize);\n\n    @Benchmark\n    public void testAtomicArray() {\n        for (int i = 0; i < arraySize; i++) {\n            atomicReferenceArray.set(i, new Object());\n        }\n    }\n\n    volatile Object[] volatileArray = new Object[arraySize];\n\n    @Benchmark\n    public void testRawArray() {\n        for (int i = 0; i < arraySize; i++) {\n            volatileArray[i] = new Object();\n            volatileArray = volatileArray;\n        }\n    }\n\n    @BenchmarkMode(Mode.AverageTime)\n    @OutputTimeUnit(TimeUnit.MICROSECONDS)\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder().include(AtomicArrayBenchmarkTest.class.getSimpleName()).build();\n        new Runner(options).run();\n    }\n}\n\nResult\nBenchmark                                                Mode  Samples     Score  Score error   Units\no.a.s.a.p.d.AtomicArrayBenchmarkTest.testAtomicArray    thrpt       25  3003.470       37.575  ops/ms\no.a.s.a.p.d.AtomicArrayBenchmarkTest.testRawArray       thrpt       25  2766.009       27.934  ops/ms\n\nit may be not that precise, but I'm with it :) since you said\n\nProfiling is happening in a high payload scenario\n\nperformance matters", "author": "kezhenxu94", "createdAt": "2020-01-17T16:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjc2MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368192761", "bodyText": "Make sense for switching to AtomicReferenceArray in this case.", "author": "wu-sheng", "createdAt": "2020-01-18T01:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMjcxMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368202712", "bodyText": "Change slot to the AtomicReferenceArray, please recheck. @wu-sheng @kezhenxu94", "author": "mrproliu", "createdAt": "2020-01-18T03:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots;\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NDI3Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367944277", "bodyText": "And this one", "author": "kezhenxu94", "createdAt": "2020-01-17T13:51:23Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -182,27 +180,4 @@ public class ProfileTaskExecutionContext {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n-\n-    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n-        // if out limit started profiling count then stop add profiling\n-        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n-            return false;\n-        }\n-\n-        // try to occupy slot\n-        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n-            return false;\n-        }\n-\n-        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n-        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n-            if (profilingSegmentSlots[slot] == null) {\n-                profilingSegmentSlots[slot] = segmentContext;\n-\n-                profilingSegmentSlots = profilingSegmentSlots;\n-                break;\n-            }\n-        }\n-        return true;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367947098", "bodyText": "I prefer to let this method return an Exception, maybe java.lang.IllegalStateException, simply return a string is no so semantic, and you may want to print the stack trace there, since it's a kind of \"exception\", in some degree", "author": "kezhenxu94", "createdAt": "2020-01-17T13:57:45Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -151,7 +202,7 @@ public long getLastCommandCreateTime() {\n      */\n     private String checkProfileTaskSuccess(ProfileTask task) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDM3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367980372", "bodyText": "In this case, I prefer to return a Result class, rather than exception. Profiling is happening in a high payload scenario, but Exception is a heavy OP. We should avoid it.", "author": "wu-sheng", "createdAt": "2020-01-17T15:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzQ4NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368027484", "bodyText": "In this case, I prefer to return a Result class, rather than exception. Profiling is happening in a high payload scenario, but Exception is a heavy OP. We should avoid it.\n\nSounds good to me", "author": "kezhenxu94", "createdAt": "2020-01-17T16:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMjY3NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368202674", "bodyText": "@kezhenxu94 @wu-sheng resolved, please check", "author": "mrproliu", "createdAt": "2020-01-18T03:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex df3c0e70cc..c3aa455f71 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -197,8 +191,7 @@ public class ProfileTaskExecutionService implements BootService, TracingThreadLi\n \n     /**\n      * check profile task data success, make the re-check, prevent receiving wrong data from database or OAP\n-     * @param task\n-     * @return\n+     * @return if not null, means profile task have error message\n      */\n     private String checkProfileTaskSuccess(ProfileTask task) {\n         // endpoint name\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MDgxNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367950814", "bodyText": "You have so many JavaDocs like this, please add corresponding descriptions, or remove the @param and @return, although it can compile, it produces uncountable warnings in CI (javadoc:javadoc), and many many warnings in the IDE, making it hard to discover warnings that really matters:", "author": "kezhenxu94", "createdAt": "2020-01-17T14:05:44Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc86d725a8ea60be80e9b579c6e451ae50244933", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex dc50785685..b4cbd8bca6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -41,7 +41,7 @@ public class ProfileTaskExecutionContext {\n     private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n \n     // profiling segment slot\n-    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+    private volatile ThreadProfiler[] profilingSegmentSlots;\n \n     // current profiling execution future\n     private volatile Future profilingFuture;\n"}}, {"oid": "b29dcad201c54295b4443bc53eaaad25db25d136", "url": "https://github.com/apache/skywalking/commit/b29dcad201c54295b4443bc53eaaad25db25d136", "message": "remove unused return val", "committedDate": "2020-01-17T15:00:51Z", "type": "commit"}, {"oid": "a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "url": "https://github.com/apache/skywalking/commit/a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "message": "remove some `@param` and `@return`", "committedDate": "2020-01-17T15:08:44Z", "type": "commit"}, {"oid": "914021a0f5611a3963b89b03cd2e54bb8157cefb", "url": "https://github.com/apache/skywalking/commit/914021a0f5611a3963b89b03cd2e54bb8157cefb", "message": "add profile task check result data bean", "committedDate": "2020-01-18T02:42:20Z", "type": "commit"}, {"oid": "d455464c9a7d2977e803db2e99a7101ddb3cb452", "url": "https://github.com/apache/skywalking/commit/d455464c9a7d2977e803db2e99a7101ddb3cb452", "message": "change profiler slot to `AtomicReferenceArray`", "committedDate": "2020-01-18T03:04:14Z", "type": "commit"}, {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "url": "https://github.com/apache/skywalking/commit/01bfafb695de56c7cc13d9d92db93dbb194d0c19", "message": "resolved java doc error", "committedDate": "2020-01-18T03:22:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg3MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204871", "bodyText": "You don't return anything at all", "author": "kezhenxu94", "createdAt": "2020-01-18T04:17:34Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +38,129 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile AtomicReferenceArray<ThreadProfiler> profilingSegmentSlots;\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n+\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+        profilingSegmentSlots = new AtomicReferenceArray<>(Config.Profile.MAX_PARALLEL);\n+    }\n+\n+    /**\n+     * start profiling this task\n+     *\n+     * @param executorService start profiling to appoint thread pool\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     *\n+     * @param tracingContext need to profiling trace\n+     * @param traceSegmentId current trace segment id\n+     * @param firstSpanOPName first span operation name\n+     * @return is add profile success\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler threadProfiler = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        int slotLength = profilingSegmentSlots.length();\n+        for (int slot = 0; slot < slotLength; slot++) {\n+            if (profilingSegmentSlots.compareAndSet(slot, null, threadProfiler)) {\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     *\n+     * @return is recheck to add profile success\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // if started, keep profiling\n+        if (tracingContext.isProfiling()) {\n+            return true;\n+        }\n+\n+        return attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext stop profiling appoint trace\n+     * @return current profiler is already start profiling", "originalCommit": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\nindex a64165e6cc..b17414c6b6 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java\n\n@@ -57,8 +57,6 @@ public class ProfileTaskExecutionContext {\n \n     /**\n      * start profiling this task\n-     *\n-     * @param executorService start profiling to appoint thread pool\n      */\n     public void startProfiling(ExecutorService executorService) {\n         profilingFuture = executorService.submit(new ProfileThread(this));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg5Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204892", "bodyText": "Same here", "author": "kezhenxu94", "createdAt": "2020-01-18T04:18:01Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     *\n+     * @return current profiler is already start profiling", "originalCommit": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex 81a814c012..0d0611d23a 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -69,8 +69,6 @@ public class ThreadProfiler {\n \n     /**\n      * Stop profiling status\n-     *\n-     * @return current profiler is already start profiling\n      */\n     public void stopProfiling() {\n         this.profilingStatus = ProfilingStatus.STOPPED;\n"}}, {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "url": "https://github.com/apache/skywalking/commit/7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "message": "fix doc error, remove meaningless descriptions", "committedDate": "2020-01-18T04:37:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208207", "bodyText": "if Config.Profile.ACTIVE ==  false TracingThreadSnapshot should be ignored, right?", "author": "arugal", "createdAt": "2020-01-18T05:42:08Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.network.language.profile.ThreadSnapshot;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<TracingThreadSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     */\n+    public void addProfilingSnapshot(TracingThreadSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODU3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208572", "bodyText": "If not active profile, there will not going to happen.  I think it is useless to add judgment here, and it will also increase the cost of judgment.", "author": "mrproliu", "createdAt": "2020-01-18T05:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODcyNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208724", "bodyText": "sorry, I was wrong.", "author": "arugal", "createdAt": "2020-01-18T05:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "85f557c3790290d4a597e11eb84165b169cae032", "url": "https://github.com/apache/skywalking/commit/85f557c3790290d4a597e11eb84165b169cae032", "message": "resolve missed profile receiver on oap starter", "committedDate": "2020-01-18T08:19:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxMzY3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368213672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Re-check current trace need profiling, encase third part plugin change the operation name.\n          \n          \n            \n                 * Re-check current trace need profiling, in case that third-party plugins change the operation name.", "author": "kezhenxu94", "createdAt": "2020-01-18T08:02:04Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,19 +90,46 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TracingContext} profiling\n+     */\n+    public boolean addProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // get current profiling task, check need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+\n+        return executionContext.attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * Re-check current trace need profiling, encase third part plugin change the operation name.", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c5eeed53b2126733b6a61db41a3e9920ef5117f", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\nindex f0211617e1..9a3f2703f7 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java\n\n@@ -104,7 +104,7 @@ public class ProfileTaskExecutionService implements BootService, TracingThreadLi\n     }\n \n     /**\n-     * Re-check current trace need profiling, encase third part plugin change the operation name.\n+     * Re-check current trace need profiling, in case that third-party plugins change the operation name.\n      */\n     public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n         // get current profiling task, check need profiling\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDA5NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isProfilingProfilingContinuable() {\n          \n          \n            \n                private boolean isProfilingContinuable() {", "author": "kezhenxu94", "createdAt": "2020-01-18T08:12:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue\n+     *\n+     * @return if true means this thread profiling is continuable\n+     */\n+    private boolean isProfilingProfilingContinuable() {", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex 0d0611d23a..d070659b4e 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -138,7 +138,7 @@ public class ThreadProfiler {\n      *\n      * @return if true means this thread profiling is continuable\n      */\n-    private boolean isProfilingProfilingContinuable() {\n+    private boolean isProfilingContinuable() {\n         return System.currentTimeMillis() - profilingStartTime < profilingMaxTimeMills;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDExMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * check profiling is should continue\n          \n          \n            \n                 * check whether profiling should continue", "author": "kezhenxu94", "createdAt": "2020-01-18T08:12:49Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex 0d0611d23a..d070659b4e 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -138,7 +138,7 @@ public class ThreadProfiler {\n      *\n      * @return if true means this thread profiling is continuable\n      */\n-    private boolean isProfilingProfilingContinuable() {\n+    private boolean isProfilingContinuable() {\n         return System.currentTimeMillis() - profilingStartTime < profilingMaxTimeMills;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214282", "bodyText": "Maybe take the case when element.getLineNumber() < 0 into consideration? Make it Unknown Source?", "author": "kezhenxu94", "createdAt": "2020-01-18T08:15:20Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNTQzNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368215435", "bodyText": "I am OK with line number = -1. :) Both are fine to me.", "author": "wu-sheng", "createdAt": "2020-01-18T08:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNTU1Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368215552", "bodyText": "It's ok to me, \"Unknown Source\" takes more bandwidth then \"-1\" after all", "author": "kezhenxu94", "createdAt": "2020-01-18T08:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "chunk": "diff --git a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\nindex 0d0611d23a..d070659b4e 100644\n--- a/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n+++ b/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java\n\n@@ -138,7 +138,7 @@ public class ThreadProfiler {\n      *\n      * @return if true means this thread profiling is continuable\n      */\n-    private boolean isProfilingProfilingContinuable() {\n+    private boolean isProfilingContinuable() {\n         return System.currentTimeMillis() - profilingStartTime < profilingMaxTimeMills;\n     }\n \n"}}, {"oid": "9c5eeed53b2126733b6a61db41a3e9920ef5117f", "url": "https://github.com/apache/skywalking/commit/9c5eeed53b2126733b6a61db41a3e9920ef5117f", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T08:52:44Z", "type": "commit"}, {"oid": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "url": "https://github.com/apache/skywalking/commit/a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "message": "update isProfilingContinuable method name\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T08:57:42Z", "type": "commit"}, {"oid": "659d794b9ed25c916990f60802d500b4d163e54d", "url": "https://github.com/apache/skywalking/commit/659d794b9ed25c916990f60802d500b4d163e54d", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T09:00:59Z", "type": "commit"}, {"oid": "8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "url": "https://github.com/apache/skywalking/commit/8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "message": "resolve method invoke error", "committedDate": "2020-01-18T09:08:53Z", "type": "commit"}]}