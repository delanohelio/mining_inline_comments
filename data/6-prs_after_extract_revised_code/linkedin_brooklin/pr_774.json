{"pr_number": 774, "pr_title": "Add preAssignmentCleanup in Coordinator and extend assignment strategy", "pr_createdAt": "2020-11-03T19:20:47Z", "pr_url": "https://github.com/linkedin/brooklin/pull/774", "timeline": [{"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "message": "Merge pull request #1 from linkedin/master\n\nPull latest", "committedDate": "2019-11-18T20:06:44Z", "type": "commit"}, {"oid": "79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "url": "https://github.com/linkedin/brooklin/commit/79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "message": "Merge branch 'master' of github.com:linkedin/brooklin", "committedDate": "2020-11-02T20:44:50Z", "type": "commit"}, {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "url": "https://github.com/linkedin/brooklin/commit/0f33e4e600ce5ef837f603269fba4118e581b6b7", "message": "Add pre assignment cleanup to let the new leader perform cleanup before assignment if required", "committedDate": "2020-11-03T19:05:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDMzNw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516910337", "bodyText": "Maybe \"need to be validated\"?", "author": "jzakaryan", "createdAt": "2020-11-03T19:37:19Z", "path": "datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java", "diffHunk": "@@ -89,4 +90,16 @@\n       Map<String, Set<String>> targetAssignment, DatastreamGroupPartitionsMetadata partitionsMetadata) {\n     throw new NotImplementedException(\"movePartitions are not implemented\");\n   }\n+\n+  /**\n+   * Validate the current assignment and return the list of DatastreamTask per instance to be cleaned up.\n+   *\n+   * @param datastreams all the datastreams for which the associated tasks to be validated", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java b/datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java\nindex aaa3b1ad..bf1558e0 100644\n--- a/datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java\n+++ b/datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java\n\n@@ -94,7 +94,7 @@ public interface AssignmentStrategy {\n   /**\n    * Validate the current assignment and return the list of DatastreamTask per instance to be cleaned up.\n    *\n-   * @param datastreams all the datastreams for which the associated tasks to be validated\n+   * @param datastreams all the datastreams for which the associated tasks need to be validated\n    * @param currentAssignment existing assignment\n    * @return tasks per instance to be cleaned up\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516913878", "bodyText": "Do you think we should turn on this feature by default without testing it in production?", "author": "jzakaryan", "createdAt": "2020-11-03T19:43:52Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java", "diffHunk": "@@ -59,6 +61,7 @@ public CoordinatorConfig(Properties config) {\n     _defaultTransportProviderName = _properties.getString(CONFIG_DEFAULT_TRANSPORT_PROVIDER, \"\");\n     _zkCleanUpOrphanConnectorTask = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK, false);\n     _zkCleanUpOrphanConnectorTaskLock = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK_LOCK, false);\n+    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, true);", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDM1MQ==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517714351", "bodyText": "+1 we should definitely test this first", "author": "somandal", "createdAt": "2020-11-05T00:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDg3NA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r518430874", "bodyText": "From testing, you mean we should just identify and print them?", "author": "vmaheshw", "createdAt": "2020-11-05T23:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzAwMg==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r518437002", "bodyText": "No, at least I meant, let's disable this by default, enable it through config when testing in cert, and once it looks good, add the config to enable it everywhere.", "author": "somandal", "createdAt": "2020-11-05T23:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java b/datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java\nindex c0360b23..bb4cf7b4 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java\n\n@@ -61,7 +61,7 @@ public final class CoordinatorConfig {\n     _defaultTransportProviderName = _properties.getString(CONFIG_DEFAULT_TRANSPORT_PROVIDER, \"\");\n     _zkCleanUpOrphanConnectorTask = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK, false);\n     _zkCleanUpOrphanConnectorTaskLock = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK_LOCK, false);\n-    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, true);\n+    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, false);\n   }\n \n   public Properties getConfigProperties() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNTYwNg==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516915606", "bodyText": "Nit: list of tasks\nAlso could be reworded to:\nIf a task is both in the dependency list as well as the current assignment list, it's possible that the previous leader went down before getting a chance to clean it up and update the zookeeper. This method identifies such tasks.", "author": "jzakaryan", "createdAt": "2020-11-03T19:47:09Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\nindex d6d82d8f..2136b225 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n\n@@ -272,15 +272,15 @@ public class StickyPartitionAssignmentStrategy extends StickyMulticastStrategy {\n   }\n \n   /**\n-   * This method checks the current assignment and returns the list of the task which are in the\n+   * This method checks the current assignment and returns the list of tasks which are in the\n    * dependency list as well as in current assignment. The logic is the task in the dependency list\n-   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * must not be present in the current assignment list. It's possible when the previous leader was\n    * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n    * from the zookeeper.\n    *\n    * @param datastreamGroups datastream groups to associate the tasks with\n    * @param currentAssignment existing assignment\n-   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   * @return  list of datastream tasks mapped by instance that need to be cleaned up.\n    */\n   public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n       Map<String, Set<DatastreamTask>> currentAssignment) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNjE4MA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517716180", "bodyText": "nit: Reword: list of datastream tasks mapped by instance that need to be cleaned up.", "author": "somandal", "createdAt": "2020-11-05T00:46:52Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\nindex d6d82d8f..2136b225 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n\n@@ -272,15 +272,15 @@ public class StickyPartitionAssignmentStrategy extends StickyMulticastStrategy {\n   }\n \n   /**\n-   * This method checks the current assignment and returns the list of the task which are in the\n+   * This method checks the current assignment and returns the list of tasks which are in the\n    * dependency list as well as in current assignment. The logic is the task in the dependency list\n-   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * must not be present in the current assignment list. It's possible when the previous leader was\n    * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n    * from the zookeeper.\n    *\n    * @param datastreamGroups datastream groups to associate the tasks with\n    * @param currentAssignment existing assignment\n-   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   * @return  list of datastream tasks mapped by instance that need to be cleaned up.\n    */\n   public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n       Map<String, Set<DatastreamTask>> currentAssignment) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzcyMA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717720", "bodyText": "nit: rename tasksPerInstance to dependencyTasksPerInstance (since this is doing the actual filtering logic, and the final list consists of dependency tasks left behind in the assignment)", "author": "somandal", "createdAt": "2020-11-05T00:51:56Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\nindex d6d82d8f..2136b225 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n\n@@ -272,15 +272,15 @@ public class StickyPartitionAssignmentStrategy extends StickyMulticastStrategy {\n   }\n \n   /**\n-   * This method checks the current assignment and returns the list of the task which are in the\n+   * This method checks the current assignment and returns the list of tasks which are in the\n    * dependency list as well as in current assignment. The logic is the task in the dependency list\n-   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * must not be present in the current assignment list. It's possible when the previous leader was\n    * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n    * from the zookeeper.\n    *\n    * @param datastreamGroups datastream groups to associate the tasks with\n    * @param currentAssignment existing assignment\n-   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   * @return  list of datastream tasks mapped by instance that need to be cleaned up.\n    */\n   public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n       Map<String, Set<DatastreamTask>> currentAssignment) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzkzNw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717937", "bodyText": "nit: Reword: find the dependency tasks which also exist in the current assignment list.", "author": "somandal", "createdAt": "2020-11-05T00:52:42Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\nindex d6d82d8f..2136b225 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n\n@@ -272,15 +272,15 @@ public class StickyPartitionAssignmentStrategy extends StickyMulticastStrategy {\n   }\n \n   /**\n-   * This method checks the current assignment and returns the list of the task which are in the\n+   * This method checks the current assignment and returns the list of tasks which are in the\n    * dependency list as well as in current assignment. The logic is the task in the dependency list\n-   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * must not be present in the current assignment list. It's possible when the previous leader was\n    * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n    * from the zookeeper.\n    *\n    * @param datastreamGroups datastream groups to associate the tasks with\n    * @param currentAssignment existing assignment\n-   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   * @return  list of datastream tasks mapped by instance that need to be cleaned up.\n    */\n   public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n       Map<String, Set<DatastreamTask>> currentAssignment) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTc2Nw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517719767", "bodyText": "Can we add a log to print the tasksToCleanUp and also the count? To keep the log readable, let's print only task names?\nFor debugging purposes it may be helpful to print the task names on which these tasks exist as dependencies. I'll leave it to you to assess if this can be useful though.", "author": "somandal", "createdAt": "2020-11-05T00:58:33Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)\n+          .stream()\n+          .filter(t -> datastreamGroupsSet.contains(t.getTaskPrefix()))\n+          .map(task -> ((DatastreamTaskImpl) task).getDependencies())\n+          .flatMap(Collection::stream)\n+          .map(assignmentsMap::get)\n+          .filter(Objects::nonNull)\n+          .collect(Collectors.toList());\n+\n+      if (!tasksPerInstance.isEmpty()) {\n+        tasksToCleanUp.put(instance, tasksPerInstance);\n+      }\n+    }\n+    return tasksToCleanUp;", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\nindex d6d82d8f..2136b225 100644\n--- a/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n+++ b/datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java\n\n@@ -272,15 +272,15 @@ public class StickyPartitionAssignmentStrategy extends StickyMulticastStrategy {\n   }\n \n   /**\n-   * This method checks the current assignment and returns the list of the task which are in the\n+   * This method checks the current assignment and returns the list of tasks which are in the\n    * dependency list as well as in current assignment. The logic is the task in the dependency list\n-   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * must not be present in the current assignment list. It's possible when the previous leader was\n    * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n    * from the zookeeper.\n    *\n    * @param datastreamGroups datastream groups to associate the tasks with\n    * @param currentAssignment existing assignment\n-   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   * @return  list of datastream tasks mapped by instance that need to be cleaned up.\n    */\n   public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n       Map<String, Set<DatastreamTask>> currentAssignment) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMDcwOA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517720708", "bodyText": "Should we also validate that the tasksToCleanup only contains the tasks we expect it to by matching task names?", "author": "somandal", "createdAt": "2020-11-05T01:01:42Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -87,11 +86,24 @@ public void testAddPartitions() {\n     DatastreamGroupPartitionsMetadata newPartitionsMetadata =\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), newPartitions);\n \n-    assignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n \n-    for (DatastreamTask task : assignment.get(\"instance1\")) {\n+    for (DatastreamTask task : newAssignment.get(\"instance0\")) {\n       Assert.assertEquals(task.getPartitionsV2().size(), 2);\n     }\n+\n+    Map<String, List<DatastreamTask>> taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 0);\n+\n+    // Adding the dependency task as well in the assignment list to simulate the scenario where\n+    // the dependency task nodes are not deleted and the leader gets interrupted, OOM or hit session expiry.\n+    // The next leader should be able to identify and cleanup.\n+    Map<String, Set<DatastreamTask>> finalAssignment = assignment;\n+    newAssignment.forEach((instance, taskSet1) -> taskSet1.addAll(finalAssignment.get(instance)));\n+\n+    taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 1);\n+    taskToCleanup.forEach((instance, taskList1) -> Assert.assertEquals(taskList1.size(), 3));", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "chunk": "diff --git a/datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java b/datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java\nindex 78c23d48..25143ee0 100644\n--- a/datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java\n+++ b/datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java\n\n@@ -104,6 +104,7 @@ public class TestStickyPartitionAssignment {\n     taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n     Assert.assertEquals(taskToCleanup.size(), 1);\n     taskToCleanup.forEach((instance, taskList1) -> Assert.assertEquals(taskList1.size(), 3));\n+    Assert.assertEquals(new HashSet<>(taskToCleanup.get(\"instance0\")), new HashSet<>(assignment.get(\"instance0\")));\n   }\n \n \n"}}, {"oid": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "url": "https://github.com/linkedin/brooklin/commit/2e308d8f5556cb4e8deae13a18d79ac6932a2187", "message": "Address comments", "committedDate": "2020-11-06T05:33:17Z", "type": "commit"}, {"oid": "4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "url": "https://github.com/linkedin/brooklin/commit/4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "message": "Merge branch 'master' into fixStickPartitionAssignment", "committedDate": "2020-11-06T23:39:55Z", "type": "commit"}]}