{"pr_number": 788, "pr_title": "Implement request forwarding for ZkRoutingDataWriter", "pr_createdAt": "2020-02-20T21:44:43Z", "pr_url": "https://github.com/apache/helix/pull/788", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382281387", "bodyText": "Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.", "author": "narendly", "createdAt": "2020-02-20T21:59:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5Mzk0Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382293943", "bodyText": "Agreed.", "author": "NealSun96", "createdAt": "2020-02-20T22:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjAwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382336008", "bodyText": "_leaderHostName is an instance variable now since it's used during multiple occasions. I'm refactoring the calling code since it can be generalized and reduce duplication.", "author": "NealSun96", "createdAt": "2020-02-21T00:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MTcyMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382341722", "bodyText": "On a second thought I cannot do that because _leaderHostName will be changing. Modified my planned code structure for that. Duplication can still be reduced.", "author": "NealSun96", "createdAt": "2020-02-21T00:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -88,24 +102,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382281982", "bodyText": "What's the point of recording \"\"? Do you really need the ternary operator in this case?", "author": "narendly", "createdAt": "2020-02-20T22:00:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDU5MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382294591", "bodyText": "When there's no response body, it is still necessary to log \"the forward request has failed\". Constructing it like this reduces duplication.\nMaybe I can change \"\" to \"No response body is returned\" or something else meaningful.", "author": "NealSun96", "createdAt": "2020-02-20T22:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjExNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326117", "bodyText": "You could do this:\nString errorMessage = \"The forwarded request from \" + (this node's hostname) + \" to leader \" + (leader's hostname) + \" has failed for addMetadataStoreRealm()!\";\nif (respEntity != null) {\n  errorMessage += \" Response: \" + EntityUtils.toString(respEntity);\n}\nLOG. error(errorMessage);", "author": "narendly", "createdAt": "2020-02-20T23:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -88,24 +102,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NDg5NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382284894", "bodyText": "See above - refactor!", "author": "narendly", "createdAt": "2020-02-20T22:07:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDcxOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382294719", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T22:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NDg5NA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -117,25 +116,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpDelete deleteRequest = new HttpDelete(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n-      if (response.getStatusLine().getStatusCode() != 200) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n-          e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",\n+        Response.Status.OK.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382285157", "bodyText": "Could we configure a timeout for these requests?\nhttps://www.baeldung.com/httpclient-timeout\nSomething like 1 minute sounds reasonable. Make that 1 minute a constant somewhere and you could use it throughout.", "author": "narendly", "createdAt": "2020-02-20T22:07:43Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTI1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295258", "bodyText": "I'll take a look. Very good point.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzcxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382347717", "bodyText": "@narendly What's your opinion on the necessity of setting a socket timeout in addition to a connection timeout?", "author": "NealSun96", "createdAt": "2020-02-21T01:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -88,24 +102,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382285670", "bodyText": "Why is the ternary necessary?\nDid you meant to have a log msg like:\n\"the forwarded request to leader has failed for deleteMetadataStoreRealm:  \"?", "author": "narendly", "createdAt": "2020-02-20T22:08:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTQyNA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295424", "bodyText": "Ditto my reply above.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjQ0Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326443", "bodyText": "See above", "author": "narendly", "createdAt": "2020-02-20T23:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -117,25 +116,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpDelete deleteRequest = new HttpDelete(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n-      if (response.getStatusLine().getStatusCode() != 200) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n-          e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",\n+        Response.Status.OK.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjAyNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286026", "bodyText": "refactor?", "author": "narendly", "createdAt": "2020-02-20T22:09:42Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -136,7 +180,23 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       return true;\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n+            + \"/sharding-keys/\" + shardingKey;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -180,24 +167,11 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return true;\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n-            + \"/sharding-keys/\" + shardingKey;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addShardingKey: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addShardingKey\", e);\n-      return false;\n-    }\n-    return true;\n+    String url_suffix =\n+        \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addShardingKey\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjI4NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286284", "bodyText": "Nit: \"failed\"", "author": "narendly", "createdAt": "2020-02-20T22:10:18Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -225,6 +302,11 @@ public synchronized boolean setRoutingData(Map<String, List<String>> routingData\n   @Override\n   public synchronized void close() {\n     _zkClient.close();\n+    try {\n+      _forwardHttpClient.close();\n+    } catch (IOException e) {\n+      LOG.error(\"HttpClient fails to close. \", e);", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTUxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295517", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -305,7 +265,7 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     try {\n       _forwardHttpClient.close();\n     } catch (IOException e) {\n-      LOG.error(\"HttpClient fails to close. \", e);\n+      LOG.error(\"HttpClient failed to close. \", e);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286772", "bodyText": "Where are you throwing an IllegalStateException?", "author": "narendly", "createdAt": "2020-02-20T22:11:27Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -90,9 +90,13 @@ public Response getAllMetadataStoreRealms() {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTA2Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309066", "bodyText": "In ZkRoutingDataWriter if _zkClient.isClosed().", "author": "NealSun96", "createdAt": "2020-02-20T23:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTgxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382319817", "bodyText": "If that\u2019s the case, I would put it in addMetadatStoreRealm or a proper place, but not here in this endpoint logic. It is not endpoint logic\u2019s responsibility to process such exception.", "author": "huizhilu", "createdAt": "2020-02-20T23:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzEzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382327132", "bodyText": "+1. Let's make sure the MSDS server logs the errors. it would be helpful if we could include as much detail as possible including the host name, etc.", "author": "narendly", "createdAt": "2020-02-20T23:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjMyNA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332324", "bodyText": "If it's not handled, the exception will cause a server error anyways. Are you suggesting to handle it and not raise server error? IMO zkClient being closed is definitely a server error.", "author": "NealSun96", "createdAt": "2020-02-21T00:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjg0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382336848", "bodyText": "You could let this IllegalStateException float up all the way to the servlet..\nFor instance, for uncaught exceptions, the servlet container usually catch the Exception, logs it and returns http status 500.\nJust make sure MetadataStoreDirectory logs the exception properly.\nThe idea being conveyed here is that the REST resource (MetadataStoreDirectoryAccessor) shouldn't probably know about/handle every kind of exception that might be thrown from downstream api calls.", "author": "narendly", "createdAt": "2020-02-21T00:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTcxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382345717", "bodyText": "I see. I'll remove this section of the code. Thank you both for the insight.", "author": "NealSun96", "createdAt": "2020-02-21T01:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\nindex aa859f593..936bd7f14 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n\n@@ -65,25 +68,53 @@ public class MetadataStoreDirectoryAccessor extends AbstractResource {\n     buildMetadataStoreDirectory(_namespace, helixRestNamespace.getMetadataStoreAddress());\n   }\n \n+  @PreDestroy\n+  private void preDestroy() {\n+    _metadataStoreDirectory.close();\n+  }\n+\n   /**\n-   * Gets all metadata store realms in a namespace with the endpoint.\n+   * Gets all existing namespaces in the routing metadata store at endpoint:\n+   * \"GET /metadata-store-namespaces\"\n+   *\n+   * @return Json response of all namespaces.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-namespaces\")\n+  public Response getAllNamespaces() {\n+    Collection<String> namespaces = _metadataStoreDirectory.getAllNamespaces();\n+    Map<String, Collection<String>> responseMap =\n+        ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_NAMESPACES, namespaces);\n+\n+    return JSONRepresentation(responseMap);\n+  }\n+\n+  /**\n+   * Gets all metadata store realms in a namespace at path: \"GET /metadata-store-realms\",\n+   * or gets a metadata store realm with the sharding key at path:\n+   * \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n    *\n    * @return Json representation of all realms.\n    */\n   @GET\n   @Path(\"/metadata-store-realms\")\n-  public Response getAllMetadataStoreRealms() {\n-    Map<String, Collection<String>> responseMap;\n+  public Response getAllMetadataStoreRealms(@QueryParam(\"sharding-key\") String shardingKey) {\n     try {\n-      Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+      if (shardingKey == null) {\n+        // Get all realms: \"GET /metadata-store-realms\"\n+        Collection<String> realms = _metadataStoreDirectory.getAllMetadataStoreRealms(_namespace);\n+        Map<String, Collection<String>> responseMap =\n+            ImmutableMap.of(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+        return JSONRepresentation(responseMap);\n+      }\n \n-      responseMap = new HashMap<>(1);\n-      responseMap.put(MetadataStoreRoutingConstants.METADATA_STORE_REALMS, realms);\n+      // Get a single realm filtered by sharding key:\n+      // \"GET /metadata-store-realms?sharding-key={sharding-key}\"\n+      String realm = _metadataStoreDirectory.getMetadataStoreRealm(_namespace, shardingKey);\n+      return JSONRepresentation(new MetadataStoreShardingKey(shardingKey, realm));\n     } catch (NoSuchElementException ex) {\n       return notFound(ex.getMessage());\n     }\n-\n-    return JSONRepresentation(responseMap);\n   }\n \n   @PUT\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzU5MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382287590", "bodyText": "Nit: rename to MSDS_SERVER_HOSTNAME_KEY?\nAnd for the actual value, let's use \"msds_hostname\" so it doesn't conflict with some general \"instance_hostname\" key.", "author": "narendly", "createdAt": "2020-02-20T22:13:21Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance\n+  public static final String HOSTNAME_SYSTEM_PROPERTY_KEY = \"instance_hostname\";", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTE4NQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309185", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-20T23:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\nindex ea5798184..40e74213c 100644\n--- a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n+++ b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n\n@@ -28,15 +28,50 @@ public class MetadataStoreRoutingConstants {\n   // Leader election ZNode for ZkRoutingDataWriter\n   public static final String LEADER_ELECTION_ZNODE = \"/_ZK_ROUTING_DATA_WRITER_LEADER\";\n \n-  // Field name in JSON REST response of getting metadata store realms in one namespace.\n-  public static final String METADATA_STORE_REALMS = \"metadataStoreRealms\";\n+  /** Field name in JSON REST response of getting all metadata store namespaces. */\n+  public static final String METADATA_STORE_NAMESPACES = \"namespaces\";\n \n-  // Field name in JSON REST response of getting sharding keys in one realm.\n-  public static final String SINGLE_METADATA_STORE_REALM = \"metadataStoreRealm\";\n+  /** Field name in JSON REST response of getting all sharding keys in a single namespace. */\n+  public static final String SINGLE_METADATA_STORE_NAMESPACE = \"namespace\";\n \n-  // Field name in JSON REST response of getting sharding keys.\n+  /** Field name in JSON REST response of getting metadata store realms in one namespace. */\n+  public static final String METADATA_STORE_REALMS = \"realms\";\n+\n+  /** Field name in JSON REST response of getting sharding keys in one realm. */\n+  public static final String SINGLE_METADATA_STORE_REALM = \"realm\";\n+\n+  /** Field name in JSON REST response of getting sharding keys. */\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n+  /** Field name in JSON REST response of getting routing data. */\n+  public static final String ROUTING_DATA = \"routingData\";\n+\n+  /** Field name in JSON REST response related to one single sharding key. */\n+  public static final String SINGLE_SHARDING_KEY = \"shardingKey\";\n+\n+  /**\n+   * Field name in JSON response of the REST endpoint getting sharding keys with prefix:\n+   * \"GET /sharding-keys?prefix={prefix}\"\n+   * It is used in below response as an example:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *  }]\n+   * }\n+   */\n+  public static final String SHARDING_KEY_PATH_PREFIX = \"prefix\";\n+\n+  // System Property Metadata Store Directory Server endpoint key\n+  public static final String MSDS_SERVER_ENDPOINT_KEY = \"metadataStoreDirectoryServerEndpoint\";\n+\n+  // MSDS resource getAllRealms endpoint string\n+  public static final String MSDS_GET_ALL_REALMS_ENDPOINT = \"/metadata-store-realms\";\n+\n+  // MSDS resource get all routing data endpoint string\n+  public static final String MSDS_GET_ALL_ROUTING_DATA_ENDPOINT = \"/routing-data\";\n+\n   // The key for system properties that contains the hostname of an instance\n   public static final String HOSTNAME_SYSTEM_PROPERTY_KEY = \"instance_hostname\";\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzY2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382287660", "bodyText": "hostname of the MSDS server instance", "author": "narendly", "createdAt": "2020-02-20T22:13:31Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTI2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309260", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T23:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\nindex ea5798184..40e74213c 100644\n--- a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n+++ b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n\n@@ -28,15 +28,50 @@ public class MetadataStoreRoutingConstants {\n   // Leader election ZNode for ZkRoutingDataWriter\n   public static final String LEADER_ELECTION_ZNODE = \"/_ZK_ROUTING_DATA_WRITER_LEADER\";\n \n-  // Field name in JSON REST response of getting metadata store realms in one namespace.\n-  public static final String METADATA_STORE_REALMS = \"metadataStoreRealms\";\n+  /** Field name in JSON REST response of getting all metadata store namespaces. */\n+  public static final String METADATA_STORE_NAMESPACES = \"namespaces\";\n \n-  // Field name in JSON REST response of getting sharding keys in one realm.\n-  public static final String SINGLE_METADATA_STORE_REALM = \"metadataStoreRealm\";\n+  /** Field name in JSON REST response of getting all sharding keys in a single namespace. */\n+  public static final String SINGLE_METADATA_STORE_NAMESPACE = \"namespace\";\n \n-  // Field name in JSON REST response of getting sharding keys.\n+  /** Field name in JSON REST response of getting metadata store realms in one namespace. */\n+  public static final String METADATA_STORE_REALMS = \"realms\";\n+\n+  /** Field name in JSON REST response of getting sharding keys in one realm. */\n+  public static final String SINGLE_METADATA_STORE_REALM = \"realm\";\n+\n+  /** Field name in JSON REST response of getting sharding keys. */\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n+  /** Field name in JSON REST response of getting routing data. */\n+  public static final String ROUTING_DATA = \"routingData\";\n+\n+  /** Field name in JSON REST response related to one single sharding key. */\n+  public static final String SINGLE_SHARDING_KEY = \"shardingKey\";\n+\n+  /**\n+   * Field name in JSON response of the REST endpoint getting sharding keys with prefix:\n+   * \"GET /sharding-keys?prefix={prefix}\"\n+   * It is used in below response as an example:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *  }]\n+   * }\n+   */\n+  public static final String SHARDING_KEY_PATH_PREFIX = \"prefix\";\n+\n+  // System Property Metadata Store Directory Server endpoint key\n+  public static final String MSDS_SERVER_ENDPOINT_KEY = \"metadataStoreDirectoryServerEndpoint\";\n+\n+  // MSDS resource getAllRealms endpoint string\n+  public static final String MSDS_GET_ALL_REALMS_ENDPOINT = \"/metadata-store-realms\";\n+\n+  // MSDS resource get all routing data endpoint string\n+  public static final String MSDS_GET_ALL_ROUTING_DATA_ENDPOINT = \"/routing-data\";\n+\n   // The key for system properties that contains the hostname of an instance\n   public static final String HOSTNAME_SYSTEM_PROPERTY_KEY = \"instance_hostname\";\n }\n"}}, {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "url": "https://github.com/apache/helix/commit/da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "message": "revert to notFound", "committedDate": "2020-02-20T23:32:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382315850", "bodyText": "What if the property is not set in system?", "author": "huizhilu", "createdAt": "2020-02-20T23:26:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +71,12 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDg3OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382324878", "bodyText": "+1. We could probably throw an IllegalStateException here if System.getProperty returns null.", "author": "narendly", "createdAt": "2020-02-20T23:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjQxMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332412", "bodyText": "Good point. Fixing.", "author": "NealSun96", "createdAt": "2020-02-21T00:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -71,12 +76,21 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    ZNRecord myServerInfo = new ZNRecord(\n-        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n \n-    _forwardHttpClient = HttpClients.createDefault();\n+    int timeout = 60; // seconds\n+    RequestConfig config = RequestConfig.custom().setConnectTimeout(timeout * 1000)\n+        .setConnectionRequestTimeout(timeout * 1000).setSocketTimeout(timeout * 1000).build();\n+    _forwardHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382316610", "bodyText": "I would use created code rather than the hard coded 201: easier to read and maintain", "author": "huizhilu", "createdAt": "2020-02-20T23:28:47Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTM4MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382325380", "bodyText": "+1. Don't we already have this as part of Helix REST? See javax.ws.rs.core.Response;?", "author": "narendly", "createdAt": "2020-02-20T23:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjYxOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332618", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-21T00:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -88,24 +102,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382321567", "bodyText": "Can we have a message in the server error message why it fails or what the client should do? Server error is too plain.", "author": "huizhilu", "createdAt": "2020-02-20T23:41:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -153,9 +161,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n     try {\n-      _metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey);\n+      if (!_metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey)) {\n+        return serverError();", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMzE1Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382333153", "bodyText": "There are numerous different reasons why this could happen, and one single returned message is not going to cover all cases; saying it's a server error is sufficient to express that it's a server side situation.\nOn the other hand, whenever false is returned here, there are server logs that can help us identify the cause.", "author": "NealSun96", "createdAt": "2020-02-21T00:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382346148", "bodyText": "That is for server side. Think about client side: what is response for this? If you are a user, what would you like to know?", "author": "huizhilu", "createdAt": "2020-02-21T01:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NDQ0NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382354444", "bodyText": "Here are the situations where this condition can be invoked:\n\nWhen the request forwarded to the leader instance returns a non-ok;\nWhen the request forwarded to the leader raises an IOException;\nWhen writing to ZooKeeper fails.\n\nAll of them happen on the layer of ZkRoutingDataWriter. I'll need some advice on how to propagate the correct information back to the REST layer - I do not see an easy way to do this.\nAt the same time, I believe it's unnecessary to let clients know the exact situation among these 3 situations, because these situations are unrelated to client input and there's nothing clients can do. All these situations are strictly internal errors and are out of the hands of clients.", "author": "NealSun96", "createdAt": "2020-02-21T01:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MTE4MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382391180", "bodyText": "I understand the possible situations and there is no need to tell the client the real reason (and it is impossible here because the api just returns true or false). I meant, include a message suggesting what to do like \u201cserver error , please contact admin\u201d is helpful than plain response. Imagine, what would you get if you do curl this endpoint but server error?\nAnyway, I have an issue Created to improve the response. You don\u2019t have to do it here. Focus on the main task of the pr instead.", "author": "huizhilu", "createdAt": "2020-02-21T04:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\nindex aa859f593..936bd7f14 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n\n@@ -119,43 +150,109 @@ public class MetadataStoreDirectoryAccessor extends AbstractResource {\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys for following requests:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n-      } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+      if (prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n       }\n+      // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+      return getAllShardingKeysUnderPath(prefix);\n     } catch (NoSuchElementException ex) {\n       return notFound(ex.getMessage());\n     }\n+  }\n \n-    responseMap.put(MetadataStoreRoutingConstants.SHARDING_KEYS, shardingKeys);\n+  /**\n+   * Gets routing data in current namespace.\n+   *\n+   * - \"HTTP GET /routing-data\"\n+   * -- Response example:\n+   * {\n+   *   \"namespace\" : \"my-namespace\",\n+   *   \"routingData\" : [ {\n+   *     \"realm\" : \"realm-1\",\n+   *     \"shardingKeys\" : [ \"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\" ]\n+   *   }, {\n+   *     \"realm\" : \"realm-2\",\n+   *     \"shardingKeys\" : [ \"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\" ]\n+   *   } ]\n+   * }\n+   */\n+  @GET\n+  @Path(\"/routing-data\")\n+  public Response getRoutingData() {\n+    Map<String, List<String>> rawRoutingData;\n+    try {\n+      rawRoutingData = _metadataStoreDirectory.getNamespaceRoutingData(_namespace);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    List<MetadataStoreShardingKeysByRealm> shardingKeysByRealm = rawRoutingData.entrySet().stream()\n+        .map(entry -> new MetadataStoreShardingKeysByRealm(entry.getKey(), entry.getValue()))\n+        .collect(Collectors.toList());\n+\n+    Map<String, Object> responseMap = ImmutableMap\n+        .of(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_NAMESPACE, _namespace,\n+            MetadataStoreRoutingConstants.ROUTING_DATA, shardingKeysByRealm);\n \n     return JSONRepresentation(responseMap);\n   }\n \n+  /**\n+   * Gets all path-based sharding keys for a queried realm at endpoint:\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys\"\n+   * <p>\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys?prefix={prefix}\" is also supported,\n+   * which is helpful when you want to check what sharding keys have the prefix substring.\n+   *\n+   * @param realm Queried metadata store realm to get sharding keys.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return All path-based sharding keys in the queried realm.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms/{realm}/sharding-keys\")\n+  public Response getRealmShardingKeys(@PathParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n+    try {\n+      if (prefix == null) {\n+        return getAllShardingKeysInRealm(realm);\n+      }\n+\n+      // For \"GET /metadata-store-realms/{realm}/sharding-keys?prefix={prefix}\"\n+      return getRealmShardingKeysUnderPath(realm, prefix);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+  }\n+\n   @PUT\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326354", "bodyText": "More helpful to include which host is forwarding to which leader.", "author": "narendly", "createdAt": "2020-02-20T23:56:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMzI2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382333260", "bodyText": "As in the hostnames? Okay.", "author": "NealSun96", "createdAt": "2020-02-21T00:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTE3MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382335171", "bodyText": "Like this:\nString errorMessage = \"The forwarded request from \" + (this node's hostname) + \" to leader \" + (leader's hostname) + \" has failed for addMetadataStoreRealm()!\";\nif (respEntity != null) {\n  errorMessage += \" Response: \" + EntityUtils.toString(respEntity);\n}\nLOG. error(errorMessage);", "author": "narendly", "createdAt": "2020-02-21T00:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -88,24 +102,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpPut putRequest = new HttpPut(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(putRequest);\n-      if (response.getStatusLine().getStatusCode() != 201) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n+        Response.Status.CREATED.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjU1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326558", "bodyText": "Improve logging with host name and leader host name", "author": "narendly", "createdAt": "2020-02-20T23:56:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n+          e);", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex d2057ecb6..256bb0688 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -117,25 +116,9 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url =\n-        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    HttpDelete deleteRequest = new HttpDelete(url);\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n-      if (response.getStatusLine().getStatusCode() != 200) {\n-        HttpEntity respEntity = response.getEntity();\n-        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n-            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n-          e);\n-      return false;\n-    }\n-\n-    return true;\n+    String url_suffix = \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",\n+        Response.Status.OK.getStatusCode());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzQ4Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r382327486", "bodyText": "Remove?", "author": "narendly", "createdAt": "2020-02-20T23:59:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -102,9 +106,13 @@ public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\nindex aa859f593..936bd7f14 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n\n@@ -110,7 +141,7 @@ public class MetadataStoreDirectoryAccessor extends AbstractResource {\n         return serverError();\n       }\n     } catch (IllegalArgumentException ex) {\n-      return notFound(ex.getMessage());\n+      return badRequest(ex.getMessage());\n     } catch (IllegalStateException ex) {\n       return serverError();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDQ2MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384310461", "bodyText": "Can you do\ngetInstance().init(namespace, zkAddress); here to cut down on duplicate code?", "author": "narendly", "createdAt": "2020-02-26T07:21:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,77 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n \n-  /**\n-   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n-   * @param routingZkAddressMap (namespace, routing ZK connect string)\n-   * @throws InvalidRoutingDataException\n-   */\n-  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+\n+    return _zkMetadataStoreDirectoryInstance;\n+  }\n+\n+  public static ZkMetadataStoreDirectory getInstance(String namespace, String zkAddress)\n       throws InvalidRoutingDataException {\n-    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n-      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n     }\n-    _routingDataReaderMap = new HashMap<>();\n-    _routingDataWriterMap = new HashMap<>();\n-    _routingZkAddressMap = routingZkAddressMap;\n+    _zkMetadataStoreDirectoryInstance.init(namespace, zkAddress);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTM3OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384735379", "bodyText": "That is a good point. Let me try that.", "author": "NealSun96", "createdAt": "2020-02-26T20:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\nindex 051985f7b..5b64f7b91 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n\n@@ -42,77 +42,49 @@ import org.slf4j.LoggerFactory;\n \n \n /**\n- * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n+  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n-  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  protected final Map<String, String> _routingZkAddressMap;\n+  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  private final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n-\n-  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n-\n-  public static ZkMetadataStoreDirectory getInstance() {\n-    if (_zkMetadataStoreDirectoryInstance == null) {\n-      synchronized (ZkMetadataStoreDirectory.class) {\n-        if (_zkMetadataStoreDirectoryInstance == null) {\n-          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n-        }\n-      }\n-    }\n-\n-    return _zkMetadataStoreDirectoryInstance;\n-  }\n-\n-  public static ZkMetadataStoreDirectory getInstance(String namespace, String zkAddress)\n-      throws InvalidRoutingDataException {\n-    if (_zkMetadataStoreDirectoryInstance == null) {\n-      synchronized (ZkMetadataStoreDirectory.class) {\n-        if (_zkMetadataStoreDirectoryInstance == null) {\n-          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n-        }\n-      }\n-    }\n-    _zkMetadataStoreDirectoryInstance.init(namespace, zkAddress);\n-\n-    return _zkMetadataStoreDirectoryInstance;\n-  }\n+  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n \n   /**\n-   * Note: this is a singleton class. The constructor is made protected for testing. DO NOT EXTEND!\n+   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n+   * @param routingZkAddressMap (namespace, routing ZK connect string)\n+   * @throws InvalidRoutingDataException\n    */\n-  @VisibleForTesting\n-  protected ZkMetadataStoreDirectory() {\n-    _routingDataReaderMap = new ConcurrentHashMap<>();\n-    _routingDataWriterMap = new ConcurrentHashMap<>();\n-    _routingZkAddressMap = new ConcurrentHashMap<>();\n+  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+      throws InvalidRoutingDataException {\n+    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n+      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    }\n+    _routingDataReaderMap = new HashMap<>();\n+    _routingDataWriterMap = new HashMap<>();\n+    _routingZkAddressMap = routingZkAddressMap;\n     _realmToShardingKeysMap = new ConcurrentHashMap<>();\n     _routingDataMap = new ConcurrentHashMap<>();\n-  }\n \n-  private void init(String namespace, String zkAddress) throws InvalidRoutingDataException {\n-    if (!_routingZkAddressMap.containsKey(namespace)) {\n-      synchronized (_routingZkAddressMap) {\n-        if (!_routingZkAddressMap.containsKey(namespace)) {\n-          _routingZkAddressMap.put(namespace, zkAddress);\n-          _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-          _routingDataWriterMap.put(namespace, new ZkRoutingDataWriter(namespace, zkAddress));\n+    // Create RoutingDataReaders and RoutingDataWriters\n+    for (Map.Entry<String, String> routingEntry : _routingZkAddressMap.entrySet()) {\n+      _routingDataReaderMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataReader(routingEntry.getKey(), routingEntry.getValue(), this));\n+      _routingDataWriterMap.put(routingEntry.getKey(),\n+          new ZkRoutingDataWriter(routingEntry.getKey(), routingEntry.getValue()));\n \n-          // Populate realmToShardingKeys with ZkRoutingDataReader\n-          _realmToShardingKeysMap\n-              .put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-          _routingDataMap\n-              .put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-        }\n-      }\n+      // Populate realmToShardingKeys with ZkRoutingDataReader\n+      _realmToShardingKeysMap.put(routingEntry.getKey(),\n+          _routingDataReaderMap.get(routingEntry.getKey()).getRoutingData());\n+      _routingDataMap.put(routingEntry.getKey(),\n+          new TrieRoutingData(_realmToShardingKeysMap.get(routingEntry.getKey())));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDk2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384310960", "bodyText": "Remove print statements? We want to avoid this kind of stuff in production code.", "author": "narendly", "createdAt": "2020-02-26T07:23:05Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -40,8 +52,11 @@\n   private final String _namespace;\n   private final HelixZkClient _zkClient;\n   private final ZkDistributedLeaderElection _leaderElection;\n+  private final CloseableHttpClient _forwardHttpClient;\n+  private final String _myHostName;\n \n   public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    System.out.println(\"writer created namespace=\" + namespace + \" zkAddress=\" + zkAddress);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzODYwNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384638605", "bodyText": "This one escaped my own review. Fixing.", "author": "NealSun96", "createdAt": "2020-02-26T17:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -53,10 +49,8 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n   private final HelixZkClient _zkClient;\n   private final ZkDistributedLeaderElection _leaderElection;\n   private final CloseableHttpClient _forwardHttpClient;\n-  private final String _myHostName;\n \n   public ZkRoutingDataWriter(String namespace, String zkAddress) {\n-    System.out.println(\"writer created namespace=\" + namespace + \" zkAddress=\" + zkAddress);\n     if (namespace == null || namespace.isEmpty()) {\n       throw new IllegalArgumentException(\"namespace cannot be null or empty!\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTIwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384311206", "bodyText": "Also include the check: _myHostName.isEmpty()", "author": "narendly", "createdAt": "2020-02-26T07:23:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzODg1Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384638852", "bodyText": "Makes sense.", "author": "NealSun96", "createdAt": "2020-02-26T17:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -77,21 +71,12 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n-    if (_myHostName == null) {\n-      throw new IllegalStateException(\n-          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n-              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n-    }\n-    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n-\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n \n-    int timeout = 60; // seconds\n-    RequestConfig config = RequestConfig.custom().setConnectTimeout(timeout * 1000)\n-        .setConnectionRequestTimeout(timeout * 1000).setSocketTimeout(timeout * 1000).build();\n-    _forwardHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n+    _forwardHttpClient = HttpClients.createDefault();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTU2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384311560", "bodyText": "Let's make this a Java constant so that we could make this configurable later.\nprivate static final int HTTP_REQUEST_TIMEOUT = 60;", "author": "narendly", "createdAt": "2020-02-26T07:24:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    int timeout = 60; // seconds", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0ODQ1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384648458", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T17:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -77,21 +71,12 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n-    if (_myHostName == null) {\n-      throw new IllegalStateException(\n-          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n-              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n-    }\n-    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n-\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n \n-    int timeout = 60; // seconds\n-    RequestConfig config = RequestConfig.custom().setConnectTimeout(timeout * 1000)\n-        .setConnectionRequestTimeout(timeout * 1000).setSocketTimeout(timeout * 1000).build();\n-    _forwardHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n+    _forwardHttpClient = HttpClients.createDefault();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384312340", "bodyText": "Generally a good idea to refactor this to a private method so that it's easier to read. For instance, create private String getUrlSuffix()\nSome of these string literals have already been defined in MetadataStoreDirectoryConstants.java. Could you use the constants there please?", "author": "narendly", "createdAt": "2020-02-26T07:27:16Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1MjQ1Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384652452", "bodyText": "I wanted to include the url creation as a part of forwardRequestToLeader, but I do not see a good way to generalize url construction. The 4 endpoints require 2 different urls; refactoring it results in an if statement, which isn't generalization. On the other hand, leaving url construction logic in the methods also clearly indicates which urls each endpoints correspond to, which is good for maintenance.\nIn MetadataStoreRoutingConstants, the constants are not quite the same as the strings in these urls. (shardingKeys vs sharding-keys, metadataStoreRealms vs metadata-store-realms)", "author": "NealSun96", "createdAt": "2020-02-26T17:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1NDgwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384654806", "bodyText": "I do see a lot of duplication here. It seems it's possible to achieve the refactoring. Let me sync with you privately.\n\n\nIf you don't have them, you can create them. That's what the constant file is for. Please clearly note what they are used for.", "author": "narendly", "createdAt": "2020-02-26T17:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MDYyMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384660621", "bodyText": "Resolved by offline discussion. A method that joins parameters will be used for url suffix building.", "author": "NealSun96", "createdAt": "2020-02-26T17:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -103,9 +88,24 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n-        Response.Status.CREATED.getStatusCode());\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzA0MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313041", "bodyText": "Same here, let's make these String constants.\nI believe \"addMetadataStoreRealm\" should come from MetadataStoreDirectoryConstants.\n\"put\" could be a private enum called\nenum RequestForwardingHttpVerbs {\n    PUT,\n    POST,\n    DELETE\n}\n``` something like this.", "author": "narendly", "createdAt": "2020-02-26T07:29:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1NDYwMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384654601", "bodyText": "I agree with this. Let me add an enum for it.", "author": "NealSun96", "createdAt": "2020-02-26T17:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -103,9 +88,24 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       return createZkRealm(realm);\n     }\n \n-    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",\n-        Response.Status.CREATED.getStatusCode());\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzE0Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313142", "bodyText": "Refactor into a private method.", "author": "narendly", "createdAt": "2020-02-26T07:29:45Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -114,12 +114,28 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return deleteZkRealm(realm);\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",\n-        Response.Status.OK.getStatusCode());\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n+          e);\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzI3Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313276", "bodyText": "Use constants. No magic string literals floating around the code.", "author": "narendly", "createdAt": "2020-02-26T07:30:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -114,12 +114,28 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return deleteZkRealm(realm);\n+      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n-    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",\n-        Response.Status.OK.getStatusCode());\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n+          e);\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzQzOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313439", "bodyText": "Replace string literals.", "author": "narendly", "createdAt": "2020-02-26T07:30:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -100,44 +128,14 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      // If the realm does not exist already, then create the realm\n-      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-      if (!_zkClient.exists(realmPath)) {\n-        // Create the realm\n-        if (!createZkRealm(realm)) {\n-          // Failed to create the realm - log and return false\n-          LOG.error(\n-              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-              _namespace, realm, shardingKey);\n-          return false;\n-        }\n-      }\n-\n-      // Add the sharding key to an empty ZNRecord\n-      ZNRecord znRecord;\n-      try {\n-        znRecord = _zkClient.readData(realmPath);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n-          Collections.singletonList(shardingKey));\n-      try {\n-        _zkClient.writeData(realmPath, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return createZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addShardingKey\",\n+        Response.Status.CREATED.getStatusCode());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -128,14 +144,60 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return createZkShardingKey(realm, shardingKey);\n+      // If the realm does not exist already, then create the realm\n+      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+      if (!_zkClient.exists(realmPath)) {\n+        // Create the realm\n+        if (!createZkRealm(realm)) {\n+          // Failed to create the realm - log and return false\n+          LOG.error(\n+              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+              _namespace, realm, shardingKey);\n+          return false;\n+        }\n+      }\n+\n+      // Add the sharding key to an empty ZNRecord\n+      ZNRecord znRecord;\n+      try {\n+        znRecord = _zkClient.readData(realmPath);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          Collections.singletonList(shardingKey));\n+      try {\n+        _zkClient.writeData(realmPath, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n     }\n \n-    String url_suffix =\n-        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n-            + shardingKey;\n-    return forwardRequestToLeader(url_suffix, \"put\", \"addShardingKey\",\n-        Response.Status.CREATED.getStatusCode());\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n+            + \"/sharding-keys/\" + shardingKey;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addShardingKey: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addShardingKey\", e);\n+      return false;\n+    }\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzUyMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313523", "bodyText": "String literals.", "author": "narendly", "createdAt": "2020-02-26T07:30:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +144,14 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteShardingKey\",\n+        Response.Status.OK.getStatusCode());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -144,14 +206,48 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return deleteZkShardingKey(realm, shardingKey);\n+      ZNRecord znRecord =\n+          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+      if (znRecord == null || !znRecord\n+          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .contains(shardingKey)) {\n+        // This realm does not exist or shardingKey doesn't exist. Return true!\n+        return true;\n+      }\n+      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+          .remove(shardingKey);\n+      // Overwrite this ZNRecord with the sharding key removed\n+      try {\n+        _zkClient\n+            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+      } catch (Exception e) {\n+        LOG.error(\n+            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+            _namespace, realm, shardingKey, e);\n+        return false;\n+      }\n+      return true;\n+    }\n+\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n+            + \"/sharding-keys/\" + shardingKey;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteShardingKey: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteShardingKey\", e);\n+      return false;\n     }\n \n-    String url_suffix =\n-        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n-            + shardingKey;\n-    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteShardingKey\",\n-        Response.Status.OK.getStatusCode());\n+    return true;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDE0Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314147", "bodyText": "Use an enum here instead of String literals.", "author": "narendly", "createdAt": "2020-02-26T07:32:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -235,119 +331,4 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n \n     return true;\n   }\n-\n-  protected boolean deleteZkRealm(String realm) {\n-    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n-  }\n-\n-  protected boolean createZkShardingKey(String realm, String shardingKey) {\n-    // If the realm does not exist already, then create the realm\n-    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-    if (!_zkClient.exists(realmPath)) {\n-      // Create the realm\n-      if (!createZkRealm(realm)) {\n-        // Failed to create the realm - log and return false\n-        LOG.error(\n-            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-            _namespace, realm, shardingKey);\n-        return false;\n-      }\n-    }\n-\n-    ZNRecord znRecord;\n-    try {\n-      znRecord = _zkClient.readData(realmPath);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    List<String> shardingKeys =\n-        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n-    if (shardingKeys == null || shardingKeys.isEmpty()) {\n-      shardingKeys = new ArrayList<>();\n-    }\n-    shardingKeys.add(shardingKey);\n-    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n-    try {\n-      _zkClient.writeData(realmPath, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-    ZNRecord znRecord =\n-        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-    if (znRecord == null || !znRecord\n-        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .contains(shardingKey)) {\n-      // This realm does not exist or shardingKey doesn't exist. Return true!\n-      return true;\n-    }\n-    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .remove(shardingKey);\n-    // Overwrite this ZNRecord with the sharding key removed\n-    try {\n-      _zkClient\n-          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n-      int expectedResponseCode) throws IllegalArgumentException {\n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url = leaderHostName + url_suffix;\n-    System.out.println(url);\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-\n-    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n-  }\n-\n-  // Set to be protected for testing purposes\n-  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n-      String endPoint, String leaderHostName) {\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(request);\n-      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n-        HttpEntity respEntity = response.getEntity();\n-        String errorLog =\n-            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n-                + _myHostName + \" Leader hostname: \" + leaderHostName;\n-        if (respEntity != null) {\n-          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n-        }\n-        LOG.error(errorLog);\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\n-          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n-          endPoint, _myHostName, leaderHostName, e);\n-      return false;\n-    }\n-\n-    return true;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314431", "bodyText": "Also a good idea to log the response code.", "author": "narendly", "createdAt": "2020-02-26T07:33:40Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MzIwMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384693201", "bodyText": "Added the response code on line 336 because it always exists. Thank you for the suggestion.", "author": "NealSun96", "createdAt": "2020-02-26T18:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -235,119 +331,4 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n \n     return true;\n   }\n-\n-  protected boolean deleteZkRealm(String realm) {\n-    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n-  }\n-\n-  protected boolean createZkShardingKey(String realm, String shardingKey) {\n-    // If the realm does not exist already, then create the realm\n-    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-    if (!_zkClient.exists(realmPath)) {\n-      // Create the realm\n-      if (!createZkRealm(realm)) {\n-        // Failed to create the realm - log and return false\n-        LOG.error(\n-            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-            _namespace, realm, shardingKey);\n-        return false;\n-      }\n-    }\n-\n-    ZNRecord znRecord;\n-    try {\n-      znRecord = _zkClient.readData(realmPath);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    List<String> shardingKeys =\n-        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n-    if (shardingKeys == null || shardingKeys.isEmpty()) {\n-      shardingKeys = new ArrayList<>();\n-    }\n-    shardingKeys.add(shardingKey);\n-    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n-    try {\n-      _zkClient.writeData(realmPath, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-    ZNRecord znRecord =\n-        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-    if (znRecord == null || !znRecord\n-        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .contains(shardingKey)) {\n-      // This realm does not exist or shardingKey doesn't exist. Return true!\n-      return true;\n-    }\n-    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .remove(shardingKey);\n-    // Overwrite this ZNRecord with the sharding key removed\n-    try {\n-      _zkClient\n-          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n-      int expectedResponseCode) throws IllegalArgumentException {\n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url = leaderHostName + url_suffix;\n-    System.out.println(url);\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-\n-    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n-  }\n-\n-  // Set to be protected for testing purposes\n-  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n-      String endPoint, String leaderHostName) {\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(request);\n-      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n-        HttpEntity respEntity = response.getEntity();\n-        String errorLog =\n-            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n-                + _myHostName + \" Leader hostname: \" + leaderHostName;\n-        if (respEntity != null) {\n-          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n-        }\n-        LOG.error(errorLog);\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\n-          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n-          endPoint, _myHostName, leaderHostName, e);\n-      return false;\n-    }\n-\n-    return true;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQ5Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314493", "bodyText": "Remove empty line?", "author": "narendly", "createdAt": "2020-02-26T07:33:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n+        }\n+        LOG.error(errorLog);\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\n+          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n+          endPoint, _myHostName, leaderHostName, e);\n+      return false;\n+    }\n+", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex ba6a8030e..d2057ecb6 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -235,119 +331,4 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n \n     return true;\n   }\n-\n-  protected boolean deleteZkRealm(String realm) {\n-    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n-  }\n-\n-  protected boolean createZkShardingKey(String realm, String shardingKey) {\n-    // If the realm does not exist already, then create the realm\n-    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-    if (!_zkClient.exists(realmPath)) {\n-      // Create the realm\n-      if (!createZkRealm(realm)) {\n-        // Failed to create the realm - log and return false\n-        LOG.error(\n-            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-            _namespace, realm, shardingKey);\n-        return false;\n-      }\n-    }\n-\n-    ZNRecord znRecord;\n-    try {\n-      znRecord = _zkClient.readData(realmPath);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    List<String> shardingKeys =\n-        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n-    if (shardingKeys == null || shardingKeys.isEmpty()) {\n-      shardingKeys = new ArrayList<>();\n-    }\n-    shardingKeys.add(shardingKey);\n-    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n-    try {\n-      _zkClient.writeData(realmPath, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-    ZNRecord znRecord =\n-        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-    if (znRecord == null || !znRecord\n-        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .contains(shardingKey)) {\n-      // This realm does not exist or shardingKey doesn't exist. Return true!\n-      return true;\n-    }\n-    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-        .remove(shardingKey);\n-    // Overwrite this ZNRecord with the sharding key removed\n-    try {\n-      _zkClient\n-          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-    } catch (Exception e) {\n-      LOG.error(\n-          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-          _namespace, realm, shardingKey, e);\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n-      int expectedResponseCode) throws IllegalArgumentException {\n-    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n-    String url = leaderHostName + url_suffix;\n-    System.out.println(url);\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-\n-    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n-  }\n-\n-  // Set to be protected for testing purposes\n-  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n-      String endPoint, String leaderHostName) {\n-    try {\n-      HttpResponse response = _forwardHttpClient.execute(request);\n-      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n-        HttpEntity respEntity = response.getEntity();\n-        String errorLog =\n-            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n-                + _myHostName + \" Leader hostname: \" + leaderHostName;\n-        if (respEntity != null) {\n-          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n-        }\n-        LOG.error(errorLog);\n-        return false;\n-      }\n-    } catch (IOException e) {\n-      LOG.error(\n-          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n-          endPoint, _myHostName, leaderHostName, e);\n-      return false;\n-    }\n-\n-    return true;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314783", "bodyText": "Nit: \"Initialize\" would the the term.", "author": "narendly", "createdAt": "2020-02-26T07:34:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -64,6 +66,8 @@ public ServerContext(String zkAddr) {\n     // cannot be started correctly.\n     _helixDataAccessorPool = new HashMap<>();\n     _taskDriverPool = new HashMap<>();\n+    // Initiate the singleton ZkMetadataStoreDirectory instance to allow it to be closed later", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MzM4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384693387", "bodyText": "I agree.", "author": "NealSun96", "createdAt": "2020-02-26T18:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NDQ4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384694487", "bodyText": "Hm, I think my eyes were caught by the \"initiate\" in the comment on line 63, therefore I wrote \"initiate\" too.", "author": "NealSun96", "createdAt": "2020-02-26T18:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java b/helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java\nindex e0a70d9ce..5a0530a59 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java\n\n@@ -66,8 +64,6 @@ public class ServerContext {\n     // cannot be started correctly.\n     _helixDataAccessorPool = new HashMap<>();\n     _taskDriverPool = new HashMap<>();\n-    // Initiate the singleton ZkMetadataStoreDirectory instance to allow it to be closed later\n-    _zkMetadataStoreDirectory = ZkMetadataStoreDirectory.getInstance();\n   }\n \n   public HelixZkClient getHelixZkClient() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTE0NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315144", "bodyText": "Could you add some comments about the Jersey behavior here for reference as a block comment?", "author": "narendly", "createdAt": "2020-02-26T07:35:56Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -152,8 +155,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5Njk5NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384696994", "bodyText": "Fixed together with the later occurrence.", "author": "NealSun96", "createdAt": "2020-02-26T18:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\nindex ba24d5fb0..936bd7f14 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n\n@@ -107,63 +141,130 @@ public class MetadataStoreDirectoryAccessor extends AbstractResource {\n         return serverError();\n       }\n     } catch (IllegalArgumentException ex) {\n-      return notFound(ex.getMessage());\n+      return badRequest(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();\n     }\n \n     return OK();\n   }\n \n   /**\n-   * Gets sharding keys mapped at path \"HTTP GET /sharding-keys\" which returns all sharding keys in\n-   * a namespace, or path \"HTTP GET /sharding-keys?realm={realmName}\" which returns sharding keys in\n-   * a realm.\n+   * Gets all sharding keys for following requests:\n+   * - \"HTTP GET /sharding-keys\" which returns all sharding keys in a namespace.\n+   * - \"HTTP GET /sharding-keys?prefix={prefix}\" which returns sharding keys that have the prefix.\n+   * -- JSON response example for this path:\n+   * {\n+   * \t\"prefix\": \"/sharding/key\",\n+   * \t\"shardingKeys\": [{\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/f\"\n+   *    }, {\n+   * \t\t\"realm\": \"testRealm2\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/e\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/b\"\n+   *  }, {\n+   * \t\t\"realm\": \"testRealm1\",\n+   * \t\t\"shardingKey\": \"/sharding/key/1/a\"\n+   *  }]\n+   * }\n    *\n-   * @param realm Query param in endpoint path\n-   * @return Json representation of a map: shardingKeys -> collection of sharding keys.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return Json representation for the sharding keys.\n    */\n   @GET\n   @Path(\"/sharding-keys\")\n-  public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n-    Map<String, Object> responseMap;\n-    Collection<String> shardingKeys;\n+  public Response getShardingKeys(@QueryParam(\"prefix\") String prefix) {\n     try {\n-      // If realm is not set in query param, the endpoint is: \"/sharding-keys\"\n-      // to get all sharding keys in a namespace.\n-      if (realm == null) {\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeys(_namespace);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS.\n-        responseMap = new HashMap<>(1);\n-      } else {\n-        // For endpoint: \"/sharding-keys?realm={realmName}\"\n-        shardingKeys = _metadataStoreDirectory.getAllShardingKeysInRealm(_namespace, realm);\n-        // To avoid allocating unnecessary resource, limit the map's capacity only for\n-        // SHARDING_KEYS and SINGLE_METADATA_STORE_REALM.\n-        responseMap = new HashMap<>(2);\n-        responseMap.put(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_REALM, realm);\n+      if (prefix == null) {\n+        // For endpoint: \"/sharding-keys\" to get all sharding keys in a namespace.\n+        return getAllShardingKeys();\n       }\n+      // For endpoint: \"/sharding-keys?prefix={prefix}\"\n+      return getAllShardingKeysUnderPath(prefix);\n     } catch (NoSuchElementException ex) {\n       return notFound(ex.getMessage());\n     }\n+  }\n \n-    responseMap.put(MetadataStoreRoutingConstants.SHARDING_KEYS, shardingKeys);\n+  /**\n+   * Gets routing data in current namespace.\n+   *\n+   * - \"HTTP GET /routing-data\"\n+   * -- Response example:\n+   * {\n+   *   \"namespace\" : \"my-namespace\",\n+   *   \"routingData\" : [ {\n+   *     \"realm\" : \"realm-1\",\n+   *     \"shardingKeys\" : [ \"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\" ]\n+   *   }, {\n+   *     \"realm\" : \"realm-2\",\n+   *     \"shardingKeys\" : [ \"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\" ]\n+   *   } ]\n+   * }\n+   */\n+  @GET\n+  @Path(\"/routing-data\")\n+  public Response getRoutingData() {\n+    Map<String, List<String>> rawRoutingData;\n+    try {\n+      rawRoutingData = _metadataStoreDirectory.getNamespaceRoutingData(_namespace);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+\n+    List<MetadataStoreShardingKeysByRealm> shardingKeysByRealm = rawRoutingData.entrySet().stream()\n+        .map(entry -> new MetadataStoreShardingKeysByRealm(entry.getKey(), entry.getValue()))\n+        .collect(Collectors.toList());\n+\n+    Map<String, Object> responseMap = ImmutableMap\n+        .of(MetadataStoreRoutingConstants.SINGLE_METADATA_STORE_NAMESPACE, _namespace,\n+            MetadataStoreRoutingConstants.ROUTING_DATA, shardingKeysByRealm);\n \n     return JSONRepresentation(responseMap);\n   }\n \n+  /**\n+   * Gets all path-based sharding keys for a queried realm at endpoint:\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys\"\n+   * <p>\n+   * \"GET /metadata-store-realms/{realm}/sharding-keys?prefix={prefix}\" is also supported,\n+   * which is helpful when you want to check what sharding keys have the prefix substring.\n+   *\n+   * @param realm Queried metadata store realm to get sharding keys.\n+   * @param prefix Query param in endpoint path: prefix substring of sharding key.\n+   * @return All path-based sharding keys in the queried realm.\n+   */\n+  @GET\n+  @Path(\"/metadata-store-realms/{realm}/sharding-keys\")\n+  public Response getRealmShardingKeys(@PathParam(\"realm\") String realm,\n+      @QueryParam(\"prefix\") String prefix) {\n+    try {\n+      if (prefix == null) {\n+        return getAllShardingKeysInRealm(realm);\n+      }\n+\n+      // For \"GET /metadata-store-realms/{realm}/sharding-keys?prefix={prefix}\"\n+      return getRealmShardingKeysUnderPath(realm, prefix);\n+    } catch (NoSuchElementException ex) {\n+      return notFound(ex.getMessage());\n+    }\n+  }\n+\n   @PUT\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n-    if (shardingKey.charAt(0) != '/') {\n-      shardingKey = \"/\" + shardingKey;\n-    }\n     try {\n       if (!_metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey)) {\n         return serverError();\n       }\n     } catch (IllegalArgumentException ex) {\n-      return notFound(ex.getMessage());\n+      return badRequest(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();\n     }\n \n     return created();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTMzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315332", "bodyText": "Now this is duplicate code. Could you refactor this out to a private method? You could explain the JAX-RS behavior around slashes there.", "author": "narendly", "createdAt": "2020-02-26T07:36:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -165,8 +173,13 @@ public Response addShardingKey(@PathParam(\"realm\") String realm,\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response deleteShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NzA2Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384697062", "bodyText": "Done so.", "author": "NealSun96", "createdAt": "2020-02-26T18:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\nindex ba24d5fb0..936bd7f14 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java\n\n@@ -173,15 +274,14 @@ public class MetadataStoreDirectoryAccessor extends AbstractResource {\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response deleteShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n-    if (shardingKey.charAt(0) != '/') {\n-      shardingKey = \"/\" + shardingKey;\n-    }\n     try {\n       if (!_metadataStoreDirectory.deleteShardingKey(_namespace, realm, shardingKey)) {\n         return serverError();\n       }\n     } catch (IllegalArgumentException ex) {\n-      return notFound(ex.getMessage());\n+      return badRequest(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();\n     }\n \n     return OK();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315906", "bodyText": "Also add here that the reason we are not putting this in the test package is because the Jersey framework does not recognize resources in the test package when it spins up servers.", "author": "narendly", "createdAt": "2020-02-26T07:38:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMjI3MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384702271", "bodyText": "This might not be true. On Monday we assumed that Jersey isn't able to recognize it in the test package, and we moved this file into the same package as MetadataStoreDirectoryAccessor for it to work, hence our conclusion. However, on Tuesday, after moving it to its own package (not in the test package, but its own package), it was not working either.\nAfter research, I realized that its package path was not correctly added. On Monday, this file is in the same package as MetadataStoreDirectoryAccessor, and it was working because the package for MetadataStoreDirectoryAccessor was added already. There were some major changes to MockHelixRestServer for it to work in this current package. Therefore, the conclusion on Monday is not true anymore - the reason it wasn't working might not be due to the test package.\nRegardless, I think it's fine to leave this file here. However, if you believe this file is better in the test package, I can experiment with that and verify our conclusion.", "author": "NealSun96", "createdAt": "2020-02-26T19:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDIyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384770220", "bodyText": "Why wasn't it working then? I'd like to know the reason. If you don't think putting this class in the test package causes a problem, should we move it back to the test package?", "author": "narendly", "createdAt": "2020-02-26T21:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjkwNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384786907", "bodyText": "It wasn't working because the file's package was never added properly. Our method of overriding silently failed.\nSure, let me experiment with moving it to a test package and let's see if it still works.", "author": "NealSun96", "createdAt": "2020-02-26T21:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MjE0MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384842141", "bodyText": "The experiment was successful. It shows that it works in the test package too. Now the file sits in test.org.apache.helix.rest.server.mock.", "author": "NealSun96", "createdAt": "2020-02-27T00:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316148", "bodyText": "Static boolean -> make it all caps?", "author": "narendly", "createdAt": "2020-02-26T07:38:49Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzUxMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384703512", "bodyText": "This is not a constant variable, though. It's a flag value that's used to identify if there were zookeeper operations. Should it still be all caps?", "author": "NealSun96", "createdAt": "2020-02-26T19:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjIxMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772213", "bodyText": "I'm actually fine either way since this is just a global created for testing.", "author": "narendly", "createdAt": "2020-02-26T21:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjM0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316340", "bodyText": "Do not leave any stacktraces here. Let's use LOG.error(...)", "author": "narendly", "createdAt": "2020-02-26T07:39:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwNDUyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384704520", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316431", "bodyText": "Not impossible, but difficult. You're making it happen here ;)", "author": "narendly", "createdAt": "2020-02-26T07:39:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjk2MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316961", "bodyText": "Could you create an issue and link that issue here as a TODO? The TODO should talk about how you should make this a configurable thing where developers could just feed in configs (like # of servers and names of resources to be included) to start multiple mock server instances. The purpose is to test features that involve multiple servers (like distributed leader election, distributed locking, etc.)", "author": "narendly", "createdAt": "2020-02-26T07:41:21Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMTgxMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384721813", "bodyText": "#816 I'll link this in the code.", "author": "NealSun96", "createdAt": "2020-02-26T19:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384317288", "bodyText": "Nit: Should you clear the maps?", "author": "narendly", "createdAt": "2020-02-26T07:42:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n+   * therefore this is the only way to create another instance.\n+   */\n+  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n+    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n+        throws InvalidRoutingDataException {\n+      super();\n+\n+      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n+      _routingZkAddressMap.put(namespace, zkAddress);\n+      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n+      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n+      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n+    }\n+\n+    @Override\n+    public void close() {\n+      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n+      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwNjc1OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384706759", "bodyText": "It's not necessary because MockMSD is not a singleton. A new instance is created each time.", "author": "NealSun96", "createdAt": "2020-02-26T19:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjQ5Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772493", "bodyText": "OK.", "author": "narendly", "createdAt": "2020-02-26T21:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java b/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\ndeleted file mode 100644\nindex dea9a59f1..000000000\n--- a/helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java\n+++ /dev/null\n\n@@ -1,118 +0,0 @@\n-package org.apache.helix.rest.server.resources.mock;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import javax.ws.rs.Path;\n-\n-import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n-import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n-\n-\n-/**\n- * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n- */\n-@Path(\"/mock\")\n-public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n-  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n-  // against ZooKeeper\n-  public static boolean operatedOnZk = false;\n-  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n-  public static MetadataStoreDirectory _mockMSDInstance;\n-\n-  /**\n-   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n-   */\n-  @Override\n-  protected void buildMetadataStoreDirectory(String namespace, String address) {\n-    try {\n-      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n-      _mockMSDInstance = _metadataStoreDirectory;\n-    } catch (InvalidRoutingDataException e) {\n-      e.printStackTrace();\n-    }\n-  }\n-\n-  /**\n-   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n-   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n-   * therefore this is the only way to create another instance.\n-   */\n-  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n-    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n-        throws InvalidRoutingDataException {\n-      super();\n-\n-      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n-      _routingZkAddressMap.put(namespace, zkAddress);\n-      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n-      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n-      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n-      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n-    }\n-\n-    @Override\n-    public void close() {\n-      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n-      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);\n-    }\n-  }\n-\n-  /**\n-   * A mock to ZkRoutingDataWriter. The only purpose is to set the static flag signifying that\n-   * this writer is used for zookeeper operations.\n-   */\n-  class MockZkRoutingDataWriter extends ZkRoutingDataWriter {\n-    public MockZkRoutingDataWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-      operatedOnZk = false;\n-    }\n-\n-    @Override\n-    protected boolean createZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.createZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkRealm(String realm) {\n-      operatedOnZk = true;\n-      return super.deleteZkRealm(realm);\n-    }\n-\n-    @Override\n-    protected boolean createZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.createZkShardingKey(realm, shardingKey);\n-    }\n-\n-    @Override\n-    protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n-      operatedOnZk = true;\n-      return super.deleteZkShardingKey(realm, shardingKey);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384317808", "bodyText": "Nit: MockZkRoutingDataWriter so there's no ambiguity?", "author": "narendly", "createdAt": "2020-02-26T07:43:47Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwODAwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384708008", "bodyText": "Ditto below. This mock writer is for unit testing ZkRoutingDataWriter, it's not the one for integration testing.", "author": "NealSun96", "createdAt": "2020-02-26T19:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjY0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772640", "bodyText": "OK", "author": "narendly", "createdAt": "2020-02-26T21:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java b/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\nindex 7077dcadf..1aba067f5 100644\n--- a/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\n+++ b/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\n\n@@ -41,35 +40,15 @@ public class TestZkRoutingDataWriter extends AbstractTestClass {\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n-  // MockWriter is used for testing request forwarding features in non-leader situations\n-  class MockWriter extends ZkRoutingDataWriter {\n-    HttpUriRequest calledRequest;\n-\n-    MockWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-    }\n-\n-    // This method does not call super() because the http call should not be actually made\n-    @Override\n-    protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n-        String endPoint, String leaderHostName) {\n-      calledRequest = request;\n-      return false;\n-    }\n-  }\n-\n   @BeforeClass\n   public void beforeClass() {\n     _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT);\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n-        getBaseUri().toString());\n     _zkRoutingDataWriter = new ZkRoutingDataWriter(DUMMY_NAMESPACE, ZK_ADDR);\n   }\n \n   @AfterClass\n   public void afterClass() {\n     _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT);\n-    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n     _zkRoutingDataWriter.close();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384318207", "bodyText": "Shouldn't you make the HTTP call? Otherwise you won't be covering distributed leader election? I think we should make the HTTP call here to the leader. Otherwise it's not a true integration test.\nOr is this meant to be a unit test?", "author": "narendly", "createdAt": "2020-02-26T07:44:56Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {\n+    HttpUriRequest calledRequest;\n+\n+    MockWriter(String namespace, String zkAddress) {\n+      super(namespace, zkAddress);\n+    }\n+\n+    // This method does not call super() because the http call should not be actually made\n+    @Override", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwODkyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384708920", "bodyText": "I think you got the wrong file. :)\nThe MockZkRoutingDataWriter for integration testing is in MockMetadataStoreDirectoryAccessor.java, and that's where the actual HTTP calls are made to the leader. This file is for unit-testing, where only the forwarding logic is tested.", "author": "NealSun96", "createdAt": "2020-02-26T19:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mjc4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772787", "bodyText": "Ok, so a unit test.", "author": "narendly", "createdAt": "2020-02-26T21:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java b/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\nindex 7077dcadf..1aba067f5 100644\n--- a/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\n+++ b/helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java\n\n@@ -41,35 +40,15 @@ public class TestZkRoutingDataWriter extends AbstractTestClass {\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n-  // MockWriter is used for testing request forwarding features in non-leader situations\n-  class MockWriter extends ZkRoutingDataWriter {\n-    HttpUriRequest calledRequest;\n-\n-    MockWriter(String namespace, String zkAddress) {\n-      super(namespace, zkAddress);\n-    }\n-\n-    // This method does not call super() because the http call should not be actually made\n-    @Override\n-    protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n-        String endPoint, String leaderHostName) {\n-      calledRequest = request;\n-      return false;\n-    }\n-  }\n-\n   @BeforeClass\n   public void beforeClass() {\n     _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT);\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n-        getBaseUri().toString());\n     _zkRoutingDataWriter = new ZkRoutingDataWriter(DUMMY_NAMESPACE, ZK_ADDR);\n   }\n \n   @AfterClass\n   public void afterClass() {\n     _baseAccessor.remove(MetadataStoreRoutingConstants.ROUTING_DATA_PATH, AccessOption.PERSISTENT);\n-    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n     _zkRoutingDataWriter.close();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319039", "bodyText": "Why do you need to create a new HashSet out of a set?\nYou could probably return Collections.unmodifiableSet(....keySet()) as well if you want to prevent modifications", "author": "narendly", "createdAt": "2020-02-26T07:47:21Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class MetadataStoreDirectoryAccessorTestBase extends AbstractTestClass {\n+  /*\n+   * The following are constants to be used for testing.\n+   */\n+  protected static final String TEST_NAMESPACE_URI_PREFIX = \"/namespaces/\" + TEST_NAMESPACE;\n+  protected static final String NON_EXISTING_NAMESPACE_URI_PREFIX =\n+      \"/namespaces/not-existed-namespace/metadata-store-realms/\";\n+  protected static final String TEST_REALM_1 = \"testRealm1\";\n+  protected static final List<String> TEST_SHARDING_KEYS_1 =\n+      Arrays.asList(\"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\");\n+  protected static final String TEST_REALM_2 = \"testRealm2\";\n+  protected static final List<String> TEST_SHARDING_KEYS_2 =\n+      Arrays.asList(\"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\");\n+  protected static final String TEST_REALM_3 = \"testRealm3\";\n+  protected static final String TEST_SHARDING_KEY = \"/sharding/key/1/x\";\n+\n+  // List of all ZK addresses, each of which corresponds to a namespace/routing ZK\n+  protected List<String> _zkList;\n+  protected MetadataStoreRoutingDataReader _routingDataReader;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _zkList = new ArrayList<>(ZK_SERVER_MAP.keySet());\n+\n+    deleteRoutingDataPath();\n+\n+    // Write dummy mappings in ZK\n+    // Create a node that represents a realm address and add 3 sharding keys to it\n+    ZNRecord znRecord = new ZNRecord(\"RoutingInfo\");\n+\n+    _zkList.forEach(zk -> {\n+      ZK_SERVER_MAP.get(zk).getZkClient().setZkSerializer(new ZNRecordSerializer());\n+      // Write first realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_1);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              znRecord);\n+\n+      // Create another realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_2);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              znRecord);\n+    });\n+\n+    _routingDataReader = new ZkRoutingDataReader(TEST_NAMESPACE, _zkAddrTestNS, null);\n+\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n+        getBaseUri().toString());\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    deleteRoutingDataPath();\n+  }\n+\n+  protected void deleteRoutingDataPath() throws Exception {\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      _zkList.forEach(zk -> ZK_SERVER_MAP.get(zk).getZkClient()\n+          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH));\n+\n+      for (String zk : _zkList) {\n+        if (ZK_SERVER_MAP.get(zk).getZkClient()\n+            .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }, TestHelper.WAIT_DURATION), \"Routing data path should be deleted after the tests.\");\n+  }\n+\n+  protected Set<String> getAllMetadataStoreRealmsHelper() throws InvalidRoutingDataException {\n+    return new HashSet<>(_routingDataReader.getRoutingData().keySet());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMDIxOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384710219", "bodyText": "Because in TestMetadataStoreDirectoryAccessor we need to modify this set. For example:\nSet<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\nexpectedRealmsSet.add(TEST_REALM_3);\n\nkeySet() is unmodifiable. Making a copy makes it modifiable.", "author": "NealSun96", "createdAt": "2020-02-26T19:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MzMyNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384773327", "bodyText": "getAllMetadataStoreRealmsHelper -> this naming is a little confusing. Consider renaming or explain what it does and why it's needed.", "author": "narendly", "createdAt": "2020-02-26T21:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNTg0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384835840", "bodyText": "Renamed and added comments.", "author": "NealSun96", "createdAt": "2020-02-26T23:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java b/helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java\ndeleted file mode 100644\nindex fe8511576..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java\n+++ /dev/null\n\n@@ -1,128 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import org.apache.helix.TestHelper;\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n-import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-\n-\n-public class MetadataStoreDirectoryAccessorTestBase extends AbstractTestClass {\n-  /*\n-   * The following are constants to be used for testing.\n-   */\n-  protected static final String TEST_NAMESPACE_URI_PREFIX = \"/namespaces/\" + TEST_NAMESPACE;\n-  protected static final String NON_EXISTING_NAMESPACE_URI_PREFIX =\n-      \"/namespaces/not-existed-namespace/metadata-store-realms/\";\n-  protected static final String TEST_REALM_1 = \"testRealm1\";\n-  protected static final List<String> TEST_SHARDING_KEYS_1 =\n-      Arrays.asList(\"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\");\n-  protected static final String TEST_REALM_2 = \"testRealm2\";\n-  protected static final List<String> TEST_SHARDING_KEYS_2 =\n-      Arrays.asList(\"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\");\n-  protected static final String TEST_REALM_3 = \"testRealm3\";\n-  protected static final String TEST_SHARDING_KEY = \"/sharding/key/1/x\";\n-\n-  // List of all ZK addresses, each of which corresponds to a namespace/routing ZK\n-  protected List<String> _zkList;\n-  protected MetadataStoreRoutingDataReader _routingDataReader;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    _zkList = new ArrayList<>(ZK_SERVER_MAP.keySet());\n-\n-    deleteRoutingDataPath();\n-\n-    // Write dummy mappings in ZK\n-    // Create a node that represents a realm address and add 3 sharding keys to it\n-    ZNRecord znRecord = new ZNRecord(\"RoutingInfo\");\n-\n-    _zkList.forEach(zk -> {\n-      ZK_SERVER_MAP.get(zk).getZkClient().setZkSerializer(new ZNRecordSerializer());\n-      // Write first realm and sharding keys pair\n-      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n-          TEST_SHARDING_KEYS_1);\n-      ZK_SERVER_MAP.get(zk).getZkClient()\n-          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n-              true);\n-      ZK_SERVER_MAP.get(zk).getZkClient()\n-          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n-              znRecord);\n-\n-      // Create another realm and sharding keys pair\n-      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n-          TEST_SHARDING_KEYS_2);\n-      ZK_SERVER_MAP.get(zk).getZkClient()\n-          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n-              true);\n-      ZK_SERVER_MAP.get(zk).getZkClient()\n-          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n-              znRecord);\n-    });\n-\n-    _routingDataReader = new ZkRoutingDataReader(TEST_NAMESPACE, _zkAddrTestNS, null);\n-\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n-        getBaseUri().toString());\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n-    deleteRoutingDataPath();\n-  }\n-\n-  protected void deleteRoutingDataPath() throws Exception {\n-    Assert.assertTrue(TestHelper.verify(() -> {\n-      _zkList.forEach(zk -> ZK_SERVER_MAP.get(zk).getZkClient()\n-          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH));\n-\n-      for (String zk : _zkList) {\n-        if (ZK_SERVER_MAP.get(zk).getZkClient()\n-            .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n-          return false;\n-        }\n-      }\n-\n-      return true;\n-    }, TestHelper.WAIT_DURATION), \"Routing data path should be deleted after the tests.\");\n-  }\n-\n-  protected Set<String> getAllMetadataStoreRealmsHelper() throws InvalidRoutingDataException {\n-    return new HashSet<>(_routingDataReader.getRoutingData().keySet());\n-  }\n-\n-  protected Set<String> getShardingKeysInRealmHelper() throws InvalidRoutingDataException {\n-    return new HashSet<>(_routingDataReader.getRoutingData().get(TEST_REALM_1));\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTI1NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319254", "bodyText": "Avoid static imports. Just qualify with \"MetadataStoreRoutingConstants.\"", "author": "narendly", "createdAt": "2020-02-26T07:48:03Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMTA1Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384711053", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTQzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319432", "bodyText": "Nit: I think TestMSDAccessorLeaderElection sounds better.", "author": "narendly", "createdAt": "2020-02-26T07:48:32Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMTU2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384711567", "bodyText": "Sure, saying \"leader election\" is sufficient.", "author": "NealSun96", "createdAt": "2020-02-26T19:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTQzMg=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTU5Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319596", "bodyText": "private static final String is how you declare a constant.", "author": "narendly", "createdAt": "2020-02-26T07:49:00Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjI2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384712267", "bodyText": "Oops. Fixing it.", "author": "NealSun96", "createdAt": "2020-02-26T19:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDE5MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320191", "bodyText": "We see a lot of getPort() + 1's here. Let's just create a new variable,\nint newPort = getPort() + 1; and use newPort throughout? This will make your code more readable.", "author": "narendly", "createdAt": "2020-02-26T07:50:45Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzA0Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384713042", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-26T19:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDMyMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320321", "bodyText": "LOG.error instead of printing stacktrace please.", "author": "narendly", "createdAt": "2020-02-26T07:51:04Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzg2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384713867", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDczNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320737", "bodyText": "\"put\" could be an enum.", "author": "narendly", "createdAt": "2020-02-26T07:52:15Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNTAxNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384715015", "bodyText": "Using the same enum as the other class.", "author": "NealSun96", "createdAt": "2020-02-26T19:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDczNw=="}], "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDc3Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320772", "bodyText": "Use enum for \"delete\"", "author": "narendly", "createdAt": "2020-02-26T07:52:23Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMTUxOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384321518", "bodyText": "Enum!", "author": "narendly", "createdAt": "2020-02-26T07:54:30Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedRealmsSet.remove(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n+  public void testAddShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n+        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n+  public void testDeleteShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  private void sendRequestAndValidate(String url_suffix, String request_method,\n+      int expectedResponseCode) throws IllegalArgumentException, IOException {\n+    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "chunk": "diff --git a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java b/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\ndeleted file mode 100644\nindex 51cd7f3ae..000000000\n--- a/helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java\n+++ /dev/null\n\n@@ -1,225 +0,0 @@\n-package org.apache.helix.rest.server;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n-import javax.ws.rs.core.Response;\n-\n-import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n-import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n-import org.apache.helix.rest.common.ContextPropertyKeys;\n-import org.apache.helix.rest.common.HelixRestNamespace;\n-import org.apache.helix.rest.common.ServletType;\n-import org.apache.helix.rest.server.auditlog.AuditLogger;\n-import org.apache.helix.rest.server.filters.CORSFilter;\n-import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n-import org.apache.http.HttpResponse;\n-import org.apache.http.client.methods.HttpDelete;\n-import org.apache.http.client.methods.HttpPut;\n-import org.apache.http.client.methods.HttpUriRequest;\n-import org.apache.http.impl.client.CloseableHttpClient;\n-import org.apache.http.impl.client.HttpClients;\n-import org.glassfish.jersey.server.ResourceConfig;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n-\n-\n-public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n-  private final String MOCK_URL_PREFIX = \"/mock\";\n-\n-  private HelixRestServer _mockHelixRestServer;\n-  private String _mockBaseUri;\n-  private String _leaderBaseUri;\n-  private CloseableHttpClient _httpClient;\n-  private HelixZkClient _zkClient;\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    super.beforeClass();\n-    _leaderBaseUri = getBaseUri().toString();\n-\n-    // Start a second server for testing Distributed Leader Election for writes\n-    _mockBaseUri =\n-        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n-            + 1);\n-    try {\n-      List<HelixRestNamespace> namespaces = new ArrayList<>();\n-      // Add test namespace\n-      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n-          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n-      _mockHelixRestServer =\n-          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n-              Collections.singletonList(_auditLogger));\n-      _mockHelixRestServer.start();\n-    } catch (InterruptedException e) {\n-      e.printStackTrace();\n-    }\n-\n-    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n-    // it didn't exist yet.\n-    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n-        Response.Status.OK.getStatusCode(), true);\n-\n-    // Set the new uri to be used in leader election\n-    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n-\n-    // Start http client for testing\n-    _httpClient = HttpClients.createDefault();\n-\n-    // Start zkclient to verify leader election behavior\n-    _zkClient = DedicatedZkClientFactory.getInstance()\n-        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n-            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-    _mockHelixRestServer.shutdown();\n-    _httpClient.close();\n-    _zkClient.close();\n-  }\n-\n-  @Test\n-  public void testAddMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n-        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedRealmsSet.add(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n-  public void testDeleteMetadataStoreRealmRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n-    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedRealmsSet.remove(TEST_REALM_3);\n-    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n-  public void testAddShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n-        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n-        Response.Status.CREATED.getStatusCode());\n-    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n-  public void testDeleteShardingKeyRequestForwarding()\n-      throws InvalidRoutingDataException, IOException {\n-    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n-    sendRequestAndValidate(\n-        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n-        Response.Status.OK.getStatusCode());\n-    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n-    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n-    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n-  }\n-\n-  private void sendRequestAndValidate(String url_suffix, String request_method,\n-      int expectedResponseCode) throws IllegalArgumentException, IOException {\n-    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n-    HttpUriRequest request;\n-    switch (request_method) {\n-      case \"put\":\n-        request = new HttpPut(url);\n-        break;\n-      case \"delete\":\n-        request = new HttpDelete(url);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n-    }\n-    HttpResponse response = _httpClient.execute(request);\n-    Assert.assertEquals(response.getStatusLine().getStatusCode(), expectedResponseCode);\n-\n-    // Validate leader election behavior\n-    List<String> leaderSelectionNodes = _zkClient.getChildren(LEADER_ELECTION_ZNODE);\n-    leaderSelectionNodes.sort(Comparator.comparing(String::toString));\n-    Assert.assertEquals(leaderSelectionNodes.size(), 2);\n-    ZNRecord firstEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(0));\n-    ZNRecord secondEphemeralNode =\n-        _zkClient.readData(LEADER_ELECTION_ZNODE + \"/\" + leaderSelectionNodes.get(1));\n-    Assert.assertEquals(firstEphemeralNode.getId(), _leaderBaseUri);\n-    Assert.assertEquals(secondEphemeralNode.getId(), _mockBaseUri);\n-\n-    // Make sure the operation is not done by the follower instance\n-    Assert.assertFalse(MockMetadataStoreDirectoryAccessor.operatedOnZk);\n-  }\n-\n-  /**\n-   * A class that mocks HelixRestServer for testing. It overloads getResourceConfig to inject\n-   * MockMetadataStoreDirectoryAccessor as a servlet.\n-   */\n-  class MockHelixRestServer extends HelixRestServer {\n-    public MockHelixRestServer(List<HelixRestNamespace> namespaces, int port, String urlPrefix,\n-        List<AuditLogger> auditLoggers) {\n-      super(namespaces, port, urlPrefix, auditLoggers);\n-    }\n-\n-    public MockHelixRestServer(String zkAddr, int port, String urlPrefix) {\n-      super(zkAddr, port, urlPrefix);\n-    }\n-\n-    @Override\n-    protected ResourceConfig getResourceConfig(HelixRestNamespace namespace, ServletType type) {\n-      ResourceConfig cfg = new ResourceConfig();\n-      List<String> packages = new ArrayList<>(Arrays.asList(type.getServletPackageArray()));\n-      packages.add(MockMetadataStoreDirectoryAccessor.class.getPackage().getName());\n-      cfg.packages(packages.toArray(new String[0]));\n-      cfg.setApplicationName(namespace.getName());\n-      cfg.property(ContextPropertyKeys.SERVER_CONTEXT.name(),\n-          new ServerContext(namespace.getMetadataStoreAddress()));\n-      cfg.property(ContextPropertyKeys.METADATA.name(), namespace);\n-      cfg.register(new CORSFilter());\n-      return cfg;\n-    }\n-  }\n-}\n\\ No newline at end of file\n"}}, {"oid": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "url": "https://github.com/apache/helix/commit/f77c181059e08811faa96e3b0ed242d3ca78ef8f", "message": "implement request forwarding", "committedDate": "2020-02-26T18:08:29Z", "type": "commit"}, {"oid": "2b00953af8a4c2d64b00d10d900516a300a287ce", "url": "https://github.com/apache/helix/commit/2b00953af8a4c2d64b00d10d900516a300a287ce", "message": "revert to notFound", "committedDate": "2020-02-26T18:08:29Z", "type": "commit"}, {"oid": "bd396337b593ea4172e7b895fa4355214e322e54", "url": "https://github.com/apache/helix/commit/bd396337b593ea4172e7b895fa4355214e322e54", "message": "fix existing bugs and make accessor tests work", "committedDate": "2020-02-26T18:13:37Z", "type": "commit"}, {"oid": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "url": "https://github.com/apache/helix/commit/b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "message": "address comments, add tests, convert MSD to singleton, fix leader election", "committedDate": "2020-02-26T18:14:11Z", "type": "commit"}, {"oid": "798fd3d3251c43f80074b161da1f0d54bbef4f48", "url": "https://github.com/apache/helix/commit/798fd3d3251c43f80074b161da1f0d54bbef4f48", "message": "add integration tests, modify sharding keys endpoint, correct writer forwarding behavior", "committedDate": "2020-02-26T18:17:40Z", "type": "commit"}, {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "message": "address first comments, need to rebase", "committedDate": "2020-02-26T18:17:40Z", "type": "commit"}, {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "message": "address first comments, need to rebase", "committedDate": "2020-02-26T18:17:40Z", "type": "forcePushed"}, {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8", "url": "https://github.com/apache/helix/commit/b8e14234b348fd4059a374468691d87d6a4a88b8", "message": "address many comments", "committedDate": "2020-02-26T20:22:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDE5Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384764197", "bodyText": "Is there a reason why you couldn't include * 1000 in the constant itself?", "author": "narendly", "createdAt": "2020-02-26T21:04:21Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,24 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null || _myHostName.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    RequestConfig config = RequestConfig.custom()\n+        .setConnectTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setConnectionRequestTimeout(\n+            MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setSocketTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4ODE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384788148", "bodyText": "Good point. Let me move the multiplication.", "author": "NealSun96", "createdAt": "2020-02-26T21:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7c3039213453521df2ad78afa27795e69e187dab", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex 4d1da2034..061372cdd 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -77,23 +80,25 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n-    if (_myHostName == null || _myHostName.isEmpty()) {\n+    String hostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (hostName == null || hostName.isEmpty()) {\n       throw new IllegalStateException(\n           \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n               + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n     }\n+    // remove trailing slash\n+    if (hostName.charAt(hostName.length() - 1) == '/') {\n+      hostName = hostName.substring(0, hostName.length() - 1);\n+    }\n+    _myHostName = hostName;\n     ZNRecord myServerInfo = new ZNRecord(_myHostName);\n \n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n \n-    RequestConfig config = RequestConfig.custom()\n-        .setConnectTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n-        .setConnectionRequestTimeout(\n-            MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n-        .setSocketTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n-        .build();\n+    RequestConfig config = RequestConfig.custom().setConnectTimeout(HTTP_REQUEST_FORWARDING_TIMEOUT)\n+        .setConnectionRequestTimeout(HTTP_REQUEST_FORWARDING_TIMEOUT)\n+        .setSocketTimeout(HTTP_REQUEST_FORWARDING_TIMEOUT).build();\n     _forwardHttpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTYyOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384765628", "bodyText": "If you want these HTTP verbs included in MetadataStoreRoutingConstants , you could use a more generalized name like HttpVerbs.  HttpRequestForwardingVerbs if you want to keep it as an enum in this class.\nIf you want to generalize and put this in MetadataStoreRoutingConstants, then I'm pretty sure you could already find the supported HTTP verb enum somewhere defined in helix-rest module. Use that instead.", "author": "narendly", "createdAt": "2020-02-26T21:07:20Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +106,11 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.PUT, \"addMetadataStoreRealm\",", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384812431", "bodyText": "Created HttpConstants.RestVerbs in org.apache.helix.rest.common that serves the enum purpose.", "author": "NealSun96", "createdAt": "2020-02-26T22:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTYyOA=="}], "type": "inlineReview", "revised_code": {"commit": "7c3039213453521df2ad78afa27795e69e187dab", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex 4d1da2034..061372cdd 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -108,8 +113,7 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n \n     String urlSuffix =\n         constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm);\n-    return forwardRequestToLeader(urlSuffix,\n-        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.PUT, \"addMetadataStoreRealm\",\n+    return forwardRequestToLeader(urlSuffix, HttpConstants.RestVerbs.PUT,\n         Response.Status.CREATED.getStatusCode());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NjEwNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384766105", "bodyText": "I still see a string literal here?", "author": "narendly", "createdAt": "2020-02-26T21:08:18Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +152,15 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm,\n+            MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, shardingKey);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.DELETE, \"deleteShardingKey\",", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjgyNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384812826", "bodyText": "Removing this method name parameter altogether because it's better to use url to log. The url is more verbose.", "author": "NealSun96", "createdAt": "2020-02-26T22:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NjEwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3039213453521df2ad78afa27795e69e187dab", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex 4d1da2034..061372cdd 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -158,8 +160,7 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n     String urlSuffix =\n         constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm,\n             MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, shardingKey);\n-    return forwardRequestToLeader(urlSuffix,\n-        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.DELETE, \"deleteShardingKey\",\n+    return forwardRequestToLeader(urlSuffix, HttpConstants.RestVerbs.DELETE,\n         Response.Status.OK.getStatusCode());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzI2OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384767269", "bodyText": "Do not rely on this behavior. Let's make sure this method creates a valid URL. Would you be okay with this failing when we swap out the HTTP client we're using right now with a different one?\nDo you think making this assumption is hacky? Could we improve it?", "author": "narendly", "createdAt": "2020-02-26T21:10:28Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +244,126 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient.writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private String constructUrlSuffix(String... urlParams) {\n+    List<String> allUrlParameters = new ArrayList<>(\n+        Arrays.asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, _namespace));\n+    allUrlParameters.addAll(Arrays.asList(urlParams));\n+    // HttpUriRequest will convert all double slashes to single slashes", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNDc4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384834787", "bodyText": "We now take out all possible double slashes.", "author": "NealSun96", "createdAt": "2020-02-26T23:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzI2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3039213453521df2ad78afa27795e69e187dab", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\nindex 4d1da2034..061372cdd 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java\n\n@@ -315,14 +316,17 @@ public class ZkRoutingDataWriter implements MetadataStoreRoutingDataWriter {\n \n   private String constructUrlSuffix(String... urlParams) {\n     List<String> allUrlParameters = new ArrayList<>(\n-        Arrays.asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, _namespace));\n-    allUrlParameters.addAll(Arrays.asList(urlParams));\n-    // HttpUriRequest will convert all double slashes to single slashes\n-    return String.join(\"/\", allUrlParameters);\n+        Arrays.asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, \"/\", _namespace));\n+    for (String urlParam : urlParams) {\n+      if (urlParam.charAt(0) != '/') {\n+        urlParam = \"/\" + urlParam;\n+      }\n+      allUrlParameters.add(urlParam);\n+    }\n+    return String.join(\"\", allUrlParameters);\n   }\n \n-  private boolean forwardRequestToLeader(String urlSuffix,\n-      MetadataStoreRoutingConstants.HttpRequestForwardingVerbs request_method, String endPoint,\n+  private boolean forwardRequestToLeader(String urlSuffix, HttpConstants.RestVerbs request_method,\n       int expectedResponseCode) throws IllegalArgumentException {\n     String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n     String url = leaderHostName + urlSuffix;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mzg4Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384773882", "bodyText": "If you want to do this, I think you could find HTTP verbs defined elsewhere already.", "author": "narendly", "createdAt": "2020-02-26T21:22:33Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -20,6 +20,11 @@\n  */\n \n public class MetadataStoreRoutingConstants {\n+  public enum HttpRequestForwardingVerbs {", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c3039213453521df2ad78afa27795e69e187dab", "chunk": "diff --git a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\nindex 0372f7c1d..766f98aa9 100644\n--- a/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n+++ b/metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java\n\n@@ -20,11 +20,6 @@ package org.apache.helix.msdcommon.constant;\n  */\n \n public class MetadataStoreRoutingConstants {\n-  public enum HttpRequestForwardingVerbs {\n-    PUT,\n-    DELETE\n-  }\n-\n   public static final String ROUTING_DATA_PATH = \"/METADATA_STORE_ROUTING_DATA\";\n \n   // For ZK only\n"}}, {"oid": "7c3039213453521df2ad78afa27795e69e187dab", "url": "https://github.com/apache/helix/commit/7c3039213453521df2ad78afa27795e69e187dab", "message": "address remaining comments", "committedDate": "2020-02-27T00:00:39Z", "type": "commit"}, {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "url": "https://github.com/apache/helix/commit/a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "message": "move mock class", "committedDate": "2020-02-27T00:08:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTUwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384859506", "bodyText": "Remove empty line", "author": "narendly", "createdAt": "2020-02-27T01:05:25Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,69 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+", "originalCommit": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\nindex 301d65660..9d54c82bd 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n\n@@ -68,7 +68,6 @@ public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, Routing\n         }\n       }\n     }\n-\n     return _zkMetadataStoreDirectoryInstance;\n   }\n \n"}}, {"oid": "1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "url": "https://github.com/apache/helix/commit/1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "message": "remove empty line", "committedDate": "2020-02-27T01:16:08Z", "type": "commit"}]}