{"pr_number": 855, "pr_title": "Make ZkBaseDataAccessor realm-aware", "pr_createdAt": "2020-03-04T07:56:41Z", "pr_url": "https://github.com/apache/helix/pull/855", "timeline": [{"oid": "8daad1d5579ca47cb2be4bc4a8122e5414d6e777", "url": "https://github.com/apache/helix/commit/8daad1d5579ca47cb2be4bc4a8122e5414d6e777", "message": "Make ZkBaseDataAccessor realm-aware", "committedDate": "2020-03-04T19:01:06Z", "type": "forcePushed"}, {"oid": "c3fb8b7ba06c86aa5b6da31eba0dc3343ac55a77", "url": "https://github.com/apache/helix/commit/c3fb8b7ba06c86aa5b6da31eba0dc3343ac55a77", "message": "Make ZkBaseDataAccessor realm-aware", "committedDate": "2020-03-04T19:22:50Z", "type": "forcePushed"}, {"oid": "383fbd3bdfc6a7eda0791600e097fa1ed245e2b9", "url": "https://github.com/apache/helix/commit/383fbd3bdfc6a7eda0791600e097fa1ed245e2b9", "message": "Make ZkBaseDataAccessor realm-aware", "committedDate": "2020-03-04T19:40:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODMxMg==", "url": "https://github.com/apache/helix/pull/855#discussion_r387968312", "bodyText": "ZkBaseDataAccessor needs to be able to take in Connection and Client configs. Instead of a constructor that takes in 0 parameters, could we use the builder pattern to achieve this? See the example for ConfigAccessor.", "author": "narendly", "createdAt": "2020-03-04T22:17:31Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,14 +107,31 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private static final String EMPTY_ZK_ADDRESS = \"\";\n+\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * This default constructor attempts to connect to ZK on multi-realm mode.\n+   *\n+   * @exception IllegalStateException if connecting to ZK on multi-realm mode fails\n+   */\n+  public ZkBaseDataAccessor() {\n+    this(EMPTY_ZK_ADDRESS);\n+  }", "originalCommit": "383fbd3bdfc6a7eda0791600e097fa1ed245e2b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b5713630c0253132d7158aea920c9df544c5607", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 17d8d3861..5496c166b 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -107,23 +107,12 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private static final String EMPTY_ZK_ADDRESS = \"\";\n-\n   private final RealmAwareZkClient _zkClient;\n   // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n-  /**\n-   * This default constructor attempts to connect to ZK on multi-realm mode.\n-   *\n-   * @exception IllegalStateException if connecting to ZK on multi-realm mode fails\n-   */\n-  public ZkBaseDataAccessor() {\n-    this(EMPTY_ZK_ADDRESS);\n-  }\n-\n   /**\n    * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n    * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODczNQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r387968735", "bodyText": "Under what circumstances will IllegalArgumentException be thrown?", "author": "narendly", "createdAt": "2020-03-04T22:18:31Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1251,41 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    RealmAwareZkClient zkClient;\n+\n+    try {\n+      zkClient = new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IllegalArgumentException | IOException | InvalidRoutingDataException e) {", "originalCommit": "383fbd3bdfc6a7eda0791600e097fa1ed245e2b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b5713630c0253132d7158aea920c9df544c5607", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 17d8d3861..5496c166b 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1252,6 +1241,93 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n     }\n   }\n \n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private ZkBaseDataAccessor(Builder builder) throws IOException, InvalidRoutingDataException {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        _zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+            builder.realmAwareZkClientConfig);\n+        break;\n+      case SINGLE_REALM:\n+        // Create a HelixZkClient: Use a SharedZkClient because ZkBaseDataAccessor does not need to\n+        // do ephemeral operations.\n+        _zkClient = SharedZkClientFactory.getInstance()\n+            .buildZkClient(builder.realmAwareZkConnectionConfig.createZkConnectionConfig(),\n+                builder.realmAwareZkClientConfig.createHelixZkClientConfig());\n+        break;\n+      default:\n+        throw new HelixException(\"Invalid RealmMode given: \" + builder.realmMode);\n+    }\n+\n+    _usesExternalZkClient = false;\n+  }\n+\n   private RealmAwareZkClient buildRealmAwareZkClient(\n       RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n       ZkClientType zkClientType) {\n"}}, {"oid": "8b5713630c0253132d7158aea920c9df544c5607", "url": "https://github.com/apache/helix/commit/8b5713630c0253132d7158aea920c9df544c5607", "message": "Make ZkBaseDataAccessor realm-aware", "committedDate": "2020-03-05T04:45:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTY3Nw==", "url": "https://github.com/apache/helix/pull/855#discussion_r388079677", "bodyText": "Could we move up this constructor so it's with other public constructors?", "author": "narendly", "createdAt": "2020-03-05T05:03:36Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"ConfigAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private ZkBaseDataAccessor(Builder builder) throws IOException, InvalidRoutingDataException {", "originalCommit": "c250acf155da2f6d20df98f82a108f16031d71df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 46ed43e0b..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1244,6 +1313,7 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   public static class Builder {\n     private String zkAddress;\n     private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n     private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n     private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTgwNQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r388079805", "bodyText": "We'd need ZkBaseDataAccessor-specific parameters here as well such as ZkClientType (See #863 for reference)", "author": "narendly", "createdAt": "2020-03-05T05:04:23Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+", "originalCommit": "c250acf155da2f6d20df98f82a108f16031d71df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY4Njc5Mg==", "url": "https://github.com/apache/helix/pull/855#discussion_r388686792", "bodyText": "Got it.", "author": "huizhilu", "createdAt": "2020-03-06T02:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3OTgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 46ed43e0b..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1244,6 +1313,7 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   public static class Builder {\n     private String zkAddress;\n     private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n     private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n     private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4MDAzNg==", "url": "https://github.com/apache/helix/pull/855#discussion_r388080036", "bodyText": "Ideally, validation logic should also resolve things like ZkClientType (if it's not set), so that the constructor should only worry about \"constructing\", not figuring out what's set or not. Let's try to separate logic as much as we can - this will help future development much easier in my opinion.", "author": "narendly", "createdAt": "2020-03-05T05:05:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1240,123 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {", "originalCommit": "c250acf155da2f6d20df98f82a108f16031d71df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 46ed43e0b..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1244,6 +1313,7 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   public static class Builder {\n     private String zkAddress;\n     private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n     private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n     private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTY3NA==", "url": "https://github.com/apache/helix/pull/855#discussion_r389205674", "bodyText": "Do we have a PR for HelixDataAccessor as well?", "author": "narendly", "createdAt": "2020-03-07T00:35:07Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {", "originalCommit": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODg4Mg==", "url": "https://github.com/apache/helix/pull/855#discussion_r389318882", "bodyText": "As we discussed offline, we decided not to add a builder constructor for HelixDataAccessor.\nThe reason is: Underneath it is using a BaseDataAccessor, which could an instance of ZkBaseDataAccessor/ZkCacheBaseDataAccessor/HelixPropertyStore, etc.. If we offer a builder constructor, we have to determine which instance of BaseDataAccessor. If we just offer a builder constructor like this Builder().setBaseDataAccessor(), I don\u2019t think we need it.", "author": "huizhilu", "createdAt": "2020-03-07T23:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 7a4659970..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -115,8 +125,9 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   private final boolean _usesExternalZkClient;\n \n   /**\n-   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n-   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n    *\n    * @param zkClient A created RealmAwareZkClient\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTg1NA==", "url": "https://github.com/apache/helix/pull/855#discussion_r389205854", "bodyText": "As discussed offline, please make sure you're throwing a HelixException and propagating the Exception.\nNote that we shouldn't fall back to single-realm mode. We should fail here.", "author": "narendly", "createdAt": "2020-03-07T00:36:04Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,21 +108,75 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    RealmAwareZkClient zkClient;\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder.realmAwareZkConnectionConfig,\n+              builder.realmAwareZkClientConfig);\n+          // Break here to exit.\n+          break;\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          if (builder.zkAddress == null || builder.zkAddress.isEmpty()) {\n+            throw new IllegalStateException(\"Not able to connect on multi-realm mode.\", e);\n+          }\n+          LOG.info(\"Not able to connect on multi-realm mode. \"\n+              + \"Connecting on single-realm mode to ZK: {}\", builder.zkAddress);\n+          builder.setRealmMode(RealmAwareZkClient.RealmMode.SINGLE_REALM);\n+        }\n+        // No break here. If connecting on multi-realm fails and ZK address is valid, connecting\n+        // on single-realm is allowed.\n+", "originalCommit": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxODg4NQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r389318885", "bodyText": "Done.", "author": "huizhilu", "createdAt": "2020-03-07T23:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 7a4659970..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -115,8 +125,9 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   private final boolean _usesExternalZkClient;\n \n   /**\n-   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n-   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n    *\n    * @param zkClient A created RealmAwareZkClient\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTk1OA==", "url": "https://github.com/apache/helix/pull/855#discussion_r389205958", "bodyText": "Is this break necessary?", "author": "narendly", "createdAt": "2020-03-07T00:36:37Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    try {\n+      return new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      // Fall back to connect on single-realm mode if failed to connect on multi-realm mode and\n+      // ZK address is not empty.\n+      LOG.info(\"Not able to connect on multi-realm mode, caused by: {}. \"\n+          + \"Connecting on single-realm mode to ZK: {}.\", e.getMessage(), zkAddress);\n+    }\n+\n+    RealmAwareZkClient zkClient;\n+\n+    switch (zkClientType) {\n+      case DEDICATED:\n+        zkClient = DedicatedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;\n+      case SHARED:\n+      default:\n+        zkClient = SharedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                clientConfig.createHelixZkClientConfig());\n+        break;", "originalCommit": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxNzAwOA==", "url": "https://github.com/apache/helix/pull/855#discussion_r389317008", "bodyText": "It is just my habit: As a matter of good form, put a break after the last case (the default here) even though it's logically unnecessary. Some day when another case gets added at the end, this bit of defensive programming will save you.", "author": "huizhilu", "createdAt": "2020-03-07T22:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNTk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 7a4659970..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1328,28 +1348,19 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n       return this;\n     }\n \n-    public ZkBaseDataAccessor<?> build() throws Exception {\n+    public ZkBaseDataAccessor<?> build() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n \n-    /**\n-     * Validate the given parameters before creating an instance of ConfigAccessor.\n+    /*\n+     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n      */\n     private void validate() {\n       // Resolve RealmMode based on other parameters\n       boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n       boolean isZkClientTypeSet = zkClientType != null;\n \n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\n-            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n       // If ZkClientType is set, RealmMode must either be single-realm or not set.\n       if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n         throw new HelixException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjI5OQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r389206299", "bodyText": "Let's clearly note that this private method is only to be used for constructors that do not take a Builder in as a parameter because of the fallback behavior.", "author": "narendly", "createdAt": "2020-03-07T00:38:38Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(", "originalCommit": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 7a4659970..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1328,28 +1348,19 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n       return this;\n     }\n \n-    public ZkBaseDataAccessor<?> build() throws Exception {\n+    public ZkBaseDataAccessor<?> build() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n \n-    /**\n-     * Validate the given parameters before creating an instance of ConfigAccessor.\n+    /*\n+     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n      */\n     private void validate() {\n       // Resolve RealmMode based on other parameters\n       boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n       boolean isZkClientTypeSet = zkClientType != null;\n \n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\n-            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n       // If ZkClientType is set, RealmMode must either be single-realm or not set.\n       if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n         throw new HelixException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNjQzMw==", "url": "https://github.com/apache/helix/pull/855#discussion_r389206433", "bodyText": "Great use of logging, but let's also note here that this is for backward-compatibility for constructors that take in zkaddress or zkclient.", "author": "narendly", "createdAt": "2020-03-07T00:39:23Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1289,122 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.\n+     */\n+    private void validate() {\n+      // Resolve RealmMode based on other parameters\n+      boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n+      boolean isZkClientTypeSet = zkClientType != null;\n+\n+      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n+        throw new HelixException(\n+            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n+      }\n+      if (realmMode == null) {\n+        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n+            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n+      }\n+\n+      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n+      if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n+        throw new HelixException(\n+            \"ZkClientType cannot be set on multi-realm mode!\");\n+      }\n+      // If ZkClientType is not set, default to SHARED\n+      if (!isZkClientTypeSet) {\n+        zkClientType = ZkBaseDataAccessor.ZkClientType.SHARED;\n+      }\n+\n+      // Resolve RealmAwareZkClientConfig\n+      boolean isZkClientConfigSet = realmAwareZkClientConfig != null;\n+      // Resolve which clientConfig to use\n+      realmAwareZkClientConfig =\n+          isZkClientConfigSet ? realmAwareZkClientConfig.createHelixZkClientConfig()\n+              : new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer());\n+\n+      // Resolve RealmAwareZkConnectionConfig\n+      if (realmAwareZkConnectionConfig == null) {\n+        // If not set, create a default one\n+        realmAwareZkConnectionConfig =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build();\n+      }\n+    }\n+  }\n+\n+  private RealmAwareZkClient buildRealmAwareZkClient(\n+      RealmAwareZkClient.RealmAwareZkClientConfig clientConfig, String zkAddress,\n+      ZkClientType zkClientType) {\n+    try {\n+      return new FederatedZkClient(\n+          new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(), clientConfig);\n+    } catch (IllegalStateException | IOException | InvalidRoutingDataException e) {\n+      // Fall back to connect on single-realm mode if failed to connect on multi-realm mode and\n+      // ZK address is not empty.\n+      LOG.info(\"Not able to connect on multi-realm mode, caused by: {}. \"\n+          + \"Connecting on single-realm mode to ZK: {}.\", e.getMessage(), zkAddress);", "originalCommit": "fb3d59e6586a0d48edf93dd054bdbd65d6fc2ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 7a4659970..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1328,28 +1348,19 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n       return this;\n     }\n \n-    public ZkBaseDataAccessor<?> build() throws Exception {\n+    public ZkBaseDataAccessor<?> build() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n \n-    /**\n-     * Validate the given parameters before creating an instance of ConfigAccessor.\n+    /*\n+     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n      */\n     private void validate() {\n       // Resolve RealmMode based on other parameters\n       boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n       boolean isZkClientTypeSet = zkClientType != null;\n \n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\n-            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n       // If ZkClientType is set, RealmMode must either be single-realm or not set.\n       if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n         throw new HelixException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNjYwMQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r389826601", "bodyText": "Change comment.", "author": "huizhilu", "createdAt": "2020-03-09T16:58:51Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -1248,4 +1280,127 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String zkAddress;\n+    private RealmAwareZkClient.RealmMode realmMode;\n+    private ZkBaseDataAccessor.ZkClientType zkClientType;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig;\n+\n+    public Builder() {\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkAddress(String zkAddress) {\n+      this.zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      this.realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setZkClientType(\n+        ZkBaseDataAccessor.ZkClientType zkClientType) {\n+      this.zkClientType = zkClientType;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      this.realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor.Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      this.realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public ZkBaseDataAccessor<?> build() throws Exception {\n+      validate();\n+      return new ZkBaseDataAccessor<>(this);\n+    }\n+\n+    /**\n+     * Validate the given parameters before creating an instance of ConfigAccessor.", "originalCommit": "f756761cf722e33fb0ca8862ed71ee394a9ee65d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex f33bb478e..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -1319,28 +1348,19 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n       return this;\n     }\n \n-    public ZkBaseDataAccessor<?> build() throws Exception {\n+    public ZkBaseDataAccessor<?> build() {\n       validate();\n       return new ZkBaseDataAccessor<>(this);\n     }\n \n-    /**\n-     * Validate the given parameters before creating an instance of ConfigAccessor.\n+    /*\n+     * Validates the given parameters before building an instance of ZkBaseDataAccessor.\n      */\n     private void validate() {\n       // Resolve RealmMode based on other parameters\n       boolean isZkAddressSet = zkAddress != null && !zkAddress.isEmpty();\n       boolean isZkClientTypeSet = zkClientType != null;\n \n-      if (realmMode == RealmAwareZkClient.RealmMode.SINGLE_REALM && !isZkAddressSet) {\n-        throw new HelixException(\n-            \"RealmMode cannot be single-realm without a valid ZkAddress set!\");\n-      }\n-      if (realmMode == null) {\n-        realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n-            : RealmAwareZkClient.RealmMode.MULTI_REALM;\n-      }\n-\n       // If ZkClientType is set, RealmMode must either be single-realm or not set.\n       if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n         throw new HelixException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzg4OA==", "url": "https://github.com/apache/helix/pull/855#discussion_r389827888", "bodyText": "I think we should make the behavior description in the Java doc.", "author": "junkaixue", "createdAt": "2020-03-09T17:00:58Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -199,20 +238,13 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  public ZkBaseDataAccessor(String zkAddress,", "originalCommit": "f756761cf722e33fb0ca8862ed71ee394a9ee65d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMjY2NQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r390732665", "bodyText": "As discussed offline, we don't want the fallback behavior and also make these old constructors deprecated.", "author": "huizhilu", "createdAt": "2020-03-11T03:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex f33bb478e..9eeb21b8f 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -237,7 +263,10 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n+   *\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n+  @Deprecated\n   public ZkBaseDataAccessor(String zkAddress,\n       org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,\n       ZkClientType zkClientType) {\n"}}, {"oid": "e427ad2b2d1f2c05d30779e9e286ed70876327fe", "url": "https://github.com/apache/helix/commit/e427ad2b2d1f2c05d30779e9e286ed70876327fe", "message": "Remove fallback behavior", "committedDate": "2020-03-11T03:50:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NDk4MQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r390794981", "bodyText": "Nit: This is already inside ZkBaseDataAccessor, so no need to qualify ZkClientTypes using ZkBaseDataAccessor. Did you copy the code from the other PRs? IDE automatically puts these things.", "author": "narendly", "createdAt": "2020-03-11T07:56:16Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkBaseDataAccessor.ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkBaseDataAccessor.ZkClientType.SHARED) {", "originalCommit": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7a24555f823ffad482f4ef1d391493d5fdaad26", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 58fa766a7..23b9f99f7 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -119,15 +114,15 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n   private final RealmAwareZkClient _zkClient;\n+\n   // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n   /**\n-   * @deprecated it is recommended to use the builder constructor {@link Builder}\n-   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n-   * outside of ZkBaseDataAccessor.\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n    *\n    * @param zkClient A created RealmAwareZkClient\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA==", "url": "https://github.com/apache/helix/pull/855#discussion_r390795448", "bodyText": "why do we need the long package name for this serializer?", "author": "narendly", "createdAt": "2020-03-11T07:57:23Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -198,21 +271,17 @@ public ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer,\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n+   *\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n-  public ZkBaseDataAccessor(String zkAddress, PathBasedZkSerializer pathBasedZkSerializer,\n+  @Deprecated\n+  public ZkBaseDataAccessor(String zkAddress,\n+      org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,", "originalCommit": "faf74392d9f83a619d1aeeb85abf6709cfab6fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0NTU5NQ==", "url": "https://github.com/apache/helix/pull/855#discussion_r391045595", "bodyText": "It is to reduce duplicate code for 2 constructors that have serializer parameters. BasicZkSerializer implements the long path PathBasedZkSerializer interface in zookeeper module. So we need this long path zookeeper PathBasedZkSerializer.\npublic ZkBaseDataAccessor(String zkAddress, ZkSerializer zkSerializer, ZkClientType zkClientType) {\n  this(zkAddress, new BasicZkSerializer(zkSerializer), zkClientType);\n}\n\nCons: new BasicZkSerializer(zkSerializer) just follows the behavior in ZkClientConfig. If it is changed in ZkClientConfig to use another instance other than BasicZkSerializer, the one here would not follow that change.\nWell, if we don't want to reduce the duplicate code, we can just keep the original code.", "author": "huizhilu", "createdAt": "2020-03-11T15:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NzQyNw==", "url": "https://github.com/apache/helix/pull/855#discussion_r391347427", "bodyText": "I'd prefer to leave it as is and tackle this later. This sort of refactoring doesn't have to be in the scope of this PR. Having 2 constructors is fine for now.", "author": "narendly", "createdAt": "2020-03-12T00:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NTQ0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f7a24555f823ffad482f4ef1d391493d5fdaad26", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 58fa766a7..23b9f99f7 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -271,10 +204,7 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n    * @param zkAddress\n    * @param pathBasedZkSerializer\n    * @param zkClientType\n-   *\n-   * @deprecated it is recommended to use the builder constructor {@link Builder}\n    */\n-  @Deprecated\n   public ZkBaseDataAccessor(String zkAddress,\n       org.apache.helix.zookeeper.zkclient.serialize.PathBasedZkSerializer pathBasedZkSerializer,\n       ZkClientType zkClientType) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg==", "url": "https://github.com/apache/helix/pull/855#discussion_r391315716", "bodyText": "So we do agree to support shared zkclient while in multi realm mode?", "author": "junkaixue", "createdAt": "2020-03-11T22:54:24Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java", "diffHunk": "@@ -102,28 +118,85 @@ public AccessResult() {\n \n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n-  private final HelixZkClient _zkClient;\n-  // true if ZkBaseDataAccessor was instantiated with a HelixZkClient, false otherwise\n+  private final RealmAwareZkClient _zkClient;\n+  // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n+  /**\n+   * @deprecated it is recommended to use the builder constructor {@link Builder}\n+   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n+   * outside of ZkBaseDataAccessor.\n+   *\n+   * @param zkClient A created RealmAwareZkClient\n+   */\n   @Deprecated\n-  public ZkBaseDataAccessor(HelixZkClient zkClient) {\n+  public ZkBaseDataAccessor(RealmAwareZkClient zkClient) {\n     if (zkClient == null) {\n       throw new NullPointerException(\"zkclient is null\");\n     }\n     _zkClient = zkClient;\n     _usesExternalZkClient = true;\n   }\n \n+  private ZkBaseDataAccessor(Builder builder) {\n+    switch (builder.realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          if (builder.zkClientType == ZkClientType.DEDICATED) {\n+            // Use a realm-aware dedicated zk client\n+            _zkClient = DedicatedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else if (builder.zkClientType == ZkClientType.SHARED) {\n+            // Use a realm-aware shared zk client\n+            _zkClient = SharedZkClientFactory.getInstance()\n+                .buildZkClient(builder.realmAwareZkConnectionConfig,\n+                    builder.realmAwareZkClientConfig);\n+          } else {", "originalCommit": "5b83c779d6638e56676d253c502a494044ee951c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNDcxMg==", "url": "https://github.com/apache/helix/pull/855#discussion_r391324712", "bodyText": "This is a realm aware shared Zk client. If the user wants to use it this way, then they can", "author": "narendly", "createdAt": "2020-03-11T23:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyNzM5Nw==", "url": "https://github.com/apache/helix/pull/855#discussion_r391327397", "bodyText": "@dasahcc This is a realm-aware shared ZkClient. Users could construct the client with the sharding key on multi-realm mode.", "author": "huizhilu", "createdAt": "2020-03-11T23:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "f7a24555f823ffad482f4ef1d391493d5fdaad26", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\nindex 05bf401de..23b9f99f7 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkBaseDataAccessor.java\n\n@@ -119,15 +114,15 @@ public class ZkBaseDataAccessor<T> implements BaseDataAccessor<T> {\n   private static Logger LOG = LoggerFactory.getLogger(ZkBaseDataAccessor.class);\n \n   private final RealmAwareZkClient _zkClient;\n+\n   // true if ZkBaseDataAccessor was instantiated with a RealmAwareZkClient, false otherwise\n   // This is used for close() to determine how ZkBaseDataAccessor should close the underlying\n   // ZkClient\n   private final boolean _usesExternalZkClient;\n \n   /**\n-   * @deprecated it is recommended to use the builder constructor {@link Builder}\n-   * instead to avoid having to manually create and maintain a RealmAwareZkClient\n-   * outside of ZkBaseDataAccessor.\n+   * @deprecated it is recommended to use the other constructors instead to avoid having to manually\n+   * create and maintain a RealmAwareZkClient outside of ZkBaseDataAccessor.\n    *\n    * @param zkClient A created RealmAwareZkClient\n    */\n"}}, {"oid": "f7a24555f823ffad482f4ef1d391493d5fdaad26", "url": "https://github.com/apache/helix/commit/f7a24555f823ffad482f4ef1d391493d5fdaad26", "message": "Make ZkBaseDataAccessor realm-aware", "committedDate": "2020-03-12T03:34:06Z", "type": "commit"}, {"oid": "ac9bf5b5116f82c566245fbbaaa3d9ff26036290", "url": "https://github.com/apache/helix/commit/ac9bf5b5116f82c566245fbbaaa3d9ff26036290", "message": "Adjust structure.", "committedDate": "2020-03-12T03:34:06Z", "type": "commit"}, {"oid": "5be8a96db684892571686142089ba448519a02b7", "url": "https://github.com/apache/helix/commit/5be8a96db684892571686142089ba448519a02b7", "message": "Add zkClientType", "committedDate": "2020-03-12T03:34:06Z", "type": "commit"}, {"oid": "42c140bcab58f18ca277c70a3240ac0cb169254b", "url": "https://github.com/apache/helix/commit/42c140bcab58f18ca277c70a3240ac0cb169254b", "message": "Address comments.", "committedDate": "2020-03-12T03:34:06Z", "type": "commit"}, {"oid": "6b87147277ca78b8c2cace6dd6491c8ffe0b5271", "url": "https://github.com/apache/helix/commit/6b87147277ca78b8c2cace6dd6491c8ffe0b5271", "message": "Remove fallback behavior", "committedDate": "2020-03-12T03:35:16Z", "type": "commit"}, {"oid": "f264649233783eca3f2f822f29b82d0a7377d935", "url": "https://github.com/apache/helix/commit/f264649233783eca3f2f822f29b82d0a7377d935", "message": "Create according zkclient type on multi-realm mode", "committedDate": "2020-03-12T03:35:16Z", "type": "commit"}, {"oid": "bd09e05235d805d1d4b8ef64a7a8bb9b39c7dfdc", "url": "https://github.com/apache/helix/commit/bd09e05235d805d1d4b8ef64a7a8bb9b39c7dfdc", "message": "waitUntilConnected for shared zkclient.", "committedDate": "2020-03-12T03:35:16Z", "type": "commit"}, {"oid": "19d5fa6ee98ad2dd4ffda04f01624076c0afdb7a", "url": "https://github.com/apache/helix/commit/19d5fa6ee98ad2dd4ffda04f01624076c0afdb7a", "message": "Remove redundants", "committedDate": "2020-03-12T03:35:16Z", "type": "commit"}, {"oid": "66b321f844e91c66e2a51043894449769e62ac6a", "url": "https://github.com/apache/helix/commit/66b321f844e91c66e2a51043894449769e62ac6a", "message": "Add TODO to refactor builder", "committedDate": "2020-03-12T03:35:16Z", "type": "commit"}, {"oid": "4f3db40d0a6523eecfe2a832459683be15487d79", "url": "https://github.com/apache/helix/commit/4f3db40d0a6523eecfe2a832459683be15487d79", "message": "Add javadoc", "committedDate": "2020-03-12T03:51:48Z", "type": "forcePushed"}, {"oid": "c063c491cfa6e466af7fdd5fc4d96f5f64c35c30", "url": "https://github.com/apache/helix/commit/c063c491cfa6e466af7fdd5fc4d96f5f64c35c30", "message": "Add javadoc", "committedDate": "2020-03-12T03:53:59Z", "type": "commit"}, {"oid": "c063c491cfa6e466af7fdd5fc4d96f5f64c35c30", "url": "https://github.com/apache/helix/commit/c063c491cfa6e466af7fdd5fc4d96f5f64c35c30", "message": "Add javadoc", "committedDate": "2020-03-12T03:53:59Z", "type": "forcePushed"}]}