{"pr_number": 933, "pr_title": "Fix MetadataStoreDirectory routing data cache refresh bug", "pr_createdAt": "2020-04-07T16:29:22Z", "pr_url": "https://github.com/apache/helix/pull/933", "timeline": [{"oid": "0ca253838bf86f27fa3cfa608db56daedfbb2726", "url": "https://github.com/apache/helix/commit/0ca253838bf86f27fa3cfa608db56daedfbb2726", "message": "Fix routing data cache refresh in MSD; fix TrieRoutingData creation edge case", "committedDate": "2020-04-03T20:44:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk1MTAyOA==", "url": "https://github.com/apache/helix/pull/933#discussion_r404951028", "bodyText": "NOTE: This check is added for the case when \"METADATA_STORE_ROUTING_DATA\" is deleted.\nThere is one edge case that's not handled: when \"METADATA_STORE_ROUTING_DATA\" contains no node, and then \"METADATA_STORE_ROUTING_DATA\" gets deleted.\nIn that case, before deletion, the routing data should be empty; after deletion, the routing data should return 404 due to missing namespace. However, since there is no listener on \"METADATA_STORE_ROUTING_DATA\" itself, its deletion event cannot be handled. Please share you thoughts on whether this edge case should be handled, or if you think this falls into misuse.", "author": "NealSun96", "createdAt": "2020-04-07T16:35:24Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -322,14 +322,19 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     Map<String, List<String>> rawRoutingData;\n+    // Remove the raw data first in case of failure on creation\n+    _realmToShardingKeysMap.remove(namespace);", "originalCommit": "0ca253838bf86f27fa3cfa608db56daedfbb2726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk1ODkwMQ==", "url": "https://github.com/apache/helix/pull/933#discussion_r404958901", "bodyText": "I don't think you need to worry about the case you're describing. MSD makes the assumption that the root path already exists.", "author": "narendly", "createdAt": "2020-04-07T16:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk1MTAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "6b719c25a8cfe8abdb308ea744a32900464a9acc", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\nindex 0139fa4fd..a8696186d 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n\n@@ -321,20 +321,20 @@ public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, Routing\n       return;\n     }\n \n-    Map<String, List<String>> rawRoutingData;\n     // Remove the raw data first in case of failure on creation\n     _realmToShardingKeysMap.remove(namespace);\n+    // Remove routing data first in case of failure on creation\n+    _routingDataMap.remove(namespace);\n+\n+    Map<String, List<String>> rawRoutingData;\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n       _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n-      _routingDataMap.remove(namespace);\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n       return;\n     }\n \n-    // Remove routing data first in case of failure on creation\n-    _routingDataMap.remove(namespace);\n     try {\n       _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n     } catch (InvalidRoutingDataException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2MTA5Mw==", "url": "https://github.com/apache/helix/pull/933#discussion_r404961093", "bodyText": "Why don't you just put _routingDataMap.remove(namespace); up there next to _realmToShardingKeysMap.remove(namespace);?\nWhy is there a need for this duplicate code? routingDataMap entry should be cleared anyway prior to update, right?", "author": "narendly", "createdAt": "2020-04-07T16:50:27Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -322,14 +322,19 @@ public void refreshRoutingData(String namespace) {\n     }\n \n     Map<String, List<String>> rawRoutingData;\n+    // Remove the raw data first in case of failure on creation\n+    _realmToShardingKeysMap.remove(namespace);\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n       _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n+      _routingDataMap.remove(namespace);\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n       return;\n     }\n \n+    // Remove routing data first in case of failure on creation\n+    _routingDataMap.remove(namespace);", "originalCommit": "0ca253838bf86f27fa3cfa608db56daedfbb2726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyMzg2MQ==", "url": "https://github.com/apache/helix/pull/933#discussion_r405023861", "bodyText": "Makes sense, let me change that.", "author": "NealSun96", "createdAt": "2020-04-07T18:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2MTA5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6b719c25a8cfe8abdb308ea744a32900464a9acc", "chunk": "diff --git a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\nindex 0139fa4fd..a8696186d 100644\n--- a/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n+++ b/helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java\n\n@@ -321,20 +321,20 @@ public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, Routing\n       return;\n     }\n \n-    Map<String, List<String>> rawRoutingData;\n     // Remove the raw data first in case of failure on creation\n     _realmToShardingKeysMap.remove(namespace);\n+    // Remove routing data first in case of failure on creation\n+    _routingDataMap.remove(namespace);\n+\n+    Map<String, List<String>> rawRoutingData;\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n       _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n-      _routingDataMap.remove(namespace);\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n       return;\n     }\n \n-    // Remove routing data first in case of failure on creation\n-    _routingDataMap.remove(namespace);\n     try {\n       _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n     } catch (InvalidRoutingDataException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ==", "url": "https://github.com/apache/helix/pull/933#discussion_r404962895", "bodyText": "Explain why this should be invalid? I thought we agreed that it's acceptable to have a realm without any keys.", "author": "narendly", "createdAt": "2020-04-07T16:53:04Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/datamodel/TrieRoutingData.java", "diffHunk": "@@ -48,6 +48,10 @@ public TrieRoutingData(Map<String, List<String>> routingData)\n       throw new InvalidRoutingDataException(\"routingData cannot be null or empty\");\n     }\n \n+    if (!containsShardingKey(routingData)) {\n+      throw new InvalidRoutingDataException(\"routingData needs at least 1 sharding key\");\n+    }", "originalCommit": "0ca253838bf86f27fa3cfa608db56daedfbb2726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzMTk2Mw==", "url": "https://github.com/apache/helix/pull/933#discussion_r405031963", "bodyText": "We agreed that it's okay for some realms to not have keys (which is handled correctly by skipping them), but not when all realms have no keys. The design of TrieRoutingData is \"a set of data with routing capability\", therefore empty routing data shouldn't be created; a group of realms with 0 key doesn't have routing capability either. When the TrieRoutingData doesn't have routing capability, we don't create it.\nIn the situation with 0 sharding keys but some realms, the current TrieRoutingData will create a structure in an erroneous state. For example, isShardingKeyInsertionValid(\"/\") called on a TrieRoutingData with 0 sharding key will return false, even though it should be true.", "author": "NealSun96", "createdAt": "2020-04-07T18:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NDE2MA==", "url": "https://github.com/apache/helix/pull/933#discussion_r405064160", "bodyText": "So it's okay to have a bunch of realms with no keys as long as we have some realm with a key?", "author": "narendly", "createdAt": "2020-04-07T19:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3OTg2Nw==", "url": "https://github.com/apache/helix/pull/933#discussion_r405079867", "bodyText": "Yes. The focus should be on \"is there a sharding key\". Without any sharding key the routing data is definitely invalid; with at least one it is valid (as long as no key conflict, etc.).", "author": "NealSun96", "createdAt": "2020-04-07T20:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4OTg0MA==", "url": "https://github.com/apache/helix/pull/933#discussion_r405089840", "bodyText": "Okay. Is this clear in our documentation, both in code and user manual? We need to document this behavior so it's crystal clear to anyone that looks at this code.", "author": "narendly", "createdAt": "2020-04-07T20:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDUxMw==", "url": "https://github.com/apache/helix/pull/933#discussion_r405090513", "bodyText": "Also what would happen if a user initially creates N realms with keys, and ends up deleting all keys for the N realms? What happens when the user tries to delete the last remaining key?", "author": "narendly", "createdAt": "2020-04-07T20:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5ODc1Nw==", "url": "https://github.com/apache/helix/pull/933#discussion_r405098757", "bodyText": "In my user manual I have briefly talked about invalid routing data. I will expand some sections for that.\nIn terms of your second question, the refresh logic will trigger and TrieRoutingData will be removed from MSD when the last key is deleted, similar to how when the user deletes all routing data, TrieRoutingData is removed. Note that the raw routing data is not removed because the realms are still there. Also a reminder, when we don't have TrieRoutingData, the accessor behaves correctly.", "author": "NealSun96", "createdAt": "2020-04-07T20:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2Mjg5NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "6b719c25a8cfe8abdb308ea744a32900464a9acc", "url": "https://github.com/apache/helix/commit/6b719c25a8cfe8abdb308ea744a32900464a9acc", "message": "Cut out duplicate line", "committedDate": "2020-04-07T18:53:14Z", "type": "commit"}]}