{"pr_number": 863, "pr_title": "Make ZkCacheBaseDataAccessor and ZkHelixPropertyStore realm-aware", "pr_createdAt": "2020-03-05T04:41:26Z", "pr_url": "https://github.com/apache/helix/pull/863", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NDA3Mw==", "url": "https://github.com/apache/helix/pull/863#discussion_r388564073", "bodyText": "static constant for \"/\" to reduce objects created?", "author": "huizhilu", "createdAt": "2020-03-05T21:03:13Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -58,7 +61,15 @@\n   protected ZkCallbackCache<T> _zkCache;\n \n   final ZkBaseDataAccessor<T> _baseAccessor;\n-  final Map<String, Cache<T>> _cacheMap;\n+\n+  // TODO: need to make sure no overlap between wtCachePaths and zkCachePaths\n+  // TreeMap key is ordered by key string length, so more general (i.e. short) prefix\n+  // comes first\n+  final Map<String, Cache<T>> _cacheMap = new TreeMap<>((o1, o2) -> {\n+    int len1 = o1.split(\"/\").length;\n+    int len2 = o2.split(\"/\").length;", "originalCommit": "45a817bb55579042bf24a89e8df0ab0598d75b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyOTQ5Mw==", "url": "https://github.com/apache/helix/pull/863#discussion_r389029493", "bodyText": "Realized this is original code. We could resolve this thread.", "author": "huizhilu", "createdAt": "2020-03-06T17:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NDA3Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0NDgwMw==", "url": "https://github.com/apache/helix/pull/863#discussion_r388744803", "bodyText": "Do we need to validate zk address before falling back to single realm mode?", "author": "huizhilu", "createdAt": "2020-03-06T07:16:36Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -146,17 +161,55 @@ public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String\n     _wtCachePaths = wtCachePaths;\n     _zkCachePaths = zkCachePaths;\n \n-    // TODO: need to make sure no overlap between wtCachePaths and zkCachePaths\n-    // TreeMap key is ordered by key string length, so more general (i.e. short) prefix\n-    // comes first\n-    _cacheMap = new TreeMap<>(new Comparator<String>() {\n-      @Override\n-      public int compare(String o1, String o2) {\n-        int len1 = o1.split(\"/\").length;\n-        int len2 = o2.split(\"/\").length;\n-        return len1 - len2;\n-      }\n-    });\n+    start();\n+  }\n+\n+  /**\n+   * Constructor using a Builder that allows users to set connection and client configs.\n+   * @param builder\n+   */\n+  private ZkCacheBaseDataAccessor(Builder builder) {\n+    _chrootPath = builder._chrootPath;\n+    _wtCachePaths = builder._wtCachePaths;\n+    _zkCachePaths = builder._zkCachePaths;\n+\n+    RealmAwareZkClient zkClient;\n+    switch (builder._realmMode) {\n+      case MULTI_REALM:\n+        try {\n+          zkClient = new FederatedZkClient(builder._realmAwareZkConnectionConfig,\n+              builder._realmAwareZkClientConfig);\n+          break; // Must break out of the switch statement here\n+        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {", "originalCommit": "45a817bb55579042bf24a89e8df0ab0598d75b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzkyNg==", "url": "https://github.com/apache/helix/pull/863#discussion_r389847926", "bodyText": "It's already done in the builder's validate()?", "author": "narendly", "createdAt": "2020-03-09T17:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0NDgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "548fe21e946af8bc846b57549049d81b12250da1", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\nindex 2afcf8c66..5809274cb 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n\n@@ -183,8 +183,7 @@ public class ZkCacheBaseDataAccessor<T> implements HelixPropertyStore<T> {\n         } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n           // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n           // found\n-          // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n-          // This is to preserve backward-compatibility\n+          throw new HelixException(\"Failed to create ZkCacheBaseDataAccessor!\", e);\n         }\n       case SINGLE_REALM:\n         switch (builder._zkClientType) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ2OTQ1MQ==", "url": "https://github.com/apache/helix/pull/863#discussion_r389469451", "bodyText": "This Builder code is very similar across all Helix APIs, I do recommend us to find some way to consolidate them.\nFor existing use case (who do not care about realm, or who is not  going to shard to multiple ZK), do they need to change anything in their code?", "author": "lei-xia", "createdAt": "2020-03-09T05:31:38Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -842,4 +894,116 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {", "originalCommit": "29f17cca0aaf24bdd6be374bbd8b57032ee8693a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MTMwMw==", "url": "https://github.com/apache/helix/pull/863#discussion_r389791303", "bodyText": "@lei-xia\n\n\nSee #873 . We will do this once all Helix Java APIs have been implemented since this is a purely internal implementation detail. User-facing APIs stay the same.\n\n\nNo, please see existing constructors for the fallback logic.", "author": "narendly", "createdAt": "2020-03-09T16:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ2OTQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ebe28e3af9ec60cc285b550a2789d9b69c5d88b1", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\nindex 5809274cb..2afcf8c66 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n\n@@ -983,11 +984,6 @@ public class ZkCacheBaseDataAccessor<T> implements HelixPropertyStore<T> {\n             \"ZkCacheBaseDataAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n       }\n \n-      if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n-        throw new HelixException(\n-            \"ZkCacheBaseDataAccessor: You cannot set the ZkAddress on multi-realm mode!\");\n-      }\n-\n       if (_realmMode == null) {\n         _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n             : RealmAwareZkClient.RealmMode.MULTI_REALM;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyMzQyMg==", "url": "https://github.com/apache/helix/pull/863#discussion_r389823422", "bodyText": "This is not very clear. Do you mean whatever type I set here, it will change the API to single-realm mode?  Then if call builder. setRealmMode(multi-realm).setZkClientType(type), what will happen?", "author": "lei-xia", "createdAt": "2020-03-09T16:54:01Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -842,4 +894,116 @@ public void close() {\n       _zkClient.close();\n     }\n   }\n+\n+  public static class Builder {\n+    private String _zkAddress;\n+    private RealmAwareZkClient.RealmMode _realmMode;\n+    private RealmAwareZkClient.RealmAwareZkConnectionConfig _realmAwareZkConnectionConfig;\n+    private RealmAwareZkClient.RealmAwareZkClientConfig _realmAwareZkClientConfig;\n+\n+    /** ZkCacheBaseDataAccessor-specific parameters */\n+    private String _chrootPath;\n+    private List<String> _wtCachePaths;\n+    private List<String> _zkCachePaths;\n+    private ZkBaseDataAccessor.ZkClientType _zkClientType;\n+\n+    public Builder() {\n+    }\n+\n+    public Builder setZkAddress(String zkAddress) {\n+      _zkAddress = zkAddress;\n+      return this;\n+    }\n+\n+    public Builder setRealmMode(RealmAwareZkClient.RealmMode realmMode) {\n+      _realmMode = realmMode;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkConnectionConfig(\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig realmAwareZkConnectionConfig) {\n+      _realmAwareZkConnectionConfig = realmAwareZkConnectionConfig;\n+      return this;\n+    }\n+\n+    public Builder setRealmAwareZkClientConfig(\n+        RealmAwareZkClient.RealmAwareZkClientConfig realmAwareZkClientConfig) {\n+      _realmAwareZkClientConfig = realmAwareZkClientConfig;\n+      return this;\n+    }\n+\n+    public Builder setChrootPath(String chrootPath) {\n+      _chrootPath = chrootPath;\n+      return this;\n+    }\n+\n+    public Builder setWtCachePaths(List<String> wtCachePaths) {\n+      _wtCachePaths = wtCachePaths;\n+      return this;\n+    }\n+\n+    public Builder setZkCachePaths(List<String> zkCachePaths) {\n+      _zkCachePaths = zkCachePaths;\n+      return this;\n+    }\n+\n+    /**\n+     * Sets the ZkClientType. If this is set, ZkCacheBaseDataAccessor will be created on\n+     * single-realm mode.\n+     * @param zkClientType\n+     * @return\n+     */", "originalCommit": "29f17cca0aaf24bdd6be374bbd8b57032ee8693a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0OTE2MA==", "url": "https://github.com/apache/helix/pull/863#discussion_r389849160", "bodyText": "That will throw an exception as ZkClientType only applies to the old Dedicated and Shared zkclients.\nDo you see the following block of code in the validate() logic? How could I make this clearer?\n      // If ZkClientType is set, RealmMode must either be single-realm or not set.\n      if (isZkClientTypeSet && _realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n        throw new HelixException(\n            \"ZkCacheBaseDataAccessor: you cannot set ZkClientType on multi-realm mode!\");", "author": "narendly", "createdAt": "2020-03-09T17:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyMzQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "ebe28e3af9ec60cc285b550a2789d9b69c5d88b1", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\nindex 5809274cb..2afcf8c66 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n\n@@ -983,11 +984,6 @@ public class ZkCacheBaseDataAccessor<T> implements HelixPropertyStore<T> {\n             \"ZkCacheBaseDataAccessor: RealmMode cannot be single-realm without a valid ZkAddress set!\");\n       }\n \n-      if (_realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM && isZkAddressSet) {\n-        throw new HelixException(\n-            \"ZkCacheBaseDataAccessor: You cannot set the ZkAddress on multi-realm mode!\");\n-      }\n-\n       if (_realmMode == null) {\n         _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM\n             : RealmAwareZkClient.RealmMode.MULTI_REALM;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNzUzNA==", "url": "https://github.com/apache/helix/pull/863#discussion_r390727534", "bodyText": "Note: current FederatedZkClient doesn't support waitUntilConnected() because of multiple raw zkClients. We shall move waitUntilConnected to only single-realm mode.", "author": "huizhilu", "createdAt": "2020-03-11T03:27:42Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java", "diffHunk": "@@ -90,50 +104,62 @@ public ZkCacheBaseDataAccessor(ZkBaseDataAccessor<T> baseAccessor, String chroot\n     _wtCachePaths = wtCachePaths;\n     _zkCachePaths = zkCachePaths;\n \n-    // TODO: need to make sure no overlap between wtCachePaths and zkCachePaths\n-    // TreeMap key is ordered by key string length, so more general (i.e. short) prefix\n-    // comes first\n-    _cacheMap = new TreeMap<>(new Comparator<String>() {\n-      @Override\n-      public int compare(String o1, String o2) {\n-        int len1 = o1.split(\"/\").length;\n-        int len2 = o2.split(\"/\").length;\n-        return len1 - len2;\n-      }\n-    });\n-\n     start();\n   }\n \n+  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths) {\n     this(zkAddress, serializer, chrootPath, wtCachePaths, zkCachePaths, null, null,\n         ZkBaseDataAccessor.ZkClientType.SHARED);\n   }\n \n+  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey) {\n     this(zkAddress, serializer, chrootPath, wtCachePaths, zkCachePaths, monitorType, monitorkey,\n         ZkBaseDataAccessor.ZkClientType.SHARED);\n   }\n \n+  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey,\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n-    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-    clientConfig.setZkSerializer(serializer).setMonitorType(monitorType).setMonitorKey(monitorkey);\n-    switch (zkClientType) {\n-    case DEDICATED:\n-      _zkClient = DedicatedZkClientFactory.getInstance().buildZkClient(\n-          new HelixZkClient.ZkConnectionConfig(zkAddress),\n-          new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n-      break;\n-    case SHARED:\n-    default:\n-      _zkClient = SharedZkClientFactory.getInstance()\n-          .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-    }\n-    _zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n+\n+    // If the multi ZK config is enabled, use multi-realm mode with FederatedZkClient\n+    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n+      try {\n+        RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder connectionConfigBuilder =\n+            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder();\n+        RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n+            new RealmAwareZkClient.RealmAwareZkClientConfig();\n+        clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n+            .setMonitorKey(monitorkey);\n+        // Use a federated zk client\n+        _zkClient = new FederatedZkClient(connectionConfigBuilder.build(), clientConfig);\n+      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+        // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n+        // found\n+        throw new HelixException(\"Failed to create ZkCacheBaseDataAccessor!\", e);\n+      }\n+    } else {\n+      HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n+      clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n+          .setMonitorKey(monitorkey);\n+      switch (zkClientType) {\n+        case DEDICATED:\n+          _zkClient = DedicatedZkClientFactory.getInstance()\n+              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                  new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n+          break;\n+        case SHARED:\n+        default:\n+          _zkClient = SharedZkClientFactory.getInstance()\n+              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n+      }\n+      _zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);", "originalCommit": "6a1ef024b982d85cb39479b9ff698e8cdc323b65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM3MjY3Nw==", "url": "https://github.com/apache/helix/pull/863#discussion_r391372677", "bodyText": "@pkuwm Could you look again? This is in the else block where we do not create FederatedZkClient...", "author": "narendly", "createdAt": "2020-03-12T02:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNzUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ebe28e3af9ec60cc285b550a2789d9b69c5d88b1", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\nindex bd05ea735..2afcf8c66 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/ZkCacheBaseDataAccessor.java\n\n@@ -107,59 +104,51 @@ public class ZkCacheBaseDataAccessor<T> implements HelixPropertyStore<T> {\n     start();\n   }\n \n-  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths) {\n     this(zkAddress, serializer, chrootPath, wtCachePaths, zkCachePaths, null, null,\n         ZkBaseDataAccessor.ZkClientType.SHARED);\n   }\n \n-  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey) {\n     this(zkAddress, serializer, chrootPath, wtCachePaths, zkCachePaths, monitorType, monitorkey,\n         ZkBaseDataAccessor.ZkClientType.SHARED);\n   }\n \n-  @Deprecated\n   public ZkCacheBaseDataAccessor(String zkAddress, ZkSerializer serializer, String chrootPath,\n       List<String> wtCachePaths, List<String> zkCachePaths, String monitorType, String monitorkey,\n       ZkBaseDataAccessor.ZkClientType zkClientType) {\n-\n-    // If the multi ZK config is enabled, use multi-realm mode with FederatedZkClient\n-    if (Boolean.parseBoolean(System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED))) {\n-      try {\n-        RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder connectionConfigBuilder =\n-            new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder();\n-        RealmAwareZkClient.RealmAwareZkClientConfig clientConfig =\n-            new RealmAwareZkClient.RealmAwareZkClientConfig();\n-        clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-            .setMonitorKey(monitorkey);\n-        // Use a federated zk client\n-        _zkClient = new FederatedZkClient(connectionConfigBuilder.build(), clientConfig);\n-      } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n-        // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n-        // found\n-        throw new HelixException(\"Failed to create ZkCacheBaseDataAccessor!\", e);\n-      }\n-    } else {\n-      HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n-      clientConfig.setZkSerializer(serializer).setMonitorType(monitorType)\n-          .setMonitorKey(monitorkey);\n-      switch (zkClientType) {\n-        case DEDICATED:\n-          _zkClient = DedicatedZkClientFactory.getInstance()\n-              .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n-                  new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n-          break;\n-        case SHARED:\n-        default:\n-          _zkClient = SharedZkClientFactory.getInstance()\n+    HelixZkClient.ZkClientConfig clientConfig = new HelixZkClient.ZkClientConfig();\n+    clientConfig.setZkSerializer(serializer).setMonitorType(monitorType).setMonitorKey(monitorkey);\n+    switch (zkClientType) {\n+      case DEDICATED:\n+        // If DEDICATED, then we use a dedicated HelixZkClient because we must support ephemeral\n+        // operations\n+        _zkClient = DedicatedZkClientFactory.getInstance()\n+            .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress),\n+                new HelixZkClient.ZkClientConfig().setZkSerializer(serializer));\n+        break;\n+      case SHARED:\n+      default:\n+        // If SHARED, we first attempt to use FederatedZkClient (multi-realm)\n+        RealmAwareZkClient zkClient;\n+        try {\n+          zkClient = new FederatedZkClient(\n+              new RealmAwareZkClient.RealmAwareZkConnectionConfig.Builder().build(),\n+              new RealmAwareZkClient.RealmAwareZkClientConfig());\n+        } catch (InvalidRoutingDataException | IOException | IllegalStateException e) {\n+          // Note: IllegalStateException is for HttpRoutingDataReader if MSDS endpoint cannot be\n+          // found\n+          // Fall back to single-realm mode using SharedZkClient (HelixZkClient)\n+          // This is to preserve backward-compatibility\n+          zkClient = SharedZkClientFactory.getInstance()\n               .buildZkClient(new HelixZkClient.ZkConnectionConfig(zkAddress), clientConfig);\n-      }\n-      _zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n+          zkClient\n+              .waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n+        }\n+        _zkClient = zkClient;\n     }\n-\n     _baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n \n     if (chrootPath == null || chrootPath.equals(\"/\")) {\n"}}, {"oid": "ebe28e3af9ec60cc285b550a2789d9b69c5d88b1", "url": "https://github.com/apache/helix/commit/ebe28e3af9ec60cc285b550a2789d9b69c5d88b1", "message": "Make ZkCacheBaseDataAccessor realm-aware", "committedDate": "2020-03-12T02:37:29Z", "type": "commit"}, {"oid": "548fe21e946af8bc846b57549049d81b12250da1", "url": "https://github.com/apache/helix/commit/548fe21e946af8bc846b57549049d81b12250da1", "message": "sadf", "committedDate": "2020-03-12T02:37:29Z", "type": "commit"}, {"oid": "bc410662751e4ac977c1c04979026bfc5f2f7f5f", "url": "https://github.com/apache/helix/commit/bc410662751e4ac977c1c04979026bfc5f2f7f5f", "message": "update removing the fallback logic", "committedDate": "2020-03-12T02:37:30Z", "type": "commit"}, {"oid": "5d108156437753f1f24746a96d5427c999d59f13", "url": "https://github.com/apache/helix/commit/5d108156437753f1f24746a96d5427c999d59f13", "message": "update", "committedDate": "2020-03-12T02:37:30Z", "type": "commit"}, {"oid": "88c5ee26ab21b3012cd0dc334e8a4955e195da64", "url": "https://github.com/apache/helix/commit/88c5ee26ab21b3012cd0dc334e8a4955e195da64", "message": "Deprecate all constructors", "committedDate": "2020-03-12T02:37:30Z", "type": "commit"}, {"oid": "88c5ee26ab21b3012cd0dc334e8a4955e195da64", "url": "https://github.com/apache/helix/commit/88c5ee26ab21b3012cd0dc334e8a4955e195da64", "message": "Deprecate all constructors", "committedDate": "2020-03-12T02:37:30Z", "type": "forcePushed"}]}