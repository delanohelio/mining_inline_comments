{"pr_number": 1107, "pr_title": "Fix ZkBucketDataAccessor failure due to concurrent modification.", "pr_createdAt": "2020-06-20T01:33:42Z", "pr_url": "https://github.com/apache/helix/pull/1107", "timeline": [{"oid": "5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "url": "https://github.com/apache/helix/commit/5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "message": "Fix ZkBucketDataAccessor failure due to concurrent modification.\n\nThe concurrent modification causes two issues.\n1. Regular GC task fails due to concurrent list modification and the stale versions are not removed at all.\n2. If, by coincident, there is newer version in the list other then the current version, then because of the modification of the list inside the loop, the final element (the newer version) won't be filtered but being left in the to-be-removed list. Then the GC task removes the most recent version. For example,\n  a) Input, current version \"2\"\n  b) Children = [1, 2, 3]\n  c) The task avoids checking \"2\", so the list for loop is: [1, 3]\n  d) When check \"1\", it is removed from the list. So the list becomes [3]. Then the loop ends, because the first item has already been looped from the for iteration perspective.\n  e) The version to be removed is \"3\"!\n\nThis PR fix the issue by avoiding concurrent modification. Also it simplies the logic so as to reduce the pending GC tasks.\nThe test is also updated accordingly.", "committedDate": "2020-06-20T04:56:18Z", "type": "commit"}, {"oid": "5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "url": "https://github.com/apache/helix/commit/5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "message": "Fix ZkBucketDataAccessor failure due to concurrent modification.\n\nThe concurrent modification causes two issues.\n1. Regular GC task fails due to concurrent list modification and the stale versions are not removed at all.\n2. If, by coincident, there is newer version in the list other then the current version, then because of the modification of the list inside the loop, the final element (the newer version) won't be filtered but being left in the to-be-removed list. Then the GC task removes the most recent version. For example,\n  a) Input, current version \"2\"\n  b) Children = [1, 2, 3]\n  c) The task avoids checking \"2\", so the list for loop is: [1, 3]\n  d) When check \"1\", it is removed from the list. So the list becomes [3]. Then the loop ends, because the first item has already been looped from the for iteration perspective.\n  e) The version to be removed is \"3\"!\n\nThis PR fix the issue by avoiding concurrent modification. Also it simplies the logic so as to reduce the pending GC tasks.\nThe test is also updated accordingly.", "committedDate": "2020-06-20T04:56:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2NDMxNw==", "url": "https://github.com/apache/helix/pull/1107#discussion_r443164317", "bodyText": "ensure that the...?", "author": "narendly", "createdAt": "2020-06-20T22:24:21Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestZkBucketDataAccessor.java", "diffHunk": "@@ -126,8 +133,17 @@ public void testMultipleWrites() throws Exception {\n     // Use Verifier because GC can take ZK delay\n     Assert.assertTrue(TestHelper.verify(() -> {\n       List<String> children = _zkBaseDataAccessor.getChildNames(PATH, AccessOption.PERSISTENT);\n-      return children.size() == 3;\n-    }, 60 * 1000L));\n+      return children.size() == 3 && children.containsAll(ImmutableList\n+          .of(LAST_SUCCESSFUL_WRITE_KEY, LAST_WRITE_KEY,\n+              new Long(lastSuccessfulWriteVer).toString()));\n+    }, VERSION_TTL_MS * 2));\n+\n+    // Wait one more TTL to ensure that the", "originalCommit": "5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2NTE3Ng==", "url": "https://github.com/apache/helix/pull/1107#discussion_r443865176", "bodyText": "Good catch. I missed this part.", "author": "jiajunwang", "createdAt": "2020-06-22T22:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2NDMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "231764292d0671af21017e99613a09941bc638d2", "chunk": "diff --git a/helix-core/src/test/java/org/apache/helix/manager/zk/TestZkBucketDataAccessor.java b/helix-core/src/test/java/org/apache/helix/manager/zk/TestZkBucketDataAccessor.java\nindex 5d491088f..70bb949d8 100644\n--- a/helix-core/src/test/java/org/apache/helix/manager/zk/TestZkBucketDataAccessor.java\n+++ b/helix-core/src/test/java/org/apache/helix/manager/zk/TestZkBucketDataAccessor.java\n\n@@ -138,7 +138,7 @@ public class TestZkBucketDataAccessor extends ZkTestBase {\n               new Long(lastSuccessfulWriteVer).toString()));\n     }, VERSION_TTL_MS * 2));\n \n-    // Wait one more TTL to ensure that the\n+    // Wait one more TTL to ensure that the GC has been done.\n     Thread.sleep(VERSION_TTL_MS);\n     List<String> children = _zkBaseDataAccessor.getChildNames(PATH, AccessOption.PERSISTENT);\n     Assert.assertTrue(children.size() == 3 && children.containsAll(ImmutableList\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2NDYwOA==", "url": "https://github.com/apache/helix/pull/1107#discussion_r443164608", "bodyText": "Do we really need to cancel? What if that causes incomplete deletion of stale versions? I think we should let it queue up?", "author": "narendly", "createdAt": "2020-06-20T22:29:37Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZkBucketDataAccessor.java", "diffHunk": "@@ -329,32 +330,34 @@ public void close() {\n     disconnect();\n   }\n \n-  private void updateGCTimer(String rootPath, String currentVersion) {\n-    TimerTask gcTask = new TimerTask() {\n-      @Override\n-      public void run() {\n+  private synchronized void updateGCTimer(String rootPath, long currentVersion) {\n+    if (_gcTaskFuture != null) {\n+      _gcTaskFuture.cancel(false);\n+    }", "originalCommit": "5cf2b677e9c7a489e044e3da40db9ec26c8e0037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2NzkzNQ==", "url": "https://github.com/apache/helix/pull/1107#discussion_r443867935", "bodyText": "This cancel will only cancel the pending tasks. For the pending tasks that are queued up, they will only cause extra children list read. The later operation will be the same. And if there is risk of incomplete deleting, then that concern lives no matter we let it queued up or not. That issue (if exists) should be addressed separately.", "author": "jiajunwang", "createdAt": "2020-06-22T22:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2NDYwOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "231764292d0671af21017e99613a09941bc638d2", "url": "https://github.com/apache/helix/commit/231764292d0671af21017e99613a09941bc638d2", "message": "Fix the comment.", "committedDate": "2020-06-22T22:44:07Z", "type": "commit"}]}