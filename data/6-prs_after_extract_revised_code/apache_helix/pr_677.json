{"pr_number": 677, "pr_title": "Add method to wait and return established session's ID", "pr_createdAt": "2020-01-09T02:44:01Z", "pr_url": "https://github.com/apache/helix/pull/677", "timeline": [{"oid": "03ea611e832acb4747d0567640547d30e9edc72a", "url": "https://github.com/apache/helix/commit/03ea611e832acb4747d0567640547d30e9edc72a", "message": "Implement waitForEstablishedSession.", "committedDate": "2020-01-09T02:49:29Z", "type": "forcePushed"}, {"oid": "0e4e97a7d2fc400051d5c9c2b0f53a2f54d7812b", "url": "https://github.com/apache/helix/commit/0e4e97a7d2fc400051d5c9c2b0f53a2f54d7812b", "message": "Implement waitForEstablishedSession.", "committedDate": "2020-01-09T02:54:18Z", "type": "forcePushed"}, {"oid": "88322618caef389b0e5159d519680248c51d52a8", "url": "https://github.com/apache/helix/commit/88322618caef389b0e5159d519680248c51d52a8", "message": "Implement waitForEstablishedSession.", "committedDate": "2020-01-09T03:01:08Z", "type": "forcePushed"}, {"oid": "c1710165db40ec3f2f30ce819da1e36b3537747c", "url": "https://github.com/apache/helix/commit/c1710165db40ec3f2f30ce819da1e36b3537747c", "message": "Implement waitForEstablishedSession.", "committedDate": "2020-01-09T21:07:53Z", "type": "commit"}, {"oid": "c1710165db40ec3f2f30ce819da1e36b3537747c", "url": "https://github.com/apache/helix/commit/c1710165db40ec3f2f30ce819da1e36b3537747c", "message": "Implement waitForEstablishedSession.", "committedDate": "2020-01-09T21:07:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3MzU1Mw==", "url": "https://github.com/apache/helix/pull/677#discussion_r364973553", "bodyText": "Why not put the lock/check current thread logic inside this method? This will help to simplify the code. As for the callers require a different return, you can handle those differences in the caller. But the lock and thread check can be put here.", "author": "jiajunwang", "createdAt": "2020-01-09T21:41:52Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -2136,4 +2146,24 @@ public int hashCode() {\n       return _listener.hashCode();\n     }\n   }\n+\n+  private void validateCurrentThread() {\n+    if (_zookeeperEventThread != null && Thread.currentThread() == _zookeeperEventThread) {\n+      throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n+    }\n+  }\n+\n+  private void waitForKeeperStateUntilDeadline(KeeperState keeperState, Date deadline) {", "originalCommit": "c1710165db40ec3f2f30ce819da1e36b3537747c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk4Nzc5Mw==", "url": "https://github.com/apache/helix/pull/677#discussion_r364987793", "bodyText": "Synced with @jiajunwang offline. Either works OK. We agree to add a locking layer for returning session, so there are less code changes and it is easier to maintain.", "author": "huizhilu", "createdAt": "2020-01-09T22:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk3MzU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b8e224418e8620734df504372620fc89771c85d5", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex b6121ce65..a28ea83e1 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -2152,18 +2156,4 @@ public class ZkClient implements Watcher {\n       throw new IllegalArgumentException(\"Must not be done in the zookeeper event thread.\");\n     }\n   }\n-\n-  private void waitForKeeperStateUntilDeadline(KeeperState keeperState, Date deadline) {\n-    try {\n-      boolean stillWaiting = true;\n-      while (_currentState != keeperState) {\n-        if (!stillWaiting) {\n-          throw new ZkTimeoutException(\"Waiting to be connected to ZK server has timed out.\");\n-        }\n-        stillWaiting = getEventLock().getStateChangedCondition().awaitUntil(deadline);\n-      }\n-    } catch (InterruptedException e) {\n-      throw new ZkInterruptedException(e);\n-    }\n-  }\n }\n"}}, {"oid": "b8e224418e8620734df504372620fc89771c85d5", "url": "https://github.com/apache/helix/commit/b8e224418e8620734df504372620fc89771c85d5", "message": "Add a locking layer for returning session.", "committedDate": "2020-01-09T22:15:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA0NTI3NQ==", "url": "https://github.com/apache/helix/pull/677#discussion_r365045275", "bodyText": "Why we need this default implementation that still have race condition?  Why default can't be the correct one? Or the default implementation just throw exception telling people they should implement the correct version?", "author": "kaisun2000", "createdAt": "2020-01-10T02:09:21Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/client/HelixZkClient.java", "diffHunk": "@@ -182,6 +183,28 @@ void asyncSetData(final String path, Object datat, final int version,\n   // ZK state control\n   boolean waitUntilConnected(long time, TimeUnit timeUnit);\n \n+  /**\n+   * Waits for SyncConnected state and returns a valid session ID(non-zero). The implementation of\n+   * this method should wait for SyncConnected state and ZK session to be established, and should\n+   * guarantee the established session's ID is returned before keeper state changes.\n+   *\n+   * Please note: this default implementation may have race condition issue and return an unexpected\n+   * session ID that is zero or another new session's ID. The default implementation is for backward\n+   * compatibility purpose.\n+   *\n+   * @param timeout Max waiting time for connecting to ZK server.\n+   * @param timeUnit Time unit for the timeout.\n+   * @return A valid ZK session ID which is non-zero.\n+   */\n+  default long waitForEstablishedSession(long timeout, TimeUnit timeUnit) {\n+    if (!waitUntilConnected(timeout, timeUnit)) {\n+      throw new ZkTimeoutException(\n+          \"Failed to get established session because connecting to ZK server has timed out in \"\n+              + timeout + \" \" + timeUnit);\n+    }\n+    return getSessionId();\n+  }\n+", "originalCommit": "b8e224418e8620734df504372620fc89771c85d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA1NTkyOQ==", "url": "https://github.com/apache/helix/pull/677#discussion_r365055929", "bodyText": "line 698 _zkclient.subscribeStateChanges(this);\nat this implementation should always happen later than first synconnected for the reason that ZkClient constructor would call waitTillConnected to guarantee the first synconnect is delivered before proceeding.\nThus first handleNewSession is not delivered from first Synconnect.\nBy the time handlNewSession is called synchronously from here, it does not necessarily have a valid sessionID. Here, we use waitForEstablishedSession to get a valid sessionID at the time. Otherwise, you have chance to get sessionID 0.\n@jiajunwang, can you confirm if my reasoning is right here?", "author": "kaisun2000", "createdAt": "2020-01-10T03:06:07Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -699,19 +699,15 @@ void createClient() throws Exception {\n     int retryCount = 0;\n     while (retryCount < 3) {\n       try {\n-        // TODO: get session id from waitUntilConnected to avoid race condition\n-        if (!_zkclient.waitUntilConnected(_connectionInitTimeout, TimeUnit.MILLISECONDS)) {\n-          throw new ZkTimeoutException(\n-              \"Unable to connect to zookeeper server within timeout: \" + _connectionInitTimeout\n-                  + \" ms.\");\n-        }\n+        final long sessionId =", "originalCommit": "b8e224418e8620734df504372620fc89771c85d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2ODY0Nw==", "url": "https://github.com/apache/helix/pull/677#discussion_r365368647", "bodyText": "The other issue identified with HuiZhi is that 698 _zkclient.subscribeStateChanges(this) is not safe for another reason.\nThe event can be like this:\n1/ Zookeeper (client) created, and syconnect comes and then the constructor of ZKClient finishes.\n2/ line 698 _zkclient.subscribeStateChanges(this) executed.\n3/ Zookeeper expired and reconnect happens in ZKClient, then synconnnected get delivered.\n4/ HandleNewSesssion get delivered.\n5/ _zkCllient.waitForEstablishedSession executed and handleNewSession get called the second time.\nSo the gist is still we should provide a constructor of ZKCLient with the stateChanges callback register at one shot. @jiajunwang what is your take?", "author": "kaisun2000", "createdAt": "2020-01-10T18:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA1NTkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3ODgzMQ==", "url": "https://github.com/apache/helix/pull/677#discussion_r365378831", "bodyText": "As we discussed offline, the issue is not newly introduced in this PR. And it is not becoming worse. I agree that we need to fix it. But not in this PR.", "author": "jiajunwang", "createdAt": "2020-01-10T18:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA1NTkyOQ=="}], "type": "inlineReview", "revised_code": null}]}