{"pr_number": 686, "pr_title": "Add resource partition weight gauge", "pr_createdAt": "2020-01-16T22:41:55Z", "pr_url": "https://github.com/apache/helix/pull/686", "timeline": [{"oid": "9b2103357be244c0e2d3353646701d260557fb62", "url": "https://github.com/apache/helix/commit/9b2103357be244c0e2d3353646701d260557fb62", "message": "Add partition weight gauge.", "committedDate": "2020-01-16T22:57:38Z", "type": "forcePushed"}, {"oid": "b4f9213770133a2368ae9f2e8bc4ab1c81aa9c09", "url": "https://github.com/apache/helix/commit/b4f9213770133a2368ae9f2e8bc4ab1c81aa9c09", "message": "Add partition weight gauge.", "committedDate": "2020-01-16T22:58:19Z", "type": "forcePushed"}, {"oid": "ce2a1ee1000865f2c2b436e3c2d45aac2f665c6d", "url": "https://github.com/apache/helix/commit/ce2a1ee1000865f2c2b436e3c2d45aac2f665c6d", "message": "Add partition weight gauge.", "committedDate": "2020-01-17T02:29:38Z", "type": "forcePushed"}, {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b", "url": "https://github.com/apache/helix/commit/df2f078a1db07bc7c892b810e10e34ec3846993b", "message": "Add partition weight gauge.", "committedDate": "2020-01-17T03:01:56Z", "type": "commit"}, {"oid": "df2f078a1db07bc7c892b810e10e34ec3846993b", "url": "https://github.com/apache/helix/commit/df2f078a1db07bc7c892b810e10e34ec3846993b", "message": "Add partition weight gauge.", "committedDate": "2020-01-17T03:01:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTM5MQ==", "url": "https://github.com/apache/helix/pull/686#discussion_r368191391", "bodyText": "getOrCreateResourceMonitor()", "author": "jiajunwang", "createdAt": "2020-01-18T00:51:52Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "diffHunk": "@@ -497,6 +497,25 @@ public void setResourceStatus(ExternalView externalView, IdealState idealState,\n     }\n   }\n \n+  /**\n+   * Updates metrics of average partition weight per capacity key for a resource. If a resource\n+   * monitor is not yet existed for this resource, a new resource monitor will be created for this\n+   * resource.\n+   *\n+   * @param resourceName The resource name for which partition weight is updated\n+   * @param averageWeightMap A map of average partition weight of each capacity key:\n+   *                         capacity key -> average partition weight\n+   */\n+  public void updatePartitionWeight(String resourceName, Map<String, Integer> averageWeightMap) {\n+    ResourceMonitor monitor = _resourceMonitorMap.get(resourceName);", "originalCommit": "df2f078a1db07bc7c892b810e10e34ec3846993b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\nindex d3c1b5b17..fc0b19d83 100644\n--- a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n+++ b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\n@@ -507,7 +507,7 @@ public class ClusterStatusMonitor implements ClusterStatusMonitorMBean {\n    *                         capacity key -> average partition weight\n    */\n   public void updatePartitionWeight(String resourceName, Map<String, Integer> averageWeightMap) {\n-    ResourceMonitor monitor = _resourceMonitorMap.get(resourceName);\n+    ResourceMonitor monitor = getOrCreateResourceMonitor(resourceName);\n     if (monitor == null) {\n       LOG.warn(\"Failed to update partition weight metric for resource: {} because resource monitor\"\n           + \" is not created.\", resourceName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ3Nw==", "url": "https://github.com/apache/helix/pull/686#discussion_r368191477", "bodyText": "Why?", "author": "jiajunwang", "createdAt": "2020-01-18T00:52:41Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java", "diffHunk": "@@ -519,7 +538,7 @@ public void updateRebalancerStats(String resourceName, long numPendingRecoveryRe\n     }\n   }\n \n-  private ResourceMonitor getOrCreateResourceMonitor(String resourceName) {\n+  ResourceMonitor getOrCreateResourceMonitor(String resourceName) {", "originalCommit": "df2f078a1db07bc7c892b810e10e34ec3846993b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTk2OQ==", "url": "https://github.com/apache/helix/pull/686#discussion_r369219969", "bodyText": "For test purpose. As I discussed offline, we will keep this private and just call monitor's register().", "author": "huizhilu", "createdAt": "2020-01-21T20:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MTQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\nindex d3c1b5b17..fc0b19d83 100644\n--- a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n+++ b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\n@@ -538,7 +538,7 @@ public class ClusterStatusMonitor implements ClusterStatusMonitorMBean {\n     }\n   }\n \n-  ResourceMonitor getOrCreateResourceMonitor(String resourceName) {\n+  private ResourceMonitor getOrCreateResourceMonitor(String resourceName) {\n     try {\n       if (!_resourceMonitorMap.containsKey(resourceName)) {\n         synchronized (_resourceMonitorMap) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjk0MA==", "url": "https://github.com/apache/helix/pull/686#discussion_r368192940", "bodyText": "long would be safer.", "author": "jiajunwang", "createdAt": "2020-01-18T01:04:08Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap =\n+        aggregatePartitionWeight(partitionCapacityMap);\n+\n+    // capacity key -> average partition weight\n+    Map<String, Integer> averagePartitionWeightMap = new HashMap<>();\n+\n+    // Calculate average partition weight for each capacity key.\n+    // Per capacity key level:\n+    // average partition weight = (total partition weight) / (number of partitions)\n+    for (Map.Entry<String, PartitionWeightCounterEntry> entry\n+        : countPartitionWeightMap.entrySet()) {\n+      String capacityKey = entry.getKey();\n+      PartitionWeightCounterEntry weightEntry = entry.getValue();\n+      int averageWeight = weightEntry.getWeight() / weightEntry.getPartitions();\n+      averagePartitionWeightMap.put(capacityKey, averageWeight);\n+    }\n+\n+    return averagePartitionWeightMap;\n+  }\n+\n+  /*\n+   * Aggregates partition weight for each capacity key.\n+   */\n+  private static Map<String, PartitionWeightCounterEntry> aggregatePartitionWeight(\n+      Map<String, Map<String, Integer>> partitionCapacityMap) {\n+    // capacity key -> [number of partitions, total weight per capacity key]\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap = new HashMap<>();\n+\n+    partitionCapacityMap.values().forEach(partitionCapacityEntry ->\n+        partitionCapacityEntry.forEach((capacityKey, weight) -> countPartitionWeightMap\n+            .computeIfAbsent(capacityKey, counterEntry -> new PartitionWeightCounterEntry())\n+            .increase(1, weight)));\n+\n+    return countPartitionWeightMap;\n+  }\n+\n+  /*\n+   * Represents total number of partitions and total partition weight for a capacity key.\n+   */\n+  private static class PartitionWeightCounterEntry {\n+    private int partitions;\n+    private int weight;", "originalCommit": "df2f078a1db07bc7c892b810e10e34ec3846993b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTQwMw==", "url": "https://github.com/apache/helix/pull/686#discussion_r369219403", "bodyText": "Done.", "author": "huizhilu", "createdAt": "2020-01-21T20:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java b/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\nindex a780bab31..e7a1b948b 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\n\n@@ -179,8 +179,14 @@ public class ResourceUsageCalculator {\n    */\n   public static Map<String, Integer> calculateAveragePartitionWeight(\n       Map<String, Map<String, Integer>> partitionCapacityMap) {\n-    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap =\n-        aggregatePartitionWeight(partitionCapacityMap);\n+    // capacity key -> [number of partitions, total weight per capacity key]\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap = new HashMap<>();\n+\n+    // Aggregates partition weight for each capacity key.\n+    partitionCapacityMap.values().forEach(partitionCapacityEntry ->\n+        partitionCapacityEntry.forEach((capacityKey, weight) -> countPartitionWeightMap\n+            .computeIfAbsent(capacityKey, counterEntry -> new PartitionWeightCounterEntry())\n+            .increase(1, weight)));\n \n     // capacity key -> average partition weight\n     Map<String, Integer> averagePartitionWeightMap = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzI0OA==", "url": "https://github.com/apache/helix/pull/686#discussion_r368193248", "bodyText": "Let's simplify this by merging the 2 methods?", "author": "jiajunwang", "createdAt": "2020-01-18T01:06:51Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java", "diffHunk": "@@ -142,4 +142,97 @@ public static double measureBaselineDivergence(Map<String, ResourceAssignment> b\n     return numTotalBestPossibleReplicas == 0 ? 1.0d\n         : (1.0d - (double) numMatchedReplicas / (double) numTotalBestPossibleReplicas);\n   }\n+\n+  /**\n+   * Calculates average partition weight per capacity key for a resource config. Example as below:\n+   * Input =\n+   * {\n+   *   \"partition1\": {\n+   *     \"capacity1\": 20,\n+   *     \"capacity2\": 40\n+   *   },\n+   *   \"partition2\": {\n+   *     \"capacity1\": 30,\n+   *     \"capacity2\": 50\n+   *   },\n+   *   \"partition3\": {\n+   *     \"capacity1\": 16,\n+   *     \"capacity2\": 30\n+   *   }\n+   * }\n+   *\n+   * Total weight for key \"capacity1\" = 20 + 30 + 16 = 66;\n+   * Total weight for key \"capacity2\" = 40 + 50 + 30 = 120;\n+   * Total partitions = 3;\n+   * Average partition weight for \"capacity1\" = 66 / 3 = 22;\n+   * Average partition weight for \"capacity2\" = 120 / 3 = 40;\n+   *\n+   * Output =\n+   * {\n+   *   \"capacity1\": 22,\n+   *   \"capacity2\": 40\n+   * }\n+   *\n+   * @param partitionCapacityMap A map of partition capacity:\n+   *        <PartitionName or DEFAULT_PARTITION_KEY, <Capacity Key, Capacity Number>>\n+   * @return A map of partition weight: capacity key -> average partition weight\n+   */\n+  public static Map<String, Integer> calculateAveragePartitionWeight(", "originalCommit": "df2f078a1db07bc7c892b810e10e34ec3846993b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxOTQ4Ng==", "url": "https://github.com/apache/helix/pull/686#discussion_r369219486", "bodyText": "Done", "author": "huizhilu", "createdAt": "2020-01-21T20:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzI0OA=="}], "type": "inlineReview", "revised_code": {"commit": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java b/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\nindex a780bab31..e7a1b948b 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/rebalancer/util/ResourceUsageCalculator.java\n\n@@ -179,8 +179,14 @@ public class ResourceUsageCalculator {\n    */\n   public static Map<String, Integer> calculateAveragePartitionWeight(\n       Map<String, Map<String, Integer>> partitionCapacityMap) {\n-    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap =\n-        aggregatePartitionWeight(partitionCapacityMap);\n+    // capacity key -> [number of partitions, total weight per capacity key]\n+    Map<String, PartitionWeightCounterEntry> countPartitionWeightMap = new HashMap<>();\n+\n+    // Aggregates partition weight for each capacity key.\n+    partitionCapacityMap.values().forEach(partitionCapacityEntry ->\n+        partitionCapacityEntry.forEach((capacityKey, weight) -> countPartitionWeightMap\n+            .computeIfAbsent(capacityKey, counterEntry -> new PartitionWeightCounterEntry())\n+            .increase(1, weight)));\n \n     // capacity key -> average partition weight\n     Map<String, Integer> averagePartitionWeightMap = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mzk0Mg==", "url": "https://github.com/apache/helix/pull/686#discussion_r368193942", "bodyText": "nit, static final and put to the class level?", "author": "jiajunwang", "createdAt": "2020-01-18T01:11:30Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java", "diffHunk": "@@ -382,6 +367,37 @@ public void updateRebalancerStats(long numPendingRecoveryRebalancePartitions,\n     _numLoadRebalanceThrottledPartitions.updateValue(numLoadRebalanceThrottledPartitions);\n   }\n \n+  /**\n+   * Updates partition weight metric. If the partition capacity keys are changed, all MBean\n+   * attributes will be updated accordingly: old capacity keys will be replaced with new capacity\n+   * keys in MBean server.\n+   *\n+   * @param partitionWeightMap A map of partition weight: capacity key -> partition weight\n+   */\n+  void updatePartitionWeightStats(Map<String, Integer> partitionWeightMap) {\n+    synchronized (_dynamicCapacityMetricsMap) {\n+      if (_dynamicCapacityMetricsMap.keySet().equals(partitionWeightMap.keySet())) {\n+        for (Map.Entry<String, Integer> entry : partitionWeightMap.entrySet()) {\n+          _dynamicCapacityMetricsMap.get(entry.getKey()).updateValue((long) entry.getValue());\n+        }\n+        return;\n+      }\n+\n+      // Capacity keys are changed, so capacity attribute map needs to be updated.\n+      _dynamicCapacityMetricsMap.clear();\n+      final String gaugeMetricSuffix = \"Gauge\";", "originalCommit": "df2f078a1db07bc7c892b810e10e34ec3846993b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIyMDE1OQ==", "url": "https://github.com/apache/helix/pull/686#discussion_r369220159", "bodyText": "OK.", "author": "huizhilu", "createdAt": "2020-01-21T20:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mzk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java\nindex e1445d658..af9c318a4 100644\n--- a/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java\n+++ b/helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ResourceMonitor.java\n\n@@ -385,11 +387,10 @@ public class ResourceMonitor extends DynamicMBeanProvider {\n \n       // Capacity keys are changed, so capacity attribute map needs to be updated.\n       _dynamicCapacityMetricsMap.clear();\n-      final String gaugeMetricSuffix = \"Gauge\";\n       for (Map.Entry<String, Integer> entry : partitionWeightMap.entrySet()) {\n         String capacityKey = entry.getKey();\n         _dynamicCapacityMetricsMap.put(capacityKey,\n-            new SimpleDynamicMetric<>(capacityKey + gaugeMetricSuffix, (long) entry.getValue()));\n+            new SimpleDynamicMetric<>(capacityKey + GAUGE_METRIC_SUFFIX, (long) entry.getValue()));\n       }\n     }\n \n"}}, {"oid": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "url": "https://github.com/apache/helix/commit/9691ed04d48a6a403b742528b926cc2bf4bb9c27", "message": "Move test to TestResourceMonitor; Simplify code.", "committedDate": "2020-01-21T21:38:13Z", "type": "commit"}, {"oid": "9691ed04d48a6a403b742528b926cc2bf4bb9c27", "url": "https://github.com/apache/helix/commit/9691ed04d48a6a403b742528b926cc2bf4bb9c27", "message": "Move test to TestResourceMonitor; Simplify code.", "committedDate": "2020-01-21T21:38:13Z", "type": "forcePushed"}, {"oid": "5b1628de6eed11ca7143cd6e82e8fbeade784fd9", "url": "https://github.com/apache/helix/commit/5b1628de6eed11ca7143cd6e82e8fbeade784fd9", "message": "Fix unit test.", "committedDate": "2020-01-22T00:12:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMjQxMg==", "url": "https://github.com/apache/helix/pull/686#discussion_r369312412", "bodyText": "In this case, put it in finally block and check if monitor is null before unregister.", "author": "jiajunwang", "createdAt": "2020-01-22T00:14:50Z", "path": "helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java", "diffHunk": "@@ -217,10 +217,13 @@ public void testReportData() throws JMException {\n     monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED);\n     Assert.assertEquals(monitor.getRebalanceState(),\n         ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED.name());\n+\n+    // Has to unregister this monitor to clean up. Otherwise, later tests may be affected and fail.\n+    monitor.unregister();", "originalCommit": "5b1628de6eed11ca7143cd6e82e8fbeade784fd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxNTU2MA==", "url": "https://github.com/apache/helix/pull/686#discussion_r369315560", "bodyText": "Done.", "author": "huizhilu", "createdAt": "2020-01-22T00:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMjQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "85790f624eb233b434bf081a83a6b349197c63c6", "chunk": "diff --git a/helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java b/helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java\nindex 23bf18069..f63012410 100644\n--- a/helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java\n+++ b/helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestResourceMonitor.java\n\n@@ -55,171 +55,175 @@ public class TestResourceMonitor {\n   @Test()\n   public void testReportData() throws JMException {\n     final int n = 5;\n-    ResourceMonitor monitor = new ResourceMonitor(_clusterName, _dbName, new ObjectName(\"testDomain:key=value\"));\n+    ResourceMonitor monitor =\n+        new ResourceMonitor(_clusterName, _dbName, new ObjectName(\"testDomain:key=value\"));\n     monitor.register();\n \n-    List<String> instances = new ArrayList<>();\n-    for (int i = 0; i < n; i++) {\n-      String instance = \"localhost_\" + (12918 + i);\n-      instances.add(instance);\n-    }\n+    try {\n+      List<String> instances = new ArrayList<>();\n+      for (int i = 0; i < n; i++) {\n+        String instance = \"localhost_\" + (12918 + i);\n+        instances.add(instance);\n+      }\n \n-    ZNRecord idealStateRecord = DefaultIdealStateCalculator\n-        .calculateIdealState(instances, _partitions, _replicas - 1, _dbName, \"MASTER\", \"SLAVE\");\n-    IdealState idealState = new IdealState(deepCopyZNRecord(idealStateRecord));\n-    idealState.setMinActiveReplicas(_replicas - 1);\n-    ExternalView externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n-    StateModelDefinition stateModelDef =\n-        BuiltInStateModelDefinitions.MasterSlave.getStateModelDefinition();\n-\n-    monitor.updateResourceState(externalView, idealState, stateModelDef);\n-\n-    Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), 0);\n-    Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getBeanName(), _clusterName + \" \" + _dbName);\n-\n-    int errorCount = 5;\n-    Random r = new Random();\n-    int start = r.nextInt(_partitions - errorCount - 1);\n-    for (int i = start; i < start + errorCount; i++) {\n-      String partition = _dbName + \"_\" + i;\n-      Map<String, String> map = externalView.getStateMap(partition);\n-      for (String key : map.keySet()) {\n-        if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n-          map.put(key, \"ERROR\");\n-          break;\n+      ZNRecord idealStateRecord = DefaultIdealStateCalculator\n+          .calculateIdealState(instances, _partitions, _replicas - 1, _dbName, \"MASTER\", \"SLAVE\");\n+      IdealState idealState = new IdealState(deepCopyZNRecord(idealStateRecord));\n+      idealState.setMinActiveReplicas(_replicas - 1);\n+      ExternalView externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n+      StateModelDefinition stateModelDef =\n+          BuiltInStateModelDefinitions.MasterSlave.getStateModelDefinition();\n+\n+      monitor.updateResourceState(externalView, idealState, stateModelDef);\n+\n+      Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), 0);\n+      Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getBeanName(), _clusterName + \" \" + _dbName);\n+\n+      int errorCount = 5;\n+      Random r = new Random();\n+      int start = r.nextInt(_partitions - errorCount - 1);\n+      for (int i = start; i < start + errorCount; i++) {\n+        String partition = _dbName + \"_\" + i;\n+        Map<String, String> map = externalView.getStateMap(partition);\n+        for (String key : map.keySet()) {\n+          if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n+            map.put(key, \"ERROR\");\n+            break;\n+          }\n         }\n+        externalView.setStateMap(partition, map);\n       }\n-      externalView.setStateMap(partition, map);\n-    }\n \n-    monitor.updateResourceState(externalView, idealState, stateModelDef);\n-\n-    Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), errorCount);\n-    Assert.assertEquals(monitor.getErrorPartitionGauge(), errorCount);\n-    Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), errorCount);\n-    Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n-\n-    int lessMinActiveReplica = 6;\n-    externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n-    start = r.nextInt(_partitions - lessMinActiveReplica - 1);\n-    for (int i = start; i < start + lessMinActiveReplica; i++) {\n-      String partition = _dbName + \"_\" + i;\n-      Map<String, String> map = externalView.getStateMap(partition);\n-      Iterator<String> it = map.keySet().iterator();\n-      int flag = 0;\n-      while (it.hasNext()) {\n-        String key = it.next();\n-        if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n-          if (flag++ % 2 == 0) {\n-            map.put(key, \"OFFLINE\");\n-          } else {\n-            it.remove();\n+      monitor.updateResourceState(externalView, idealState, stateModelDef);\n+\n+      Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), errorCount);\n+      Assert.assertEquals(monitor.getErrorPartitionGauge(), errorCount);\n+      Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), errorCount);\n+      Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n+\n+      int lessMinActiveReplica = 6;\n+      externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n+      start = r.nextInt(_partitions - lessMinActiveReplica - 1);\n+      for (int i = start; i < start + lessMinActiveReplica; i++) {\n+        String partition = _dbName + \"_\" + i;\n+        Map<String, String> map = externalView.getStateMap(partition);\n+        Iterator<String> it = map.keySet().iterator();\n+        int flag = 0;\n+        while (it.hasNext()) {\n+          String key = it.next();\n+          if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n+            if (flag++ % 2 == 0) {\n+              map.put(key, \"OFFLINE\");\n+            } else {\n+              it.remove();\n+            }\n           }\n         }\n+        externalView.setStateMap(partition, map);\n       }\n-      externalView.setStateMap(partition, map);\n-    }\n \n-    monitor.updateResourceState(externalView, idealState, stateModelDef);\n-\n-    Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), lessMinActiveReplica);\n-    Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), lessMinActiveReplica);\n-    Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), lessMinActiveReplica);\n-    Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n-\n-    int lessReplica = 4;\n-    externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n-    start = r.nextInt(_partitions - lessReplica - 1);\n-    for (int i = start; i < start + lessReplica; i++) {\n-      String partition = _dbName + \"_\" + i;\n-      Map<String, String> map = externalView.getStateMap(partition);\n-      int flag = 0;\n-      Iterator<String> it = map.keySet().iterator();\n-      while (it.hasNext()) {\n-        String key = it.next();\n-        if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n-          if (flag++ % 2 == 0) {\n-            map.put(key, \"OFFLINE\");\n-          } else {\n-            it.remove();\n+      monitor.updateResourceState(externalView, idealState, stateModelDef);\n+\n+      Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), lessMinActiveReplica);\n+      Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), lessMinActiveReplica);\n+      Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), lessMinActiveReplica);\n+      Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n+\n+      int lessReplica = 4;\n+      externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n+      start = r.nextInt(_partitions - lessReplica - 1);\n+      for (int i = start; i < start + lessReplica; i++) {\n+        String partition = _dbName + \"_\" + i;\n+        Map<String, String> map = externalView.getStateMap(partition);\n+        int flag = 0;\n+        Iterator<String> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+          String key = it.next();\n+          if (map.get(key).equalsIgnoreCase(\"SLAVE\")) {\n+            if (flag++ % 2 == 0) {\n+              map.put(key, \"OFFLINE\");\n+            } else {\n+              it.remove();\n+            }\n+            break;\n           }\n-          break;\n         }\n+        externalView.setStateMap(partition, map);\n       }\n-      externalView.setStateMap(partition, map);\n-    }\n \n-    monitor.updateResourceState(externalView, idealState, stateModelDef);\n-\n-    Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), lessReplica);\n-    Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), lessReplica);\n-    Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n-\n-    int missTopState = 7;\n-    externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n-    start = r.nextInt(_partitions - missTopState - 1);\n-    for (int i = start; i < start + missTopState; i++) {\n-      String partition = _dbName + \"_\" + i;\n-      Map<String, String> map = externalView.getStateMap(partition);\n-      int flag = 0;\n-      for (String key : map.keySet()) {\n-        if (map.get(key).equalsIgnoreCase(\"MASTER\")) {\n-          if (flag++ % 2 == 0) {\n-            map.put(key, \"OFFLINE\");\n-          } else {\n-            map.remove(key);\n+      monitor.updateResourceState(externalView, idealState, stateModelDef);\n+\n+      Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), lessReplica);\n+      Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), lessReplica);\n+      Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), 0);\n+\n+      int missTopState = 7;\n+      externalView = new ExternalView(deepCopyZNRecord(idealStateRecord));\n+      start = r.nextInt(_partitions - missTopState - 1);\n+      for (int i = start; i < start + missTopState; i++) {\n+        String partition = _dbName + \"_\" + i;\n+        Map<String, String> map = externalView.getStateMap(partition);\n+        int flag = 0;\n+        for (String key : map.keySet()) {\n+          if (map.get(key).equalsIgnoreCase(\"MASTER\")) {\n+            if (flag++ % 2 == 0) {\n+              map.put(key, \"OFFLINE\");\n+            } else {\n+              map.remove(key);\n+            }\n+            break;\n           }\n-          break;\n         }\n+        externalView.setStateMap(partition, map);\n       }\n-      externalView.setStateMap(partition, map);\n-    }\n \n-    monitor.updateResourceState(externalView, idealState, stateModelDef);\n-\n-    Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), missTopState);\n-    Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n-    Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n-    Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), missTopState);\n-    Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), missTopState);\n-\n-    Assert.assertEquals(monitor.getNumPendingStateTransitionGauge(), 0);\n-    // test pending state transition message report and read\n-    int messageCount = new Random().nextInt(_partitions) + 1;\n-    monitor.updatePendingStateTransitionMessages(messageCount);\n-    Assert.assertEquals(monitor.getNumPendingStateTransitionGauge(), messageCount);\n-\n-    Assert\n-        .assertEquals(monitor.getRebalanceState(), ResourceMonitor.RebalanceStatus.UNKNOWN.name());\n-    monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.NORMAL);\n-    Assert.assertEquals(monitor.getRebalanceState(), ResourceMonitor.RebalanceStatus.NORMAL.name());\n-    monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.BEST_POSSIBLE_STATE_CAL_FAILED);\n-    Assert.assertEquals(monitor.getRebalanceState(),\n-        ResourceMonitor.RebalanceStatus.BEST_POSSIBLE_STATE_CAL_FAILED.name());\n-    monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED);\n-    Assert.assertEquals(monitor.getRebalanceState(),\n-        ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED.name());\n-\n-    // Has to unregister this monitor to clean up. Otherwise, later tests may be affected and fail.\n-    monitor.unregister();\n+      monitor.updateResourceState(externalView, idealState, stateModelDef);\n+\n+      Assert.assertEquals(monitor.getDifferenceWithIdealStateGauge(), missTopState);\n+      Assert.assertEquals(monitor.getErrorPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getExternalViewPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getPartitionGauge(), _partitions);\n+      Assert.assertEquals(monitor.getMissingMinActiveReplicaPartitionGauge(), 0);\n+      Assert.assertEquals(monitor.getMissingReplicaPartitionGauge(), missTopState);\n+      Assert.assertEquals(monitor.getMissingTopStatePartitionGauge(), missTopState);\n+\n+      Assert.assertEquals(monitor.getNumPendingStateTransitionGauge(), 0);\n+      // test pending state transition message report and read\n+      int messageCount = new Random().nextInt(_partitions) + 1;\n+      monitor.updatePendingStateTransitionMessages(messageCount);\n+      Assert.assertEquals(monitor.getNumPendingStateTransitionGauge(), messageCount);\n+\n+      Assert.assertEquals(monitor.getRebalanceState(),\n+          ResourceMonitor.RebalanceStatus.UNKNOWN.name());\n+      monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.NORMAL);\n+      Assert\n+          .assertEquals(monitor.getRebalanceState(), ResourceMonitor.RebalanceStatus.NORMAL.name());\n+      monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.BEST_POSSIBLE_STATE_CAL_FAILED);\n+      Assert.assertEquals(monitor.getRebalanceState(),\n+          ResourceMonitor.RebalanceStatus.BEST_POSSIBLE_STATE_CAL_FAILED.name());\n+      monitor.setRebalanceState(ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED);\n+      Assert.assertEquals(monitor.getRebalanceState(),\n+          ResourceMonitor.RebalanceStatus.INTERMEDIATE_STATE_CAL_FAILED.name());\n+    } finally {\n+      // Has to unregister this monitor to clean up. Otherwise, later tests may be affected and fail.\n+      monitor.unregister();\n+    }\n   }\n \n   @Test\n"}}, {"oid": "85790f624eb233b434bf081a83a6b349197c63c6", "url": "https://github.com/apache/helix/commit/85790f624eb233b434bf081a83a6b349197c63c6", "message": "Move monitor unregister to finally block.", "committedDate": "2020-01-22T00:27:36Z", "type": "commit"}]}