{"pr_number": 688, "pr_title": "Fix the watcher leakage issue", "pr_createdAt": "2020-01-17T02:58:09Z", "pr_url": "https://github.com/apache/helix/pull/688", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NTA0MA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368055040", "bodyText": "nit: doesPathExist or pathExists", "author": "narendly", "createdAt": "2020-01-17T17:37:57Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1258,62 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean isPathExist = event.getType() != EventType.NodeDeleted;", "originalCommit": "d0405a53b2ff01eb60b877cbec6b27f90333861a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NzA0OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r368067049", "bodyText": "Another option is, you can pass the EventType to fireDataChangedEvents. I think this option is better than passing a boolean as parameter to determine the behavior. So you don't have to check the condition here.", "author": "huizhilu", "createdAt": "2020-01-17T18:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NTA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 403c92216..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1258,62 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n     }\n   }\n \n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    for (final IZkDataListenerEntry listener : listeners) {\n-      ZkEvent zkEvent = new ZkEvent(\n-          \"Data of \" + path + \" changed sent to \" + listener.getDataListener() + \" prefetch data: \"\n-              + listener.isPrefetchData()) {\n-        @Override\n-        public void run()\n-            throws Exception {\n-          Object data;\n-          // TODO: are we fetching the data multiple times?\n-          if (listener.isPrefetchData()) {\n-            LOG.debug(\"Prefetch data for path: {}\", path);\n-            try {\n-              data = readData(path, null, true);\n-            } catch (ZkNoNodeException e) {\n-              LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            listener.getDataListener().handleDataChange(path, data);\n-          }\n-        }\n-      };\n-\n-      _eventThread.send(zkEvent);\n-    }\n-  }\n-\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean isPathExist) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!isPathExist) {\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n+            }\n+            if (!pathStatRecord.pathExists()) {\n               // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            if (!pathStatRecord.isPathChecked()) {\n-              // Reinstall watch before listener callbacks to check the znode status\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n-            }\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NDIyNQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r368064225", "bodyText": "Could you add some javadoc on how this is different from the other method?", "author": "narendly", "createdAt": "2020-01-17T18:01:48Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1258,62 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n+        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n       }\n     }\n   }\n \n+  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {", "originalCommit": "d0405a53b2ff01eb60b877cbec6b27f90333861a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5NTkxNw==", "url": "https://github.com/apache/helix/pull/688#discussion_r368195917", "bodyText": "done", "author": "i3wangyi", "createdAt": "2020-01-18T01:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NDIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 403c92216..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1258,62 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n     }\n   }\n \n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    for (final IZkDataListenerEntry listener : listeners) {\n-      ZkEvent zkEvent = new ZkEvent(\n-          \"Data of \" + path + \" changed sent to \" + listener.getDataListener() + \" prefetch data: \"\n-              + listener.isPrefetchData()) {\n-        @Override\n-        public void run()\n-            throws Exception {\n-          Object data;\n-          // TODO: are we fetching the data multiple times?\n-          if (listener.isPrefetchData()) {\n-            LOG.debug(\"Prefetch data for path: {}\", path);\n-            try {\n-              data = readData(path, null, true);\n-            } catch (ZkNoNodeException e) {\n-              LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            listener.getDataListener().handleDataChange(path, data);\n-          }\n-        }\n-      };\n-\n-      _eventThread.send(zkEvent);\n-    }\n-  }\n-\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean isPathExist) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!isPathExist) {\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n+            }\n+            if (!pathStatRecord.pathExists()) {\n               // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            if (!pathStatRecord.isPathChecked()) {\n-              // Reinstall watch before listener callbacks to check the znode status\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n-            }\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NjE3MQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r368066171", "bodyText": "Question: main Helix paths (like /IDEALSTATES, /CONFIG, etc) do not get deleted, so I am wondering if this is really meaningful?\nI think handling deleted/non-existent ZNodes might be more effective for children ZNodes? Like not the main IDEALSTATES path, but the IdealState ZNodes inside it.", "author": "narendly", "createdAt": "2020-01-17T18:06:50Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1258,62 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n+        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n       }\n     }\n   }\n \n+  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n+    for (final IZkDataListenerEntry listener : listeners) {\n+      ZkEvent zkEvent = new ZkEvent(\n+          \"Data of \" + path + \" changed sent to \" + listener.getDataListener() + \" prefetch data: \"\n+              + listener.isPrefetchData()) {\n+        @Override\n+        public void run()\n+            throws Exception {\n+          Object data;\n+          // TODO: are we fetching the data multiple times?\n+          if (listener.isPrefetchData()) {\n+            LOG.debug(\"Prefetch data for path: {}\", path);\n+            try {\n+              data = readData(path, null, true);\n+            } catch (ZkNoNodeException e) {\n+              LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n+              listener.getDataListener().handleDataDeleted(path);\n+              return;\n+            }\n+            listener.getDataListener().handleDataChange(path, data);\n+          }\n+        }\n+      };\n+\n+      _eventThread.send(zkEvent);\n+    }\n+  }\n+\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final OptionalLong notificationTime) {\n+      final long notificationTime, final boolean isPathExist) {\n+    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);", "originalCommit": "d0405a53b2ff01eb60b877cbec6b27f90333861a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Njk5Mw==", "url": "https://github.com/apache/helix/pull/688#discussion_r368196993", "bodyText": "The truth is: currently both exists listener and child listener are listening on the path (e.g /IDEALSTATES/db32). When the db32 path is removed, both types of listeners will get triggered and they should be (cannot avoid it) unless doing additional checks on the path (check if it's Helix main path or not).\nThe child change handler needs to handle the child node change. Then a re-installation of a child handler needs to happen.\nThe data change handler also gets triggered to handle the data change. In the deletion case, because of the existing code, we'll add the unwanted watcher again onto the deleted path. With the fix, it will avoid adding the unwanted watcher and the logic applies to every path in Znode", "author": "i3wangyi", "createdAt": "2020-01-18T01:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NjE3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 403c92216..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1258,62 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n     }\n   }\n \n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    for (final IZkDataListenerEntry listener : listeners) {\n-      ZkEvent zkEvent = new ZkEvent(\n-          \"Data of \" + path + \" changed sent to \" + listener.getDataListener() + \" prefetch data: \"\n-              + listener.isPrefetchData()) {\n-        @Override\n-        public void run()\n-            throws Exception {\n-          Object data;\n-          // TODO: are we fetching the data multiple times?\n-          if (listener.isPrefetchData()) {\n-            LOG.debug(\"Prefetch data for path: {}\", path);\n-            try {\n-              data = readData(path, null, true);\n-            } catch (ZkNoNodeException e) {\n-              LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            listener.getDataListener().handleDataChange(path, data);\n-          }\n-        }\n-      };\n-\n-      _eventThread.send(zkEvent);\n-    }\n-  }\n-\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean isPathExist) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!isPathExist) {\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n+            }\n+            if (!pathStatRecord.pathExists()) {\n               // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            if (!pathStatRecord.isPathChecked()) {\n-              // Reinstall watch before listener callbacks to check the znode status\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n-            }\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwMTYyMQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r368301621", "bodyText": "I did not see the value of changing this. If you feel this is necessary, please make it for separate PR as it does impact logic and purely code refactoring.", "author": "junkaixue", "createdAt": "2020-01-19T15:19:02Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -145,32 +145,28 @@ public int hashCode() {\n \n   private class ZkPathStatRecord {\n     private final String _path;\n-    private Stat _stat = null;\n-    private boolean _checked = false;\n+    private AtomicBoolean _isChecked = new AtomicBoolean(false);\n \n-    public ZkPathStatRecord(String path) {\n+    ZkPathStatRecord(String path) {\n       _path = path;\n     }\n \n-    public boolean pathExists() {\n-      return _stat != null;\n-    }\n-\n-    public boolean pathChecked() {\n-      return _checked;\n+    boolean isPathChecked() {\n+      return _isChecked.get();\n     }\n \n     /*\n      * Note this method is not thread safe.\n      */\n-    public void recordPathStat(Stat stat, OptionalLong notificationTime) {\n-      _checked = true;\n-      _stat = stat;\n-\n-      if (_monitor != null && stat != null && notificationTime.isPresent()) {\n+    void recordPathStat(Stat stat, long notificationTime) {\n+      if (isPathChecked()) {\n+        return;\n+      }\n+      _isChecked.set(true);\n+      if (_monitor != null && stat != null) {\n         long updateTime = Math.max(stat.getCtime(), stat.getMtime());\n-        if (notificationTime.getAsLong() > updateTime) {\n-          _monitor.recordDataPropagationLatency(_path, notificationTime.getAsLong() - updateTime);\n+        if (notificationTime > updateTime) {\n+          _monitor.recordDataPropagationLatency(_path, notificationTime - updateTime);", "originalCommit": "4956c04d9c8ab4b50d497ea64455ca1ee5c81758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyMDYzNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r372120634", "bodyText": "The latest changes will not need to touch the existing codes too much, so it's no longer valid. Could you take another look, thanks?", "author": "i3wangyi", "createdAt": "2020-01-28T23:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwMTYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex a078e6d03..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -145,28 +145,32 @@ public class ZkClient implements Watcher {\n \n   private class ZkPathStatRecord {\n     private final String _path;\n-    private AtomicBoolean _isChecked = new AtomicBoolean(false);\n+    private Stat _stat = null;\n+    private boolean _checked = false;\n \n-    ZkPathStatRecord(String path) {\n+    public ZkPathStatRecord(String path) {\n       _path = path;\n     }\n \n-    boolean isPathChecked() {\n-      return _isChecked.get();\n+    public boolean pathExists() {\n+      return _stat != null;\n+    }\n+\n+    public boolean pathChecked() {\n+      return _checked;\n     }\n \n     /*\n      * Note this method is not thread safe.\n      */\n-    void recordPathStat(Stat stat, long notificationTime) {\n-      if (isPathChecked()) {\n-        return;\n-      }\n-      _isChecked.set(true);\n-      if (_monitor != null && stat != null) {\n+    public void recordPathStat(Stat stat, OptionalLong notificationTime) {\n+      _checked = true;\n+      _stat = stat;\n+\n+      if (_monitor != null && stat != null && notificationTime.isPresent()) {\n         long updateTime = Math.max(stat.getCtime(), stat.getMtime());\n-        if (notificationTime > updateTime) {\n-          _monitor.recordDataPropagationLatency(_path, notificationTime - updateTime);\n+        if (notificationTime.getAsLong() > updateTime) {\n+          _monitor.recordDataPropagationLatency(_path, notificationTime.getAsLong() - updateTime);\n         } // else, the node was updated again after the notification. Propagation latency is\n           // unavailable.\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwMTk2OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368301968", "bodyText": "I do see some duplicated code between these three methods. Can you combine the logic to optimize the code structure.", "author": "junkaixue", "createdAt": "2020-01-19T15:24:44Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1257,75 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean pathExists = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n+        fireDataChangedEvents(event.getPath(), listeners, notificationTime, pathExists);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * The method is called when state change occurs and we need to handle existing path data handlers\n+   */\n+  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {", "originalCommit": "4956c04d9c8ab4b50d497ea64455ca1ee5c81758", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex a078e6d03..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1257,75 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean pathExists = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, pathExists);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * The method is called when state change occurs and we need to handle existing path data handlers\n-   */\n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    try {\n-      for (final IZkDataListenerEntry listener : listeners) {\n-        ZkEvent zkEvent = new ZkEvent(\n-            \"Data of \" + path + \" changed sent to \" + listener.getDataListener()\n-                + \" prefetch data: \" + listener.isPrefetchData()) {\n-          @Override\n-          public void run()\n-              throws Exception {\n-            Object data;\n-            // TODO: are we fetching the data multiple times?\n-            if (listener.isPrefetchData()) {\n-              LOG.debug(\"Prefetch data for path: {}\", path);\n-              try {\n-                data = readData(path, null, true);\n-              } catch (ZkNoNodeException e) {\n-                LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-                listener.getDataListener().handleDataDeleted(path);\n-                return;\n-              }\n-              listener.getDataListener().handleDataChange(path, data);\n-            }\n-          }\n-        };\n-\n-        _eventThread.send(zkEvent);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to fire data changed event for path: {}\", path, e);\n     }\n   }\n \n-  /**\n-   * It differs from {@link #fireDataChangedEvents(String, Set)} that the method is called\n-   * upon callback notification on the path\n-   */\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean pathExists) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!pathExists) {\n-              // since the path no longer exists, ONLY need to handle data deleted listener\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            // Make sure the propagation latency will only be reported once\n-            // even when multiple listeners of the path exist\n-            if (!pathStatRecord.isPathChecked()) {\n-              // The watcher will be re-installed\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n+            if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n+              listener.getDataListener().handleDataDeleted(path);\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjQwMA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368312400", "bodyText": "Can you please explain why we need to change this value to Atomic?", "author": "jiajunwang", "createdAt": "2020-01-19T18:26:35Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -145,32 +145,28 @@ public int hashCode() {\n \n   private class ZkPathStatRecord {\n     private final String _path;\n-    private Stat _stat = null;\n-    private boolean _checked = false;\n+    private AtomicBoolean _isChecked = new AtomicBoolean(false);", "originalCommit": "4956c04d9c8ab4b50d497ea64455ca1ee5c81758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTQ1OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r370329459", "bodyText": "It was my simple try to make it thread-safe, the atomic has the ability though; Do you have concrete suggestions on how to use it?", "author": "i3wangyi", "createdAt": "2020-01-23T20:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzQ3Mg==", "url": "https://github.com/apache/helix/pull/688#discussion_r370337472", "bodyText": "But is it really necessary to use atomic? Is there a clue that there would be concurrency issue?", "author": "huizhilu", "createdAt": "2020-01-23T20:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NzU4OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r371547589", "bodyText": "@pkuwm I agree it's not necessary (my understanding of this code currently involves no multi-threading; To make it thread-safe with a simple atomic boolean is merely a simple try.\n@jiajunwang @pkuwm The latest updates involve little changes on the existing code, it's no longer needed plus I don't really want to improve (refactor) the existing ones :)", "author": "i3wangyi", "createdAt": "2020-01-27T23:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex a078e6d03..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -145,28 +145,32 @@ public class ZkClient implements Watcher {\n \n   private class ZkPathStatRecord {\n     private final String _path;\n-    private AtomicBoolean _isChecked = new AtomicBoolean(false);\n+    private Stat _stat = null;\n+    private boolean _checked = false;\n \n-    ZkPathStatRecord(String path) {\n+    public ZkPathStatRecord(String path) {\n       _path = path;\n     }\n \n-    boolean isPathChecked() {\n-      return _isChecked.get();\n+    public boolean pathExists() {\n+      return _stat != null;\n+    }\n+\n+    public boolean pathChecked() {\n+      return _checked;\n     }\n \n     /*\n      * Note this method is not thread safe.\n      */\n-    void recordPathStat(Stat stat, long notificationTime) {\n-      if (isPathChecked()) {\n-        return;\n-      }\n-      _isChecked.set(true);\n-      if (_monitor != null && stat != null) {\n+    public void recordPathStat(Stat stat, OptionalLong notificationTime) {\n+      _checked = true;\n+      _stat = stat;\n+\n+      if (_monitor != null && stat != null && notificationTime.isPresent()) {\n         long updateTime = Math.max(stat.getCtime(), stat.getMtime());\n-        if (notificationTime > updateTime) {\n-          _monitor.recordDataPropagationLatency(_path, notificationTime - updateTime);\n+        if (notificationTime.getAsLong() > updateTime) {\n+          _monitor.recordDataPropagationLatency(_path, notificationTime.getAsLong() - updateTime);\n         } // else, the node was updated again after the notification. Propagation latency is\n           // unavailable.\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjY0OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368312648", "bodyText": "This might be a potential bug. For example,\nT1: node deleted, and NodeDeleted is sent.\nT2: node is re-created\nT3: The NodeDeleted event is processed, pathExists is set to false. And it is NOT the truth!\nThis might be OK, since we will have another event coming later. But it may introduce a substantial change of the ZkClient behavior. So I would prefer if we don't do it. The minimum fix itself does not require this enhancement. Please correct me if I am wrong.", "author": "jiajunwang", "createdAt": "2020-01-19T18:31:13Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1257,75 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean pathExists = event.getType() != EventType.NodeDeleted;", "originalCommit": "4956c04d9c8ab4b50d497ea64455ca1ee5c81758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzMjA4OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r370332089", "bodyText": "It's an interesting case though I don't think it will introduce any new substantial change to the behavior. Given ZK's consistency, the node recreation event will guarantee to arrive later than the node deletion event. Let me explain fundamentally what happens on handleNodeDeleted, it unsubscribes the listener entry in zkClient (it can be confirmed that all operations are all in-memory operations without any ZK relations);\nWhen the T2 node re-creation event gets processed, it will re-subscribe the listener just like it has never seen it before.", "author": "i3wangyi", "createdAt": "2020-01-23T20:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MTQ5MQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r370341491", "bodyText": "I think you don't have to check pathExits here and pass it to fireDataChangedEvents(). Instead, you can check the condition within fireDataChangedEvents. The pro is the api can avoid the boolean param and 2 logic branches in fireDataChangedEvents. If it is a DELETED event, you will call handleDataDeleted.", "author": "huizhilu", "createdAt": "2020-01-23T20:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NzczOQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r371547739", "bodyText": "No longer valid comment since the new change doesn't modify the existing codes that much", "author": "i3wangyi", "createdAt": "2020-01-27T23:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMjY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex a078e6d03..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1257,75 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean pathExists = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, pathExists);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * The method is called when state change occurs and we need to handle existing path data handlers\n-   */\n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    try {\n-      for (final IZkDataListenerEntry listener : listeners) {\n-        ZkEvent zkEvent = new ZkEvent(\n-            \"Data of \" + path + \" changed sent to \" + listener.getDataListener()\n-                + \" prefetch data: \" + listener.isPrefetchData()) {\n-          @Override\n-          public void run()\n-              throws Exception {\n-            Object data;\n-            // TODO: are we fetching the data multiple times?\n-            if (listener.isPrefetchData()) {\n-              LOG.debug(\"Prefetch data for path: {}\", path);\n-              try {\n-                data = readData(path, null, true);\n-              } catch (ZkNoNodeException e) {\n-                LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-                listener.getDataListener().handleDataDeleted(path);\n-                return;\n-              }\n-              listener.getDataListener().handleDataChange(path, data);\n-            }\n-          }\n-        };\n-\n-        _eventThread.send(zkEvent);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to fire data changed event for path: {}\", path, e);\n     }\n   }\n \n-  /**\n-   * It differs from {@link #fireDataChangedEvents(String, Set)} that the method is called\n-   * upon callback notification on the path\n-   */\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean pathExists) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!pathExists) {\n-              // since the path no longer exists, ONLY need to handle data deleted listener\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            // Make sure the propagation latency will only be reported once\n-            // even when multiple listeners of the path exist\n-            if (!pathStatRecord.isPathChecked()) {\n-              // The watcher will be re-installed\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n+            if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n+              listener.getDataListener().handleDataDeleted(path);\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMzQ3OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368313478", "bodyText": "The answer is yes. There is a solution, can we do the same as the other methods so as to avoid multiple reads?", "author": "jiajunwang", "createdAt": "2020-01-19T18:46:53Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1257,75 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean pathExists = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n+        fireDataChangedEvents(event.getPath(), listeners, notificationTime, pathExists);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * The method is called when state change occurs and we need to handle existing path data handlers\n+   */\n+  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n+    try {\n+      for (final IZkDataListenerEntry listener : listeners) {\n+        ZkEvent zkEvent = new ZkEvent(\n+            \"Data of \" + path + \" changed sent to \" + listener.getDataListener()\n+                + \" prefetch data: \" + listener.isPrefetchData()) {\n+          @Override\n+          public void run()\n+              throws Exception {\n+            Object data;\n+            // TODO: are we fetching the data multiple times?", "originalCommit": "4956c04d9c8ab4b50d497ea64455ca1ee5c81758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzMjM2OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r370332369", "bodyText": "I will make it a formal TODO and let's first focus on the watcher leakage issue :)", "author": "i3wangyi", "createdAt": "2020-01-23T20:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxMzQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex a078e6d03..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1257,75 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean pathExists = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, pathExists);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * The method is called when state change occurs and we need to handle existing path data handlers\n-   */\n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    try {\n-      for (final IZkDataListenerEntry listener : listeners) {\n-        ZkEvent zkEvent = new ZkEvent(\n-            \"Data of \" + path + \" changed sent to \" + listener.getDataListener()\n-                + \" prefetch data: \" + listener.isPrefetchData()) {\n-          @Override\n-          public void run()\n-              throws Exception {\n-            Object data;\n-            // TODO: are we fetching the data multiple times?\n-            if (listener.isPrefetchData()) {\n-              LOG.debug(\"Prefetch data for path: {}\", path);\n-              try {\n-                data = readData(path, null, true);\n-              } catch (ZkNoNodeException e) {\n-                LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-                listener.getDataListener().handleDataDeleted(path);\n-                return;\n-              }\n-              listener.getDataListener().handleDataChange(path, data);\n-            }\n-          }\n-        };\n-\n-        _eventThread.send(zkEvent);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to fire data changed event for path: {}\", path, e);\n     }\n   }\n \n-  /**\n-   * It differs from {@link #fireDataChangedEvents(String, Set)} that the method is called\n-   * upon callback notification on the path\n-   */\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean pathExists) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!pathExists) {\n-              // since the path no longer exists, ONLY need to handle data deleted listener\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            // Make sure the propagation latency will only be reported once\n-            // even when multiple listeners of the path exist\n-            if (!pathStatRecord.isPathChecked()) {\n-              // The watcher will be re-installed\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n+            if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n+              listener.getDataListener().handleDataDeleted(path);\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2ODQ4NA==", "url": "https://github.com/apache/helix/pull/688#discussion_r368068484", "bodyText": "I think you can refactor fireDataChangedEvents(path, listeners, notificationTime, isPathExist) a bit, which fireDataChangedEvents(path, listeners) can call. So we would avoid duplicate code and 2 branches of logic.", "author": "huizhilu", "createdAt": "2020-01-17T18:12:42Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1261,31 +1258,62 @@ private void processDataOrChildChange(WatchedEvent event, long notificationTime)\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n+      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n+        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n       }\n     }\n   }\n \n+  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {", "originalCommit": "d0405a53b2ff01eb60b877cbec6b27f90333861a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29019600639d59d911ab34850c6202cbf0bcdb9d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 403c92216..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1258,62 +1267,30 @@ public class ZkClient implements Watcher {\n \n     if (event.getType() == EventType.NodeDataChanged || event.getType() == EventType.NodeDeleted\n         || event.getType() == EventType.NodeCreated) {\n-      boolean isPathExist = event.getType() != EventType.NodeDeleted;\n       Set<IZkDataListenerEntry> listeners = _dataListener.get(path);\n       if (listeners != null && !listeners.isEmpty()) {\n-        fireDataChangedEvents(event.getPath(), listeners, notificationTime, isPathExist);\n+        fireDataChangedEvents(event.getPath(), listeners, OptionalLong.of(notificationTime));\n       }\n     }\n   }\n \n-  private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners) {\n-    for (final IZkDataListenerEntry listener : listeners) {\n-      ZkEvent zkEvent = new ZkEvent(\n-          \"Data of \" + path + \" changed sent to \" + listener.getDataListener() + \" prefetch data: \"\n-              + listener.isPrefetchData()) {\n-        @Override\n-        public void run()\n-            throws Exception {\n-          Object data;\n-          // TODO: are we fetching the data multiple times?\n-          if (listener.isPrefetchData()) {\n-            LOG.debug(\"Prefetch data for path: {}\", path);\n-            try {\n-              data = readData(path, null, true);\n-            } catch (ZkNoNodeException e) {\n-              LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-              listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            listener.getDataListener().handleDataChange(path, data);\n-          }\n-        }\n-      };\n-\n-      _eventThread.send(zkEvent);\n-    }\n-  }\n-\n   private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry> listeners,\n-      final long notificationTime, final boolean isPathExist) {\n-    final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n+      final OptionalLong notificationTime) {\n     try {\n+      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       // Trigger listener callbacks\n       for (final IZkDataListenerEntry listener : listeners) {\n         _eventThread.send(new ZkEvent(\"Data of \" + path + \" changed sent to \"\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            if (!isPathExist) {\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n+            }\n+            if (!pathStatRecord.pathExists()) {\n               // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            if (!pathStatRecord.isPathChecked()) {\n-              // Reinstall watch before listener callbacks to check the znode status\n-              Stat stat = getStat(path, true);\n-              pathStatRecord.recordPathStat(stat, notificationTime);\n-            }\n+            } else {\n               Object data = null;\n               if (listener.isPrefetchData()) {\n                 if (LOG.isDebugEnabled()) {\n"}}, {"oid": "29019600639d59d911ab34850c6202cbf0bcdb9d", "url": "https://github.com/apache/helix/commit/29019600639d59d911ab34850c6202cbf0bcdb9d", "message": "Fix the zk watcher leakage issue\n- reinstall the watchers before handling the event\n- then event handling logic doesn't need to re-install the watcher anymore", "committedDate": "2020-01-27T23:36:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTI1MA==", "url": "https://github.com/apache/helix/pull/688#discussion_r372135250", "bodyText": "Do you change this list initialization from null to an instance for the later for loop? But do you expect the listener will be removed in any case in handleChildChange? From the code in handleChildChange, if children is not null, the listener will not be removed.", "author": "huizhilu", "createdAt": "2020-01-29T00:35:58Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1310,26 +1318,30 @@ public void run() throws Exception {\n   }\n \n   private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n+    //TODO: Use event type to check if path exists and save network request\n+    boolean pathExists = exists(path);\n     try {\n-      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n-            if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path)),\n-                  OptionalLong.empty());\n-            }\n-            List<String> children = null;\n-            if (pathStatRecord.pathExists()) {\n+            List<String> children = new ArrayList<>();", "originalCommit": "6571dd9411cc482583606a58f2c39f91e9db91a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0MjQzMQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r372142431", "bodyText": "Thanks for mentioning it! You're talking about CallbackHandler's implementation, right? I just checked you're right, that CallbackHandler does rely on the NULL to remove the listener.\nTo me, it's very odd cause it obviously violates the decoupling principle while 2 different classes are so tightly correlated, also it doesn't make sense to pass a NULL variable.\nI will put a TODO and leave the current code as it is. But still, need to add the child exists watcher part.", "author": "i3wangyi", "createdAt": "2020-01-29T01:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 536c3500b..d6f832025 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1317,31 +1306,29 @@ public class ZkClient implements Watcher {\n     }\n   }\n \n-  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n-    //TODO: Use event type to check if path exists and save network request\n-    boolean pathExists = exists(path);\n+  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners, boolean pathExists) {\n     try {\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            List<String> children = new ArrayList<>();\n+            List<String> children = null;\n             if (pathExists) {\n               try {\n-                //TODO: duplicate read happen when multiple child listener exists\n-                // if path exists, still necessary to catch the NoNodeException? (the exception occurs under race-condition)\n+                //TODO: duplicate reads when multiple child listener exists\n                 children = getChildren(path);\n+                if (children != null) {\n+                  for (String child : children) {\n+                    // add the exists watcher for all child path, it's to prevent watcher missing\n+                    // in case of node recreation shortly after deletion\n+                    watchForData(path + \"/\" + child);\n+                  }\n+                }\n               } catch (ZkNoNodeException e) {\n                 LOG.warn(\"Get children under path: {} failed.\", path, e);\n-                //TODO: still handle child change if getting children failed?\n                 // Continue trigger the change handler\n               }\n             }\n-            for (String child : children) {\n-              // add the exists watcher for all child path, it's to prevent watcher missing\n-              // in case of node recreation shortly after deletion\n-              watchForData(path + \"/\" + child);\n-            }\n             listener.handleChildChange(path, children);\n           }\n         });\n"}}, {"oid": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "url": "https://github.com/apache/helix/commit/619eb4810770a5c1c03c1790afb198b6842c8cc8", "message": "Realize the zookeeper process thread and zkClient thread run differently, update the PR", "committedDate": "2020-01-30T02:15:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNTA5NQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r373225095", "bodyText": "Do we have a new place to debug log delete event? I didn't see it in this PR. Please confirm. If we don't have, let's keep it here.", "author": "jiajunwang", "createdAt": "2020-01-30T22:20:23Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -904,13 +904,6 @@ public void process(WatchedEvent event) {\n         || event.getType() == Event.EventType.NodeCreated\n         || event.getType() == Event.EventType.NodeChildrenChanged;\n \n-    if (event.getType() == Event.EventType.NodeDeleted) {", "originalCommit": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNTIxNw==", "url": "https://github.com/apache/helix/pull/688#discussion_r373225217", "bodyText": "Feel free to enrich the log message though.", "author": "jiajunwang", "createdAt": "2020-01-30T22:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5Mjk4Ng==", "url": "https://github.com/apache/helix/pull/688#discussion_r373692986", "bodyText": "updated. The removal is not intended", "author": "i3wangyi", "createdAt": "2020-01-31T21:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex d6f832025..c347fa4ec 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -903,6 +903,9 @@ public class ZkClient implements Watcher {\n         || event.getType() == Event.EventType.NodeDeleted\n         || event.getType() == Event.EventType.NodeCreated\n         || event.getType() == Event.EventType.NodeChildrenChanged;\n+    if (event.getType() == EventType.NodeDeleted) {\n+      LOG.debug(\"Path {} is deleted\", event.getPath());\n+    }\n \n     getEventLock().lock();\n     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r373227348", "bodyText": "This will remove our previous improvement for multiple listeners. Why we remove it?", "author": "jiajunwang", "createdAt": "2020-01-30T22:26:06Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1309,22 +1306,24 @@ public void run() throws Exception {\n     }\n   }\n \n-  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n+  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners, boolean pathExists) {\n     try {\n-      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n-            if (!pathStatRecord.pathChecked()) {", "originalCommit": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzMjEzNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r373232134", "bodyText": "You can just change the condition from hasListeners(path) to pathExists && hasListeners(path), right?", "author": "jiajunwang", "createdAt": "2020-01-30T22:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NTczMg==", "url": "https://github.com/apache/helix/pull/688#discussion_r373695732", "bodyText": "I checked the code in recordPathStat, basically, the line pathStatRecord.recordPathStat(getStat(path, hasListeners(path)), OptionalLong.empty()); does nothing! This is because notificationTime is optional.empty() and the propogation latency is never recorded when child change events.\nI feel like leaving this piece of code here will just make ourselves confused. And if in the future, we do need to record propagation latency for child events. We could add it back.\nSecond, getStat(path, hasListeners(path)) will add a exists watcher for the parent path (child listener). Don't we want to add watcher type of child? The code here looks problematic for me, please clarify the original purpose if I misunderstand it. Thanks!", "author": "i3wangyi", "createdAt": "2020-01-31T21:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxOTc4Mw==", "url": "https://github.com/apache/helix/pull/688#discussion_r375019783", "bodyText": "Seems to me that we can keep the same style as fireDataChangeEvent\n`\nif (!pathStatRecord.pathChecked()) {\npathStatRecord.recordPathStat(getStat(path, pathExists), OptionalLong.empty());\n}\n// The rest leave it the same\n`", "author": "kaisun2000", "createdAt": "2020-02-05T01:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyNDA2OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375024068", "bodyText": "@kaisun2000 Yes. However, as I replied earlier, this line pathStatRecord.recordPathStat(getStat(path, pathExists), OptionalLong.empty()); does nothing (need to read the exact implemenation) when OptionalLong.empty() is passed in. We're not recording propogation latency for child listeners anyway. It only confuses us AND the getStat() method will possibly add another leaked watch", "author": "i3wangyi", "createdAt": "2020-02-05T02:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyNzMxMA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375027310", "bodyText": "I see. Is it because if (_monitor != null && stat != null && **notificationTime.isPresent())** in the pathStatRecord.recordPathState() implementation?\nThen my question is that before this diff, line 1321 pathStatRecord.recordPathStat(getStat(path, hasListeners(path)), OptionalLong.empty()); still does not really emit metrics either. So my proposal keeps the old behavior? Or did I miss something here?", "author": "kaisun2000", "createdAt": "2020-02-05T02:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMDQyNg==", "url": "https://github.com/apache/helix/pull/688#discussion_r375030426", "bodyText": "@kaisun2000 Yes, keep the same code is fine; Is it really necessary? Why not add it later once we do need to record propagation latency?", "author": "i3wangyi", "createdAt": "2020-02-05T02:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMDg3NA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375030874", "bodyText": "This is actually debatable. I am more into thinking that \" the fix\" just fix the problem, don't introduce non essential change. Or change the metric reporting behavior. One fix for one issue.\nThat said, I don't have strong opinion here. Check with JJ. I am fine either way.", "author": "kaisun2000", "createdAt": "2020-02-05T02:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMTQwNw==", "url": "https://github.com/apache/helix/pull/688#discussion_r375031407", "bodyText": "all right, I will revert this part of change", "author": "i3wangyi", "createdAt": "2020-02-05T02:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex d6f832025..c347fa4ec 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1317,13 +1320,6 @@ public class ZkClient implements Watcher {\n               try {\n                 //TODO: duplicate reads when multiple child listener exists\n                 children = getChildren(path);\n-                if (children != null) {\n-                  for (String child : children) {\n-                    // add the exists watcher for all child path, it's to prevent watcher missing\n-                    // in case of node recreation shortly after deletion\n-                    watchForData(path + \"/\" + child);\n-                  }\n-                }\n               } catch (ZkNoNodeException e) {\n                 LOG.warn(\"Get children under path: {} failed.\", path, e);\n                 // Continue trigger the change handler\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzc3MA==", "url": "https://github.com/apache/helix/pull/688#discussion_r373227770", "bodyText": "This is not necessary, it has been done in the \"listener.handleChildChange(path, children);\" later.", "author": "jiajunwang", "createdAt": "2020-01-30T22:27:05Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1309,22 +1306,24 @@ public void run() throws Exception {\n     }\n   }\n \n-  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n+  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners, boolean pathExists) {\n     try {\n-      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n-            if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path)),\n-                  OptionalLong.empty());\n-            }\n             List<String> children = null;\n-            if (pathStatRecord.pathExists()) {\n+            if (pathExists) {\n               try {\n+                //TODO: duplicate reads when multiple child listener exists\n                 children = getChildren(path);\n+                if (children != null) {\n+                  for (String child : children) {\n+                    // add the exists watcher for all child path, it's to prevent watcher missing\n+                    // in case of node recreation shortly after deletion\n+                    watchForData(path + \"/\" + child);", "originalCommit": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NjgzNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r373696834", "bodyText": "That's true... However, I do feel it's odd to connect the relationship between two separate classes as it violates the separation of concern. I could either delete the added part or just add the change but remove the code path in CallbackListener. Which one do you prefer?\nTo make things easier, I will mark it as a TODO (IMO, Re-install watchers should be the concern of ZkClient(Watcher) class, not CallbackHandler).", "author": "i3wangyi", "createdAt": "2020-01-31T21:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyNzc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex d6f832025..c347fa4ec 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1317,13 +1320,6 @@ public class ZkClient implements Watcher {\n               try {\n                 //TODO: duplicate reads when multiple child listener exists\n                 children = getChildren(path);\n-                if (children != null) {\n-                  for (String child : children) {\n-                    // add the exists watcher for all child path, it's to prevent watcher missing\n-                    // in case of node recreation shortly after deletion\n-                    watchForData(path + \"/\" + child);\n-                  }\n-                }\n               } catch (ZkNoNodeException e) {\n                 LOG.warn(\"Get children under path: {} failed.\", path, e);\n                 // Continue trigger the change handler\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyOTg5NQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r373229895", "bodyText": "You avoided the notificationTime report on the deleting events with this change. Please keep the original order.", "author": "jiajunwang", "createdAt": "2020-01-30T22:32:38Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1278,29 +1276,28 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n+            if (!pathExists) {\n+              listener.getDataListener().handleDataDeleted(path);\n+              return;\n+            }\n             if (!pathStatRecord.pathChecked()) {\n               pathStatRecord.recordPathStat(getStat(path, true), notificationTime);", "originalCommit": "619eb4810770a5c1c03c1790afb198b6842c8cc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzMDExMQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r373230111", "bodyText": "This will invalidate our propagation latency metric, BTW.", "author": "jiajunwang", "createdAt": "2020-01-30T22:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyOTg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NjkyNg==", "url": "https://github.com/apache/helix/pull/688#discussion_r373696926", "bodyText": "Thanks for catching it, fixed it.", "author": "i3wangyi", "createdAt": "2020-01-31T21:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIyOTg5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex d6f832025..c347fa4ec 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1276,13 +1279,13 @@ public class ZkClient implements Watcher {\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n+            if (!pathStatRecord.pathChecked()) {\n+              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+            }\n             if (!pathExists) {\n               listener.getDataListener().handleDataDeleted(path);\n               return;\n             }\n-            if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, true), notificationTime);\n-            }\n             Object data = null;\n             if (listener.isPrefetchData()) {\n               if (LOG.isDebugEnabled()) {\n"}}, {"oid": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "url": "https://github.com/apache/helix/commit/f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "message": "Finalize the integration test for zk watcher", "committedDate": "2020-02-04T23:55:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNzU3OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375017579", "bodyText": "Seems to me all the change from line 1285 is not necessary, right? We can still use the old code.\nThe change may not be wrong, but seems to necessary.\nOr did I miss something here?", "author": "kaisun2000", "createdAt": "2020-02-05T01:34:33Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1278,29 +1279,28 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, true), notificationTime);\n+              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n             }\n-            if (!pathStatRecord.pathExists()) {\n-              // no znode found at the path, trigger data deleted handler.\n+            if (!pathExists) {", "originalCommit": "f456c3cc3995e1cec0dc752f9be0d96d2ea7449d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyNDgzMw==", "url": "https://github.com/apache/helix/pull/688#discussion_r375024833", "bodyText": "Yes, we can keep the old code. I just changed the\nif { } else {} to if () return; xxx to make the code less indent. No function change", "author": "i3wangyi", "createdAt": "2020-02-05T02:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyNTkxNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375025914", "bodyText": "How about let us keep the old code. The thing is that later if people looking at the change, it would take some time to figure out there is not really logical change here.\nThis is more of a beautification work. This may look better, but for fix, can be confusing.", "author": "kaisun2000", "createdAt": "2020-02-05T02:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMDU1NQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375030555", "bodyText": "Sure, reverted the style", "author": "i3wangyi", "createdAt": "2020-02-05T02:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNzU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex c347fa4ec..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1280,27 +1285,27 @@ public class ZkClient implements Watcher {\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n-            if (!pathExists) {\n+            if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n-              return;\n-            }\n-            Object data = null;\n-            if (listener.isPrefetchData()) {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Prefetch data for path: {}\", path);\n-              }\n-              try {\n-                // TODO: the data is redundantly read multiple times when multiple listeners exist\n-                data = readData(path, null, true);\n-              } catch (ZkNoNodeException e) {\n-                LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n-                listener.getDataListener().handleDataDeleted(path);\n-                return;\n+            } else {\n+              Object data = null;\n+              if (listener.isPrefetchData()) {\n+                if (LOG.isDebugEnabled()) {\n+                  LOG.debug(\"Prefetch data for path: {}\", path);\n+                }\n+                try {\n+                  data = readData(path, null, true);\n+                } catch (ZkNoNodeException e) {\n+                  LOG.warn(\"Prefetch data for path: {} failed.\", path, e);\n+                  listener.getDataListener().handleDataDeleted(path);\n+                  return;\n+                }\n               }\n+              listener.getDataListener().handleDataChange(path, data);\n             }\n-            listener.getDataListener().handleDataChange(path, data);\n           }\n         });\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzM3OA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375033378", "bodyText": "Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962.  THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?", "author": "kaisun2000", "createdAt": "2020-02-05T02:41:28Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -960,10 +956,10 @@ public void process(WatchedEvent event) {\n \n   private void fireAllEvents() {\n     for (Entry<String, Set<IZkChildListener>> entry : _childListener.entrySet()) {\n-      fireChildChangedEvents(entry.getKey(), entry.getValue());\n+      fireChildChangedEvents(entry.getKey(), entry.getValue(), true);\n     }\n     for (Entry<String, Set<IZkDataListenerEntry>> entry : _dataListener.entrySet()) {\n-      fireDataChangedEvents(entry.getKey(), entry.getValue(), OptionalLong.empty());\n+      fireDataChangedEvents(entry.getKey(), entry.getValue());", "originalCommit": "2624b5709322454a40057680feca36149961738e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzgxOQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375033819", "bodyText": "This private void fireAllEvents() will be invoked when session expiry and handle the new session. I think it will be used to initialize the states; Thus it makes sense to assume the path exists", "author": "i3wangyi", "createdAt": "2020-02-05T02:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzNDUxMQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375034511", "bodyText": "I see. By default it is true.", "author": "kaisun2000", "createdAt": "2020-02-05T02:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzNDU5Mw==", "url": "https://github.com/apache/helix/pull/688#discussion_r375034593", "bodyText": "Actually I could remove the overloading method by passing the default value here", "author": "i3wangyi", "createdAt": "2020-02-05T02:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzM3OA=="}], "type": "inlineReview", "revised_code": {"commit": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 4545e4e6a..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -956,10 +966,10 @@ public class ZkClient implements Watcher {\n \n   private void fireAllEvents() {\n     for (Entry<String, Set<IZkChildListener>> entry : _childListener.entrySet()) {\n-      fireChildChangedEvents(entry.getKey(), entry.getValue(), true);\n+      fireChildChangedEvents(entry.getKey(), entry.getValue());\n     }\n     for (Entry<String, Set<IZkDataListenerEntry>> entry : _dataListener.entrySet()) {\n-      fireDataChangedEvents(entry.getKey(), entry.getValue());\n+      fireDataChangedEvents(entry.getKey(), entry.getValue(), OptionalLong.empty());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzUwOA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375033508", "bodyText": "nit: if (pathStatRecord.pathExists()) would also work here.", "author": "kaisun2000", "createdAt": "2020-02-05T02:42:03Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1309,21 +1309,21 @@ public void run() throws Exception {\n     }\n   }\n \n-  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n+  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners, boolean pathExists) {\n     try {\n       final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path)),\n+              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && !pathExists),\n                   OptionalLong.empty());\n             }\n             List<String> children = null;\n-            if (pathStatRecord.pathExists()) {\n+            if (pathExists) {", "originalCommit": "2624b5709322454a40057680feca36149961738e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzNDE4MQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375034181", "bodyText": "updated", "author": "i3wangyi", "createdAt": "2020-02-05T02:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 4545e4e6a..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1309,21 +1314,16 @@ public class ZkClient implements Watcher {\n     }\n   }\n \n-  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners, boolean pathExists) {\n+  private void fireChildChangedEvents(final String path, Set<IZkChildListener> childListeners) {\n+    boolean pathExists = exists(path);\n     try {\n-      final ZkPathStatRecord pathStatRecord = new ZkPathStatRecord(path);\n       for (final IZkChildListener listener : childListeners) {\n         _eventThread.send(new ZkEvent(\"Children of \" + path + \" changed sent to \" + listener) {\n           @Override\n           public void run() throws Exception {\n-            if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, hasListeners(path) && !pathExists),\n-                  OptionalLong.empty());\n-            }\n             List<String> children = null;\n             if (pathExists) {\n               try {\n-                //TODO: duplicate reads when multiple child listener exists\n                 children = getChildren(path);\n               } catch (ZkNoNodeException e) {\n                 LOG.warn(\"Get children under path: {} failed.\", path, e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzczNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375033734", "bodyText": "nit: if (!pathStatRecord.pathExists()) also works here.", "author": "kaisun2000", "createdAt": "2020-02-05T02:43:03Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1278,12 +1279,10 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, true), notificationTime);\n+              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n             }\n-            if (!pathStatRecord.pathExists()) {\n-              // no znode found at the path, trigger data deleted handler.\n+            if (!pathExists) {", "originalCommit": "2624b5709322454a40057680feca36149961738e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzNDE2MA==", "url": "https://github.com/apache/helix/pull/688#discussion_r375034160", "bodyText": "updated", "author": "i3wangyi", "createdAt": "2020-02-05T02:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzMzczNA=="}], "type": "inlineReview", "revised_code": {"commit": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 4545e4e6a..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1280,9 +1285,10 @@ public class ZkClient implements Watcher {\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n-            if (!pathExists) {\n+            if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n             } else {\n               Object data = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MTA3OQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375461079", "bodyText": "Can you add a comment like this? We reinstall watch based on the node has been deleted or not.", "author": "junkaixue", "createdAt": "2020-02-05T19:27:52Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -1278,12 +1275,10 @@ private void fireDataChangedEvents(final String path, Set<IZkDataListenerEntry>\n             + listener.getDataListener() + \" prefetch data: \" + listener.isPrefetchData()) {\n           @Override\n           public void run() throws Exception {\n-            // Reinstall watch before listener callbacks to check the znode status", "originalCommit": "c36398e83e81bc9dafb275338a9bcbd74a8464c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MTA1Ng==", "url": "https://github.com/apache/helix/pull/688#discussion_r375481056", "bodyText": "updated!", "author": "i3wangyi", "createdAt": "2020-02-05T20:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MTA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex ccdea4534..ea4938324 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -1276,9 +1285,10 @@ public class ZkClient implements Watcher {\n           @Override\n           public void run() throws Exception {\n             if (!pathStatRecord.pathChecked()) {\n-              pathStatRecord.recordPathStat(getStat(path, pathExists), notificationTime);\n+              pathStatRecord.recordPathStat(getStat(path), notificationTime);\n             }\n             if (!pathStatRecord.pathExists()) {\n+              // no znode found at the path, trigger data deleted handler.\n               listener.getDataListener().handleDataDeleted(path);\n             } else {\n               Object data = null;\n"}}, {"oid": "ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "url": "https://github.com/apache/helix/commit/ccb9c0caa379ec5f6bcfc0b587ac41c31537be51", "message": "Fix the zk watcher leakage issue\n- reinstall the watchers before handling the event\n- then event handling logic doesn't need to re-install the watcher anymore", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "c61fa0c8ad3d8b41f1e4ee12165bfd647c407c1c", "url": "https://github.com/apache/helix/commit/c61fa0c8ad3d8b41f1e4ee12165bfd647c407c1c", "message": "test and address comments", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "f54b47f41b7d8a9bf75cbc9359dabf9b81e3f6fa", "url": "https://github.com/apache/helix/commit/f54b47f41b7d8a9bf75cbc9359dabf9b81e3f6fa", "message": "Add more TODOs and add exists watcher for all child path when handling child events", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "928b8abbd95cb31ff9c4f74c5d7b3f701ddc6956", "url": "https://github.com/apache/helix/commit/928b8abbd95cb31ff9c4f74c5d7b3f701ddc6956", "message": "Update & leave the children list to be NULL", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "95fb6796b63aff211e9f5c22dadbcd965b492454", "url": "https://github.com/apache/helix/commit/95fb6796b63aff211e9f5c22dadbcd965b492454", "message": "Realize the zookeeper process thread and zkClient thread run differently, update the PR", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "4fcf86f94de59451413d8ce000e7420296d2623f", "url": "https://github.com/apache/helix/commit/4fcf86f94de59451413d8ce000e7420296d2623f", "message": "Address comments", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "794f0e2d6fccc5ab34a1818451b65a6d662bfc42", "url": "https://github.com/apache/helix/commit/794f0e2d6fccc5ab34a1818451b65a6d662bfc42", "message": "Don't review yet, add the integration test case for watcher", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "55dd3029383d0121c79cc714930449070f842094", "url": "https://github.com/apache/helix/commit/55dd3029383d0121c79cc714930449070f842094", "message": "Verify the watches", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "82b6113eea4732346dd6310cb3d7bcba8c7c61a5", "url": "https://github.com/apache/helix/commit/82b6113eea4732346dd6310cb3d7bcba8c7c61a5", "message": "Finalize the integration test for zk watcher", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "0e78b4c99df98b5561c0e8cdbcf360b4887e2e7a", "url": "https://github.com/apache/helix/commit/0e78b4c99df98b5561c0e8cdbcf360b4887e2e7a", "message": "Fix the TestHelixZkClient", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "89fd1702fc382d3870736ffc3ae07264fbd559e8", "url": "https://github.com/apache/helix/commit/89fd1702fc382d3870736ffc3ae07264fbd559e8", "message": "Minor code style change", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "649e2596cb8bc8519417c554fd8ebad9f3c648c8", "url": "https://github.com/apache/helix/commit/649e2596cb8bc8519417c554fd8ebad9f3c648c8", "message": "Revert the old code in fireChildChangedEvents", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "591e81b15c7c6d7c1ab2144d95f495312fc4f0fb", "url": "https://github.com/apache/helix/commit/591e81b15c7c6d7c1ab2144d95f495312fc4f0fb", "message": "Address comments", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "525137eb4609d895cbf4cb5c04d50755d88e4b73", "url": "https://github.com/apache/helix/commit/525137eb4609d895cbf4cb5c04d50755d88e4b73", "message": "Remove the overloading method", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "879422fa0767d45c69563a352e816cdb0648cedb", "url": "https://github.com/apache/helix/commit/879422fa0767d45c69563a352e816cdb0648cedb", "message": "Fix a typo", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "64d4d9f828bee5ed1a4931c1c83d0034ac899605", "url": "https://github.com/apache/helix/commit/64d4d9f828bee5ed1a4931c1c83d0034ac899605", "message": "Update the comment", "committedDate": "2020-02-05T21:31:14Z", "type": "commit"}, {"oid": "64d4d9f828bee5ed1a4931c1c83d0034ac899605", "url": "https://github.com/apache/helix/commit/64d4d9f828bee5ed1a4931c1c83d0034ac899605", "message": "Update the comment", "committedDate": "2020-02-05T21:31:14Z", "type": "forcePushed"}, {"oid": "130a34ce96b341b34e9546d4db2ee98bbc9e5932", "url": "https://github.com/apache/helix/commit/130a34ce96b341b34e9546d4db2ee98bbc9e5932", "message": "Add watcher test for cluster controller", "committedDate": "2020-02-06T01:07:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r375668311", "bodyText": "So while the client is reconnected, it will just reinstall the watcher without checking, right? Will we still see watcher leakage?", "author": "jiajunwang", "createdAt": "2020-02-06T07:05:16Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java", "diffHunk": "@@ -960,10 +956,10 @@ public void process(WatchedEvent event) {\n \n   private void fireAllEvents() {\n     for (Entry<String, Set<IZkChildListener>> entry : _childListener.entrySet()) {\n-      fireChildChangedEvents(entry.getKey(), entry.getValue());\n+      fireChildChangedEvents(entry.getKey(), entry.getValue(), true);", "originalCommit": "130a34ce96b341b34e9546d4db2ee98bbc9e5932", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyMjM3Ng==", "url": "https://github.com/apache/helix/pull/688#discussion_r376022376", "bodyText": "Good question. I think with the default value, it will reinstall the watcher whatever left on the previous session; It's likely the node deletion happens after session expiry, in this case, it will leak; One mitigation approach is to perform EXISTS check when handling new session, but it's always possible a race-condition exists (that the node deletion happen after the exists check).  One good thing though comes with new session is that all the \"leaked\" watchers will be gone.\nDo you think a set of exists check on each path from original session should be performed or it's OK to trade-off between performance and excessive watchers.", "author": "i3wangyi", "createdAt": "2020-02-06T19:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzOTcxMg==", "url": "https://github.com/apache/helix/pull/688#discussion_r376039712", "bodyText": "I still think the fix should be bumping up ZK version. If the concern is not super urgent, we should do that. Clean and no side effects.\nOtherwise, given this issue, a background GC thread would be easier. What I'm thinking is that we have a running timeout for the existing check-in that thread for each watched path.\n\n\nIf delete event, timeout set to zero and trigger GC immediately.\nOtherwise, the GC thread will validate the path after the timeout.", "author": "jiajunwang", "createdAt": "2020-02-06T19:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjExNzQ0Ng==", "url": "https://github.com/apache/helix/pull/688#discussion_r376117446", "bodyText": "I don't think to bump up the ZK version and use the new API to delete ZK watcher explicitly would resolve the problem.\n\nLet me explain why: if the node is re-created after deleting the watcher request is submitted, without the parent path's child listener, there's no way the ZkClient would be able to receive new events from the path. It's the same dilemma this fix is currently facing.\n\nA background GC thread is an over-kill solution. First It's difficult to determine the right TTL; Second, it comes with the additional thread cost.\n\nMy argument point is that it's not always valid to say we need to be 100% stick to the old behavior, especially when the old behavior is incorrect and leading to the excessive amount of leakage.\nThe easiest way is to release a newer Helix version and educate the client with the caveat \"Once a node is deleted, the listener on the path will be inactive even the node is re-created; The workaround is to have a child listener on the parent path or re-subscribe the path\". The statement IMO makes sense to most clients.\nAs to how many clients will be suffering from the behavior change, I don't have a good answer but the experience told me the number is minor if the client is using Helix as a cluster management tool instead of a generic ZKClient proxy.\nDo these all make sense? @kaisun2000 @dasahcc please feel free to leave any thoughts about this, cause it will change the design fundamentally and won't be able to help Venice reduce the watcher pains in any near future.", "author": "i3wangyi", "createdAt": "2020-02-06T22:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNDUxNw==", "url": "https://github.com/apache/helix/pull/688#discussion_r376124517", "bodyText": "The first point is for us to simplify the GC. I agree it won't help with the listener becoming inactive case.\nAnd, about the second part, a behavior change is fine as long as it is reasonable. However, the main concern is that, even with the current design, leakage is still possible, right? Since the watcher removing depends on the notification, if no notification arrived, or the client missed, the watcher will be leaked. That's why I think this design is not good enough. Feel free to fix the current design if there is a way to avoid all leakages.", "author": "jiajunwang", "createdAt": "2020-02-06T22:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNjg4MQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r376126881", "bodyText": "If I understand correctly, @jiajunwang concern is that reconnect happen and fireAllEvent would be triggered and install the watcher for all the paths in subscriber list. The thing is that there can be case that in the disconnecting period, the zkpath can be deleted. This can still leak another path. This is very good point.\nThe first propose fix by @jiajunwang is:\n1/ use exists to re-subscribe in re-connecting phase anyway.\n2/ if path is not there, delete the watcher for this path.\nThis require 3.5 zk feature though. Not feasible now.\nFor the GC approach, what I can see is that this may still be a problem. First you check if the subscribe path is there. If it is not there, you delete it. The problem is that these are two steps operation to ZK. The problem is between the two steps, the user may create the path and install watcher as one operation. Now you delete it. This is even worse than leaking.\nThe second step of the first proposal has the same problem.\nActually I thought about this before, if Zookeeper does not have atomic check if the path not there then delete watcher, it is hard for us to implement this correctly.\n@jiajunwang, what is your take?\nMaybe let us note this issue and have an enhancement task to track it?", "author": "kaisun2000", "createdAt": "2020-02-06T22:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyODIzMg==", "url": "https://github.com/apache/helix/pull/688#discussion_r376128232", "bodyText": "@jiajunwang I agree that during re-connecting, it's still possible to leak the watcher if the in-memory listeners contain already deleted paths; I will think about the case and see if it can be overcome. But we all know at least the case here is not the major leakage point.\nIn fact, the long comment is more about the other one you claimed about changing the existing behavior cause I have to modify the integration test case.", "author": "i3wangyi", "createdAt": "2020-02-06T22:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODAwNA==", "url": "https://github.com/apache/helix/pull/688#discussion_r376628004", "bodyText": "Discussed offline and we reached the consensus that the leakage during session expiry is a potential issue and since the impact of it is minor, we'll create a ticket to track the fixing progress in the future", "author": "i3wangyi", "createdAt": "2020-02-07T22:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY2ODMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3515593299f8e3455d87fc979055dd1096e60ba4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\nindex 4a32782ab..453c8c3c1 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n\n@@ -955,6 +961,7 @@ public class ZkClient implements Watcher {\n   }\n \n   private void fireAllEvents() {\n+    //TODO: During handling new session, if the path is deleted, watcher leakage could still happen\n     for (Entry<String, Set<IZkChildListener>> entry : _childListener.entrySet()) {\n       fireChildChangedEvents(entry.getKey(), entry.getValue(), true);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MDQxMw==", "url": "https://github.com/apache/helix/pull/688#discussion_r375670413", "bodyText": "Usually, I'm very cautious about changing the existing test case. This indicates that we changed the behavior. So after this change, the user will need to resubscribe the watch once it is deleted, right? Regardless of the Helix reserved node that has children change listeners to cover, how about the other zk path that we allow the user to subscribe listener? The listeners will be idle after the node has been removed once, right? This breaks the feature IMO.\nOverall, I think we will need to make it optional. 1. It is fine that we change the behavior for the reserved patch with additional children change listener on the parent node. But for the other random path from user's requests, we should keep the old behavior.", "author": "jiajunwang", "createdAt": "2020-02-06T07:13:31Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/client/TestHelixZkClient.java", "diffHunk": "@@ -163,6 +163,8 @@ public void handleDataDeleted(String s) {\n       // expected to be here.\n     }\n \n+    // client B needs to re-install the data watch\n+    sharedZkClientB.watchForData(TEST_PATH);", "originalCommit": "130a34ce96b341b34e9546d4db2ee98bbc9e5932", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAxMDMyOQ==", "url": "https://github.com/apache/helix/pull/688#discussion_r376010329", "bodyText": "Your concern is valid! To think about it, actually, it is the reason why native zookeeper has 2 sets of path related watcher: exists type and data type. To make a distinction between two, IMO, we either create a new subscribeXXXDataChange method or add a parameter like subscribeDataChange(xx, xx, boolean listenOnNonExistPath = True/False.\nWhat's your opinion? In fact, at the current stage,  do we have users listen on random paths? If not, I think we're creating problems for ourselves.", "author": "i3wangyi", "createdAt": "2020-02-06T18:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MDQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTM0Ng==", "url": "https://github.com/apache/helix/pull/688#discussion_r376041346", "bodyText": "One way is keeping the existing subscription methods the same. But we created some private/protected methods for the HelixManager to use.\nAlternatively, as you said, adding options to the method. It is not optimal but compared with adding more methods, I would prefer to keep it simple now. One improvement is that we extend the listeners so the one keeps existing after delete would be a different listener type internally. Then the callback knows what to do. It helps to keep the methods simple.", "author": "jiajunwang", "createdAt": "2020-02-06T19:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MDQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODI4Mg==", "url": "https://github.com/apache/helix/pull/688#discussion_r376628282", "bodyText": "Discussed offline and we agreed that the behavior change is necessary and the client needs to be aware of the change.", "author": "i3wangyi", "createdAt": "2020-02-07T22:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3MDQxMw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "3515593299f8e3455d87fc979055dd1096e60ba4", "url": "https://github.com/apache/helix/commit/3515593299f8e3455d87fc979055dd1096e60ba4", "message": "Add comment and TODO", "committedDate": "2020-02-07T21:59:27Z", "type": "commit"}]}