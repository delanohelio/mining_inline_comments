{"pr_number": 690, "pr_title": "Reset the WAGED rebalancer once the controller newly acquires leadership.", "pr_createdAt": "2020-01-18T00:47:25Z", "pr_url": "https://github.com/apache/helix/pull/690", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTkxOQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369741919", "bodyText": "Please comment if anyone of you has a better name. This one is not good.", "author": "jiajunwang", "createdAt": "2020-01-22T18:55:44Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/AttributeName.java", "diffHunk": "@@ -38,5 +38,6 @@\n   AsyncFIFOWorkerPool,\n   PipelineType,\n   LastRebalanceFinishTimeStamp,\n-  ControllerDataProvider\n+  ControllerDataProvider,\n+  STATEFUL_REBALANCER", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODAyOQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370758029", "bodyText": "I think now, with the introduction of a StatefulRebalancer interface, having this name makes sense and pretty clear. What do you think?\nAlso, could we follow the enum convention? Use StatefulRebalancer instead?", "author": "narendly", "createdAt": "2020-01-24T17:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc4NDYzMw==", "url": "https://github.com/apache/helix/pull/690#discussion_r370784633", "bodyText": "Thanks for the feedback.\nAs for the convention, it is not really clear to me. So I did some research. There are different opinions. The one that seems to be more reasonable to me is that enum items should be treated as constants, so they should follow constants name convention. Given this, uppercase letters make more sense here. I intend to enforce this as our enum convention unless a different rule has been documented somewhere else that I don't know : )", "author": "jiajunwang", "createdAt": "2020-01-24T18:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MTcwOA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371441708", "bodyText": "Either way is fine - I realized there is no convention for this enum.", "author": "narendly", "createdAt": "2020-01-27T19:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MTkxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1NjQzOQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369856439", "bodyText": "Do you mean that the old controller will continue to process events even after having lost the leadership using the in-memory rebalancer/cache state?", "author": "narendly", "createdAt": "2020-01-22T23:11:57Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -626,6 +631,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n       return;\n     }\n \n+    // Event handling happens in a different thread from the onControllerChange processing thread.\n+    // Thus, there are several possible conditions.\n+    // 1. Event handled after leadership acquired. So we will have a valid rebalancer for the\n+    // event processing.\n+    // 2. Event handled shortly after leadership relinquished. And the rebalancer has not been", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg3MDMxOQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369870319", "bodyText": "The one that is being processed will continue.", "author": "jiajunwang", "createdAt": "2020-01-22T23:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1NjQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -645,7 +651,7 @@ public class GenericHelixController implements IdealStateChangeListener,\n     // the pipeline will be triggered. So the reset rebalancer won't be used before the controller\n     // regains leadership.\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n-        _wagedRebalancerRef.getWagedRebalancer(manager));\n+        _rebalancerRef.getRebalancer(manager));\n \n     if (!manager.isLeader()) {\n       logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1NzAyMQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369857021", "bodyText": "Shouldn't we just discard all events from stale sessions?\nResetting the cache will trigger a fresh, up-to-date global baseline calculation anyways?", "author": "narendly", "createdAt": "2020-01-22T23:13:49Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -626,6 +631,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n       return;\n     }\n \n+    // Event handling happens in a different thread from the onControllerChange processing thread.\n+    // Thus, there are several possible conditions.\n+    // 1. Event handled after leadership acquired. So we will have a valid rebalancer for the\n+    // event processing.\n+    // 2. Event handled shortly after leadership relinquished. And the rebalancer has not been\n+    // marked as invalid yet. So the event will be processed the same as case one.\n+    // 3. Event is leftover from the previous session, and it is handled when the controller", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg3MDg5Mg==", "url": "https://github.com/apache/helix/pull/690#discussion_r369870892", "bodyText": "We should, but there is no good way to do it for now. And even we discard the queued events, the concerning one is actually the one that is being processed. Force canceling that could be risky. So I don't think to do it without deeply improve the pipeline logic is a good idea.", "author": "jiajunwang", "createdAt": "2020-01-22T23:59:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1NzAyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -645,7 +651,7 @@ public class GenericHelixController implements IdealStateChangeListener,\n     // the pipeline will be triggered. So the reset rebalancer won't be used before the controller\n     // regains leadership.\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n-        _wagedRebalancerRef.getWagedRebalancer(manager));\n+        _rebalancerRef.getRebalancer(manager));\n \n     if (!manager.isLeader()) {\n       logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MjEwMA==", "url": "https://github.com/apache/helix/pull/690#discussion_r369862100", "bodyText": "Could you please explain why another pipeline is being triggered when the controller is no longer a leader?", "author": "narendly", "createdAt": "2020-01-22T23:28:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -626,6 +631,22 @@ private void handleEvent(ClusterEvent event, BaseControllerDataProvider dataProv\n       return;\n     }\n \n+    // Event handling happens in a different thread from the onControllerChange processing thread.\n+    // Thus, there are several possible conditions.\n+    // 1. Event handled after leadership acquired. So we will have a valid rebalancer for the\n+    // event processing.\n+    // 2. Event handled shortly after leadership relinquished. And the rebalancer has not been\n+    // marked as invalid yet. So the event will be processed the same as case one.\n+    // 3. Event is leftover from the previous session, and it is handled when the controller\n+    // regains the leadership. The rebalancer will be reset before being used. That is the\n+    // expected behavior so as to avoid inconsistent rebalance result.\n+    // 4. Event handled shortly after leadership relinquished. And the rebalancer has been marked\n+    // as invalid. So we reset the rebalancer. But the later isLeader() check will return false and", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg3MTM3Ng==", "url": "https://github.com/apache/helix/pull/690#discussion_r369871376", "bodyText": "in event thread, check if is leader, return true, so event thread continues\nin the ZK thread, session expired, so handling triggered, and leadership switch is done.\nin the event thread, keep triggering the pipeline.", "author": "jiajunwang", "createdAt": "2020-01-23T00:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MjEwMA=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -645,7 +651,7 @@ public class GenericHelixController implements IdealStateChangeListener,\n     // the pipeline will be triggered. So the reset rebalancer won't be used before the controller\n     // regains leadership.\n     event.addAttribute(AttributeName.STATEFUL_REBALANCER.name(),\n-        _wagedRebalancerRef.getWagedRebalancer(manager));\n+        _rebalancerRef.getRebalancer(manager));\n \n     if (!manager.isLeader()) {\n       logger.error(\"Cluster manager: \" + manager.getInstanceName() + \" is not leader for \" + manager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MzYxMQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369863611", "bodyText": "\"invalidate\"Rebalancer?", "author": "narendly", "createdAt": "2020-01-22T23:33:54Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1259,3 +1287,54 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.start();\n   }\n }\n+\n+/**\n+ * A wrapper class for the WAGED rebalancer instance.\n+ */\n+class WagedRebalancerRef {\n+  private WagedRebalancer _rebalancer = null;\n+  private boolean _isRebalancerValid = true;\n+\n+  private void createWagedRebalancer(HelixManager helixManager) {\n+    // Create WagedRebalancer instance if it hasn't been already initialized\n+    if (_rebalancer == null) {\n+      _rebalancer = new WagedRebalancer(helixManager);\n+      _isRebalancerValid = true;\n+    }\n+  }\n+\n+  /**\n+   * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n+   * the next usage.\n+   */\n+  synchronized void invalidRebalancer() {", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4ODE4MQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r369888181", "bodyText": "Sure, I will update after #696.", "author": "jiajunwang", "createdAt": "2020-01-23T01:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2MzYxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1286,55 +1292,57 @@ public class GenericHelixController implements IdealStateChangeListener,\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n-}\n-\n-/**\n- * A wrapper class for the WAGED rebalancer instance.\n- */\n-class WagedRebalancerRef {\n-  private WagedRebalancer _rebalancer = null;\n-  private boolean _isRebalancerValid = true;\n-\n-  private void createWagedRebalancer(HelixManager helixManager) {\n-    // Create WagedRebalancer instance if it hasn't been already initialized\n-    if (_rebalancer == null) {\n-      _rebalancer = new WagedRebalancer(helixManager);\n-      _isRebalancerValid = true;\n-    }\n-  }\n \n   /**\n-   * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n-   * the next usage.\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n    */\n-  synchronized void invalidRebalancer() {\n-    _isRebalancerValid = false;\n-  }\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {\n+    private T _rebalancer = null;\n+    private boolean _isRebalancerValid = true;\n+\n+    /**\n+     * @param helixManager\n+     * @return A new stateful rebalancer instance with initial state.\n+     */\n+    protected abstract T createRebalancer(HelixManager helixManager);\n+\n+    /**\n+     * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n+     * the next usage.\n+     */\n+    synchronized void invalidateRebalancer() {\n+      _isRebalancerValid = false;\n+    }\n \n-  /**\n-   * @return A valid rebalancer object.\n-   *         If the rebalancer is no longer valid, it will be reset before returning.\n-   */\n-  synchronized WagedRebalancer getWagedRebalancer(HelixManager helixManager) {\n-    // Lazily initialize the WAGED rebalancer instance since the GenericHelixController instance is\n-    // instantiated without the HelixManager information that is required.\n-    createWagedRebalancer(helixManager);\n-    // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n-    // to be reset before return.\n-    if (!_isRebalancerValid) {\n-      _rebalancer.reset();\n-      _isRebalancerValid = true;\n+    /**\n+     * @return A valid rebalancer object.\n+     *         If the rebalancer is no longer valid, it will be reset before returning.\n+     */\n+    synchronized T getRebalancer(HelixManager helixManager) {\n+      // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n+      // instance is instantiated without the HelixManager information that is required.\n+      if (_rebalancer == null) {\n+        _rebalancer = createRebalancer(helixManager);\n+        _isRebalancerValid = true;\n+      }\n+      // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n+      // to be reset before return.\n+      if (!_isRebalancerValid) {\n+        _rebalancer.reset();\n+        _isRebalancerValid = true;\n+      }\n+      return _rebalancer;\n     }\n-    return _rebalancer;\n-  }\n \n-  /**\n-   * Proactively close the rebalance object to release the resources.\n-   */\n-  synchronized void closeWagedRebalancer() {\n-    if (_rebalancer != null) {\n-      _rebalancer.close();\n-      _rebalancer = null;\n+    /**\n+     * Proactively close the rebalance object to release the resources.\n+     */\n+    synchronized void closeRebalancer() {\n+      if (_rebalancer != null) {\n+        _rebalancer.close();\n+        _rebalancer = null;\n+      }\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NDE2OA==", "url": "https://github.com/apache/helix/pull/690#discussion_r369864168", "bodyText": "Do you think it would be better to generalize this into all rebalancers?\nFor example, RebalancerRef could be an interface here that provides things like getRebalancer() or createRebalancer(), invalidate(), etc. so that the GenericHelixController class does not depend on a specific stateful rebalancer here.", "author": "narendly", "createdAt": "2020-01-22T23:35:52Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1259,3 +1287,54 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.start();\n   }\n }\n+\n+/**\n+ * A wrapper class for the WAGED rebalancer instance.\n+ */\n+class WagedRebalancerRef {", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg4ODU2Mg==", "url": "https://github.com/apache/helix/pull/690#discussion_r369888562", "bodyText": "I think it's a good idea. Let me try to implement a simple version as a starting point. Will update later.", "author": "jiajunwang", "createdAt": "2020-01-23T01:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NDE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1286,55 +1292,57 @@ public class GenericHelixController implements IdealStateChangeListener,\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n-}\n-\n-/**\n- * A wrapper class for the WAGED rebalancer instance.\n- */\n-class WagedRebalancerRef {\n-  private WagedRebalancer _rebalancer = null;\n-  private boolean _isRebalancerValid = true;\n-\n-  private void createWagedRebalancer(HelixManager helixManager) {\n-    // Create WagedRebalancer instance if it hasn't been already initialized\n-    if (_rebalancer == null) {\n-      _rebalancer = new WagedRebalancer(helixManager);\n-      _isRebalancerValid = true;\n-    }\n-  }\n \n   /**\n-   * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n-   * the next usage.\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n    */\n-  synchronized void invalidRebalancer() {\n-    _isRebalancerValid = false;\n-  }\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {\n+    private T _rebalancer = null;\n+    private boolean _isRebalancerValid = true;\n+\n+    /**\n+     * @param helixManager\n+     * @return A new stateful rebalancer instance with initial state.\n+     */\n+    protected abstract T createRebalancer(HelixManager helixManager);\n+\n+    /**\n+     * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n+     * the next usage.\n+     */\n+    synchronized void invalidateRebalancer() {\n+      _isRebalancerValid = false;\n+    }\n \n-  /**\n-   * @return A valid rebalancer object.\n-   *         If the rebalancer is no longer valid, it will be reset before returning.\n-   */\n-  synchronized WagedRebalancer getWagedRebalancer(HelixManager helixManager) {\n-    // Lazily initialize the WAGED rebalancer instance since the GenericHelixController instance is\n-    // instantiated without the HelixManager information that is required.\n-    createWagedRebalancer(helixManager);\n-    // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n-    // to be reset before return.\n-    if (!_isRebalancerValid) {\n-      _rebalancer.reset();\n-      _isRebalancerValid = true;\n+    /**\n+     * @return A valid rebalancer object.\n+     *         If the rebalancer is no longer valid, it will be reset before returning.\n+     */\n+    synchronized T getRebalancer(HelixManager helixManager) {\n+      // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n+      // instance is instantiated without the HelixManager information that is required.\n+      if (_rebalancer == null) {\n+        _rebalancer = createRebalancer(helixManager);\n+        _isRebalancerValid = true;\n+      }\n+      // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n+      // to be reset before return.\n+      if (!_isRebalancerValid) {\n+        _rebalancer.reset();\n+        _isRebalancerValid = true;\n+      }\n+      return _rebalancer;\n     }\n-    return _rebalancer;\n-  }\n \n-  /**\n-   * Proactively close the rebalance object to release the resources.\n-   */\n-  synchronized void closeWagedRebalancer() {\n-    if (_rebalancer != null) {\n-      _rebalancer.close();\n-      _rebalancer = null;\n+    /**\n+     * Proactively close the rebalance object to release the resources.\n+     */\n+    synchronized void closeRebalancer() {\n+      if (_rebalancer != null) {\n+        _rebalancer.close();\n+        _rebalancer = null;\n+      }\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NDU3OA==", "url": "https://github.com/apache/helix/pull/690#discussion_r369864578", "bodyText": "Design suggestion:\nCould we make this generic by using RebalancerRef or StatefulRebalancerRef (since this is only a problem for stateful rebalancers)? Also, instead of directly instantiating, we could make this a cluster config and have it be dynamically created? (Waged, CrushED, etc.). That way, we decouple GenericHelixController from WAGED (or a particular rebalancer) as much as possible.\nIt would be okay to set the default type to be WAGED since this is the only stateful rebalancer we have available so far?", "author": "narendly", "createdAt": "2020-01-22T23:37:24Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -187,6 +187,11 @@\n \n   private HelixManager _helixManager;\n \n+  // Since the WAGED rebalancer needs to be lazily constructed, the GenericHelixController will not\n+  // be constructed with a WAGED rebalancer. This wrapper is to avoid the complexity of handling a\n+  // nullable value in the GenericHelixController logic.\n+  private final WagedRebalancerRef _wagedRebalancerRef = new WagedRebalancerRef();", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNjM0MQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370336341", "bodyText": "I've tried to make the class more generic. Now it is an abstract class. But the configuration part seems to be overdesign for now. Let's consider that part once we have multiple ones.", "author": "jiajunwang", "createdAt": "2020-01-23T20:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NDU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -187,10 +188,15 @@ public class GenericHelixController implements IdealStateChangeListener,\n \n   private HelixManager _helixManager;\n \n-  // Since the WAGED rebalancer needs to be lazily constructed, the GenericHelixController will not\n-  // be constructed with a WAGED rebalancer. This wrapper is to avoid the complexity of handling a\n-  // nullable value in the GenericHelixController logic.\n-  private final WagedRebalancerRef _wagedRebalancerRef = new WagedRebalancerRef();\n+  // Since the stateful rebalancer needs to be lazily constructed when the HelixManager instance is\n+  // ready, the GenericHelixController is not constructed with a stateful rebalancer. This wrapper\n+  // is to avoid the complexity of handling a nullable value in the event handling process.\n+  private final StatefulRebalancerRef _rebalancerRef = new StatefulRebalancerRef() {\n+    @Override\n+    protected StatefulRebalancer createRebalancer(HelixManager helixManager) {\n+      return new WagedRebalancer(helixManager);\n+    }\n+  };\n \n   /**\n    * TODO: We should get rid of this once we move to:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTYyMg==", "url": "https://github.com/apache/helix/pull/690#discussion_r369865622", "bodyText": "If we want to follow the double-checked locking pattern for lazy initialization, we could follow the following structure using volatile:\npublic class Singleton {\n    private volatile static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}", "author": "narendly", "createdAt": "2020-01-22T23:41:06Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1259,3 +1287,54 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.start();\n   }\n }\n+\n+/**\n+ * A wrapper class for the WAGED rebalancer instance.\n+ */\n+class WagedRebalancerRef {\n+  private WagedRebalancer _rebalancer = null;\n+  private boolean _isRebalancerValid = true;\n+\n+  private void createWagedRebalancer(HelixManager helixManager) {", "originalCommit": "28b7a88b1d210570dd9e4f2a78a6a3813ff5a7af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MTg0Ng==", "url": "https://github.com/apache/helix/pull/690#discussion_r370341846", "bodyText": "That's the first thing I tried, if we don't need the _isRebalancerValid flag, it works fine and we won't need to create StatefulRebalancerRef at all. Basically, in this case, we make the WAGED rebalancer singleton.\nHowever, since we have a flag that is not quite suitable for the WAGED class, it would be easier for me to put both the flag and the rebalancer in a StatefulRebalancerRef object. And the Ref class is for the GenericHelixController only. Given that done, the singleton pattern becomes optional.\nMoreover, it is concerning to make the WAGED rebalancer singleton. If we want to use it for both task framework and the resource rebalancer, or we want to manage different resources with different rebalancer configuration, singleton won't work. That's why I didn't pick up that design.", "author": "jiajunwang", "createdAt": "2020-01-23T20:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "03c1b510971aafefcb0e431295a6b56c24777fd4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 97258aee3..759a85bf6 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1286,55 +1292,57 @@ public class GenericHelixController implements IdealStateChangeListener,\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n-}\n-\n-/**\n- * A wrapper class for the WAGED rebalancer instance.\n- */\n-class WagedRebalancerRef {\n-  private WagedRebalancer _rebalancer = null;\n-  private boolean _isRebalancerValid = true;\n-\n-  private void createWagedRebalancer(HelixManager helixManager) {\n-    // Create WagedRebalancer instance if it hasn't been already initialized\n-    if (_rebalancer == null) {\n-      _rebalancer = new WagedRebalancer(helixManager);\n-      _isRebalancerValid = true;\n-    }\n-  }\n \n   /**\n-   * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n-   * the next usage.\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n    */\n-  synchronized void invalidRebalancer() {\n-    _isRebalancerValid = false;\n-  }\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {\n+    private T _rebalancer = null;\n+    private boolean _isRebalancerValid = true;\n+\n+    /**\n+     * @param helixManager\n+     * @return A new stateful rebalancer instance with initial state.\n+     */\n+    protected abstract T createRebalancer(HelixManager helixManager);\n+\n+    /**\n+     * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n+     * the next usage.\n+     */\n+    synchronized void invalidateRebalancer() {\n+      _isRebalancerValid = false;\n+    }\n \n-  /**\n-   * @return A valid rebalancer object.\n-   *         If the rebalancer is no longer valid, it will be reset before returning.\n-   */\n-  synchronized WagedRebalancer getWagedRebalancer(HelixManager helixManager) {\n-    // Lazily initialize the WAGED rebalancer instance since the GenericHelixController instance is\n-    // instantiated without the HelixManager information that is required.\n-    createWagedRebalancer(helixManager);\n-    // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n-    // to be reset before return.\n-    if (!_isRebalancerValid) {\n-      _rebalancer.reset();\n-      _isRebalancerValid = true;\n+    /**\n+     * @return A valid rebalancer object.\n+     *         If the rebalancer is no longer valid, it will be reset before returning.\n+     */\n+    synchronized T getRebalancer(HelixManager helixManager) {\n+      // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n+      // instance is instantiated without the HelixManager information that is required.\n+      if (_rebalancer == null) {\n+        _rebalancer = createRebalancer(helixManager);\n+        _isRebalancerValid = true;\n+      }\n+      // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n+      // to be reset before return.\n+      if (!_isRebalancerValid) {\n+        _rebalancer.reset();\n+        _isRebalancerValid = true;\n+      }\n+      return _rebalancer;\n     }\n-    return _rebalancer;\n-  }\n \n-  /**\n-   * Proactively close the rebalance object to release the resources.\n-   */\n-  synchronized void closeWagedRebalancer() {\n-    if (_rebalancer != null) {\n-      _rebalancer.close();\n-      _rebalancer = null;\n+    /**\n+     * Proactively close the rebalance object to release the resources.\n+     */\n+    synchronized void closeRebalancer() {\n+      if (_rebalancer != null) {\n+        _rebalancer.close();\n+        _rebalancer = null;\n+      }\n     }\n   }\n }\n"}}, {"oid": "d82c160edc2999b878b27962e7263042336ac8eb", "url": "https://github.com/apache/helix/commit/d82c160edc2999b878b27962e7263042336ac8eb", "message": "Reset the WAGED rebalancer once the controller newly acquires leadership.\n\nThis is to prevent any cached assignment information which is recorded during the previous session from impacting the rebalance result.\nDetailed change list:\n1. Move the stateful WAGED rebalancer to the GenericHelixController object instead of the rebalance stage. This is for resolving the possible race condition between the event processing thread and leader switch handling thread.\n2. Adding a new test regarding leadership switch to verify that the WAGED rebalancer has been reset after the processing.", "committedDate": "2020-01-23T19:32:05Z", "type": "commit"}, {"oid": "03c1b510971aafefcb0e431295a6b56c24777fd4", "url": "https://github.com/apache/helix/commit/03c1b510971aafefcb0e431295a6b56c24777fd4", "message": "Address comments.", "committedDate": "2020-01-23T22:03:28Z", "type": "commit"}, {"oid": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "url": "https://github.com/apache/helix/commit/e3e985d5d79328d12bab8402a0b057a18a1dbacc", "message": "Adding test.", "committedDate": "2020-01-24T00:40:09Z", "type": "commit"}, {"oid": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "url": "https://github.com/apache/helix/commit/e3e985d5d79328d12bab8402a0b057a18a1dbacc", "message": "Adding test.", "committedDate": "2020-01-24T00:40:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NDYzNQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370754635", "bodyText": "Could we add a TODO here for making it configurable (based on ClusterConfig for example) in the future as we have different versions of stateful rebalancers?\nIdeally we won't have to import WagedRebalancer explicitly (which seems like we're creating a dependency between GenericHelixController and a specific rebalancer class). I'm fine with creating an issue and getting to it later.", "author": "narendly", "createdAt": "2020-01-24T17:34:25Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -187,6 +188,16 @@\n \n   private HelixManager _helixManager;\n \n+  // Since the stateful rebalancer needs to be lazily constructed when the HelixManager instance is\n+  // ready, the GenericHelixController is not constructed with a stateful rebalancer. This wrapper\n+  // is to avoid the complexity of handling a nullable value in the event handling process.\n+  private final StatefulRebalancerRef _rebalancerRef = new StatefulRebalancerRef() {\n+    @Override\n+    protected StatefulRebalancer createRebalancer(HelixManager helixManager) {\n+      return new WagedRebalancer(helixManager);\n+    }", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3MzMzMA==", "url": "https://github.com/apache/helix/pull/690#discussion_r370773330", "bodyText": "The vision is not clear to me. I don't think we have a solid idea for the TODO. For example, relying on the cluster config to set up the rebalancer type may be invalid. If we have multiple optional stateful rebalancers, they will be configured in the ideal state for each resource, instead of cluster config.\nMore likely, we will need to init all the stateful rebalancers here. It is just too far even for planning. For now, please assume we will only have one stateful rebalancer.\nHowever, making the code generic enough for the future extension is always a good idea. That why I added the interface according to your suggestion : )", "author": "jiajunwang", "createdAt": "2020-01-24T18:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NDYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3NjA2OA==", "url": "https://github.com/apache/helix/pull/690#discussion_r370776068", "bodyText": "In addition, about your 2nd paragraph comment, I guess what you concerned about is that the rebalancer class should be only configurable in the IS. So the GenericHelixController should not be aware of the resource level thing. However, please note that even there is no resource using the WAGED rebalancer, the controller will still need to init the stateful rebalancer instance.\nI agree this design can be improved. But I would prefer to keep it simple before the rebalancer logic and the algorithm are stable enough.\nFor now, let me add a TODO.", "author": "jiajunwang", "createdAt": "2020-01-24T18:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NDYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "40c7f029ba959c45e7697052cef717529afda49d", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 759a85bf6..e2ecd8bb5 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -191,6 +191,7 @@ public class GenericHelixController implements IdealStateChangeListener,\n   // Since the stateful rebalancer needs to be lazily constructed when the HelixManager instance is\n   // ready, the GenericHelixController is not constructed with a stateful rebalancer. This wrapper\n   // is to avoid the complexity of handling a nullable value in the event handling process.\n+  // TODO Create the required stateful rebalancer only when it is used by any resource.\n   private final StatefulRebalancerRef _rebalancerRef = new StatefulRebalancerRef() {\n     @Override\n     protected StatefulRebalancer createRebalancer(HelixManager helixManager) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NTc4MA==", "url": "https://github.com/apache/helix/pull/690#discussion_r370755780", "bodyText": "How do we prevent this from being called multiple times?", "author": "narendly", "createdAt": "2020-01-24T17:37:14Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1258,4 +1292,57 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n+\n+  /**\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n+   */\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {\n+    private T _rebalancer = null;\n+    private boolean _isRebalancerValid = true;\n+\n+    /**\n+     * @param helixManager\n+     * @return A new stateful rebalancer instance with initial state.\n+     */\n+    protected abstract T createRebalancer(HelixManager helixManager);", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2ODc5OQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370768799", "bodyText": "It is prevented in the get method. This method itself is a protected method, with no external callers.", "author": "jiajunwang", "createdAt": "2020-01-24T18:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NTc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "1345841e3023cc2f3ffc1e11a6dcb79401359f17", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 759a85bf6..e47c420d9 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1318,6 +1319,8 @@ public class GenericHelixController implements IdealStateChangeListener,\n     /**\n      * @return A valid rebalancer object.\n      *         If the rebalancer is no longer valid, it will be reset before returning.\n+     * TODO: Make rebalancer volatile or make it singleton, if this method is called in multiple\n+     * TODO: threads outside the controller object.\n      */\n     synchronized T getRebalancer(HelixManager helixManager) {\n       // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NzA3OQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370757079", "bodyText": "Should we think about which methods in this class should be idempotent?\n\n\nWhy an abstract class vs an interface?", "author": "narendly", "createdAt": "2020-01-24T17:40:13Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1258,4 +1292,57 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n+\n+  /**\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n+   */\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3MDYzMA==", "url": "https://github.com/apache/helix/pull/690#discussion_r370770630", "bodyText": "Since it is a private class, I don't think we need to overdesign it. As for idempotent, could you be more specific, please? What's the concern that you have?", "author": "jiajunwang", "createdAt": "2020-01-24T18:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzOTA4Nw==", "url": "https://github.com/apache/helix/pull/690#discussion_r371439087", "bodyText": "My concern is that we should probably make the behavior more explicit around create() or close() being multiple times. It wasn't very clear from the code?", "author": "narendly", "createdAt": "2020-01-27T19:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1NzkzNQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r371457935", "bodyText": "My point is that we don't restrict the behavior in the Ref class. The source of truth is in the rebalancer object itself. So it won't be explicitly mentioned here.\nMoreover, as I commented in the other thread, it is not a real concern for now. But I have added a TODO in the rebalancer class for rejecting requests after close() called.", "author": "jiajunwang", "createdAt": "2020-01-27T20:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NzA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1345841e3023cc2f3ffc1e11a6dcb79401359f17", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex 759a85bf6..e47c420d9 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1318,6 +1319,8 @@ public class GenericHelixController implements IdealStateChangeListener,\n     /**\n      * @return A valid rebalancer object.\n      *         If the rebalancer is no longer valid, it will be reset before returning.\n+     * TODO: Make rebalancer volatile or make it singleton, if this method is called in multiple\n+     * TODO: threads outside the controller object.\n      */\n     synchronized T getRebalancer(HelixManager helixManager) {\n       // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg==", "url": "https://github.com/apache/helix/pull/690#discussion_r370758902", "bodyText": "Should we check things on the WagedRebalancer too? is closed?", "author": "narendly", "createdAt": "2020-01-24T17:43:56Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -249,23 +220,33 @@ private boolean validateOfflineInstancesLimit(final ResourceControllerDataProvid\n     return true;\n   }\n \n+  private void updateWagedRebalancer(WagedRebalancer wagedRebalancer, ClusterConfig clusterConfig) {", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODE3Nw==", "url": "https://github.com/apache/helix/pull/690#discussion_r370778177", "bodyText": "That's a good point. For now, an explicit check would be optional. If the rebalancer has been closed, the computing will fail. One concern might be metric. It will be unregistered after the close.\nLet me add a TODO to the close() method. I would prefer to keep this PR simple for now.", "author": "jiajunwang", "createdAt": "2020-01-24T18:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc4NjM3NQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370786375", "bodyText": "One more comment, for now, the close is only called in 2 conditions:\n\nthe instance is GCed. So there should be no one calling any methods.\nThe controller is shutdown. There won't be a pipeline running after. So there should be no one calling any methods.\n\nThat's why I don't think we need to do this check immediately.", "author": "jiajunwang", "createdAt": "2020-01-24T18:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0NDgwNA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371444804", "bodyText": "True, but adding a check is safer and we could add a TODO to remove with better design?", "author": "narendly", "createdAt": "2020-01-27T19:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MDMzMQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r371460331", "bodyText": "I'd prefer adding a TODO to add this check properly. Since that is not one or two lines of change, let's not squeeze it into this PR.", "author": "jiajunwang", "createdAt": "2020-01-27T20:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ5NTI1Mg==", "url": "https://github.com/apache/helix/pull/690#discussion_r371495252", "bodyText": "Will we be tracking this work with an issue?", "author": "narendly", "createdAt": "2020-01-27T21:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODkwMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTIxMQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r370759211", "bodyText": "Perhaps we should check whether the rebalancer has been closed here?", "author": "narendly", "createdAt": "2020-01-24T17:44:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java", "diffHunk": "@@ -282,22 +263,22 @@ private boolean validateOfflineInstancesLimit(final ResourceControllerDataProvid\n \n     Map<String, IdealState> newIdealStates = new HashMap<>();\n \n-    ClusterConfig clusterConfig = cache.getClusterConfig();\n-    WagedRebalancer wagedRebalancer =\n-        getWagedRebalancer(helixManager, clusterConfig.getGlobalRebalancePreference(),\n-            clusterConfig.isGlobalRebalanceAsyncModeEnabled());\n-    try {\n-      newIdealStates.putAll(wagedRebalancer.computeNewIdealStates(cache, wagedRebalancedResourceMap,\n-          currentStateOutput));\n-    } catch (HelixRebalanceException ex) {\n-      // Note that unlike the legacy rebalancer, the WAGED rebalance won't return partial result.\n-      // Since it calculates for all the eligible resources globally, a partial result is invalid.\n-      // TODO propagate the rebalancer failure information to updateRebalanceStatus for monitoring.\n+    if (wagedRebalancer != null) {", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3OTQyMw==", "url": "https://github.com/apache/helix/pull/690#discussion_r370779423", "bodyText": "As mentioned above, I would prefer to reject call (by throwing exceptions or so) inside the rebalancer. For the calc stage, there is nothing it can do.\nMoreover, checking inside the rebalancer can help to keep the close status private.\nTODO added.", "author": "jiajunwang", "createdAt": "2020-01-24T18:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0NTMzMQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r371445331", "bodyText": "Where is the reject call? Are you referring to Line 271?", "author": "narendly", "createdAt": "2020-01-27T19:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1OTQ3Mw==", "url": "https://github.com/apache/helix/pull/690#discussion_r371459473", "bodyText": "No reject call yet. TODO is for this task. It is not a must for now since all the callers are private.", "author": "jiajunwang", "createdAt": "2020-01-27T20:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ5NTA1OA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371495058", "bodyText": "I still don't see a TODO stating that we need to check on the rebalancer status (whether it's closed, null, etc.)", "author": "narendly", "createdAt": "2020-01-27T21:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTIxMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTQxOA==", "url": "https://github.com/apache/helix/pull/690#discussion_r370759418", "bodyText": "We should add a TODO here for all the sleep() calls?", "author": "narendly", "createdAt": "2020-01-24T17:45:22Z", "path": "helix-core/src/test/java/org/apache/helix/integration/rebalancer/WagedRebalancer/TestWagedRebalance.java", "diffHunk": "@@ -473,6 +473,58 @@ public void testNewInstances()\n     }\n   }\n \n+  /**\n+   * The stateful WAGED rebalancer will be reset while the controller regains the leadership.\n+   * This test is to verify if the reset has been done and the rebalancer has forgotten any previous\n+   * status after leadership switched.\n+   */\n+  @Test(dependsOnMethods = \"test\")\n+  public void testRebalancerReset() throws Exception {\n+    // Configure the rebalance preference so as to trigger more partition movements for evenness.\n+    // This is to ensure the controller will try to move something if the rebalancer has been reset.\n+    ConfigAccessor configAccessor = new ConfigAccessor(_gZkClient);\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(CLUSTER_NAME);\n+    clusterConfig.setGlobalRebalancePreference(ImmutableMap\n+        .of(ClusterConfig.GlobalRebalancePreferenceKey.EVENNESS, 10,\n+            ClusterConfig.GlobalRebalancePreferenceKey.LESS_MOVEMENT, 0));\n+    configAccessor.setClusterConfig(CLUSTER_NAME, clusterConfig);\n+\n+    int i = 0;\n+    for (String stateModel : _testModels) {\n+      String db = \"Test-DB-\" + TestHelper.getTestMethodName() + i++;\n+      createResourceWithWagedRebalance(CLUSTER_NAME, db, stateModel, PARTITIONS, _replica,\n+          _replica);\n+      _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, db, _replica);\n+      _allDBs.add(db);\n+    }\n+    Thread.sleep(300);", "originalCommit": "e3e985d5d79328d12bab8402a0b057a18a1dbacc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc4MDI5Ng==", "url": "https://github.com/apache/helix/pull/690#discussion_r370780296", "bodyText": "You are right, but there are too many...\nLet me add to the newly created method. After we fixed the issue  #526 we will be able to remove all sleep anyway.", "author": "jiajunwang", "createdAt": "2020-01-24T18:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1OTQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "40c7f029ba959c45e7697052cef717529afda49d", "chunk": "diff --git a/helix-core/src/test/java/org/apache/helix/integration/rebalancer/WagedRebalancer/TestWagedRebalance.java b/helix-core/src/test/java/org/apache/helix/integration/rebalancer/WagedRebalancer/TestWagedRebalance.java\nindex be89fd9c2..96180bf8a 100644\n--- a/helix-core/src/test/java/org/apache/helix/integration/rebalancer/WagedRebalancer/TestWagedRebalance.java\n+++ b/helix-core/src/test/java/org/apache/helix/integration/rebalancer/WagedRebalancer/TestWagedRebalance.java\n\n@@ -497,6 +497,7 @@ public class TestWagedRebalance extends ZkTestBase {\n       _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, db, _replica);\n       _allDBs.add(db);\n     }\n+    // TODO remove this sleep after fix https://github.com/apache/helix/issues/526\n     Thread.sleep(300);\n     validate(_replica);\n \n"}}, {"oid": "40c7f029ba959c45e7697052cef717529afda49d", "url": "https://github.com/apache/helix/commit/40c7f029ba959c45e7697052cef717529afda49d", "message": "Address comment.", "committedDate": "2020-01-24T18:49:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MDQwMA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371440400", "bodyText": "Should we follow the lazy-initialization idiom (using volatile keyword on the singleton objects)?", "author": "narendly", "createdAt": "2020-01-27T19:35:48Z", "path": "helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java", "diffHunk": "@@ -1258,4 +1293,57 @@ private void initPipeline(Thread eventThread, BaseControllerDataProvider cache)\n     eventThread.setDaemon(true);\n     eventThread.start();\n   }\n+\n+  /**\n+   * A wrapper class for the stateful rebalancer instance that will be tracked in the\n+   * GenericHelixController.\n+   */\n+  private abstract class StatefulRebalancerRef<T extends StatefulRebalancer> {\n+    private T _rebalancer = null;\n+    private boolean _isRebalancerValid = true;\n+\n+    /**\n+     * @param helixManager\n+     * @return A new stateful rebalancer instance with initial state.\n+     */\n+    protected abstract T createRebalancer(HelixManager helixManager);\n+\n+    /**\n+     * Mark the current rebalancer object to be invalid, which indicates it needs to be reset before\n+     * the next usage.\n+     */\n+    synchronized void invalidateRebalancer() {\n+      _isRebalancerValid = false;\n+    }\n+\n+    /**\n+     * @return A valid rebalancer object.\n+     *         If the rebalancer is no longer valid, it will be reset before returning.\n+     */\n+    synchronized T getRebalancer(HelixManager helixManager) {\n+      // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n+      // instance is instantiated without the HelixManager information that is required.\n+      if (_rebalancer == null) {\n+        _rebalancer = createRebalancer(helixManager);\n+        _isRebalancerValid = true;\n+      }\n+      // If the rebalance exists but has been marked as invalid (due to leadership switch), it needs\n+      // to be reset before return.\n+      if (!_isRebalancerValid) {\n+        _rebalancer.reset();\n+        _isRebalancerValid = true;\n+      }\n+      return _rebalancer;", "originalCommit": "40c7f029ba959c45e7697052cef717529afda49d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2OTQ5NA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371469494", "bodyText": "I still think it is not necessary since we want to maximize the event handling performance here.\n\ngetRebalancer is called in a single thread, there is no concern that multiple getRebalancer will cause the rebalancer to be created multiple times.\nthe possible concern is between getRebalancer() and closeRebalancer().\n2.1. it is not possible that getRebalancer is called after closeRebalancer. Since the event thread has been stopped by the controller before closeRebalancer is triggered.\n2.2. if the closeRebalancer is called after getRebalancer, and the reference has not been safed in the main memory, closeRebalancer does nothing. The clean up will be done a little bit late while the rebalancer object is GCed. This is fine. Since the controller has been close, the rebalancer will not be used for sure.\nOn the other hand, when adding volatile to the _rebalancer object, each getRebalancer will access the main memory. It's a minor delay increament, but if it happens on every event, these latencies together might count something. So I prefer not adding volatile unless it help to resolve a real concern.\n\nMoreover, as I mentioned, the rebalancer should not be a singleton by design.", "author": "jiajunwang", "createdAt": "2020-01-27T20:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ5OTQ3OQ==", "url": "https://github.com/apache/helix/pull/690#discussion_r371499479", "bodyText": "Adding volatile is for correctness and I don't think we should sacrifice correctness in favor of a minor performance improvement. And I am not positive if the performance is a valid concern at this juncture with so many synchronization primitives that are already in use.\nNow is Helix Controller single-thread? Yes. Will it remain that way? Not necessarily. If we do make this change (which should happen soon, especially due to the memory pressure Controller is facing), we should revisit this code. Could we add a TODO here as well, marking it not thread-safe?", "author": "narendly", "createdAt": "2020-01-27T21:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MDQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwNjQ3OA==", "url": "https://github.com/apache/helix/pull/690#discussion_r371506478", "bodyText": "I understand the concern. And I also thought about that. Actually, even the controller has been changed and split, there probably still be one single thread calculating for resource rebalance. Given that, in the foreseeable future, my assumption will still be valid.\nI agree with you that the performance impact is minor. But since it won't impact our correctness, I'd prefer to keep the design simple and not design for the unknown future.", "author": "jiajunwang", "createdAt": "2020-01-27T21:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MDQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "1345841e3023cc2f3ffc1e11a6dcb79401359f17", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\nindex e2ecd8bb5..e47c420d9 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\n@@ -1319,6 +1319,8 @@ public class GenericHelixController implements IdealStateChangeListener,\n     /**\n      * @return A valid rebalancer object.\n      *         If the rebalancer is no longer valid, it will be reset before returning.\n+     * TODO: Make rebalancer volatile or make it singleton, if this method is called in multiple\n+     * TODO: threads outside the controller object.\n      */\n     synchronized T getRebalancer(HelixManager helixManager) {\n       // Lazily initialize the stateful rebalancer instance since the GenericHelixController\n"}}, {"oid": "1345841e3023cc2f3ffc1e11a6dcb79401359f17", "url": "https://github.com/apache/helix/commit/1345841e3023cc2f3ffc1e11a6dcb79401359f17", "message": "Address comment.", "committedDate": "2020-01-27T22:04:39Z", "type": "commit"}]}