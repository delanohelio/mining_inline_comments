{"pr_number": 1422, "pr_title": "Fix currentState not being removed when pending message existed", "pr_createdAt": "2020-09-29T01:18:45Z", "pr_url": "https://github.com/apache/helix/pull/1422", "timeline": [{"oid": "9475b7d100063602f0ea59f3f045296c635c36a8", "url": "https://github.com/apache/helix/commit/9475b7d100063602f0ea59f3f045296c635c36a8", "message": "Fix currentState not removed when pending message existed\n\nThis commit, makes sure that controller drops send DROPPED message for the\njobs that have finished and have pending messages.", "committedDate": "2020-09-28T23:31:25Z", "type": "commit"}, {"oid": "57428d337cce88c11e4512d9acca4ebed4afcc2e", "url": "https://github.com/apache/helix/commit/57428d337cce88c11e4512d9acca4ebed4afcc2e", "message": "fix comments", "committedDate": "2020-09-29T01:23:24Z", "type": "commit"}, {"oid": "680927bae6374dabac05c6e9080a665339cb4e30", "url": "https://github.com/apache/helix/commit/680927bae6374dabac05c6e9080a665339cb4e30", "message": "Add comments", "committedDate": "2020-10-01T20:13:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjA4OQ==", "url": "https://github.com/apache/helix/pull/1422#discussion_r498546089", "bodyText": "nit, is it possible to add this test to some existing test class? Recreating the whole test environment is expensive. And I feel we are adding more test classes than necessary. It will soon become unmanageable.", "author": "jiajunwang", "createdAt": "2020-10-01T22:38:33Z", "path": "helix-core/src/test/java/org/apache/helix/integration/task/TestJobCurrentStateDroppedAfterCompletion.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.apache.helix.integration.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.task.JobConfig;\n+import org.apache.helix.task.JobQueue;\n+import org.apache.helix.task.TaskState;\n+import org.apache.helix.task.TaskUtil;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.zookeeper.data.Stat;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+public class TestJobCurrentStateDroppedAfterCompletion extends TaskTestBase {\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _numPartitions = 1;\n+    _numNodes = 1;\n+    super.beforeClass();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+  }\n+\n+  @Test\n+  public void testJobCurrentStateDroppedAfterCompletion() throws Exception {", "originalCommit": "680927bae6374dabac05c6e9080a665339cb4e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNjI5Ng==", "url": "https://github.com/apache/helix/pull/1422#discussion_r499716296", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-10-05T16:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "chunk": "diff --git a/helix-core/src/test/java/org/apache/helix/integration/task/TestJobCurrentStateDroppedAfterCompletion.java b/helix-core/src/test/java/org/apache/helix/integration/task/TestJobCurrentStateDroppedAfterCompletion.java\ndeleted file mode 100644\nindex 7574be78a..000000000\n--- a/helix-core/src/test/java/org/apache/helix/integration/task/TestJobCurrentStateDroppedAfterCompletion.java\n+++ /dev/null\n\n@@ -1,102 +0,0 @@\n-package org.apache.helix.integration.task;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import org.apache.helix.AccessOption;\n-import org.apache.helix.TestHelper;\n-import org.apache.helix.ZkTestHelper;\n-import org.apache.helix.task.JobConfig;\n-import org.apache.helix.task.JobQueue;\n-import org.apache.helix.task.TaskState;\n-import org.apache.helix.task.TaskUtil;\n-import org.apache.helix.zookeeper.datamodel.ZNRecord;\n-import org.apache.helix.zookeeper.impl.client.ZkClient;\n-import org.apache.zookeeper.data.Stat;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import com.google.common.collect.ImmutableMap;\n-\n-public class TestJobCurrentStateDroppedAfterCompletion extends TaskTestBase {\n-\n-  @BeforeClass\n-  public void beforeClass() throws Exception {\n-    _numPartitions = 1;\n-    _numNodes = 1;\n-    super.beforeClass();\n-  }\n-\n-  @AfterClass\n-  public void afterClass() throws Exception {\n-    super.afterClass();\n-  }\n-\n-  @Test\n-  public void testJobCurrentStateDroppedAfterCompletion() throws Exception {\n-    String jobQueueName = TestHelper.getTestMethodName();\n-\n-    JobConfig.Builder jobBuilderCompleted =\n-        JobConfig.Builder.fromMap(WorkflowGenerator.DEFAULT_JOB_CONFIG).setMaxAttemptsPerTask(1)\n-            .setWorkflow(jobQueueName)\n-            .setJobCommandConfigMap(ImmutableMap.of(MockTask.JOB_DELAY, \"10\"));\n-\n-    // Task gets timed out in 10 seconds because the the default value is 10 seconds in\n-    // DEFAULT_JOB_CONFIG\n-    JobConfig.Builder jobBuilderTimedOut =\n-        JobConfig.Builder.fromMap(WorkflowGenerator.DEFAULT_JOB_CONFIG).setMaxAttemptsPerTask(1)\n-            .setWorkflow(jobQueueName)\n-            .setJobCommandConfigMap(ImmutableMap.of(MockTask.JOB_DELAY, \"100000\"));\n-\n-    JobQueue.Builder jobQueue = TaskTestUtil.buildJobQueue(jobQueueName, 0, 100);\n-\n-    for (int i = 0; i < 20; i++) {\n-      jobQueue.enqueueJob(\"job\" + i, jobBuilderCompleted);\n-    }\n-\n-    jobQueue.enqueueJob(\"job\" + 20, jobBuilderTimedOut);\n-\n-    _driver.start(jobQueue.build());\n-\n-    for (int i = 0; i < 20; i++) {\n-      _driver.pollForJobState(jobQueueName, TaskUtil.getNamespacedJobName(jobQueueName, \"job\" + i),\n-          TaskState.COMPLETED);\n-    }\n-    _driver.pollForJobState(jobQueueName, TaskUtil.getNamespacedJobName(jobQueueName, \"job\" + 20),\n-        TaskState.FAILED);\n-\n-    String instanceP0 = PARTICIPANT_PREFIX + \"_\" + (_startPort + 0);\n-    ZkClient clientP0 = (ZkClient) _participants[0].getZkClient();\n-    String sessionIdP0 = ZkTestHelper.getSessionId(clientP0);\n-\n-    for (int i = 0; i < 21; i++) {\n-      String currentStatePathP0 =\n-          \"/\" + CLUSTER_NAME + \"/INSTANCES/\" + instanceP0 + \"/CURRENTSTATES/\" + sessionIdP0 + \"/\"\n-              + TaskUtil.getNamespacedJobName(jobQueueName, \"job\" + i);\n-      boolean isCurrentStateRemoved = TestHelper.verify(() -> {\n-        ZNRecord record = _manager.getHelixDataAccessor().getBaseDataAccessor()\n-            .get(currentStatePathP0, new Stat(), AccessOption.PERSISTENT);\n-        return record == null;\n-      }, TestHelper.WAIT_DURATION);\n-      Assert.assertTrue(isCurrentStateRemoved);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NzQwMQ==", "url": "https://github.com/apache/helix/pull/1422#discussion_r498547401", "bodyText": "This means even the pending message target state matches the current state, we won't proceed? I know it is safer. But since it rolls back this enhancement, it might increase latency. Or does the removed check that the target state matches the current state will introduce any bug?", "author": "jiajunwang", "createdAt": "2020-10-01T22:43:16Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -122,30 +122,37 @@ public void updatePreviousAssignedTasksStatus(\n       Set<Integer> donePartitions = new TreeSet<>();\n       for (int pId : pSet) {\n         final String pName = pName(jobResource, pId);\n-        TaskPartitionState currState = updateJobContextAndGetTaskCurrentState(currStateOutput,\n+        TaskPartitionState currState = getTaskCurrentState(currStateOutput,\n             jobResource, pId, pName, instance, jobCtx, jobTgtState);\n \n-        if (!instance.equals(jobCtx.getAssignedParticipant(pId))) {\n-          LOG.warn(\n-              \"Instance {} does not match the assigned participant for pId {} in the job context. Skipping task scheduling.\",\n-              instance, pId);\n-          continue;\n-        }\n-\n         // Check for pending state transitions on this (partition, instance). If there is a pending\n         // state transition, we prioritize this pending state transition and set the assignment from\n         // this pending state transition, essentially \"waiting\" until this pending message clears\n+        // If there is a pending message, we should not continue to update the context because from", "originalCommit": "680927bae6374dabac05c6e9080a665339cb4e30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDgxMw==", "url": "https://github.com/apache/helix/pull/1422#discussion_r499724813", "bodyText": "This is more toward the functionality of our scheduling. Without this change, there is a whole in our scheduling decision. Before IS removal change, we were relying on IS to remove the last CS from the participants. However, removing IS revealed this issue. This PR basically handles these cases and helps CS to be cleaned up after the job is being completed. Also, we think about it logically, it makes sense to consider ST not complete when a pending message has not been deleted from the ZK.", "author": "alirezazamani", "createdAt": "2020-10-05T16:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NzQwMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "url": "https://github.com/apache/helix/commit/966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "message": "Address the comments", "committedDate": "2020-10-05T16:01:29Z", "type": "commit"}, {"oid": "966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "url": "https://github.com/apache/helix/commit/966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "message": "Address the comments", "committedDate": "2020-10-05T16:01:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3Mjk3NA==", "url": "https://github.com/apache/helix/pull/1422#discussion_r499972974", "bodyText": "It looks like it's just about the order of jobContext updating vs processing pending messages, if I understood you correctly. If that's the case, is there a reason why we removed the second section of the if statement here, as @jiajunwang mentioned?", "author": "NealSun96", "createdAt": "2020-10-06T02:34:23Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -122,30 +122,37 @@ public void updatePreviousAssignedTasksStatus(\n       Set<Integer> donePartitions = new TreeSet<>();\n       for (int pId : pSet) {\n         final String pName = pName(jobResource, pId);\n-        TaskPartitionState currState = updateJobContextAndGetTaskCurrentState(currStateOutput,\n+        TaskPartitionState currState = getTaskCurrentState(currStateOutput,\n             jobResource, pId, pName, instance, jobCtx, jobTgtState);\n \n-        if (!instance.equals(jobCtx.getAssignedParticipant(pId))) {\n-          LOG.warn(\n-              \"Instance {} does not match the assigned participant for pId {} in the job context. Skipping task scheduling.\",\n-              instance, pId);\n-          continue;\n-        }\n-\n         // Check for pending state transitions on this (partition, instance). If there is a pending\n         // state transition, we prioritize this pending state transition and set the assignment from\n         // this pending state transition, essentially \"waiting\" until this pending message clears\n+        // If there is a pending message, we should not continue to update the context because from\n+        // controller prospective, state transition has not been completed yet if pending message\n+        // still existed.\n+        // If context gets updated here, controller might remove the job from RunTimeJobDAG which\n+        // can cause the task's CurrentState not being removed when there is a pending message for\n+        // that task.\n         Message pendingMessage =\n             currStateOutput.getPendingMessage(jobResource, new Partition(pName), instance);\n-        if (pendingMessage != null && !pendingMessage.getToState().equals(currState.name())) {", "originalCommit": "966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTM0NQ==", "url": "https://github.com/apache/helix/pull/1422#discussion_r500415345", "bodyText": "It is very complicated to explain:\n1- The controller sends RUNNING to COMPLETED message.\n2- The participant marks the current state to be COMPLETED but the pending message has not been removed yet.\n3- In the next pipeline (pending message toState is COMPLETED, currentState is COMPLETED), this if statement would not be satisfied. Hence, we decide COMPLETED to DROPPED without considering pending messages.\n4- The controller marks the job as completed and removes it from the DAG (so we will never consider this job again unless the controller switch to etc).\n5- Since the controller sees the pending message, in the message generation phase we do not consider a new decision which is COMPLETED to DROPPED and then CS will never be DROPPED.\nThe conclusion is that the controller should not consider state transition as a done/completed state transition until the pending message is gone from ZK.", "author": "alirezazamani", "createdAt": "2020-10-06T15:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3Mjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTY3Mw==", "url": "https://github.com/apache/helix/pull/1422#discussion_r500469673", "bodyText": "Thanks for explaining. So it looks to be a problem with 2 parts:\n\nJob context is updated while there are pending messages. This can cause jobs to be removed since it's marked as completed. If DROPPED message isn't correctly sent here, then the DROPPED message will never be sent because the job is deleted;\nCurrent state gets updated but pending messages aren't removed (async problem). In that case, the old if statement would not catch the problem and will proceed as if the message doesn't exist.\nI suppose 2 is not a problem except when the job is about to be deleted; if the job isn't deleted, the pipeline can simply retry next time.\n\nFor 1, I don't understand why the new code in TaskSchedulingStage doesn't catch it. Specifically:\n    // Jobs that exist in current states but are missing corresponding JobConfigs or WorkflowConfigs\n    // or WorkflowContexts need to be cleaned up. Note that restOfResources can only be jobs,\n    // because workflow resources are created based on Configs only - workflows don't have\n    // CurrentStates\n    for (String resourceName : restOfResources.keySet()) {\n      _workflowDispatcher.processJobForDrop(resourceName, currentStateOutput, output);\n    }", "author": "NealSun96", "createdAt": "2020-10-06T17:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3Mjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3ODExNA==", "url": "https://github.com/apache/helix/pull/1422#discussion_r500478114", "bodyText": "For 1, it is not related to the deletion of the job. The issue is once you mark the last task of the job in the jobContext as completed, then you remove this job from RunTimeJobDag in jobDispatcher. Then next pipeline you will not even see this job in your RuntimeJobDAG. Now there is no way to drop the current state until JobConfig existed. After JobConfig is removed, then the code you pasted should take care of it.", "author": "alirezazamani", "createdAt": "2020-10-06T17:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3Mjk3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NDE1OQ==", "url": "https://github.com/apache/helix/pull/1422#discussion_r499974159", "bodyText": "General comment: how did the legacy pipeline help masking this problem before? Or, was it not related to the legacy pipeline, but related to how we delete CurrentStates? The legacy pipeline logic processes the inflight jobs again, but it shouldn't make a difference?", "author": "NealSun96", "createdAt": "2020-10-06T02:39:15Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -122,30 +122,37 @@ public void updatePreviousAssignedTasksStatus(\n       Set<Integer> donePartitions = new TreeSet<>();\n       for (int pId : pSet) {\n         final String pName = pName(jobResource, pId);\n-        TaskPartitionState currState = updateJobContextAndGetTaskCurrentState(currStateOutput,\n+        TaskPartitionState currState = getTaskCurrentState(currStateOutput,\n             jobResource, pId, pName, instance, jobCtx, jobTgtState);\n \n-        if (!instance.equals(jobCtx.getAssignedParticipant(pId))) {\n-          LOG.warn(\n-              \"Instance {} does not match the assigned participant for pId {} in the job context. Skipping task scheduling.\",\n-              instance, pId);\n-          continue;\n-        }\n-\n         // Check for pending state transitions on this (partition, instance). If there is a pending\n         // state transition, we prioritize this pending state transition and set the assignment from\n         // this pending state transition, essentially \"waiting\" until this pending message clears\n+        // If there is a pending message, we should not continue to update the context because from\n+        // controller prospective, state transition has not been completed yet if pending message\n+        // still existed.\n+        // If context gets updated here, controller might remove the job from RunTimeJobDAG which\n+        // can cause the task's CurrentState not being removed when there is a pending message for\n+        // that task.\n         Message pendingMessage =\n             currStateOutput.getPendingMessage(jobResource, new Partition(pName), instance);\n-        if (pendingMessage != null && !pendingMessage.getToState().equals(currState.name())) {\n-          // If there is a pending message whose destination state is different from the current\n-          // state, just make the same assignment as the pending message. This is essentially\n-          // \"waiting\" until this state transition is complete\n+        if (pendingMessage != null) {\n           processTaskWithPendingMessage(pId, pName, instance, pendingMessage, jobState, currState,\n               paMap, assignedPartitions);\n           continue;\n         }\n ", "originalCommit": "966f1cf5a4cac29b0cc93d27b8575d3a168f0f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwOTUzNQ==", "url": "https://github.com/apache/helix/pull/1422#discussion_r500409535", "bodyText": "It is related to legacy code. Previously, when a job is completed, failed, or timed out, IS would be deleted by the controller. In the next pipeline, since the Ideal state does not exist but the current state exists, we go to legacy code and drop the remaining current states.", "author": "alirezazamani", "createdAt": "2020-10-06T15:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTkzNg==", "url": "https://github.com/apache/helix/pull/1422#discussion_r500469936", "bodyText": "Feel free to close this. My questions are combined at the previous comment.", "author": "NealSun96", "createdAt": "2020-10-06T17:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NDE1OQ=="}], "type": "inlineReview", "revised_code": null}]}