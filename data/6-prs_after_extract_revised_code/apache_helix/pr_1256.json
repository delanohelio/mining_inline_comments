{"pr_number": 1256, "pr_title": "Do not ignore any map or list field key change in the Change Detector.", "pr_createdAt": "2020-08-12T05:07:15Z", "pr_url": "https://github.com/apache/helix/pull/1256", "timeline": [{"oid": "7a49fa3be60afb35f13ee9b7f04d1173b37ee15f", "url": "https://github.com/apache/helix/commit/7a49fa3be60afb35f13ee9b7f04d1173b37ee15f", "message": "Do not ignore any map or list field key change in the Change Detector.", "committedDate": "2020-08-12T03:50:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NjQ1OQ==", "url": "https://github.com/apache/helix/pull/1256#discussion_r469046459", "bodyText": "This is a high-level comment:\nSince this is causing an issue for the admin.rebalance method (which essentially just populates the mapFields in the IdealState), my immediate instinct would be that this change could be contained in IdealStateTrimmer.\nThis way, we contain the scope of changes for IdealStates only - and it should fix the problem we're seeing with resources not being rebalanced. Is there any difficulty with overriding doTrim() in IdealStateTrimmer instead of making the change and applying it generally in HelixPropertyTrimmer?", "author": "narendly", "createdAt": "2020-08-12T07:00:57Z", "path": "helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java", "diffHunk": "@@ -57,38 +57,49 @@\n    * @param originalProperty\n    */\n   protected ZNRecord doTrim(T originalProperty) {\n+    ZNRecord originalZNRecord = originalProperty.getRecord();", "originalCommit": "7a49fa3be60afb35f13ee9b7f04d1173b37ee15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3MDk5OA==", "url": "https://github.com/apache/helix/pull/1256#discussion_r469070998", "bodyText": "Good point. So this is also my first try. FYI, I also tried to extend the field type to include LIST_FIELD_KEY_ONLY. But then I find these 2 solutions are too complicated.\nIt is correct that putting this logic into the IdealStateTrimmer will immediately fix the problem without too much change. The complex is that in this way, it would be hard to reason the overall logic of all trimmers. Some of them care about values, the others do not. Of course, we can add comments. But gradually, it will become harder to understand and maintain.\nSo I go back and think about why we need these trimmers. Do we need to trim soo much information? I think we don't. The rebalancer will perform well even we detect all keys change (no value, just key's change) for all the properties. And the logic is very clean and concentrate:\n\nKeys are not ignored\nValues are ignored accordingly and this is specified by the getNonTrimmableFields() method.\n\nThen I firstly tried to not trim all keys (including the simple fields). But then I realize it is not optimal, since the simple fields' keys are tightly bounded with the values. And finally, I have the current proposal.\nOverall, the main reason for this trade-off is to make the trim logic less diverse and easier to maintain.", "author": "jiajunwang", "createdAt": "2020-08-12T07:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxNzI0MA==", "url": "https://github.com/apache/helix/pull/1256#discussion_r469417240", "bodyText": "BTW, the ideal solution is to separate the ZK paths for input and output. Then we can simplify or even remove the trim logic as desired.", "author": "jiajunwang", "createdAt": "2020-08-12T17:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0NjQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5787fbd81094ec1ecad2c40371af56172993e150", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java b/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\nindex 123df7c85..63cb01a45 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\n\n@@ -51,6 +51,8 @@ public abstract class HelixPropertyTrimmer<T extends HelixProperty> {\n    */\n   public abstract T trimProperty(T property);\n \n+  // TODO: Simplify or remove the trim logic when we clearly separate the input and output ZNode.\n+  // TODO: e.g. Resource Config for user input and the Ideal State for the Helix output.\n   /**\n    * Return a ZNrecord as the trimmed copy of the original property.\n    * Note that we are NOT doing deep copy to avoid performance impact.\n"}}, {"oid": "5787fbd81094ec1ecad2c40371af56172993e150", "url": "https://github.com/apache/helix/commit/5787fbd81094ec1ecad2c40371af56172993e150", "message": "Add a TODO comment.", "committedDate": "2020-08-12T17:14:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxNjU1Mg==", "url": "https://github.com/apache/helix/pull/1256#discussion_r469416552", "bodyText": "This part of code may come as a surprise to future developers that extend this class. When getNonTrimmableFields() is provided for overriding, it's natural to think getNonTrimmableFields() provides full control on \"what fields to keep\". This logic here, while necessary, may become debug overhead. It's also hard to change this behavior in the future if it stays in doTrim() like so.\nI suggest creating another function such as getNonTrimmableKeysOnly() and implement it under HelixPropertyTrimmer.java to preserve MapField and ListField keys by default; in doTrim(), we call that function and preserve keys only. The extended classes may choose to override it (and for now, they shouldn't). This is a clearer approach to creating this abstract class.", "author": "NealSun96", "createdAt": "2020-08-12T17:16:50Z", "path": "helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java", "diffHunk": "@@ -57,38 +57,49 @@\n    * @param originalProperty\n    */\n   protected ZNRecord doTrim(T originalProperty) {\n+    ZNRecord originalZNRecord = originalProperty.getRecord();\n     ZNRecord trimmedZNRecord = new ZNRecord(originalProperty.getId());\n-    for (Map.Entry<FieldType, Set<String>> fieldEntry : getNonTrimmableFields(\n-        originalProperty).entrySet()) {\n+    Map<FieldType, Set<String>> nonTrimmableFields = getNonTrimmableFields(originalProperty);\n+\n+    // Ensure the keys of all map fields and list fields are preserved even after the trim.\n+    // The keys of list and map fields are relatively stable and contain important information. So\n+    // they should not be trimmed.\n+    originalZNRecord.getMapFields().keySet().stream()\n+        .forEach(key -> trimmedZNRecord.setMapField(key, Collections.EMPTY_MAP));\n+    originalZNRecord.getListFields().keySet().stream()\n+        .forEach(key -> trimmedZNRecord.setListField(key, Collections.EMPTY_LIST));", "originalCommit": "7a49fa3be60afb35f13ee9b7f04d1173b37ee15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQyNzg5NQ==", "url": "https://github.com/apache/helix/pull/1256#discussion_r469427895", "bodyText": "Good idea. It helps to clean up the code.", "author": "jiajunwang", "createdAt": "2020-08-12T17:35:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxNjU1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b69f2dba87eafa2a4b348dd15573bf1940a43bb4", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java b/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\nindex 123df7c85..dbab09ccc 100644\n--- a/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\n+++ b/helix-core/src/main/java/org/apache/helix/controller/changedetector/trimmer/HelixPropertyTrimmer.java\n\n@@ -41,16 +42,34 @@ public abstract class HelixPropertyTrimmer<T extends HelixProperty> {\n \n   /**\n    * @param property\n-   * @return a map contains the field keys of all non-trimmable fields that need to be kept.\n+   * @return a map contains the field keys of all non-trimmable field values that need to be kept.\n    */\n   protected abstract Map<FieldType, Set<String>> getNonTrimmableFields(T property);\n \n+  /**\n+   * By default, ensure the keys of all map fields and list fields are preserved even after the\n+   * trim. The keys of list and map fields are relatively stable and contain important information.\n+   * So they should not be trimmed.\n+   * Extend to override this behavior if necessary.\n+   * @param property\n+   * @return a map contains all non-trimmable field keys that need to be kept.\n+   *         Note that the values will be trimmed.\n+   */\n+  protected Map<FieldType, Set<String>> getNonTrimmableKeys(T property) {\n+    Map<FieldType, Set<String>> nonTrimmableKeys = new HashMap<>();\n+    nonTrimmableKeys.put(FieldType.MAP_FIELD, property.getRecord().getMapFields().keySet());\n+    nonTrimmableKeys.put(FieldType.LIST_FIELD, property.getRecord().getListFields().keySet());\n+    return nonTrimmableKeys;\n+  }\n+\n   /**\n    * @param property\n    * @return a copy of the property that has been trimmed.\n    */\n   public abstract T trimProperty(T property);\n \n+  // TODO: Simplify or remove the trim logic when we clearly separate the input and output ZNode.\n+  // TODO: e.g. Resource Config for user input and the Ideal State for the Helix output.\n   /**\n    * Return a ZNrecord as the trimmed copy of the original property.\n    * Note that we are NOT doing deep copy to avoid performance impact.\n"}}, {"oid": "b69f2dba87eafa2a4b348dd15573bf1940a43bb4", "url": "https://github.com/apache/helix/commit/b69f2dba87eafa2a4b348dd15573bf1940a43bb4", "message": "Address the comment.", "committedDate": "2020-08-12T17:41:21Z", "type": "commit"}]}