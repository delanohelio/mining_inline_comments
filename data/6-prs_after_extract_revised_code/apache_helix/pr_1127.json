{"pr_number": 1127, "pr_title": "Fix validation logic in GenericApiBuilders and add usage tests", "pr_createdAt": "2020-06-28T21:21:00Z", "pr_url": "https://github.com/apache/helix/pull/1127", "timeline": [{"oid": "4ef79137a5fef3ee809e508366c539f39bee088b", "url": "https://github.com/apache/helix/commit/4ef79137a5fef3ee809e508366c539f39bee088b", "message": "Fix validation logic in GenericApiBuilders and add usage tests\n\nSome of the validation logic in GenericBaseDataAccessorBuilder and GenericZkHelixApiBuilder were confusing and there were no usage tests. This commit reviews the consistency between validate methods of BaseDataAccessor APIs and writes test cases to demonstrate how they should be used.\n\nAlso, connection timeout setting wasn't being honored in the createZkClient() methods, so this bug was fixed as well.", "committedDate": "2020-06-28T21:12:06Z", "type": "commit"}, {"oid": "ac70f4805154f3e833465669645854a2c472d96a", "url": "https://github.com/apache/helix/commit/ac70f4805154f3e833465669645854a2c472d96a", "message": "Clean up the code", "committedDate": "2020-06-28T21:16:55Z", "type": "commit"}, {"oid": "6123ca7d25b0dcc654862cf52cb8b4ffd13c5784", "url": "https://github.com/apache/helix/commit/6123ca7d25b0dcc654862cf52cb8b4ffd13c5784", "message": "Fix bug", "committedDate": "2020-06-28T21:56:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNzYwOA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447317608", "bodyText": "Do we have some default mode for it? Shall we make it default behavior as single realm?", "author": "junkaixue", "createdAt": "2020-06-29T23:33:17Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -123,23 +124,26 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n \n   /**\n    * Validate ZkClientType based on RealmMode.\n+   * If ZkClientType is DEDICATED or SHARED, the realm mode must be SINGLE-REALM.\n+   * If ZkClientType is FEDERATED, the realm mode must be MULTI-REALM.\n    * @param zkClientType\n    * @param realmMode\n    */\n   private void validateZkClientType(ZkClientType zkClientType,\n       RealmAwareZkClient.RealmMode realmMode) {\n-    boolean isZkClientTypeSet = zkClientType != null;\n-    // If ZkClientType is set, RealmMode must either be single-realm or not set.\n-    if (isZkClientTypeSet && realmMode == RealmAwareZkClient.RealmMode.MULTI_REALM) {\n-      throw new HelixException(\"ZkClientType cannot be set on multi-realm mode!\");\n+    if (realmMode == null) {", "originalCommit": "6123ca7d25b0dcc654862cf52cb8b4ffd13c5784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5Mzc5MQ==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447393791", "bodyText": "In GenericZkHelixApiBuilder.java::validate(), we do this:\n    if (_realmMode == null) { _realmMode = isZkAddressSet ? RealmAwareZkClient.RealmMode.SINGLE_REALM : RealmAwareZkClient.RealmMode.MULTI_REALM; }\nAnd GenericZkHelixApiBuilder.java::validate() is called before this function. So we can assume that realmMode will never be null. I'm glad you asked this question - I will clarify this in the code and the JavaDoc.", "author": "narendly", "createdAt": "2020-06-30T03:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNzYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5NDIwMQ==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447394201", "bodyText": "As seen in:\nprotected void validate() {\n   super.validate();\n   validateZkClientType(_zkClientType, _realmMode);\n }", "author": "narendly", "createdAt": "2020-06-30T03:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNzYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "721274e8c45aa0554bff5989a83e8b01212cc6bf", "chunk": "diff --git a/helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java b/helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java\nindex cc7bddefd..6845802b5 100644\n--- a/helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java\n+++ b/helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java\n\n@@ -132,6 +121,8 @@ public class GenericBaseDataAccessorBuilder<B extends GenericBaseDataAccessorBui\n   private void validateZkClientType(ZkClientType zkClientType,\n       RealmAwareZkClient.RealmMode realmMode) {\n     if (realmMode == null) {\n+      // NOTE: GenericZkHelixApiBuilder::validate() is and must be called before this function, so\n+      // we could assume that realmMode will not be null. If it is, we throw an exception.\n       throw new HelixException(\n           \"GenericBaseDataAccessorBuilder: Cannot validate ZkClient type! RealmMode is null!\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447330082", "bodyText": "In this case, shall we merge the realm option into the enum item's fields? Then we don't need to check since the user cannot configure this option.", "author": "jiajunwang", "createdAt": "2020-06-30T00:11:38Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/ZkClientType.java", "diffHunk": "@@ -25,18 +25,24 @@\n    * creation, callback functionality, and session management. But note that this is more\n    * resource-heavy since it creates a dedicated ZK connection so should be used sparingly only\n    * when the aforementioned features are needed.\n+   *\n+   * Valid on SINGLE_REALM only.\n    */\n   DEDICATED,", "originalCommit": "6123ca7d25b0dcc654862cf52cb8b4ffd13c5784", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5NDkwMA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447394900", "bodyText": "@jiajunwang\nThe user does have the ability to select the ZkClientType. Before ZooScalability, we allowed users to select the ZkClientType (Dedicated or Shared) when creating a BaseDataAccessor. We are doing this to keep things backward-compatible. See the following examples (copy-pasted from the test cases added as part of this PR) below:\n  // Create ZkBaseDataAccessor, multi-realm, dedicated ZkClient (should fail)\n   try {\n     accessor = zkBaseDataAccessorBuilder.setRealmMode(RealmAwareZkClient.RealmMode.MULTI_REALM)\n         .setZkClientType(ZkClientType.DEDICATED).setZkAddress(firstZkAddress)\n         .setRealmAwareZkConnectionConfig(connectionConfigBuilder.build()).build();\n     Assert.fail(\"MULTI_REALM and DEDICATED ZkClientType are an invalid combination!\");\n   } catch (HelixException e) {\n     // Expected\n   }\n\n    // Create ZkBaseDataAccessor, multi-realm, shared ZkClient (should fail)\n   try {\n     accessor = zkBaseDataAccessorBuilder.setRealmMode(RealmAwareZkClient.RealmMode.MULTI_REALM)\n         .setZkClientType(ZkClientType.SHARED).setZkAddress(firstZkAddress)\n         .setRealmAwareZkConnectionConfig(connectionConfigBuilder.build()).build();\n     Assert.fail(\"MULTI_REALM and SHARED ZkClientType are an invalid combination!\");\n   } catch (HelixException e) {\n     // Expected\n   }\n\n    // Create ZkBaseDataAccessor, multi-realm, federated ZkClient, ZkAddress set (should fail)\n   try {\n     accessor = zkBaseDataAccessorBuilder.setRealmMode(RealmAwareZkClient.RealmMode.MULTI_REALM)\n         .setZkClientType(ZkClientType.FEDERATED).setZkAddress(firstZkAddress)\n         .setRealmAwareZkConnectionConfig(connectionConfigBuilder.build()).build();\n     Assert.fail(\"MULTI_REALM and FEDERATED ZkClientType do not connect to one ZK!\");\n   } catch (HelixException e) {\n     // Expected\n   }", "author": "narendly", "createdAt": "2020-06-30T04:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM5NTEzMQ==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447395131", "bodyText": "So to answer your question, because the user may want to choose which ZkClientType to use, it's appropriate that we leave this enum as a separate public enum.", "author": "narendly", "createdAt": "2020-06-30T04:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMDU0OQ==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447410549", "bodyText": "The user does have the ability to select the ZkClientType.\n\nSure. My question is that once a user selects a certain type, do they have to specify a RealmMode in addition? Since based on your comment, it seems to be pure overhead. Because if they select DEDICATED, then the real mode has to be SINGLE_REALM.\nI know this is for backward compatibility, so shall we just fill the RealmMode for the user when they configure the client using ZkClientType? In this case, we don't need the validation logic.", "author": "jiajunwang", "createdAt": "2020-06-30T05:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MjU5Mg==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447872592", "bodyText": "@jiajunwang\nThat is actually something I've considered and the original implementation was somewhat doing that. But I realized that this type of \"backfill\" or doing this under the surface was more confusing to the user and adds more difficulty in the usage of the Builder API. We should make sure we require the users to explicitly set the types/configs, otherwise we run the risk of doing things without the user knowing and confusing them.\nSo I made the decision to be as explicit as possible. This way, it will be more maintainable because we're not using hidden assumptions or rules.", "author": "narendly", "createdAt": "2020-06-30T17:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5MjI2NA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447892264", "bodyText": "So I have several questions after reviewing more code. Maybe you would like to clarify the plan?\n\n\nThe default builder build() method can actually create a client with MultiRealm enabled for DEDICATED client. However, we disable this option by enforcing the validation logic. Was it intentionally done?\n\n\nIf this is the case, then the actual build() code can be simplified, right? Since half of the branches won't be called forever.\n\n\n\nRegarding what you replied,\n\nmore confusing to the user and adds more difficulty in the usage of the Builder API\n\nI guess what you meant is that if there are 2 ways of configuring the client and these 2 options are all available in one builder, it would be confusing that which one to use.\nI think we discussed this topic before. To make it clearer, my suggestion would be,\n\nThe new builder does not allow ZkClientType config. Assume this is for backward compatibility. So we should not introduce to the new APIs.\nFor the older APIs (deprecated ones), as long as the type is passed in, we auto-fill the RealmMode based on the type. Since you mentioned in the comment that the mapping is one to one, this is doable.\nIn this case, there won't be a confusing part, IMO. And we won't need these validation logics everywhere. This helps with future maintenance work greatly.\n\nNot sure if you agree, please feel free to schedule a discussion. Maybe I missed some usage.\nBTW, if you are concerned about the already published version, then we can deprecate the ZkClientType setting method in the builders to suggest users not using it for now. The validation part can be left in the code until we make the API clean later.", "author": "jiajunwang", "createdAt": "2020-06-30T18:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MTA2OA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r447951068", "bodyText": "I think you're referring to\n\n      case MULTI_REALM:\n        try {\n          if (_zkClientType == ZkClientType.DEDICATED) {\n            // Use a realm-aware dedicated zk client\n            zkClient = DedicatedZkClientFactory.getInstance()\n                .buildZkClient(connectionConfig, clientConfig);\n          } else if (_zkClientType == ZkClientType.SHARED) {\n            // Use a realm-aware shared zk client\n            zkClient =\n                SharedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n          } else {\n            zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n          }\n        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n          throw new HelixException(\"Not able to connect on multi-realm mode.\", e);\n        }\n        break;\n\nReviewing this logic again, I believe this was a bug. Multi-realm means it has to use FederatedZkClient only because it has to be able to talk to multiple ZKs. I've fixed this. Good catch!\n\n\nI've removed some code in the createZkClient() method.\n\n\nWe can still support ZkClientType after fixing the bug. Like you said, ZkClientType is not set, we default to SHARED (original behavior).", "author": "narendly", "createdAt": "2020-06-30T20:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMjAzMA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r448022030", "bodyText": "Given the current situation that user still has an option to choose between dedicated/shared clients when the realm mode is single realm, I agree that we still need to keep the methods in the builder.", "author": "jiajunwang", "createdAt": "2020-06-30T22:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzMDA4Mg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "721274e8c45aa0554bff5989a83e8b01212cc6bf", "url": "https://github.com/apache/helix/commit/721274e8c45aa0554bff5989a83e8b01212cc6bf", "message": "fix", "committedDate": "2020-06-30T22:45:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTk1MA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r448541950", "bodyText": "If you think this is a bug we should fix, then we need to make clear definition of what is single realm and what is multi realm. My original thought was if you are using sharding key to determine the ZK address then it is mutli realm.\nThen for dedicated zkclient, and shared zkclient, they can still use sharding key for searching zk address. Then it will be meaningless for dedicated/shared Zkclient to have the sharding key and they will only accept the ZK address. This conflict with what we have changed.", "author": "junkaixue", "createdAt": "2020-07-01T18:25:31Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -82,38 +82,28 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n     switch (realmMode) {\n       case MULTI_REALM:\n         try {\n-          if (_zkClientType == ZkClientType.DEDICATED) {\n-            // Use a realm-aware dedicated zk client\n-            zkClient = DedicatedZkClientFactory.getInstance()\n-                .buildZkClient(connectionConfig, clientConfig);\n-          } else if (_zkClientType == ZkClientType.SHARED) {\n-            // Use a realm-aware shared zk client\n-            zkClient =\n-                SharedZkClientFactory.getInstance().buildZkClient(connectionConfig, clientConfig);\n-          } else {\n-            zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n-          }\n-        } catch (IOException | InvalidRoutingDataException | IllegalStateException e) {\n+          zkClient = new FederatedZkClient(connectionConfig, clientConfig);", "originalCommit": "721274e8c45aa0554bff5989a83e8b01212cc6bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU4NjU2OA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r448586568", "bodyText": "If you think this is a bug we should fix, then we need to make clear definition of what is single realm and what is multi realm. My original thought was if you are using sharding key to determine the ZK address then it is mutli realm.\n\n\"Multi-realm\" means it needs to be able to talk to different realms. \"Single-realm\" means it only connects to one realm.\nIf you're using a sharding key to locate which ZK to talk to, then it's \"realm-aware\", not multi-realm.\n\nThen for dedicated zkclient, and shared zkclient, they can still use sharding key for searching zk address. Then it will be meaningless for dedicated/shared Zkclient to have the sharding key and they will only accept the ZK address. This conflict with what we have changed.\n\nRealmAware DedicatedZkClient and SharedZkClient do not require a ZK address. They instead require the ZK path sharding key and only connect to the ZK realm that the given ZK path sharding key maps to. Again, they fall under the single-realm use case.\n@dasahcc Does this clarify?", "author": "narendly", "createdAt": "2020-07-01T20:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwMDUzMA==", "url": "https://github.com/apache/helix/pull/1127#discussion_r448600530", "bodyText": "Sounds good. We need to clear deliver this to users. Then for the change. I am totally fine with it.", "author": "junkaixue", "createdAt": "2020-07-01T20:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0MTk1MA=="}], "type": "inlineReview", "revised_code": null}]}