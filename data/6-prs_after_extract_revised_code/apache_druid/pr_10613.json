{"pr_number": 10613, "pr_title": "expression filter support for vectorized query engines", "pr_createdAt": "2020-11-28T00:20:24Z", "pr_url": "https://github.com/apache/druid/pull/10613", "timeline": [{"oid": "bdee07d201d713d7b4543ec7ce2bf07ac9f12763", "url": "https://github.com/apache/druid/commit/bdee07d201d713d7b4543ec7ce2bf07ac9f12763", "message": "expression filter support for vectorized query engines", "committedDate": "2020-11-27T08:25:46Z", "type": "commit"}, {"oid": "b53ae6e944cff8c846d9b509f7825adc0f76bd19", "url": "https://github.com/apache/druid/commit/b53ae6e944cff8c846d9b509f7825adc0f76bd19", "message": "remove unused codes", "committedDate": "2020-11-28T04:01:45Z", "type": "commit"}, {"oid": "14c83dba61f8f705c503fea712bdc94899921170", "url": "https://github.com/apache/druid/commit/14c83dba61f8f705c503fea712bdc94899921170", "message": "more tests", "committedDate": "2020-11-29T07:18:49Z", "type": "commit"}, {"oid": "3737851bdd1674c30a16aa3c1e75bc3b6ff2ba83", "url": "https://github.com/apache/druid/commit/3737851bdd1674c30a16aa3c1e75bc3b6ff2ba83", "message": "refactor, more tests", "committedDate": "2020-11-30T11:02:37Z", "type": "commit"}, {"oid": "c6cbe3fb4832d945737063f959a45525ed323622", "url": "https://github.com/apache/druid/commit/c6cbe3fb4832d945737063f959a45525ed323622", "message": "suppress", "committedDate": "2020-12-01T07:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553782719", "bodyText": "This opens not just STRING but also LONG_ARRAY and DOUBLE_ARRAY. Is that intentional (will numeric arrays work)?", "author": "gianm", "createdAt": "2021-01-08T07:28:35Z", "path": "core/src/main/java/org/apache/druid/math/expr/BinaryLogicalOperatorExpr.java", "diffHunk": "@@ -74,7 +74,7 @@ public ExprType getOutputType(InputBindingInspector inspector)\n   @Override\n   public boolean canVectorize(InputBindingInspector inspector)\n   {\n-    return inspector.areNumeric(left, right) && inspector.canVectorize(left, right);", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NzA4Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553847083", "bodyText": "i think canVectorize will still end up false because array types/functions are not yet vectorizable, but yeah i guess array types would not be well handled here even if they were, though maybe that is the case for non-vectorized expression as well. I'll do a bit of exploration and see what up", "author": "clintropolis", "createdAt": "2021-01-08T09:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODExNTMzNg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558115336", "bodyText": "Did this exploration lead somewhere?", "author": "gianm", "createdAt": "2021-01-15T09:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyMTY1MQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558121651", "bodyText": "array types do not currently implement canVectorize so will return the default false. We probably should not use canVectorize for argument validation and maybe should consider doing this explicitly when we can resolve the input types I think.", "author": "clintropolis", "createdAt": "2021-01-15T09:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2MjAzNA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558162034", "bodyText": "Got it. IMO we shouldn't rely on the fact that the array types happen to not be vectorizable. If they suddenly became vectorizable then this method would start returning true, maybe improperly.", "author": "gianm", "createdAt": "2021-01-15T09:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4MjcyNw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578982727", "bodyText": "like, I agree here, but canVectorize still feels wrong to saddle with type validation, it can explode when creating the processor if the types are nonsense\nI think what might be best is to introduce a 'validate' method to expressions so that arguments can be checked up front, and maybe explode if the input is madness", "author": "clintropolis", "createdAt": "2021-02-19T07:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk1NjQ2Nw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582956467", "bodyText": "In that case, could you add a comment about the situation?", "author": "gianm", "createdAt": "2021-02-25T16:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Mzg2NA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553783864", "bodyText": "This method deserves a javadoc.", "author": "gianm", "createdAt": "2021-01-08T07:32:04Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java", "diffHunk": "@@ -20,24 +20,29 @@\n package org.apache.druid.math.expr;\n \n import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n \n import javax.annotation.Nullable;\n import java.util.List;\n \n public class ExprTypeConversion\n {\n+  public static Pair<ExprType, ExprType> coerceNull(Expr.InputBindingInspector inspector, Expr left, Expr right)", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2Nzk1OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578967958", "bodyText": "i did one better and just removed it. null literals output type is now null instead of their type, so that they behave and are handled like missing columns (since null doesn't have a type)", "author": "clintropolis", "createdAt": "2021-02-19T06:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Mzg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "711a6b5d06450afbc809d6174a2919207d59cec1", "chunk": "diff --git a/core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java b/core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java\nindex 9671ce53ee..a5bd093ad7 100644\n--- a/core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java\n+++ b/core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java\n\n@@ -20,21 +20,12 @@\n package org.apache.druid.math.expr;\n \n import org.apache.druid.java.util.common.IAE;\n-import org.apache.druid.java.util.common.Pair;\n \n import javax.annotation.Nullable;\n import java.util.List;\n \n public class ExprTypeConversion\n {\n-  public static Pair<ExprType, ExprType> coerceNull(Expr.InputBindingInspector inspector, Expr left, Expr right)\n-  {\n-    return new Pair<>(\n-        left.isNullLiteral() ? right.getOutputType(inspector) : left.getOutputType(inspector),\n-        right.isNullLiteral() ? left.getOutputType(inspector) : right.getOutputType(inspector)\n-    );\n-  }\n-\n   /**\n    * Infer the output type of a list of possible 'conditional' expression outputs (where any of these could be the\n    * output expression if the corresponding case matching expression evaluates to true)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NTA4Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553785082", "bodyText": "What guarantees that the objects in the vector are Strings?", "author": "gianm", "createdAt": "2021-01-08T07:35:42Z", "path": "core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java", "diffHunk": "@@ -149,13 +150,14 @@ public boolean canVectorize(InputBindingInspector inspector)\n     ExprType inputType = inspector.getType(binding);\n \n     if (inputType == null) {\n-      // nil column, we can be anything, why not be a double\n-      return new IdentifierVectorProcessor<double[]>(ExprType.DOUBLE)\n+      // nil column, we can be anything, so be a string because it's the most flexible\n+      // (numbers will be populated with default values in default mode and non-null)\n+      return new IdentifierVectorProcessor<String[]>(ExprType.STRING)\n       {\n         @Override\n-        public ExprEvalVector<double[]> evalVector(VectorInputBinding bindings)\n+        public ExprEvalVector<String[]> evalVector(VectorInputBinding bindings)\n         {\n-          return new ExprEvalDoubleVector(bindings.getDoubleVector(binding), bindings.getNullVector(binding));\n+          return new ExprEvalStringVector(Arrays.stream(bindings.getObjectVector(binding)).map(x -> (String) x).toArray(String[]::new));", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTAwMzE1OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r579003158", "bodyText": "not sure why i had this code like this since in this case it is getting back nulls... it can just call bindings.getObjectVector. changed", "author": "clintropolis", "createdAt": "2021-02-19T08:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NTA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTAxMDI3Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r579010273", "bodyText": "oops, i lied, it needs to cast because non-existent column gives back Object[] of nulls instead of String[] of nulls", "author": "clintropolis", "createdAt": "2021-02-19T08:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NTA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "95bcf60b04d5f0b1ac04022e80dfeb4751a4381c", "chunk": "diff --git a/core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java b/core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java\nindex 00a8b43ab4..f021b41c03 100644\n--- a/core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java\n+++ b/core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java\n\n@@ -157,7 +156,7 @@ class IdentifierExpr implements Expr\n         @Override\n         public ExprEvalVector<String[]> evalVector(VectorInputBinding bindings)\n         {\n-          return new ExprEvalStringVector(Arrays.stream(bindings.getObjectVector(binding)).map(x -> (String) x).toArray(String[]::new));\n+          return new ExprEvalStringVector(bindings.getObjectVector(binding));\n         }\n       };\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786456", "bodyText": "This method should have a javadoc. The others should too, and they don't, but don't let that prevent you from adding one here \ud83d\ude42\nAs I type this, it's not clear to me what this method does, but hopefully it becomes clear elsewhere in the patch.", "author": "gianm", "createdAt": "2021-01-08T07:39:34Z", "path": "processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java", "diffHunk": "@@ -70,6 +71,11 @@ default MultiValueDimensionVectorSelector decorate(MultiValueDimensionVectorSele\n     throw new UOE(\"DimensionSpec[%s] cannot vectorize\", getClass().getName());\n   }\n \n+  default VectorObjectSelector decorate(VectorObjectSelector selector)", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0NTU5Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553845596", "bodyText": "This is used with the poorly named VectorColumnSelectorFactory.makeStringObjectSelector, which should be renamed VectorColumnSelectorFactory.makeDimensionObjectSelector or something, which is for doing dimensiony things with a vector object selector similar to what is done for SingleValueDimensionVectorSelector or MultiValueDimensionVectorSelector. There are currently no implementations of this, like is the case with the other decorate methods with vector selectors, i was just trying for symmetry here so that the object selector could behave similar to the other string selectors when used in this context", "author": "clintropolis", "createdAt": "2021-01-08T09:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEzMTQ1Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558131456", "bodyText": "I think this makes sense, so if we're going to keep this method, that'd all be good stuff to add to the javadoc. This method does need one because it's not obvious from the signature how it works, what its preconditions are, and what kinds of objects will come out of the selector it returns.", "author": "gianm", "createdAt": "2021-01-15T09:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2NjkwNQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582966905", "bodyText": "Will the VectorObjectSelector passed to this method always return an array whose values are all Strings? And is the same thing expected of the returned VectorObjectSelector? If so, please add that to the javadoc. If not, then I must be missing something and could you please explain it to me \ud83d\ude42\nBy the way, what happens if the input is multi-value? Will some of the entries in the Object[] of either the input or the output VectorObjectSelector actually be String[] instead of String? Or is multi-value not supported today?", "author": "gianm", "createdAt": "2021-02-25T16:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE5OTE0NA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r584199144", "bodyText": "I haven't yet implemented support for multi-value string object selectors, but your question also seems applicable if we were to add array types too. I guess the contents of the array would be dependent on whatever the underlying selector is providing, and it would be the responsibility of the DimensionSpec implementation to handle decoration appropriately? I guess we should also probably consider adding methods for the primitive numeric columns as well, since they are not masqueraded as \"dimension selectors\" in the vectorized engine, (if we ever want to fully support all of the non-vectorized behavior here I think).\nI don't know, the more I think about this, do we really need DimensionSpec, like at all? The stuff it does is all over the place, and it feels like maybe this type of stuff should just be pushed down into either expression virtual columns or something more specialized as appropriate (more generic predicate filtered selectors virtual column?). Then we maybe we can just ditch this stuff entirely in some sunny future instead of implementing vectorized versions of decorate for the various DimensionSpec implementations. Or is there an advantage to DimensionSpec that I am missing?", "author": "clintropolis", "createdAt": "2021-02-27T22:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDkyNTk1Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r584925952", "bodyText": "I don't know, the more I think about this, do we really need DimensionSpec, like at all?\n\nI don't think so, because the stuff it does could be done by virtual columns. Removing them would be a big backwards-incompatibility, but we don't necessarily have to remove them; we could just make them not-vectorizable and add notes in the docs that they are a legacy thing.\nToday the only DimensionSpec that is vectorizable is DefaultDimensionSpec (the one that does nothing other than pass-through), so nothing special is needed to support it.", "author": "gianm", "createdAt": "2021-03-01T17:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzQzMTI3Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r587431276", "bodyText": "I've removed the decorate method I added in this PR, in favor of removing this functionality from the vectorized engine. Since no decorate, no need for a separate \"object dimension selector\", I've removed that from VectorColumnSelectorFactory as well and reverted the signatures changes to processors that were needed to support that \ud83d\udc4d\nIf we do the same thing and ditch decorate for SingleValueDimensionVectorSelector and MultiValueDimensionVectorSelector there is quite a bit of simplification we can do, because we can discard the DimensionSpec much earlier and just work with columnName like the other selectors instead of going all the way down like it does now.", "author": "clintropolis", "createdAt": "2021-03-04T12:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5903fab18b8cfa5ebed434843021e1156a1c8857", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java b/processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java\nindex 64a5232e58..c6620ca41f 100644\n--- a/processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java\n+++ b/processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java\n\n@@ -59,18 +59,47 @@ public interface DimensionSpec extends Cacheable\n   @Nullable\n   ExtractionFn getExtractionFn();\n \n+  /**\n+   * Decorate a {@link DimensionSelector}, allowing custom transformation of underlying behavior (e.g. performing\n+   * extraction functions in the case of {@link ExtractionDimensionSpec}, regex filtering in the case of\n+   * {@link RegexFilteredDimensionSpec}, and so on).\n+   */\n   DimensionSelector decorate(DimensionSelector selector);\n \n+  /**\n+   * Vectorized analog of {@link #decorate(DimensionSelector)} for {@link SingleValueDimensionVectorSelector}, most\n+   * likely produced with\n+   * {@link org.apache.druid.segment.vector.VectorColumnSelectorFactory#makeSingleValueDimensionSelector(DimensionSpec)}\n+   *\n+   * Decoration allows a {@link DimensionSpec} to customize the behavior of the underlying selector, for example\n+   * transforming or filtering values.\n+   */\n   default SingleValueDimensionVectorSelector decorate(SingleValueDimensionVectorSelector selector)\n   {\n     throw new UOE(\"DimensionSpec[%s] cannot vectorize\", getClass().getName());\n   }\n \n+  /**\n+   * Vectorized analog of {@link #decorate(DimensionSelector) for {@link MultiValueDimensionVectorSelector}, most likely\n+   * produced with\n+   * {@link org.apache.druid.segment.vector.VectorColumnSelectorFactory#makeMultiValueDimensionSelector(DimensionSpec)}\n+   *\n+   * Decoration allows a {@link DimensionSpec} to customize the behavior of the underlying selector, for example\n+   * transforming or filtering values.\n+   */\n   default MultiValueDimensionVectorSelector decorate(MultiValueDimensionVectorSelector selector)\n   {\n     throw new UOE(\"DimensionSpec[%s] cannot vectorize\", getClass().getName());\n   }\n \n+  /**\n+   * Vectorized version of {@link #decorate(DimensionSelector)} for dimension {@link VectorObjectSelector}, most likely\n+   * produced with\n+   * {@link org.apache.druid.segment.vector.VectorColumnSelectorFactory#makeObjectDimensionSelector(DimensionSpec)}\n+   *\n+   * Decoration allows a {@link DimensionSpec} to customize the behavior of the underlying selector, for example\n+   * transforming or filtering values.\n+   */\n   default VectorObjectSelector decorate(VectorObjectSelector selector)\n   {\n     throw new UOE(\"DimensionSpec[%s] cannot vectorize\", getClass().getName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjgyMg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786822", "bodyText": "\"try\" makes it sound like this could potentially not work out. Why might it not work out? What bad stuff will happen if it doesn't work out?", "author": "gianm", "createdAt": "2021-01-08T07:40:34Z", "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -27,6 +27,13 @@\n {\n   Predicate<String> makeStringPredicate();\n \n+  default Predicate<Object> makeObjectPredicate()\n+  {\n+    // default to try to use string predicate;", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMzMxOA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553833318", "bodyText": "currently I don't think it should be possible because only expression filter will make a matcher factory with object matching predicate and only for string column types, but i guess cast exceptions if an object selector of a complex column somehow got in here from future code, see other comment about thinking a bit further about this \ud83d\ude05", "author": "clintropolis", "createdAt": "2021-01-08T09:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEzMjMyMw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558132323", "bodyText": "(see next comment #10613 (comment))", "author": "gianm", "createdAt": "2021-01-15T09:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjgyMg=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\nindex 45bca0c466..62d32f9061 100644\n--- a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n+++ b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n\n@@ -27,13 +27,6 @@ public interface DruidPredicateFactory\n {\n   Predicate<String> makeStringPredicate();\n \n-  default Predicate<Object> makeObjectPredicate()\n-  {\n-    // default to try to use string predicate;\n-    final Predicate<String> stringPredicate = makeStringPredicate();\n-    return o -> stringPredicate.apply((String) o);\n-  }\n-\n   DruidLongPredicate makeLongPredicate();\n \n   DruidFloatPredicate makeFloatPredicate();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Njg5MQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786891", "bodyText": "What guarantees that o is a String?", "author": "gianm", "createdAt": "2021-01-08T07:40:47Z", "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -27,6 +27,13 @@\n {\n   Predicate<String> makeStringPredicate();\n \n+  default Predicate<Object> makeObjectPredicate()\n+  {\n+    // default to try to use string predicate;\n+    final Predicate<String> stringPredicate = makeStringPredicate();\n+    return o -> stringPredicate.apply((String) o);", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMzA1Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553833052", "bodyText": "uh, it is sort of built on hope right now... the hope that it will probably be a string because the only context it will currently happen in is from making vector matcher object processors on string expression columns, but if we opened it up to additional non-primitive number types like array expressions and complex column types then this would need to be reconsidered, or stronger checks in place that the filter supports filtering on the underlying object type. I might need to think about this a bit deeper.", "author": "clintropolis", "createdAt": "2021-01-08T09:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Njg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyNzk3Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558127972", "bodyText": "I think it's worth designing this properly now, so we don't have to go back and fix it later.\nMaybe the right approach is to not add an extra method to DruidPredicateFactory, and instead have the callers call makeStringPredicate, because the callers are the ones that should have the knowledge that it's definitely a String column being dealt with.\nWould that work?", "author": "gianm", "createdAt": "2021-01-15T09:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Njg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4NTAyNw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578985027", "bodyText": "So, I agree that String objects should just use the string predicate, but I also liked the idea of having an object predicate so that we can potentially match array types and possibly complex types.\nI've modified the default implementation of object predicate to instead mimic the behavior of the NilVectorValueMatcher predicate, which supplied null to the string predicate.\nVectorValueMatcherColumnProcessorFactory.makeObjectProcessor  now checks the type, and uses either StringObjectVectorValueMatcher which always uses the string predicate, or ObjectVectorValueMatcher which calls the object predicate, and so has the behavior of the NilVectorValueMatcher.", "author": "clintropolis", "createdAt": "2021-02-19T07:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Njg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\nindex 45bca0c466..62d32f9061 100644\n--- a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n+++ b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n\n@@ -27,13 +27,6 @@ public interface DruidPredicateFactory\n {\n   Predicate<String> makeStringPredicate();\n \n-  default Predicate<Object> makeObjectPredicate()\n-  {\n-    // default to try to use string predicate;\n-    final Predicate<String> stringPredicate = makeStringPredicate();\n-    return o -> stringPredicate.apply((String) o);\n-  }\n-\n   DruidLongPredicate makeLongPredicate();\n \n   DruidFloatPredicate makeFloatPredicate();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NzU2Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553787566", "bodyText": "\"yet\"? Will they ever be?", "author": "gianm", "createdAt": "2021-01-08T07:42:45Z", "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java", "diffHunk": "@@ -64,7 +65,16 @@ public GroupByVectorColumnSelector makeMultiValueDimensionProcessor(\n         ValueType.STRING == capabilities.getType(),\n         \"groupBy dimension processors must be STRING typed\"\n     );\n-    throw new UnsupportedOperationException(\"Multi-value dimensions not yet implemented for vectorized groupBys\");\n+    throw new UnsupportedOperationException(\"Multi-value dimensions are not yet implemented for vectorized groupBys\");\n+  }\n+\n+  @Override\n+  public GroupByVectorColumnSelector makeObjectProcessor(\n+      ColumnCapabilities capabilities,\n+      VectorObjectSelector selector\n+  )\n+  {\n+    throw new UnsupportedOperationException(\"Object columns are not yet implemented for vectorized groupBys\");", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg0MDU3MA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553840570", "bodyText": "yes, I have a related branch that I will open as a follow-up to this PR that adds support for group-by queries on vectorized string expressions, using an object selector and a newly added dictionary building GroupByVectorColumnSelector similar to the non-vectorized group by code-path. In that branch this part checks that the column capabilities are string typed, and if so then will make the new dictionary building selector, else throw an exception for being an unsupported type.\nIt seems beneficial to not have to make the string expression vector results have to masquerade as dictionary encoded, to be translated to string values to be re-encoded into a new dictionary, which is part of my reason for pushing for object selectors for the use case", "author": "clintropolis", "createdAt": "2021-01-08T09:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEzMzYxNQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558133615", "bodyText": "Ah, in that case I wouldn't call them \"object columns\". IMO it's clearer to call them string columns that are being accessed through an object selector instead of a dimension selector.\n\"Object columns\" makes me think of complex columns, or of selectors of unknown types where we need to have runtime type detection.", "author": "gianm", "createdAt": "2021-01-15T09:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NzU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java b/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java\nindex 248e97195d..59faa7ff7c 100644\n--- a/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java\n+++ b/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java\n\n@@ -68,15 +68,6 @@ public class GroupByVectorColumnProcessorFactory implements VectorColumnProcesso\n     throw new UnsupportedOperationException(\"Multi-value dimensions are not yet implemented for vectorized groupBys\");\n   }\n \n-  @Override\n-  public GroupByVectorColumnSelector makeObjectProcessor(\n-      ColumnCapabilities capabilities,\n-      VectorObjectSelector selector\n-  )\n-  {\n-    throw new UnsupportedOperationException(\"Object columns are not yet implemented for vectorized groupBys\");\n-  }\n-\n   @Override\n   public GroupByVectorColumnSelector makeFloatProcessor(\n       final ColumnCapabilities capabilities,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4ODYwOQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553788609", "bodyText": "Why does it matter if the dictionary values are unique? (Even if they're not, can't we still use a regular string selector?)", "author": "gianm", "createdAt": "2021-01-08T07:45:34Z", "path": "processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java", "diffHunk": "@@ -305,17 +305,29 @@ private static ColumnCapabilities getEffectiveCapabilities(\n         originalCapabilities == null || ValueType.COMPLEX.equals(originalCapabilities.getType());\n \n     if (type == ValueType.STRING) {\n-      if (!forceSingleValue && effectiveCapabilites.hasMultipleValues().isMaybeTrue()) {\n-        return strategyFactory.makeMultiValueDimensionProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeMultiValueDimensionSelector(dimensionSpec)\n-        );\n-      } else {\n-        return strategyFactory.makeSingleValueDimensionProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeSingleValueDimensionSelector(dimensionSpec)\n-        );\n+      if (!forceSingleValue) {\n+        // if column is not dictionary encoded (and not non-existent or complex), use object selector\n+        if (effectiveCapabilites.isDictionaryEncoded().isFalse() ||\n+            effectiveCapabilites.areDictionaryValuesUnique().isFalse()", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgxNDY0OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553814648", "bodyText": "by regular string selector do you mean dimension selector? The answer is yes we could, but if the dictionary values are not unique, i came to the conclusion that they aren't especially useful since in all the cases I can think of you can't use them as is and you're going to have to lookup the string values anyway (e.g. filter matching and vector group by).\nI was trying to provide an avenue to avoid the extra steps with expression virtual columns, and allow an object selector to be created directly since the string is the useable part in this case, and the dictionary ids just feel like an obstruction. But maybe this is overly broad and there are cases where we would want it to act like a dictionary encoded column for some reason that I have missed?", "author": "clintropolis", "createdAt": "2021-01-08T08:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4ODYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEyNDc5Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558124796", "bodyText": "I think your reasoning makes sense, and it sounds like your assumption is that when selecting string-typed things that aren't dictionary-encoded, we should prefer the object selector vs. one of the DimensionVectorSelectors, because that'll incur less overhead.\nThis logic should be spelled out somewhere though. IMO javadocs on the appropriate methods in VectorColumnSelectorFactory is the best place. They should say when callers should prefer using the object selector vs. the more specifically-typed selectors.", "author": "gianm", "createdAt": "2021-01-15T09:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4ODYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2NDc0MA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578964740", "bodyText": "I think I've got this covered better now", "author": "clintropolis", "createdAt": "2021-02-19T06:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4ODYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java b/processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java\nindex 0f49a22939..c2d748e5c9 100644\n--- a/processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java\n+++ b/processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java\n\n@@ -256,108 +290,6 @@ public final class DimensionHandlerUtils\n     return strategyFactory.makeColumnSelectorStrategy(capabilities, selector);\n   }\n \n-  /**\n-   * Equivalent to calling makeVectorProcessor(DefaultDimensionSpec.of(column), strategyFactory, selectorFactory).\n-   *\n-   * @see #makeVectorProcessor(DimensionSpec, VectorColumnProcessorFactory, VectorColumnSelectorFactory)\n-   * @see ColumnProcessors#makeProcessor the non-vectorized version\n-   */\n-  public static <T> T makeVectorProcessor(\n-      final String column,\n-      final VectorColumnProcessorFactory<T> strategyFactory,\n-      final VectorColumnSelectorFactory selectorFactory\n-  )\n-  {\n-    return makeVectorProcessor(DefaultDimensionSpec.of(column), strategyFactory, selectorFactory);\n-  }\n-\n-  /**\n-   * Creates \"vector processors\", which are objects that wrap a single vectorized input column and provide some\n-   * functionality on top of it. Used by things like query engines and filter matchers.\n-   *\n-   * Supports the basic types STRING, LONG, DOUBLE, and FLOAT.\n-   *\n-   * @param dimensionSpec   dimensionSpec for the input to the processor\n-   * @param strategyFactory object that encapsulates the knowledge about how to create processors\n-   * @param selectorFactory column selector factory used for creating the vector processor\n-   *\n-   * @see ColumnProcessors#makeProcessor the non-vectorized version\n-   */\n-  public static <T> T makeVectorProcessor(\n-      final DimensionSpec dimensionSpec,\n-      final VectorColumnProcessorFactory<T> strategyFactory,\n-      final VectorColumnSelectorFactory selectorFactory\n-  )\n-  {\n-    final ColumnCapabilities originalCapabilities =\n-        selectorFactory.getColumnCapabilities(dimensionSpec.getDimension());\n-\n-    final ColumnCapabilities effectiveCapabilites = getEffectiveCapabilities(\n-        dimensionSpec,\n-        originalCapabilities\n-    );\n-\n-    final ValueType type = effectiveCapabilites.getType();\n-\n-    // vector selectors should never have null column capabilities, these signify a non-existent column, and complex\n-    // columns should never be treated as a multi-value column, so always use single value string processor\n-    final boolean forceSingleValue =\n-        originalCapabilities == null || ValueType.COMPLEX.equals(originalCapabilities.getType());\n-\n-    if (type == ValueType.STRING) {\n-      if (!forceSingleValue) {\n-        // if column is not dictionary encoded (and not non-existent or complex), use object selector\n-        if (effectiveCapabilites.isDictionaryEncoded().isFalse() ||\n-            effectiveCapabilites.areDictionaryValuesUnique().isFalse()\n-        ) {\n-          return strategyFactory.makeObjectProcessor(\n-              effectiveCapabilites,\n-              selectorFactory.makeStringObjectSelector(dimensionSpec)\n-          );\n-        }\n-        // multi-value dictionary encoded string?\n-        if (effectiveCapabilites.hasMultipleValues().isMaybeTrue()) {\n-          return strategyFactory.makeMultiValueDimensionProcessor(\n-              effectiveCapabilites,\n-              selectorFactory.makeMultiValueDimensionSelector(dimensionSpec)\n-          );\n-        }\n-      }\n-      // single-value dictionary encoded\n-      return strategyFactory.makeSingleValueDimensionProcessor(\n-          effectiveCapabilites,\n-          selectorFactory.makeSingleValueDimensionSelector(dimensionSpec)\n-      );\n-    } else {\n-      Preconditions.checkState(\n-          dimensionSpec.getExtractionFn() == null && !dimensionSpec.mustDecorate(),\n-          \"Uh oh, was about to try to make a value selector for type[%s] with a dimensionSpec of class[%s] that \"\n-          + \"requires decoration. Possible bug.\",\n-          type,\n-          dimensionSpec.getClass().getName()\n-      );\n-\n-      if (type == ValueType.LONG) {\n-        return strategyFactory.makeLongProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeValueSelector(dimensionSpec.getDimension())\n-        );\n-      } else if (type == ValueType.FLOAT) {\n-        return strategyFactory.makeFloatProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeValueSelector(dimensionSpec.getDimension())\n-        );\n-      } else if (type == ValueType.DOUBLE) {\n-        return strategyFactory.makeDoubleProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeValueSelector(dimensionSpec.getDimension())\n-        );\n-      } else {\n-        throw new ISE(\"Unsupported type[%s]\", effectiveCapabilites.getType());\n-      }\n-    }\n-  }\n-\n   @Nullable\n   public static String convertObjectToString(@Nullable Object valObj)\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553796056", "bodyText": "Interesting. It sounds like a bug that DruidPredicateFactory is annotated with @SubclassesMustOverrideEqualsAndHashCodeTest but yet its toString method is used for equality checks. Is that right? If so, perhaps a good fix would be:\n\nKeep the annotation on DimensionPredicateFilter\nSwitch the equality checks in DimensionPredicateFilter to use DruidPredicateFactory equals rather than toString\n\nIf we do that, IMO it'd be good to do it separately from this patch and also separately from #8256.\n\nDruidPredicateFactory doesn't really need equals or hashcode\n\nHow else would DimensionPredicateFilter's equals be implemented?", "author": "gianm", "createdAt": "2021-01-08T08:06:36Z", "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgxNjIwNg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553816206", "bodyText": "yeah, I was planning on addressing this in a separate PR, the comments are partially to help remind us to do it in case I didn't get to it immediately", "author": "clintropolis", "createdAt": "2021-01-08T08:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEzNjI5Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558136293", "bodyText": "\ud83d\udc4d  although I'm still wondering: how else would DimensionPredicateFilter's equals be implemented, if not via equals and hashCode on DruidPredicateFactory?\n(Assuming we stop it from using toString, which IMO we should)", "author": "gianm", "createdAt": "2021-01-15T09:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2NDYxNw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578964617", "bodyText": "oops, I forgot to rework this comment, it is assuming that it keeps using toString. If we changed that to not use the string for its equality then it would be the toString that isn't necessary, will try to rework", "author": "clintropolis", "createdAt": "2021-02-19T06:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTAwMzg0Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r579003843", "bodyText": "changed comment to suggest DimensionPredicateFilter should use equals of predicate factory instead of string form", "author": "clintropolis", "createdAt": "2021-02-19T08:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\nindex 46c1795370..50636d1f13 100644\n--- a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n+++ b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n\n@@ -135,7 +135,7 @@ public class ExpressionFilter implements Filter\n \n       // in sql compatible mode, this means no matches ever, so just use the false matcher:\n       if (NullHandling.sqlCompatible()) {\n-        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+        return BooleanVectorValueMatcher.of(factory.getReadableVectorInspector(), false);\n       }\n       // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n       // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjY2OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553796668", "bodyText": "Love the comment but the patch shouldn't go live like this \ud83d\ude42\nCan you come up with a scenario where we'll actually hit this case and add some tests for it? Maybe in the process of doing that, a better way to behave or a better way to describe the behavior will come up.", "author": "gianm", "createdAt": "2021-01-08T08:08:15Z", "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called\n+      // when testing equality of DimensionPredicateFilter, so it's the truly required method, but even that seems\n+      // strange at best.\n+      // Rather than tackle removing the annotation and reworking equality tests for now, will leave this to refactor\n+      // as part of https://github.com/apache/druid/issues/8256 which suggests combining Filter and DimFilter\n+      // implementations, which should clean up some of this mess.\n+      @Override\n+      public int hashCode()\n+      {\n+        return super.hashCode();\n+      }\n+\n+      @Override\n+      public boolean equals(Object obj)\n+      {\n+        return super.equals(obj);\n+      }\n+    };\n+\n+\n+    final ExprType outputType = theExpr.getOutputType(factory);\n+\n+    if (outputType == null) {\n+      // if an expression is vectorizable, but the output type is null, the result will be null (or the default\n+      // value in default mode) because expression is either all null constants or missing columns\n+\n+      // in sql compatible mode, this means no matches ever, so just use the false matcher:\n+      if (NullHandling.sqlCompatible()) {\n+        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+      }\n+      // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n+      // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n+      // in default mode is dancing on the edge of insanity anyway...", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2MTk3OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578961978", "bodyText": "I reworked this to be cooler I think, since a vectorizable expression that produces a 'null' output type means all inputs are null constants or missing columns, so the function is a constant function, we can just evaluate the expression and make a constant matcher of the correct type instead of just going with something that worked in most cases by luck.", "author": "clintropolis", "createdAt": "2021-02-19T06:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\nindex 46c1795370..50636d1f13 100644\n--- a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n+++ b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n\n@@ -135,7 +135,7 @@ public class ExpressionFilter implements Filter\n \n       // in sql compatible mode, this means no matches ever, so just use the false matcher:\n       if (NullHandling.sqlCompatible()) {\n-        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+        return BooleanVectorValueMatcher.of(factory.getReadableVectorInspector(), false);\n       }\n       // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n       // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMDAyNQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553800025", "bodyText": "createSimpleNumericColumnCapabilities is a weird method to call with type STRING. Is this a mistake? Or is the method just named poorly?", "author": "gianm", "createdAt": "2021-01-08T08:16:41Z", "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called\n+      // when testing equality of DimensionPredicateFilter, so it's the truly required method, but even that seems\n+      // strange at best.\n+      // Rather than tackle removing the annotation and reworking equality tests for now, will leave this to refactor\n+      // as part of https://github.com/apache/druid/issues/8256 which suggests combining Filter and DimFilter\n+      // implementations, which should clean up some of this mess.\n+      @Override\n+      public int hashCode()\n+      {\n+        return super.hashCode();\n+      }\n+\n+      @Override\n+      public boolean equals(Object obj)\n+      {\n+        return super.equals(obj);\n+      }\n+    };\n+\n+\n+    final ExprType outputType = theExpr.getOutputType(factory);\n+\n+    if (outputType == null) {\n+      // if an expression is vectorizable, but the output type is null, the result will be null (or the default\n+      // value in default mode) because expression is either all null constants or missing columns\n+\n+      // in sql compatible mode, this means no matches ever, so just use the false matcher:\n+      if (NullHandling.sqlCompatible()) {\n+        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+      }\n+      // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n+      // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n+      // in default mode is dancing on the edge of insanity anyway...\n+      return VectorValueMatcherColumnProcessorFactory.instance().makeLongProcessor(\n+          ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.LONG),\n+          ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+      ).makeMatcher(predicateFactory);\n+    }\n+\n+    switch (outputType) {\n+      case LONG:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeLongProcessor(\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.LONG),\n+            ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+        ).makeMatcher(predicateFactory);\n+      case DOUBLE:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeDoubleProcessor(\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.DOUBLE),\n+            ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+        ).makeMatcher(predicateFactory);\n+      case STRING:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeObjectProcessor(\n+            // using 'numeric' capabilities creator so we are configured to NOT be dictionary encoded, etc\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.STRING),", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgxODE1Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553818153", "bodyText": "it is strange, but on purpose for the reason the comment says since the numeric capabilities defaults are correct in this case. I will make sure all current users are numeric types, and if so then just make these capabilites from scratch because we should be counting on something geared towards numeric behavior in case those change in some unexpected way. Or, if it is used by other non-numbers then rename it to something more appropriate, like createSimpleSingleValueColumnCapabilites or similar", "author": "clintropolis", "createdAt": "2021-01-08T08:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMDAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODEzODYyNg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558138626", "bodyText": "I think one of those two options you mentioned would be good. IMO we shouldn't call a function named createSimpleNumericColumnCapabilities in this context, even if it happens to do the right thing, because it \"looks wrong\" and that trips people up that are trying to read through it.", "author": "gianm", "createdAt": "2021-01-15T09:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMDAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2MTAwMw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578961003", "bodyText": "added a createSimpleStringColumnCapabilities", "author": "clintropolis", "createdAt": "2021-02-19T06:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMDAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\nindex 46c1795370..50636d1f13 100644\n--- a/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n+++ b/processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java\n\n@@ -135,7 +135,7 @@ public class ExpressionFilter implements Filter\n \n       // in sql compatible mode, this means no matches ever, so just use the false matcher:\n       if (NullHandling.sqlCompatible()) {\n-        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+        return BooleanVectorValueMatcher.of(factory.getReadableVectorInspector(), false);\n       }\n       // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n       // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMTY5Nw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553801697", "bodyText": "What does it do when called on a non-string column? Cast the stuff to strings? Return null? Something else?", "author": "gianm", "createdAt": "2021-01-08T08:21:00Z", "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -57,6 +57,15 @@ default int getMaxVectorSize()\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns an object selector for string columns, useful for non-dictionary encoded strings, or when", "originalCommit": "c6cbe3fb4832d945737063f959a45525ed323622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyMDYxOQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r553820619", "bodyText": "hmm, i have no idea why I named this function like this, it should probably be called makeDimensionObjectSelector. Its just expected to make a VectorObjectSelector from a DimensionSpec rather than a raw column name", "author": "clintropolis", "createdAt": "2021-01-08T09:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE0MzU5NQ==", "url": "https://github.com/apache/druid/pull/10613#discussion_r558143595", "bodyText": "The javadoc here should be fleshed out to describe the expected contract. IMO it should answer questions like:\n\nIf you call this with a DimensionSpec that refers to a non-string column, what happens?\nWill the returned VectorObjectSelector always return a String or null?\n\u2026might it return List for a multi-value string column?", "author": "gianm", "createdAt": "2021-01-15T09:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk2MDc2OA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r578960768", "bodyText": "I think javadocs are maybe cooler now in describing the intent of these methods", "author": "clintropolis", "createdAt": "2021-02-19T06:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMTY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3736bed61e604004a77caea166ac7d72f62b103f", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\nindex ef11c1fec7..87f922bc1d 100644\n--- a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n+++ b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n\n@@ -44,39 +48,67 @@ public interface VectorColumnSelectorFactory extends ColumnInspector\n    */\n   default int getMaxVectorSize()\n   {\n-    return getVectorSizeInspector().getMaxVectorSize();\n+    return getReadableVectorInspector().getMaxVectorSize();\n   }\n \n   /**\n-   * Returns a string-typed, single-value-per-row column selector.\n+   * Returns a dictionary encoded, string-typed, single-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING, or on nonexistent columns. Since the selector\n+   * created with this method operates directly on the dictionary encoded input, STRING values must be translated from\n+   * the dictionary id for a given row value using {@link SingleValueDimensionVectorSelector#lookupName(int)}, but\n+   * this selector can prove optimal for operations which can be done directly on the underlying dictionary ids, such\n+   * as grouping within a segment.\n+   *\n+   * If you need to write code that adapts to different input types, you should write a\n+   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n+   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   SingleValueDimensionVectorSelector makeSingleValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a string-typed, multi-value-per-row column selector.\n+   * Returns a dictionary encoded, string-typed, multi-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING. Unlike\n+   * {@link #makeSingleValueDimensionSelector}, this should not be called on nonexistent columns.\n+   *\n+   * If you need to write code that adapts to different input types, you should write a\n+   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n+   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns an object selector for string columns, useful for non-dictionary encoded strings, or when\n-   * using the dictionary isn't useful\n+   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n+   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING\n+   * vector object selector is not yet implemented), but perhaps a world can be imagined where this could work with\n+   * COMPLEX too perhaps if it were useful for them to interact with {@link DimensionSpec} in some manner? May be called\n+   * for non-existent columns.\n+   *\n+   * If you need to write code that adapts to different input types, you should write a\n+   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n+   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n-  default VectorObjectSelector makeStringObjectSelector(DimensionSpec dimensionSpec)\n-  {\n-    return makeObjectSelector(dimensionSpec.getDimension());\n-  }\n+  VectorObjectSelector makeObjectDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a primitive column selector.\n+   * Returns a primitive column selector. Should only be called on columns where {@link #getColumnCapabilities}\n+   * indicates they return DOUBLE, FLOAT, or LONG, or on nonexistent columns.\n+   *\n+   * If you need to write code that adapts to different input types, you should write a\n+   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n+   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   VectorValueSelector makeValueSelector(String column);\n \n   /**\n-   * Returns an object selector, useful for complex columns.\n+   * Returns an object selector. Should only be called on columns where {@link #getColumnCapabilities} indicates that\n+   * they return STRING or COMPLEX, or on nonexistent columns.\n+   *\n+   * If you need to write code that adapts to different input types, you should write a\n+   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n+   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   VectorObjectSelector makeObjectSelector(String column);\n \n-\n   /**\n    * Returns capabilities of a particular column, or null if the column doesn't exist. Unlike ColumnSelectorFactory,\n    * null does not potentially indicate a dynamically discovered column.\n"}}, {"oid": "3736bed61e604004a77caea166ac7d72f62b103f", "url": "https://github.com/apache/druid/commit/3736bed61e604004a77caea166ac7d72f62b103f", "message": "Merge remote-tracking branch 'upstream/master' into vector-expr-filter", "committedDate": "2021-02-08T03:36:56Z", "type": "commit"}, {"oid": "5903fab18b8cfa5ebed434843021e1156a1c8857", "url": "https://github.com/apache/druid/commit/5903fab18b8cfa5ebed434843021e1156a1c8857", "message": "more", "committedDate": "2021-02-10T10:21:36Z", "type": "commit"}, {"oid": "711a6b5d06450afbc809d6174a2919207d59cec1", "url": "https://github.com/apache/druid/commit/711a6b5d06450afbc809d6174a2919207d59cec1", "message": "more", "committedDate": "2021-02-11T08:24:52Z", "type": "commit"}, {"oid": "95bcf60b04d5f0b1ac04022e80dfeb4751a4381c", "url": "https://github.com/apache/druid/commit/95bcf60b04d5f0b1ac04022e80dfeb4751a4381c", "message": "more", "committedDate": "2021-02-19T08:17:06Z", "type": "commit"}, {"oid": "8d29fd6e2050ace4b2e19ba56f538a50bd64d321", "url": "https://github.com/apache/druid/commit/8d29fd6e2050ace4b2e19ba56f538a50bd64d321", "message": "Merge remote-tracking branch 'upstream/master' into vector-expr-filter", "committedDate": "2021-02-19T08:22:21Z", "type": "commit"}, {"oid": "a3e5c915b7f13e701e3c6f2767a90e853aaefca9", "url": "https://github.com/apache/druid/commit/a3e5c915b7f13e701e3c6f2767a90e853aaefca9", "message": "oops, i was wrong", "committedDate": "2021-02-19T08:30:32Z", "type": "commit"}, {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "url": "https://github.com/apache/druid/commit/406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "message": "comment", "committedDate": "2021-02-19T08:53:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3MTY5Mw==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582971693", "bodyText": "Based on #10613 (comment) it seems like the intent of this method is that it will only be called for complex types (or maybe nonexistent columns too). If that's the case, please add some javadoc explaining that this method will only be called for complex types. It's analogous to \"makeObjectProcessor\" in \"VectorColumnProcessorFactory\". (You could even @see to that method in the javadocs if you want.)", "author": "gianm", "createdAt": "2021-02-25T16:20:18Z", "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -32,4 +32,15 @@\n   DruidFloatPredicate makeFloatPredicate();\n \n   DruidDoublePredicate makeDoublePredicate();\n+\n+  /**\n+   * Object predicate is currently only used by vectorized matchers for non-string object selectors. To preserve\n+   * behavior with non-vectorized matchers which use a string predicate with null inputs for these 'nil' matchers,\n+   * do the same thing here...\n+   */\n+  default Predicate<Object> makeObjectPredicate()", "originalCommit": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzQzMjIyMg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r587432222", "bodyText": "adjusted javadocs", "author": "clintropolis", "createdAt": "2021-03-04T12:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3MTY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e3b0a948b128461470c562d4681b4e1af21a9ded", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\nindex 8a83e9353b..aff4346c43 100644\n--- a/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n+++ b/processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java\n\n@@ -34,9 +34,14 @@ public interface DruidPredicateFactory\n   DruidDoublePredicate makeDoublePredicate();\n \n   /**\n-   * Object predicate is currently only used by vectorized matchers for non-string object selectors. To preserve\n-   * behavior with non-vectorized matchers which use a string predicate with null inputs for these 'nil' matchers,\n-   * do the same thing here...\n+   * Object predicate is currently only used by vectorized matchers for non-string object selectors. This currently\n+   * means it will be used only if we encounter COMPLEX types, but will also include array types once they are more\n+   * supported throughout the query engines.\n+   *\n+   * To preserve behavior with non-vectorized matchers which use a string predicate with null inputs for these 'nil'\n+   * matchers, we do the same thing here.\n+   *\n+   * @see org.apache.druid.segment.VectorColumnProcessorFactory#makeObjectProcessor\n    */\n   default Predicate<Object> makeObjectPredicate()\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4NTM0Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582985342", "bodyText": "These javadocs should explicitly constrain the type of Object that may show up in the returned VectorObjectSelector. Is it always going to be a String or a null? Might it be String[], if the underlying column is multi-value?", "author": "gianm", "createdAt": "2021-02-25T16:36:49Z", "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -62,16 +66,29 @@ default int getMaxVectorSize()\n   SingleValueDimensionVectorSelector makeSingleValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a string-typed, multi-value-per-row column selector. Should only be called on columns where\n-   * {@link #getColumnCapabilities} indicates they return STRING. Unlike {@link #makeSingleValueDimensionSelector},\n-   * this should not be called on nonexistent columns.\n+   * Returns a dictionary encoded, string-typed, multi-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING. Unlike\n+   * {@link #makeSingleValueDimensionSelector}, this should not be called on nonexistent columns.\n    *\n    * If you need to write code that adapts to different input types, you should write a\n    * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n    * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n+   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING\n+   * vector object selector is not yet implemented), but perhaps a world can be imagined where this could work with\n+   * COMPLEX too perhaps if it were useful for them to interact with {@link DimensionSpec} in some manner? May be called\n+   * for non-existent columns.", "originalCommit": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e3b0a948b128461470c562d4681b4e1af21a9ded", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\nindex 87f922bc1d..4928b43fe6 100644\n--- a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n+++ b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n\n@@ -76,19 +76,6 @@ public interface VectorColumnSelectorFactory extends ColumnInspector\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n-  /**\n-   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n-   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING\n-   * vector object selector is not yet implemented), but perhaps a world can be imagined where this could work with\n-   * COMPLEX too perhaps if it were useful for them to interact with {@link DimensionSpec} in some manner? May be called\n-   * for non-existent columns.\n-   *\n-   * If you need to write code that adapts to different input types, you should write a\n-   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n-   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n-   */\n-  VectorObjectSelector makeObjectDimensionSelector(DimensionSpec dimensionSpec);\n-\n   /**\n    * Returns a primitive column selector. Should only be called on columns where {@link #getColumnCapabilities}\n    * indicates they return DOUBLE, FLOAT, or LONG, or on nonexistent columns.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4NTk1Mg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582985952", "bodyText": "Get rid of the \"probably\" \ud83d\ude42\nEither it will work or it won't. If it doesn't work, say firmly not to do it, and ideally describe what will happen if you do it accidentally (the method will throw an error? the method will return a selector with undefined behavior? etc). If it does work, but might be a bad idea for some reason, spell that out.", "author": "gianm", "createdAt": "2021-02-25T16:37:33Z", "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -62,16 +66,29 @@ default int getMaxVectorSize()\n   SingleValueDimensionVectorSelector makeSingleValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a string-typed, multi-value-per-row column selector. Should only be called on columns where\n-   * {@link #getColumnCapabilities} indicates they return STRING. Unlike {@link #makeSingleValueDimensionSelector},\n-   * this should not be called on nonexistent columns.\n+   * Returns a dictionary encoded, string-typed, multi-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING. Unlike\n+   * {@link #makeSingleValueDimensionSelector}, this should not be called on nonexistent columns.\n    *\n    * If you need to write code that adapts to different input types, you should write a\n    * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n    * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n+   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING", "originalCommit": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzQzMTcxMg==", "url": "https://github.com/apache/druid/pull/10613#discussion_r587431712", "bodyText": "i got rid of this method, and merged these javadocs into the makeObjectSelector javadocs", "author": "clintropolis", "createdAt": "2021-03-04T12:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4NTk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e3b0a948b128461470c562d4681b4e1af21a9ded", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\nindex 87f922bc1d..4928b43fe6 100644\n--- a/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n+++ b/processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java\n\n@@ -76,19 +76,6 @@ public interface VectorColumnSelectorFactory extends ColumnInspector\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n-  /**\n-   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n-   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING\n-   * vector object selector is not yet implemented), but perhaps a world can be imagined where this could work with\n-   * COMPLEX too perhaps if it were useful for them to interact with {@link DimensionSpec} in some manner? May be called\n-   * for non-existent columns.\n-   *\n-   * If you need to write code that adapts to different input types, you should write a\n-   * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n-   * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n-   */\n-  VectorObjectSelector makeObjectDimensionSelector(DimensionSpec dimensionSpec);\n-\n   /**\n    * Returns a primitive column selector. Should only be called on columns where {@link #getColumnCapabilities}\n    * indicates they return DOUBLE, FLOAT, or LONG, or on nonexistent columns.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4OTI2NA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r582989264", "bodyText": "Is it ok that hasMultipleValues is false here? That seems like the potentially-sketchiest of the behaviors, since someone might use this method for a multi-value string accidentally. How about naming it createSimpleSingleValueStringColumnCapabilities?\nMethod names: the longer the better. Go, Java.", "author": "gianm", "createdAt": "2021-02-25T16:41:31Z", "path": "processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java", "diffHunk": "@@ -177,6 +177,21 @@ public static ColumnCapabilitiesImpl createSimpleNumericColumnCapabilities(Value\n     return builder;\n   }\n \n+  /**\n+   * Simple, non dictionary encoded string without bitmap index or anything fancy\n+   */\n+  public static ColumnCapabilitiesImpl createSimpleStringColumnCapabilities()\n+  {\n+    return new ColumnCapabilitiesImpl().setType(ValueType.STRING)\n+                                       .setHasMultipleValues(false)", "originalCommit": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzQzMTQyNA==", "url": "https://github.com/apache/druid/pull/10613#discussion_r587431424", "bodyText": "renamed ^", "author": "clintropolis", "createdAt": "2021-03-04T12:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4OTI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e3b0a948b128461470c562d4681b4e1af21a9ded", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\nindex 3c8feb8c3c..7b3dd448c5 100644\n--- a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\n+++ b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\n\n@@ -178,9 +178,9 @@ public class ColumnCapabilitiesImpl implements ColumnCapabilities\n   }\n \n   /**\n-   * Simple, non dictionary encoded string without bitmap index or anything fancy\n+   * Simple, single valued, non dictionary encoded string without bitmap index or anything fancy\n    */\n-  public static ColumnCapabilitiesImpl createSimpleStringColumnCapabilities()\n+  public static ColumnCapabilitiesImpl createSimpleSingleValueStringColumnCapabilities()\n   {\n     return new ColumnCapabilitiesImpl().setType(ValueType.STRING)\n                                        .setHasMultipleValues(false)\n"}}, {"oid": "e3b0a948b128461470c562d4681b4e1af21a9ded", "url": "https://github.com/apache/druid/commit/e3b0a948b128461470c562d4681b4e1af21a9ded", "message": "remove decorate, object dimension selector, more javadocs", "committedDate": "2021-03-04T12:26:02Z", "type": "commit"}, {"oid": "347752463fab8f2f57b58c84a28b2b58d26fcb43", "url": "https://github.com/apache/druid/commit/347752463fab8f2f57b58c84a28b2b58d26fcb43", "message": "style", "committedDate": "2021-03-05T06:58:49Z", "type": "commit"}]}