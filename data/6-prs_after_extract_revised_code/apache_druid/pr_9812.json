{"pr_number": 9812, "pr_title": "Fix filtering on boolean values in transformation", "pr_createdAt": "2020-05-03T00:25:07Z", "pr_url": "https://github.com/apache/druid/pull/9812", "timeline": [{"oid": "8b53f0bd21a1d6f13fe7ae5e8dbc41ae62d56d74", "url": "https://github.com/apache/druid/commit/8b53f0bd21a1d6f13fe7ae5e8dbc41ae62d56d74", "message": "Fix filter on boolean value in Transform", "committedDate": "2020-05-03T00:09:36Z", "type": "commit"}, {"oid": "6747ea78865d72153cd0f4eb35e4bd8c5709edf2", "url": "https://github.com/apache/druid/commit/6747ea78865d72153cd0f4eb35e4bd8c5709edf2", "message": "assert", "committedDate": "2020-05-03T01:45:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjUxOA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419142518", "bodyText": "It's not obvious where dmFy comes from. What do you think about adding comment about base64 or adding a variable with a descriptive name?", "author": "ccaominh", "createdAt": "2020-05-03T18:40:49Z", "path": "processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.filter;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.SelectorPredicateFactory;\n+import org.apache.druid.query.filter.ValueMatcher;\n+import org.apache.druid.segment.DimensionSelector;\n+import org.apache.druid.segment.SimpleAscendingOffset;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.data.GenericIndexed;\n+import org.apache.druid.segment.data.VSizeColumnarInts;\n+import org.apache.druid.segment.data.VSizeColumnarMultiInts;\n+import org.apache.druid.segment.selector.TestColumnValueSelector;\n+import org.apache.druid.segment.serde.DictionaryEncodedColumnSupplier;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+\n+public class PredicateValueMatcherFactoryTest extends InitializedNullHandlingTest\n+{\n+  @Test\n+  public void testDefaultType()\n+  {\n+    Assert.assertEquals(ValueType.COMPLEX, forSelector(null).defaultType());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorSingleValuedDimensionMatchingValue()\n+  {\n+    final ValueMatcher matcher = forSelector(\"0\").makeDimensionProcessor(DimensionSelector.constant(\"0\"), false);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorSingleValuedDimensionNotMatchingValue()\n+  {\n+    final ValueMatcher matcher = forSelector(\"1\").makeDimensionProcessor(DimensionSelector.constant(\"0\"), false);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorMultiValuedDimensionMatchingValue()\n+  {\n+    // Emulate multi-valued dimension\n+    final DictionaryEncodedColumnSupplier columnSupplier = new DictionaryEncodedColumnSupplier(\n+        GenericIndexed.fromIterable(ImmutableList.of(\"v1\", \"v2\", \"v3\"), GenericIndexed.STRING_STRATEGY),\n+        null,\n+        () -> VSizeColumnarMultiInts.fromIterable(ImmutableList.of(VSizeColumnarInts.fromArray(new int[]{1}))),\n+        0\n+    );\n+    final ValueMatcher matcher = forSelector(\"v2\")\n+        .makeDimensionProcessor(columnSupplier.get().makeDimensionSelector(new SimpleAscendingOffset(1), null), true);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorMultiValuedDimensionNotMatchingValue()\n+  {\n+    // Emulate multi-valued dimension\n+    final DictionaryEncodedColumnSupplier columnSupplier = new DictionaryEncodedColumnSupplier(\n+        GenericIndexed.fromIterable(ImmutableList.of(\"v1\", \"v2\", \"v3\"), GenericIndexed.STRING_STRATEGY),\n+        null,\n+        () -> VSizeColumnarMultiInts.fromIterable(ImmutableList.of(VSizeColumnarInts.fromArray(new int[]{1}))),\n+        0\n+    );\n+    final ValueMatcher matcher = forSelector(\"v3\")\n+        .makeDimensionProcessor(columnSupplier.get().makeDimensionSelector(new SimpleAscendingOffset(1), null), true);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testFloatProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(2.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2.f\").makeFloatProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testFloatProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(2.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5.f\").makeFloatProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDoubleProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(2.),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2.\").makeDoubleProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDoubleProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(2.),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5.\").makeDoubleProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testLongProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(2L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2\").makeLongProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testLongProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(2L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5\").makeLongProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingNull()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        Arrays.asList(null, \"v\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorEmptyString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        Arrays.asList(\"\", \"v\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    if (NullHandling.sqlCompatible()) {\n+      Assert.assertFalse(matcher.matches());\n+    } else {\n+      Assert.assertTrue(matcher.matches());\n+    }\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingInteger()\n+  {\n+    final TestColumnValueSelector<Integer> columnValueSelector = TestColumnValueSelector.of(\n+        Integer.class,\n+        ImmutableList.of(11),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingInteger()\n+  {\n+    final TestColumnValueSelector<Integer> columnValueSelector = TestColumnValueSelector.of(\n+        Integer.class,\n+        ImmutableList.of(15),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingLong()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(11L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingLong()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(15L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingFloat()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(11.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.f\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingFloat()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(15.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.f\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingDouble()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(11.d),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.d\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingDouble()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(15.d),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.d\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(\"val\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(\"bar\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingStringList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of(\"val\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingStringList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of(\"bar\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingEmptyList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of()),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingBoolean()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(false),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"false\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingBoolean()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(true),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"false\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingByteArray()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(StringUtils.toUtf8(\"var\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"dmFy\").makeComplexProcessor(columnValueSelector);", "originalCommit": "6747ea78865d72153cd0f4eb35e4bd8c5709edf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1Njg2OQ==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419156869", "bodyText": "Sounds good. Changed it to be more descriptive.", "author": "jihoonson", "createdAt": "2020-05-03T20:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "abe6a6bb03fa21ee07819c01d9edb62180c06d10", "chunk": "diff --git a/processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java b/processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java\nindex 12df51d3c3..df5a35e5d3 100644\n--- a/processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java\n+++ b/processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java\n\n@@ -404,7 +404,8 @@ public class PredicateValueMatcherFactoryTest extends InitializedNullHandlingTes\n         DateTimes.nowUtc()\n     );\n     columnValueSelector.advance();\n-    final ValueMatcher matcher = forSelector(\"dmFy\").makeComplexProcessor(columnValueSelector);\n+    final String base64Encoded = StringUtils.encodeBase64String(StringUtils.toUtf8(\"var\"));\n+    final ValueMatcher matcher = forSelector(base64Encoded).makeComplexProcessor(columnValueSelector);\n     Assert.assertTrue(matcher.matches());\n   }\n \n"}}, {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10", "url": "https://github.com/apache/druid/commit/abe6a6bb03fa21ee07819c01d9edb62180c06d10", "message": "more descriptive test", "committedDate": "2020-05-03T20:37:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzE0Ng==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419717146", "bodyText": "For anti-bug safety, it'd be good to have a Preconditions.checkState(stringValueValid) here.", "author": "gianm", "createdAt": "2020-05-04T20:45:25Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprEval.java", "diffHunk": "@@ -137,6 +137,23 @@ public T value()\n     return value;\n   }\n \n+  void setStringValue(@Nullable String value)\n+  {\n+    stringValue = value;\n+    stringValueValid = true;\n+  }\n+\n+  @Nullable\n+  String getStringValue()\n+  {\n+    return stringValue;\n+  }\n+\n+  boolean isStringValueValid()\n+  {\n+    return stringValueValid;", "originalCommit": "abe6a6bb03fa21ee07819c01d9edb62180c06d10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NTU4MQ==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419775581", "bodyText": "This method is to check whether or not stringValue is initialized. It will explode this line.", "author": "jihoonson", "createdAt": "2020-05-04T22:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4Nzk5NA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419787994", "bodyText": "Sorry, I meant to add this comment to getStringValue(). That's the one I was thinking should have the precondition check.", "author": "gianm", "createdAt": "2020-05-04T23:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMTU0OA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419801548", "bodyText": "Ah good point. Added an assert. Also renamed getStringValue() and isStringValueValid() to getCachedStringValue() and isStringValueCached().", "author": "jihoonson", "createdAt": "2020-05-05T00:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "chunk": "diff --git a/core/src/main/java/org/apache/druid/math/expr/ExprEval.java b/core/src/main/java/org/apache/druid/math/expr/ExprEval.java\nindex 3ea6adbf65..18d0cc75f7 100644\n--- a/core/src/main/java/org/apache/druid/math/expr/ExprEval.java\n+++ b/core/src/main/java/org/apache/druid/math/expr/ExprEval.java\n\n@@ -137,34 +137,35 @@ public abstract class ExprEval<T>\n     return value;\n   }\n \n-  void setStringValue(@Nullable String value)\n+  void cacheStringValue(@Nullable String value)\n   {\n     stringValue = value;\n-    stringValueValid = true;\n+    stringValueCached = true;\n   }\n \n   @Nullable\n-  String getStringValue()\n+  String getCacheStringValue()\n   {\n+    assert stringValueCached;\n     return stringValue;\n   }\n \n-  boolean isStringValueValid()\n+  boolean isStringValueCached()\n   {\n-    return stringValueValid;\n+    return stringValueCached;\n   }\n \n   @Nullable\n   public String asString()\n   {\n-    if (!stringValueValid) {\n+    if (!stringValueCached) {\n       if (value == null) {\n         stringValue = null;\n       } else {\n         stringValue = String.valueOf(value);\n       }\n \n-      stringValueValid = true;\n+      stringValueCached = true;\n     }\n \n     return stringValue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxOTk2Nw==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419719967", "bodyText": "If I'm reading this right, eval really could be an array at runtime, so an assert isn't the right thing to do here. They are disabled by default outside of unit tests. So they're mostly useful for checking things that cannot possibly be false unless there is some bug in the software logic itself.\nBesides that, since this error could happen due to legitimate user input, it should have a nicer error message.\nAlso, is there a reason to only adjust strlen in this patch? Lots of other functions have similar issues. I'm wondering if we should split this part off into a separate patch, and make sure we address it systematically.", "author": "gianm", "createdAt": "2020-05-04T20:50:52Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -1490,7 +1491,9 @@ public String name()\n     @Override\n     public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n     {\n-      final String arg = args.get(0).eval(bindings).asString();\n+      final ExprEval eval = args.get(0).eval(bindings);\n+      assert !(eval instanceof ArrayExprEval);", "originalCommit": "abe6a6bb03fa21ee07819c01d9edb62180c06d10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NTY1Mw==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419775653", "bodyText": "Besides that, since this error could happen due to legitimate user input, it should have a nicer error message.\n\nOh yeah, that's true. I forgot about that even though that was the original issue. I changed from throwing an exception to an assert here since it should never happen on the query side and apply() will be called per row. A systematic way to check before calling apply() makes most sense to me.\n\nAlso, is there a reason to only adjust strlen in this patch? Lots of other functions have similar issues. I'm wondering if we should split this part off into a separate patch, and make sure we address it systematically.\n\nThere is no reason to fix only strlen. I just happened to find it while adding unit tests and thought fixed it. I reverted this change back for now.", "author": "jihoonson", "createdAt": "2020-05-04T22:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxOTk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "chunk": "diff --git a/core/src/main/java/org/apache/druid/math/expr/Function.java b/core/src/main/java/org/apache/druid/math/expr/Function.java\nindex 78371be2c8..757451fe4f 100644\n--- a/core/src/main/java/org/apache/druid/math/expr/Function.java\n+++ b/core/src/main/java/org/apache/druid/math/expr/Function.java\n\n@@ -1491,9 +1491,7 @@ public interface Function\n     @Override\n     public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n     {\n-      final ExprEval eval = args.get(0).eval(bindings);\n-      assert !(eval instanceof ArrayExprEval);\n-      final String arg = eval.asString();\n+      final String arg = args.get(0).eval(bindings).asString();\n       return arg == null ? ExprEval.ofLong(NullHandling.defaultLongValue()) : ExprEval.of(arg.length());\n     }\n \n"}}, {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "url": "https://github.com/apache/druid/commit/c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "message": "remove assert", "committedDate": "2020-05-04T22:55:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4ODE1Nw==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419788157", "bodyText": "This line might get flagged as an unused import.", "author": "gianm", "createdAt": "2020-05-04T23:32:31Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -25,6 +25,7 @@\n import org.apache.druid.java.util.common.IAE;\n import org.apache.druid.java.util.common.RE;\n import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprEval.ArrayExprEval;", "originalCommit": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMTEwNw==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419801107", "bodyText": "Oops, fixed.", "author": "jihoonson", "createdAt": "2020-05-05T00:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4ODE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "chunk": "diff --git a/core/src/main/java/org/apache/druid/math/expr/Function.java b/core/src/main/java/org/apache/druid/math/expr/Function.java\nindex 757451fe4f..af52555793 100644\n--- a/core/src/main/java/org/apache/druid/math/expr/Function.java\n+++ b/core/src/main/java/org/apache/druid/math/expr/Function.java\n\n@@ -25,7 +25,6 @@ import org.apache.druid.java.util.common.DateTimes;\n import org.apache.druid.java.util.common.IAE;\n import org.apache.druid.java.util.common.RE;\n import org.apache.druid.java.util.common.StringUtils;\n-import org.apache.druid.math.expr.ExprEval.ArrayExprEval;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEwMQ==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419795101", "bodyText": "This test should be adjusted since you removed the strlen change.", "author": "gianm", "createdAt": "2020-05-04T23:55:51Z", "path": "processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.transform;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowListPlusRawValues;\n+import org.apache.druid.data.input.MapBasedInputRow;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.query.expression.TestExprMacroTable;\n+import org.apache.druid.query.filter.SelectorDimFilter;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.joda.time.DateTime;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class TransformerTest extends InitializedNullHandlingTest\n+{\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testTransformNullRowReturnNull()\n+  {\n+    final Transformer transformer = new Transformer(new TransformSpec(null, null));\n+    Assert.assertNull(transformer.transform((InputRow) null));\n+    Assert.assertNull(transformer.transform((InputRowListPlusRawValues) null));\n+  }\n+\n+  @Test\n+  public void testTransformTimeColumn()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(\n+                new ExpressionTransform(\"__time\", \"timestamp_shift(__time, 'P1D', -2)\", TestExprMacroTable.INSTANCE)\n+            )\n+        )\n+    );\n+    final DateTime now = DateTimes.nowUtc();\n+    final InputRow row = new MapBasedInputRow(\n+        now,\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"__time\", now, \"dim\", false)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(now.minusDays(2), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnBooleanColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", false)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(5L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnLongColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", 10L)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(2L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnDoubleColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", 200.5d)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(5L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnListColumnThrowingException()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", ImmutableList.of(10, 20, 100))\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    // Unlike for querying, Druid doesn't explode multi-valued columns automatically for ingestion.\n+    expectedException.expect(AssertionError.class);", "originalCommit": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMTEzNA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419801134", "bodyText": "Oops, disabled this test.", "author": "jihoonson", "createdAt": "2020-05-05T00:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "chunk": "diff --git a/processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java b/processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java\nindex 89df47306d..5cf1b33d5a 100644\n--- a/processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java\n+++ b/processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java\n\n@@ -30,6 +30,7 @@ import org.apache.druid.query.filter.SelectorDimFilter;\n import org.apache.druid.testing.InitializedNullHandlingTest;\n import org.joda.time.DateTime;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.ExpectedException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEzNA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419795134", "bodyText": "This test should be adjusted since you removed the strlen change.", "author": "gianm", "createdAt": "2020-05-04T23:55:58Z", "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "diffHunk": "@@ -100,6 +105,7 @@ public void testStrlen()\n   {\n     assertExpr(\"strlen(x)\", 3L);\n     assertExpr(\"strlen(nonexistent)\", NullHandling.defaultLongValue());\n+    assertExprFail(\"strlen(a)\", AssertionError.class, null);", "originalCommit": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMTM0OA==", "url": "https://github.com/apache/druid/pull/9812#discussion_r419801348", "bodyText": "Removed this test for now. We can add it back when we fix #9824.", "author": "jihoonson", "createdAt": "2020-05-05T00:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "chunk": "diff --git a/core/src/test/java/org/apache/druid/math/expr/FunctionTest.java b/core/src/test/java/org/apache/druid/math/expr/FunctionTest.java\nindex ad9badf594..2fe52490c4 100644\n--- a/core/src/test/java/org/apache/druid/math/expr/FunctionTest.java\n+++ b/core/src/test/java/org/apache/druid/math/expr/FunctionTest.java\n\n@@ -105,7 +100,6 @@ public class FunctionTest extends InitializedNullHandlingTest\n   {\n     assertExpr(\"strlen(x)\", 3L);\n     assertExpr(\"strlen(nonexistent)\", NullHandling.defaultLongValue());\n-    assertExprFail(\"strlen(a)\", AssertionError.class, null);\n   }\n \n   @Test\n"}}, {"oid": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "url": "https://github.com/apache/druid/commit/a1eb51e7ff06d5621a76036b71d5ed3b96149451", "message": "add assert for cached string; disable tests", "committedDate": "2020-05-05T00:15:21Z", "type": "commit"}, {"oid": "2309381fedf3966bfd557199a5d779bb58320358", "url": "https://github.com/apache/druid/commit/2309381fedf3966bfd557199a5d779bb58320358", "message": "typo", "committedDate": "2020-05-05T00:18:12Z", "type": "commit"}]}