{"pr_number": 10171, "pr_title": "Add integration tests for query retry on missing segments", "pr_createdAt": "2020-07-11T06:20:44Z", "pr_url": "https://github.com/apache/druid/pull/10171", "timeline": [{"oid": "ee004a6c21963acb0ad2544472d56fbb51e2fe1f", "url": "https://github.com/apache/druid/commit/ee004a6c21963acb0ad2544472d56fbb51e2fe1f", "message": "Add integration tests for query retry on missing segments", "committedDate": "2020-07-11T06:14:11Z", "type": "commit"}, {"oid": "77712b6b6bac4ca457b8e9e107bacf4061a3c4d7", "url": "https://github.com/apache/druid/commit/77712b6b6bac4ca457b8e9e107bacf4061a3c4d7", "message": "add missing dependencies; fix travis conf", "committedDate": "2020-07-11T19:30:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE5NTg2NA==", "url": "https://github.com/apache/druid/pull/10171#discussion_r454195864", "bodyText": "what is this change for?", "author": "clintropolis", "createdAt": "2020-07-14T08:36:39Z", "path": "processing/src/main/java/org/apache/druid/query/timeseries/TimeseriesQueryQueryToolChest.java", "diffHunk": "@@ -138,7 +139,9 @@ public TimeseriesQueryQueryToolChest(TimeseriesQueryMetricsFactory queryMetricsF\n \n       final Sequence<Result<TimeseriesResultValue>> finalSequence;\n \n-      if (query.getGranularity().equals(Granularities.ALL) && !query.isSkipEmptyBuckets()) {\n+      if (query.getGranularity().equals(Granularities.ALL) &&", "originalCommit": "77712b6b6bac4ca457b8e9e107bacf4061a3c4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTEwMw==", "url": "https://github.com/apache/druid/pull/10171#discussion_r454735103", "bodyText": "To be more sql-compliant, the timeseries query returns something if there is no grouping key even when there is nothing to return. However, this behavior is not preferred I think when bySegment is set because, bySegment is used for caching in historicals or debugging where exact results are supposed to be returned. When caching is enabled, it will populate empty result in historicals after this change, but the broker will return the correct result since bySegment won't be set for it. I added some comment for it.", "author": "jihoonson", "createdAt": "2020-07-15T01:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE5NTg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "00269102e00e0330ab496910713195ab31f07801", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/timeseries/TimeseriesQueryQueryToolChest.java b/processing/src/main/java/org/apache/druid/query/timeseries/TimeseriesQueryQueryToolChest.java\nindex e7731dc3ba..9b4c94b895 100644\n--- a/processing/src/main/java/org/apache/druid/query/timeseries/TimeseriesQueryQueryToolChest.java\n+++ b/processing/src/main/java/org/apache/druid/query/timeseries/TimeseriesQueryQueryToolChest.java\n\n@@ -139,10 +139,17 @@ public class TimeseriesQueryQueryToolChest extends QueryToolChest<Result<Timeser\n \n       final Sequence<Result<TimeseriesResultValue>> finalSequence;\n \n+      // When granularity = ALL, there is no grouping key for this query.\n+      // To be more sql-compliant, we should return something (e.g., 0 for count queries) even when\n+      // the sequence is empty.\n       if (query.getGranularity().equals(Granularities.ALL) &&\n+          // Returns empty sequence if this query allows skipping empty buckets\n           !query.isSkipEmptyBuckets() &&\n+          // Returns empty sequence if bySegment is set because bySegment results are mostly used for\n+          // caching in historicals or debugging where the exact results are preferred.\n           !QueryContexts.isBySegment(query)) {\n-        //Usally it is NOT Okay to materialize results via toList(), but Granularity is ALL thus we have only one record\n+        // Usally it is NOT Okay to materialize results via toList(), but Granularity is ALL thus\n+        // we have only one record.\n         final List<Result<TimeseriesResultValue>> val = baseResults.toList();\n         finalSequence = val.isEmpty() ? Sequences.simple(Collections.singletonList(\n             getNullTimeseriesResultValue(query))) : Sequences.simple(val);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwODk5OA==", "url": "https://github.com/apache/druid/pull/10171#discussion_r454208998", "bodyText": "Is a custom main method easier than using theCliCommandCreator extension point? I thought you just need something like this:\npublic class QueryRetryTestCommandCreator implements CliCommandCreator\n{\n  @Override\n  public void addCommands(Cli.CliBuilder builder)\n  {\n    builder.withGroup(\"server\").withCommands(CliHistoricalForQueryRetryTest.class);\n  }\n}\nand a META-INF/services entry for it, but I can't remember, maybe there is something more to it", "author": "clintropolis", "createdAt": "2020-07-14T08:59:00Z", "path": "integration-tests/src/main/java/org/apache/druid/cli/MainForQueryRetryTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.cli;\n+\n+import com.google.inject.Injector;\n+import io.airlift.airline.Cli;\n+import io.airlift.airline.Help;\n+import io.airlift.airline.ParseException;\n+import io.netty.util.SuppressForbidden;\n+import org.apache.druid.guice.ExtensionsConfig;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.initialization.Initialization;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+\n+/**\n+ * Main class for query retry testing.\n+ *\n+ * @see CliHistoricalForQueryRetryTest\n+ */\n+public class MainForQueryRetryTest", "originalCommit": "77712b6b6bac4ca457b8e9e107bacf4061a3c4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjIwOQ==", "url": "https://github.com/apache/druid/pull/10171#discussion_r454736209", "bodyText": "Thanks for pointing it out. I didn't know that is a thing. However, looking at that, it seems like a useful way to develop a custom service based on Druid's extension system. This will work for now since the integration tests load all extensions with the same class loader, but won't work once we fix them to use Druid's extension loading system. I would keep the current implementation for now.", "author": "jihoonson", "createdAt": "2020-07-15T01:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwODk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5ODUzMA==", "url": "https://github.com/apache/druid/pull/10171#discussion_r456198530", "bodyText": "Hmm, first of all, I didn't notice that our integration tests already use Druid's extension system. This is a pretty good improvement! \ud83d\ude42 Looking at this more, the suggested way seems working since it's the main thread which loads and executes this command. I have added an integration-tests extension and made it to be loaded for query-retry testing group.", "author": "jihoonson", "createdAt": "2020-07-17T03:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIwODk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "cf0055b492309eb129dbade7efebd5b3fd38ba1e", "chunk": "diff --git a/integration-tests/src/main/java/org/apache/druid/cli/MainForQueryRetryTest.java b/integration-tests/src/main/java/org/apache/druid/cli/MainForQueryRetryTest.java\ndeleted file mode 100644\nindex 7132771b18..0000000000\n--- a/integration-tests/src/main/java/org/apache/druid/cli/MainForQueryRetryTest.java\n+++ /dev/null\n\n@@ -1,93 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.druid.cli;\n-\n-import com.google.inject.Injector;\n-import io.airlift.airline.Cli;\n-import io.airlift.airline.Help;\n-import io.airlift.airline.ParseException;\n-import io.netty.util.SuppressForbidden;\n-import org.apache.druid.guice.ExtensionsConfig;\n-import org.apache.druid.guice.GuiceInjectors;\n-import org.apache.druid.initialization.Initialization;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.ServiceLoader;\n-\n-/**\n- * Main class for query retry testing.\n- *\n- * @see CliHistoricalForQueryRetryTest\n- */\n-public class MainForQueryRetryTest\n-{\n-  static {\n-    ServiceLoader<PropertyChecker> serviceLoader = ServiceLoader.load(PropertyChecker.class);\n-    for (PropertyChecker propertyChecker : serviceLoader) {\n-      propertyChecker.checkProperties(System.getProperties());\n-    }\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  @SuppressForbidden(reason = \"System#out\")\n-  public static void main(String[] args)\n-  {\n-    final Cli.CliBuilder<Runnable> builder = Cli.builder(\"druid\");\n-\n-    builder.withDescription(\"Druid command-line runner.\")\n-           .withDefaultCommand(Help.class)\n-           .withCommands(Help.class, Version.class);\n-\n-    List<Class<? extends Runnable>> serverCommands = Collections.singletonList(CliHistoricalForQueryRetryTest.class);\n-    builder.withGroup(\"server\")\n-           .withDescription(\"Run one of the Druid server types.\")\n-           .withDefaultCommand(Help.class)\n-           .withCommands(serverCommands);\n-\n-    final Injector injector = GuiceInjectors.makeStartupInjector();\n-    final ExtensionsConfig config = injector.getInstance(ExtensionsConfig.class);\n-    final Collection<CliCommandCreator> extensionCommands = Initialization.getFromExtensions(\n-        config,\n-        CliCommandCreator.class\n-    );\n-\n-    for (CliCommandCreator creator : extensionCommands) {\n-      creator.addCommands(builder);\n-    }\n-\n-    final Cli<Runnable> cli = builder.build();\n-    try {\n-      final Runnable command = cli.parse(args);\n-      if (!(command instanceof Help)) { // Hack to work around Help not liking being injected\n-        injector.injectMembers(command);\n-      }\n-      command.run();\n-    }\n-    catch (ParseException e) {\n-      System.out.println(\"HMMMM ERROR!!!!\");\n-      System.out.println(e.getMessage());\n-      System.out.println(\"===\");\n-      cli.parse(new String[]{\"help\"}).run();\n-      System.exit(1);\n-    }\n-  }\n-}\n"}}, {"oid": "00269102e00e0330ab496910713195ab31f07801", "url": "https://github.com/apache/druid/commit/00269102e00e0330ab496910713195ab31f07801", "message": "address comments", "committedDate": "2020-07-15T01:18:46Z", "type": "commit"}, {"oid": "cf0055b492309eb129dbade7efebd5b3fd38ba1e", "url": "https://github.com/apache/druid/commit/cf0055b492309eb129dbade7efebd5b3fd38ba1e", "message": "Integration tests extension", "committedDate": "2020-07-17T03:26:50Z", "type": "commit"}, {"oid": "04695125277ebcb885b5e95efd0b702c8bd65b47", "url": "https://github.com/apache/druid/commit/04695125277ebcb885b5e95efd0b702c8bd65b47", "message": "remove unused dependency", "committedDate": "2020-07-17T04:27:49Z", "type": "commit"}, {"oid": "d329359b2dbc05a6e4ea2dd3df104d5ba11079d5", "url": "https://github.com/apache/druid/commit/d329359b2dbc05a6e4ea2dd3df104d5ba11079d5", "message": "Merge branch 'master' into it-test-query-retry", "committedDate": "2020-07-20T20:48:22Z", "type": "commit"}, {"oid": "d22f034c2cc768dd4af882600da7869895d4831c", "url": "https://github.com/apache/druid/commit/d22f034c2cc768dd4af882600da7869895d4831c", "message": "remove druid_main", "committedDate": "2020-07-20T20:52:15Z", "type": "commit"}, {"oid": "ef06f3b18a4dd8bfacc7f132d69853045598c12d", "url": "https://github.com/apache/druid/commit/ef06f3b18a4dd8bfacc7f132d69853045598c12d", "message": "Merge branch 'master' into it-test-query-retry", "committedDate": "2020-07-21T17:51:13Z", "type": "commit"}, {"oid": "dbd587e96bb00c994a036c82f6fc31d790096736", "url": "https://github.com/apache/druid/commit/dbd587e96bb00c994a036c82f6fc31d790096736", "message": "fix java agent port", "committedDate": "2020-07-22T18:42:14Z", "type": "commit"}, {"oid": "a08a3da71f18f379130db29a70732bd5c00f061e", "url": "https://github.com/apache/druid/commit/a08a3da71f18f379130db29a70732bd5c00f061e", "message": "Merge branch 'it-test-query-retry' of github.com:jihoonson/druid into it-test-query-retry", "committedDate": "2020-07-22T18:42:39Z", "type": "commit"}]}