{"pr_number": 9648, "pr_title": "SQL: More straightforward handling of join planning.", "pr_createdAt": "2020-04-08T11:40:39Z", "pr_url": "https://github.com/apache/druid/pull/9648", "timeline": [{"oid": "b35fc89a2b363d52bf08b5384b20a54b41f815f2", "url": "https://github.com/apache/druid/commit/b35fc89a2b363d52bf08b5384b20a54b41f815f2", "message": "SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead, add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal), but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now, and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\", and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6', 'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646.", "committedDate": "2020-04-08T11:42:48Z", "type": "commit"}, {"oid": "b35fc89a2b363d52bf08b5384b20a54b41f815f2", "url": "https://github.com/apache/druid/commit/b35fc89a2b363d52bf08b5384b20a54b41f815f2", "message": "SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead, add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal), but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now, and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\", and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6', 'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646.", "committedDate": "2020-04-08T11:42:48Z", "type": "forcePushed"}, {"oid": "37bdd608922c4d6447fd7d406801e9b8a5f06572", "url": "https://github.com/apache/druid/commit/37bdd608922c4d6447fd7d406801e9b8a5f06572", "message": "Fix comments.", "committedDate": "2020-04-08T11:56:34Z", "type": "commit"}, {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "url": "https://github.com/apache/druid/commit/915c324b7ad37fd7dfb398a54ff70385900ff2dc", "message": "Fix tests.", "committedDate": "2020-04-08T21:30:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMzQ3NQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406103475", "bodyText": "nit: javadocs might make these a bit friendlier (comments and javadoc are very nice up to this point)", "author": "clintropolis", "createdAt": "2020-04-09T10:16:36Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -148,4 +246,148 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n \n     return retVal;\n   }\n+\n+  private static boolean isLeftExpression(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return ImmutableBitSet.range(numLeftFields).contains(RelOptUtil.InputFinder.bits(rexNode));\n+  }\n+\n+  private static boolean isRightInputRef(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return rexNode.isA(SqlKind.INPUT_REF) && ((RexInputRef) rexNode).getIndex() >= numLeftFields;\n+  }\n+\n+  @VisibleForTesting\n+  static class ConditionAnalysis\n+  {\n+    /**\n+     * Number of fields on the left-hand side. Useful for identifying if a particular field is from on the left\n+     * or right side of a join.\n+     */\n+    private final int numLeftFields;\n+\n+    /**\n+     * Each equality subcondition is an equality of the form f(LeftRel) = g(RightRel).\n+     */\n+    private final List<Pair<RexNode, RexInputRef>> equalitySubConditions;\n+\n+    /**\n+     * Each literal subcondition is... a literal.\n+     */\n+    private final List<RexLiteral> literalSubConditions;\n+\n+    ConditionAnalysis(\n+        int numLeftFields,\n+        List<Pair<RexNode, RexInputRef>> equalitySubConditions,\n+        List<RexLiteral> literalSubConditions\n+    )\n+    {\n+      this.numLeftFields = numLeftFields;\n+      this.equalitySubConditions = equalitySubConditions;\n+      this.literalSubConditions = literalSubConditions;\n+    }\n+\n+    public ConditionAnalysis pushThroughLeftProject(final Project leftProject)", "originalCommit": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1ODU2OQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406458569", "bodyText": "Yeah, good call. If you don't mind I'd like to add them in a follow up patch, because this patch is release-blocking.", "author": "gianm", "createdAt": "2020-04-09T20:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMzQ3NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI2Mg==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406107262", "bodyText": "I can't think of any specific examples off the top of my head, but I know we've seen a handful of performance issues using .stream(); I don't think anything needs to change right now, just commenting to increase the chances I'll remember this area as much as anything else as a potential area to look at to make small gains in planning time in the future.\nI don't imagine these collections will be so large, so maybe isn't a very big deal, but then again could maybe add up depending how planning goes and how many times this stuff gets evaluated.", "author": "clintropolis", "createdAt": "2020-04-09T10:23:51Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -148,4 +246,148 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n \n     return retVal;\n   }\n+\n+  private static boolean isLeftExpression(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return ImmutableBitSet.range(numLeftFields).contains(RelOptUtil.InputFinder.bits(rexNode));\n+  }\n+\n+  private static boolean isRightInputRef(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return rexNode.isA(SqlKind.INPUT_REF) && ((RexInputRef) rexNode).getIndex() >= numLeftFields;\n+  }\n+\n+  @VisibleForTesting\n+  static class ConditionAnalysis\n+  {\n+    /**\n+     * Number of fields on the left-hand side. Useful for identifying if a particular field is from on the left\n+     * or right side of a join.\n+     */\n+    private final int numLeftFields;\n+\n+    /**\n+     * Each equality subcondition is an equality of the form f(LeftRel) = g(RightRel).\n+     */\n+    private final List<Pair<RexNode, RexInputRef>> equalitySubConditions;\n+\n+    /**\n+     * Each literal subcondition is... a literal.\n+     */\n+    private final List<RexLiteral> literalSubConditions;\n+\n+    ConditionAnalysis(\n+        int numLeftFields,\n+        List<Pair<RexNode, RexInputRef>> equalitySubConditions,\n+        List<RexLiteral> literalSubConditions\n+    )\n+    {\n+      this.numLeftFields = numLeftFields;\n+      this.equalitySubConditions = equalitySubConditions;\n+      this.literalSubConditions = literalSubConditions;\n+    }\n+\n+    public ConditionAnalysis pushThroughLeftProject(final Project leftProject)\n+    {\n+      // Pushing through the project will shift right-hand field references by this amount.\n+      final int rhsShift =\n+          leftProject.getInput().getRowType().getFieldCount() - leftProject.getRowType().getFieldCount();\n+\n+      return new ConditionAnalysis(\n+          leftProject.getInput().getRowType().getFieldCount(),\n+          equalitySubConditions\n+              .stream()", "originalCommit": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM5NjUzMw==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406396533", "bodyText": "I have some benchmark results for stream (StreamBenchmark and HighlyNestedStreamBenchmark).\nStreamBenchmark.flatMapIterator            avgt   10   9.584 \u00b1 0.055  ms/op\nStreamBenchmark.flatMapSequenceAccumulate  avgt   10   5.908 \u00b1 0.041  ms/op\nStreamBenchmark.flatMapSequenceYielder     avgt   10  22.976 \u00b1 0.064  ms/op\nStreamBenchmark.flatMapStream              avgt   10   6.249 \u00b1 0.050  ms/op\nStreamBenchmark.fluentIteratorToList       avgt   10  18.455 \u00b1 0.254  ms/op\nStreamBenchmark.sequenceToList             avgt   10  14.326 \u00b1 0.662  ms/op\nStreamBenchmark.streamToList               avgt   10  17.720 \u00b1 0.173  ms/op\nStreamBenchmark.sumIterator                avgt   10   2.648 \u00b1 0.023  ms/op  <-- native for loop\nStreamBenchmark.sumIteratorFlatMap         avgt   10   7.270 \u00b1 0.095  ms/op\nStreamBenchmark.sumSequence                avgt   10   6.654 \u00b1 0.137  ms/op\nStreamBenchmark.sumStream                  avgt   10   2.162 \u00b1 0.048  ms/op\n\nBenchmark                                              Mode  Cnt     Score    Error  Units\nHighlyNestedStreamBenchmark.flatMapIterator            avgt   10  2413.571 \u00b1 15.151  ms/op\nHighlyNestedStreamBenchmark.flatMapSequenceAccumulate  avgt   10  1157.817 \u00b1 13.575  ms/op\nHighlyNestedStreamBenchmark.flatMapSequenceYielder     avgt   10  6308.657 \u00b1 28.802  ms/op\nHighlyNestedStreamBenchmark.flatMapStream              avgt   10   953.539 \u00b1  6.755  ms/op\nHighlyNestedStreamBenchmark.sumIteratorFlatMap         avgt   10  2129.499 \u00b1 20.541  ms/op\nHighlyNestedStreamBenchmark.sumNestedFor               avgt   10   297.307 \u00b1  0.626  ms/op <-- native for loop\nHighlyNestedStreamBenchmark.sumSequence                avgt   10  1503.816 \u00b1  5.720  ms/op\nHighlyNestedStreamBenchmark.sumStream                  avgt   10  1136.636 \u00b1 12.353  ms/op\n\nI did notice that stream is sometimes bad and these benchmarks were to see what makes it bad. Unfortunately, these benchmarks show that stream is pretty good for computing a sum, it can compete with even native for loop when the stream is not highly nested. For highly nested stream, it's worse than native for loop, but still best among others. For toList, stream seems worse than others which I'm not sure how much it matters.\nI'm suspecting that stream could be very efficient in these benchmarks because the benchmark code could be easily inlined with stream. I was planning to do another benchmark with a map function which is complex enough to hinder inlining, but haven't done yet.", "author": "jihoonson", "createdAt": "2020-04-09T18:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MTk0NQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406461945", "bodyText": "Personally my strategy has been to use whatever seems most readable for code that isn't performance critical (small collections, not called tons of times). And for situations where performance is critical then to benchmark.", "author": "gianm", "createdAt": "2020-04-09T20:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwOTA4NQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406109085", "bodyText": "Out of curiosity where did these numbers come from? Experiments I guess?", "author": "clintropolis", "createdAt": "2020-04-09T10:27:18Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/CostEstimates.java", "diffHunk": "@@ -74,13 +74,19 @@\n    * Multiplier to apply to an outer query via {@link DruidOuterQueryRel}. Encourages pushing down time-saving\n    * operations to the lowest level of the query stack, because they'll have bigger impact there.\n    */\n-  static final double MULTIPLIER_OUTER_QUERY = 0.1;\n+  static final double MULTIPLIER_OUTER_QUERY = .1;\n \n   /**\n-   * Multiplier to apply to a join when the left-hand side is a subquery. Encourages avoiding subqueries. Subqueries\n-   * inside joins must be inlined, which incurs substantial reduction in scalability, so this high number is justified.\n+   * Cost to add to a join when either side is a subquery. Strongly encourages avoiding subqueries, since they must be\n+   * inlined and then the join must run on the Broker.\n    */\n-  static final double MULTIPLIER_JOIN_SUBQUERY = 1000000000;\n+  static final double COST_JOIN_SUBQUERY = 1e5;", "originalCommit": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2Mjg5Mw==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406462893", "bodyText": "Mostly I made them up, but then verified through experiments that they achieve the plans that we want to achieve.", "author": "gianm", "createdAt": "2020-04-09T20:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwOTA4NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2NjcxNQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r405966715", "bodyText": "should we add a branch to set the cost to 0 if the joinCondition is a literal and is always false?\nsince a false join condition means nothing will match therefore you don't need to do work for either the left or the right hand side?", "author": "suneet-s", "createdAt": "2020-04-09T05:38:21Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -336,10 +293,23 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory()\n-                  .makeCost(partialQuery.estimateCost(), 0, 0)\n-                  .multiplyBy(leftRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1)\n-                  .multiplyBy(rightRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1);\n+    double cost;\n+\n+    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n+      cost = CostEstimates.COST_JOIN_SUBQUERY;\n+    } else {\n+      cost = partialQuery.estimateCost();\n+    }\n+\n+    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n+      cost += CostEstimates.COST_JOIN_SUBQUERY;\n+    }\n+\n+    if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n+      cost += CostEstimates.COST_JOIN_CROSS;\n+    }", "originalCommit": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2Mzg2Mw==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406463863", "bodyText": "Currently, the native query join handling isn't smart enough to totally eliminate a join that has a false condition. It will still evaluate the left and right hand sides if they are subqueries. And it will still walk through every row on the left hand side. So I think it is fair to keep considering these costs in the cost estimator.", "author": "gianm", "createdAt": "2020-04-09T20:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2NjcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NjgyMw==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406486823", "bodyText": "ah makes sense", "author": "suneet-s", "createdAt": "2020-04-09T21:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2NjcxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r405970161", "bodyText": "how do we know this will be a RelSubset? I couldn't trace that path down here", "author": "suneet-s", "createdAt": "2020-04-09T05:50:36Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -395,4 +365,14 @@ private static boolean computeRightRequiresSubquery(final DruidRel<?> right)\n \n     return Pair.of(rightPrefix, signatureBuilder.build());\n   }\n+\n+  private static DruidRel<?> getSomeDruidChild(final RelNode child)\n+  {\n+    if (child instanceof DruidRel) {\n+      return (DruidRel<?>) child;\n+    } else {\n+      final RelSubset subset = (RelSubset) child;", "originalCommit": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NDQ3NQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406464475", "bodyText": "My understanding of Calcite's planner tells me that the children will either be single rels or will be a subset of equivalent rels. So DruidRel and RelSubset are the two cases that can happen.\nI hope I understand the planner correctly \u2014\u00a0I can't point to any specific code that guarantees what I am saying is true.", "author": "gianm", "createdAt": "2020-04-09T20:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NzU3NQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406487575", "bodyText": "when I wrote this, I was wondering whether bindable parameters would change the node here somehow. The calcite query tests are pretty comprehensive around different types of JOINs and nested queries, that I feel pretty confident to agree with your understanding. Any chance you can test this with parameterized sql.", "author": "suneet-s", "createdAt": "2020-04-09T21:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyODQyNQ==", "url": "https://github.com/apache/druid/pull/9648#discussion_r406528425", "bodyText": "I will look at adding some tests for this in the same followup as #9648 (comment).", "author": "gianm", "createdAt": "2020-04-09T23:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAxMjM3Ng==", "url": "https://github.com/apache/druid/pull/9648#discussion_r415012376", "bodyText": "\"subset of equivalent rels\" -> Does this imply that the cost of each RelNode will be equal? I saw that computeLeftRequiresSubquery can returns different depending on which child we pick from the list of RelList. This then result in a very very different cost since a child that results in requiring subquery will have very high cost and a child that doesnt will have a much lower cost.\nMore specifically, I saw two RelNode in the list. One RelNode has a filter = null and the other has \"filter\":{\"type\":\"selector\",\"dimension\":\"v\",\"value\":\"xa\",\"extractionFn\":null}", "author": "maytasm", "createdAt": "2020-04-25T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ=="}], "type": "inlineReview", "revised_code": null}]}