{"pr_number": 9671, "pr_title": "Add support for Avro OCF using InputFormat", "pr_createdAt": "2020-04-10T17:53:32Z", "pr_url": "https://github.com/apache/druid/pull/9671", "timeline": [{"oid": "8e8952ee76461ecf460f685ee8d453ce2e1366c3", "url": "https://github.com/apache/druid/commit/8e8952ee76461ecf460f685ee8d453ce2e1366c3", "message": "Add AvroOCFInputFormat", "committedDate": "2020-04-12T08:15:04Z", "type": "commit"}, {"oid": "d1936052af8005e291352671ed3706541c1aa31b", "url": "https://github.com/apache/druid/commit/d1936052af8005e291352671ed3706541c1aa31b", "message": "Support supplying a reader schema in AvroOCFInputFormat", "committedDate": "2020-04-13T17:00:28Z", "type": "commit"}, {"oid": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "url": "https://github.com/apache/druid/commit/2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "message": "Add docs for Avro OCF input format", "committedDate": "2020-04-13T17:00:28Z", "type": "commit"}, {"oid": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "url": "https://github.com/apache/druid/commit/2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "message": "Add docs for Avro OCF input format", "committedDate": "2020-04-13T17:00:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0Mzg4MQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421843881", "bodyText": "The created reader should be closed.", "author": "jihoonson", "createdAt": "2020-05-07T23:06:56Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    return new DataFileReader<GenericRecord>(file, new GenericDatumReader<>()).getSchema();", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\nindex b10b995dac..de0bc452e2 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n\n@@ -35,6 +35,7 @@ import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n import org.apache.druid.java.util.common.parsers.ParseException;\n \n+import javax.annotation.Nullable;\n import java.io.File;\n import java.io.IOException;\n import java.util.Collections;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDMxMw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844313", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:08:30Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\nindex 086ebfc388..90c74f65e6 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n\n@@ -42,13 +42,14 @@ public class AvroOCFInputFormat extends NestedInputFormat\n   private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n \n   private final boolean binaryAsString;\n+  @Nullable\n   private final Schema readerSchema;\n \n   @JsonCreator\n   public AvroOCFInputFormat(\n       @JacksonInject @Json ObjectMapper mapper,\n       @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n-      @JsonProperty(\"schema\") Map<String, Object> schema,\n+      @JsonProperty(\"schema\") @Nullable Map<String, Object> schema,\n       @JsonProperty(\"binaryAsString\") @Nullable Boolean binaryAsString\n   ) throws Exception\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDM2NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844365", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:08:40Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;\n+\n+  @JsonCreator\n+  public AvroOCFInputFormat(\n+      @JacksonInject @Json ObjectMapper mapper,\n+      @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n+      @JsonProperty(\"schema\") Map<String, Object> schema,", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\nindex 086ebfc388..90c74f65e6 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n\n@@ -42,13 +42,14 @@ public class AvroOCFInputFormat extends NestedInputFormat\n   private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n \n   private final boolean binaryAsString;\n+  @Nullable\n   private final Schema readerSchema;\n \n   @JsonCreator\n   public AvroOCFInputFormat(\n       @JacksonInject @Json ObjectMapper mapper,\n       @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n-      @JsonProperty(\"schema\") Map<String, Object> schema,\n+      @JsonProperty(\"schema\") @Nullable Map<String, Object> schema,\n       @JsonProperty(\"binaryAsString\") @Nullable Boolean binaryAsString\n   ) throws Exception\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDc3MA==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844770", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:09:39Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\nindex b10b995dac..de0bc452e2 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n\n@@ -35,6 +35,7 @@ import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n import org.apache.druid.java.util.common.parsers.ParseException;\n \n+import javax.annotation.Nullable;\n import java.io.File;\n import java.io.IOException;\n import java.util.Collections;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NjMwNA==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421846304", "bodyText": "dataFileReader should be registered on closer.", "author": "jihoonson", "createdAt": "2020-05-07T23:14:02Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    return new DataFileReader<GenericRecord>(file, new GenericDatumReader<>()).getSchema();\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());\n+    if (readerSchema == null) {\n+      readerSchema = writerSchema;\n+    }\n+    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);\n+    final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\nindex b10b995dac..de0bc452e2 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n\n@@ -35,6 +35,7 @@ import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n import org.apache.druid.java.util.common.parsers.ParseException;\n \n+import javax.annotation.Nullable;\n import java.io.File;\n import java.io.IOException;\n import java.util.Collections;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0OTQ4NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421849485", "bodyText": "This seems fine for now, but we would probably want to make it splittable in the future. Would you please add a comment about it with this link?", "author": "jihoonson", "createdAt": "2020-05-07T23:24:05Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;\n+\n+  @JsonCreator\n+  public AvroOCFInputFormat(\n+      @JacksonInject @Json ObjectMapper mapper,\n+      @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n+      @JsonProperty(\"schema\") Map<String, Object> schema,\n+      @JsonProperty(\"binaryAsString\") @Nullable Boolean binaryAsString\n+  ) throws Exception\n+  {\n+    super(flattenSpec);\n+    // If a reader schema is supplied create the datum reader with said schema, otherwise use the writer schema\n+    if (schema != null) {\n+      String schemaStr = mapper.writeValueAsString(schema);\n+      LOGGER.debug(\"Initialising with reader schema: [%s]\", schemaStr);\n+      this.readerSchema = new Schema.Parser().parse(schemaStr);\n+    } else {\n+      this.readerSchema = null;\n+    }\n+    this.binaryAsString = binaryAsString == null ? false : binaryAsString;\n+  }\n+\n+  @Override\n+  public boolean isSplittable()\n+  {\n+    return false;", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3OTA0NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421979045", "bodyText": "Yeah I think the best way to do splitting would be block-wise. I will add a comment about it and link to the spec as you suggested.", "author": "josephglanville", "createdAt": "2020-05-08T07:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0OTQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\nindex 086ebfc388..90c74f65e6 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java\n\n@@ -42,13 +42,14 @@ public class AvroOCFInputFormat extends NestedInputFormat\n   private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n \n   private final boolean binaryAsString;\n+  @Nullable\n   private final Schema readerSchema;\n \n   @JsonCreator\n   public AvroOCFInputFormat(\n       @JacksonInject @Json ObjectMapper mapper,\n       @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n-      @JsonProperty(\"schema\") Map<String, Object> schema,\n+      @JsonProperty(\"schema\") @Nullable Map<String, Object> schema,\n       @JsonProperty(\"binaryAsString\") @Nullable Boolean binaryAsString\n   ) throws Exception\n   {\n"}}, {"oid": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "url": "https://github.com/apache/druid/commit/80f7d561b6604aa921937ab7f26bbcb7d12307df", "message": "Address review comments", "committedDate": "2020-05-13T17:36:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTQzMQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424801431", "bodyText": "I'm wondering if we can reuse the created dataFileReader rather than creating two instances even though creating an instance would be probably cheap (it only reads the header). It seems possible if you update reader and writher schemas as below:\n      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n      final Schema writerSchema = dataFileReader.getSchema();\n      if (readerSchema == null) {\n        readerSchema = writerSchema;\n      }\n      datumReader.setSchema(writerSchema);\n      datumReader.setExpected(readerSchema);", "author": "jihoonson", "createdAt": "2020-05-14T00:14:38Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      @Nullable Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n+    final Schema schema = reader.getSchema();\n+    reader.close();\n+    return schema;\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());\n+    if (readerSchema == null) {\n+      readerSchema = writerSchema;\n+    }\n+    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);", "originalCommit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3Njc0Mw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424876743", "bodyText": "Yes this is possible, I didn't do it originally because I made the same observation that it's likely cheap. However may as well avoid it.", "author": "josephglanville", "createdAt": "2020-05-14T05:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b08f4c1469d905c9c2d1042c496a4090edbce2ca", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\nindex de0bc452e2..39e82c14a5 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n\n@@ -66,49 +66,48 @@ public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n     this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n   }\n \n-  private static Schema dataFileSchema(File file) throws IOException\n-  {\n-    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n-    final Schema schema = reader.getSchema();\n-    reader.close();\n-    return schema;\n-  }\n-\n   @Override\n   protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n   {\n     final Closer closer = Closer.create();\n-\n     final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n-    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n-    final Schema writerSchema = dataFileSchema(file.file());\n-    if (readerSchema == null) {\n-      readerSchema = writerSchema;\n-    }\n-    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);\n-    final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n-    closer.register(dataFileReader);\n-\n-    return new CloseableIterator<GenericRecord>()\n-    {\n-      @Override\n-      public boolean hasNext()\n-      {\n-        return dataFileReader.hasNext();\n+    try {\n+      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n+      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n+      final Schema writerSchema = dataFileReader.getSchema();\n+      if (readerSchema == null) {\n+        readerSchema = writerSchema;\n       }\n+      datumReader.setSchema(writerSchema);\n+      datumReader.setExpected(readerSchema);\n+      closer.register(dataFileReader);\n \n-      @Override\n-      public GenericRecord next()\n+      return new CloseableIterator<GenericRecord>()\n       {\n-        return dataFileReader.next();\n-      }\n+        @Override\n+        public boolean hasNext()\n+        {\n+          return dataFileReader.hasNext();\n+        }\n \n-      @Override\n-      public void close() throws IOException\n-      {\n-        closer.close();\n-      }\n-    };\n+        @Override\n+        public GenericRecord next()\n+        {\n+          return dataFileReader.next();\n+        }\n+\n+        @Override\n+        public void close() throws IOException\n+        {\n+          closer.close();\n+        }\n+      };\n+    }\n+    catch (Exception e) {\n+      closer.close();\n+      throw new RuntimeException(e);\n+    }\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTg5Nw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424801897", "bodyText": "I noticed #9867 while reviewing this.. Any exceptions should be caught before returning the iterator. So, the code should probably be\n  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n  {\n    final Closer closer = Closer.create();\n    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n\n    try {\n      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n      final Schema writerSchema = dataFileReader.getSchema();\n      if (readerSchema == null) {\n        readerSchema = writerSchema;\n      }\n      datumReader.setSchema(writerSchema);\n      datumReader.setExpected(readerSchema);\n      closer.register(dataFileReader);\n    }\n    catch (Exception e) {\n      closer.close();\n      throw new RuntimeException(e);\n    }\n\n    return new CloseableIterator<GenericRecord>()\n    ...", "author": "jihoonson", "createdAt": "2020-05-14T00:16:29Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      @Nullable Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n+    final Schema schema = reader.getSchema();\n+    reader.close();\n+    return schema;\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());", "originalCommit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3Njc5Ng==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424876796", "bodyText": "I see, yes will fix.", "author": "josephglanville", "createdAt": "2020-05-14T05:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b08f4c1469d905c9c2d1042c496a4090edbce2ca", "chunk": "diff --git a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\nindex de0bc452e2..39e82c14a5 100644\n--- a/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n+++ b/extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java\n\n@@ -66,49 +66,48 @@ public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n     this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n   }\n \n-  private static Schema dataFileSchema(File file) throws IOException\n-  {\n-    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n-    final Schema schema = reader.getSchema();\n-    reader.close();\n-    return schema;\n-  }\n-\n   @Override\n   protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n   {\n     final Closer closer = Closer.create();\n-\n     final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n-    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n-    final Schema writerSchema = dataFileSchema(file.file());\n-    if (readerSchema == null) {\n-      readerSchema = writerSchema;\n-    }\n-    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);\n-    final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n-    closer.register(dataFileReader);\n-\n-    return new CloseableIterator<GenericRecord>()\n-    {\n-      @Override\n-      public boolean hasNext()\n-      {\n-        return dataFileReader.hasNext();\n+    try {\n+      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n+      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n+      final Schema writerSchema = dataFileReader.getSchema();\n+      if (readerSchema == null) {\n+        readerSchema = writerSchema;\n       }\n+      datumReader.setSchema(writerSchema);\n+      datumReader.setExpected(readerSchema);\n+      closer.register(dataFileReader);\n \n-      @Override\n-      public GenericRecord next()\n+      return new CloseableIterator<GenericRecord>()\n       {\n-        return dataFileReader.next();\n-      }\n+        @Override\n+        public boolean hasNext()\n+        {\n+          return dataFileReader.hasNext();\n+        }\n \n-      @Override\n-      public void close() throws IOException\n-      {\n-        closer.close();\n-      }\n-    };\n+        @Override\n+        public GenericRecord next()\n+        {\n+          return dataFileReader.next();\n+        }\n+\n+        @Override\n+        public void close() throws IOException\n+        {\n+          closer.close();\n+        }\n+      };\n+    }\n+    catch (Exception e) {\n+      closer.close();\n+      throw new RuntimeException(e);\n+    }\n   }\n \n   @Override\n"}}, {"oid": "b08f4c1469d905c9c2d1042c496a4090edbce2ca", "url": "https://github.com/apache/druid/commit/b08f4c1469d905c9c2d1042c496a4090edbce2ca", "message": "Address second round of review", "committedDate": "2020-05-15T01:12:06Z", "type": "commit"}]}