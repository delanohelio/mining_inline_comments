{"pr_number": 10219, "pr_title": "add hasNulls to ColumnCapabilities, ColumnAnalysis", "pr_createdAt": "2020-07-28T11:54:31Z", "pr_url": "https://github.com/apache/druid/pull/10219", "timeline": [{"oid": "f1c5b2debae73c92a6c0b19bcfda91a58584ffd6", "url": "https://github.com/apache/druid/commit/f1c5b2debae73c92a6c0b19bcfda91a58584ffd6", "message": "add isNullable to ColumnCapabilities, ColumnAnalysis", "committedDate": "2020-07-17T06:32:07Z", "type": "commit"}, {"oid": "69e772e2998375dccad0966a08e84ff4472ddf82", "url": "https://github.com/apache/druid/commit/69e772e2998375dccad0966a08e84ff4472ddf82", "message": "better builder", "committedDate": "2020-07-21T11:09:01Z", "type": "commit"}, {"oid": "1126f1579f4d284778aa385b0e9379df34d581d3", "url": "https://github.com/apache/druid/commit/1126f1579f4d284778aa385b0e9379df34d581d3", "message": "fix segment metadata queries in integration tests", "committedDate": "2020-07-30T20:00:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0MDg4MQ==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466140881", "bodyText": "I realize you just copied this code from somewhere else, but is there a way we can do this without instanceof? Maybe a new method on StorageAdapter with some nice javadocs? This code is pretty brittle otherwise.", "author": "gianm", "createdAt": "2020-08-06T04:37:24Z", "path": "processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java", "diffHunk": "@@ -100,6 +100,11 @@ public long numRows(Segment segment)\n \n     Map<String, ColumnAnalysis> columns = new TreeMap<>();\n \n+    Function<String, ColumnCapabilities> adapterCapabilitesFn =", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNjU2Nw==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469536567", "bodyText": "eh, I think introduced the ugly instanceof in the first place in a previous PR to fix a different bug. I have a plan to not need this, since it is only necessary for incremental index adapter, so I hope this code is rather temporary but the changes are too big to be part of this patch.\nI would rather not introduce a new method to storage adapter specifically for incremental index adapter, and would prefer to address it when I eliminate the need for it, if that is cool with you. If you disagree and feel strongly about it though, I can introduce a temporary method for it now, and just remove it in the follow-up.", "author": "clintropolis", "createdAt": "2020-08-12T20:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0MDg4MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0MTQ3Ng==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466141476", "bodyText": "When would it be unknown if a column has nulls?\nWill bad stuff happen if we return false when it actually does have nulls, but for some reason it's marked as unknown?", "author": "gianm", "createdAt": "2020-08-06T04:39:42Z", "path": "processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java", "diffHunk": "@@ -192,6 +193,7 @@ private ColumnAnalysis analyzeNumericColumn(\n     return new ColumnAnalysis(\n         capabilities.getType().name(),\n         capabilities.hasMultipleValues().isTrue(),\n+        capabilities.isNullable().isTrue(),", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNzgzNA==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469537834", "bodyText": "I think maybe the only current unknowns will come from complex columns, which thinking about it should probably just report that they have nulls as true instead of unknown...\nRight now nothing bad would happen if the segment metadata falsely reports not having nulls, but in the follow-up where this is wired into DruidSchema, falsely reporting nulls would cause the SQL planner to incorrectly plan to not handle nulls, so I think this should probably be modified to check isMaybeTrue.", "author": "clintropolis", "createdAt": "2020-08-12T20:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0MTQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java b/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\nindex 663ed13e46..34fde0ccf9 100644\n--- a/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\n+++ b/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\n\n@@ -193,7 +193,7 @@ public class SegmentAnalyzer\n     return new ColumnAnalysis(\n         capabilities.getType().name(),\n         capabilities.hasMultipleValues().isTrue(),\n-        capabilities.isNullable().isTrue(),\n+        capabilities.hasNulls().isTrue(),\n         size,\n         null,\n         null,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1Mjk4Ng==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466152986", "bodyText": "With this addition, I'm wondering if the snapshot method still makes sense. What reason is there that callers generally want to set all these unknown things to the same boolean? They don't seem incredibly related. Maybe we should have callers explicitly resolve all the unknowns in particular directions.", "author": "gianm", "createdAt": "2020-08-06T05:23:07Z", "path": "processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java", "diffHunk": "@@ -72,22 +74,35 @@ public static ColumnCapabilitiesImpl snapshot(@Nullable final ColumnCapabilities\n     copy.hasMultipleValues = copy.hasMultipleValues.coerceUnknownToBoolean(unknownIsTrue);\n     copy.dictionaryValuesSorted = copy.dictionaryValuesSorted.coerceUnknownToBoolean(unknownIsTrue);\n     copy.dictionaryValuesUnique = copy.dictionaryValuesUnique.coerceUnknownToBoolean(unknownIsTrue);\n+    copy.nullable = copy.nullable.coerceUnknownToBoolean(unknownIsTrue);", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzODAyMA==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469538020", "bodyText": "I agree, and have reworked this in #10248, so have added this to the CoerceLogic interface and implementations.", "author": "clintropolis", "createdAt": "2020-08-12T20:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1Mjk4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\nindex 14f75ed7fa..645904dcdf 100644\n--- a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\n+++ b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java\n\n@@ -38,44 +39,73 @@ public class ColumnCapabilitiesImpl implements ColumnCapabilities\n     if (other != null) {\n       capabilities.type = other.getType();\n       capabilities.dictionaryEncoded = other.isDictionaryEncoded();\n-      capabilities.runLengthEncoded = other.isRunLengthEncoded();\n       capabilities.hasInvertedIndexes = other.hasBitmapIndexes();\n       capabilities.hasSpatialIndexes = other.hasSpatialIndexes();\n       capabilities.hasMultipleValues = other.hasMultipleValues();\n       capabilities.dictionaryValuesSorted = other.areDictionaryValuesSorted();\n       capabilities.dictionaryValuesUnique = other.areDictionaryValuesUnique();\n-      capabilities.nullable = other.isNullable();\n+      capabilities.hasNulls = other.hasNulls();\n       capabilities.filterable = other.isFilterable();\n     }\n     return capabilities;\n   }\n \n   /**\n-   * Used at indexing time to finalize all {@link Capable#UNKNOWN} values to\n-   * {@link Capable#FALSE}, in order to present a snapshot of the state of the this column\n+   * Copy a {@link ColumnCapabilities} and coerce all {@link ColumnCapabilities.Capable#UNKNOWN} to\n+   * {@link ColumnCapabilities.Capable#TRUE} or {@link ColumnCapabilities.Capable#FALSE} as specified by\n+   * {@link ColumnCapabilities.CoercionLogic}\n    */\n   @Nullable\n-  public static ColumnCapabilitiesImpl snapshot(@Nullable final ColumnCapabilities capabilities)\n+  public static ColumnCapabilitiesImpl snapshot(@Nullable final ColumnCapabilities capabilities, CoercionLogic coerce)\n   {\n-    return snapshot(capabilities, false);\n+    if (capabilities == null) {\n+      return null;\n+    }\n+    ColumnCapabilitiesImpl copy = copyOf(capabilities);\n+    copy.dictionaryEncoded = copy.dictionaryEncoded.coerceUnknownToBoolean(coerce.dictionaryEncoded());\n+    copy.dictionaryValuesSorted = copy.dictionaryValuesSorted.coerceUnknownToBoolean(coerce.dictionaryValuesSorted());\n+    copy.dictionaryValuesUnique = copy.dictionaryValuesUnique.coerceUnknownToBoolean(coerce.dictionaryValuesUnique());\n+    copy.hasMultipleValues = copy.hasMultipleValues.coerceUnknownToBoolean(coerce.multipleValues());\n+    copy.hasNulls = copy.hasNulls.coerceUnknownToBoolean(coerce.hasNulls());\n+    return copy;\n   }\n \n   /**\n-   * Used at indexing time to finalize all {@link Capable#UNKNOWN} values to\n-   * {@link Capable#FALSE} or {@link Capable#TRUE}, in order to present a snapshot of the state of the this column\n+   * Snapshots a pair of capabilities and then merges them\n    */\n   @Nullable\n-  public static ColumnCapabilitiesImpl snapshot(@Nullable final ColumnCapabilities capabilities, boolean unknownIsTrue)\n+  public static ColumnCapabilitiesImpl merge(\n+      @Nullable final ColumnCapabilities capabilities,\n+      @Nullable final ColumnCapabilities other,\n+      CoercionLogic coercionLogic\n+  )\n   {\n-    if (capabilities == null) {\n-      return null;\n+    ColumnCapabilitiesImpl merged = snapshot(capabilities, coercionLogic);\n+    ColumnCapabilitiesImpl otherSnapshot = snapshot(other, coercionLogic);\n+    if (merged == null) {\n+      return otherSnapshot;\n+    } else if (otherSnapshot == null) {\n+      return merged;\n     }\n-    ColumnCapabilitiesImpl copy = copyOf(capabilities);\n-    copy.hasMultipleValues = copy.hasMultipleValues.coerceUnknownToBoolean(unknownIsTrue);\n-    copy.dictionaryValuesSorted = copy.dictionaryValuesSorted.coerceUnknownToBoolean(unknownIsTrue);\n-    copy.dictionaryValuesUnique = copy.dictionaryValuesUnique.coerceUnknownToBoolean(unknownIsTrue);\n-    copy.nullable = copy.nullable.coerceUnknownToBoolean(unknownIsTrue);\n-    return copy;\n+\n+    if (merged.type == null) {\n+      merged.type = other.getType();\n+    }\n+\n+    if (!merged.type.equals(otherSnapshot.getType())) {\n+      throw new ISE(\"Cannot merge columns of type[%s] and [%s]\", merged.type, otherSnapshot.getType());\n+    }\n+\n+    merged.dictionaryEncoded = merged.dictionaryEncoded.or(otherSnapshot.isDictionaryEncoded());\n+    merged.hasMultipleValues = merged.hasMultipleValues.or(otherSnapshot.hasMultipleValues());\n+    merged.dictionaryValuesSorted = merged.dictionaryValuesSorted.and(otherSnapshot.areDictionaryValuesSorted());\n+    merged.dictionaryValuesUnique = merged.dictionaryValuesUnique.and(otherSnapshot.areDictionaryValuesUnique());\n+    merged.hasNulls = merged.hasNulls.or(other.hasNulls());\n+    merged.hasInvertedIndexes |= otherSnapshot.hasBitmapIndexes();\n+    merged.hasSpatialIndexes |= otherSnapshot.hasSpatialIndexes();\n+    merged.filterable &= otherSnapshot.isFilterable();\n+\n+    return merged;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NDMzMA==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466154330", "bodyText": "If it's string won't it still count as a null, even in replace-with-default mode?\nBtw, consider adding a NullHandling.isNullable(ValueType) method if seems useful.", "author": "gianm", "createdAt": "2020-08-06T05:27:53Z", "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -685,6 +685,9 @@ IncrementalIndexRowResult toIncrementalIndexRow(InputRow row)\n         }\n         dimsKeySize += indexer.estimateEncodedKeyComponentSize(dimsKey);\n         // Set column capabilities as data is coming in\n+        if (dimsKey == null) {\n+          capabilities.setIsNullable(NullHandling.sqlCompatible());", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzODExMw==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469538113", "bodyText": "This is now handled by the dimension indexers, which now can all determine if they have null values or not, so I don't think NullHandling.isNullable(ValueType) is necessary anymore.", "author": "clintropolis", "createdAt": "2020-08-12T20:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NDMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java b/processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java\nindex b2b919c899..44d4b3d66c 100644\n--- a/processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java\n+++ b/processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java\n\n@@ -684,21 +687,10 @@ public abstract class IncrementalIndex<AggregatorType> extends AbstractIndex imp\n           parseExceptionMessages.add(pe.getMessage());\n         }\n         dimsKeySize += indexer.estimateEncodedKeyComponentSize(dimsKey);\n-        // Set column capabilities as data is coming in\n-        if (dimsKey == null) {\n-          capabilities.setIsNullable(NullHandling.sqlCompatible());\n-        }\n-        if (!capabilities.hasMultipleValues().isTrue() &&\n-            dimsKey != null &&\n-            handler.getLengthOfEncodedKeyComponent(dimsKey) > 1) {\n-          capabilities.setHasMultipleValues(true);\n-        }\n-\n         if (wasNewDim) {\n           // unless this is the first row we are processing, all newly discovered columns will be sparse\n           if (maxIngestedEventTime != null) {\n             indexer.setSparseIndexed();\n-            capabilities.setIsNullable(NullHandling.sqlCompatible());\n           }\n           if (overflow == null) {\n             overflow = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1OTA0Mg==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466159042", "bodyText": "Broad comment: \"hasNulls\" would be a better name for this property, because it's meant to mean whether or not the column really has nulls in it right now.\n\"isNullable\" will make people think of the SQL sense of the term, which is a different concept: it means a column could have nulls potentially, even if it doesn't right now.", "author": "gianm", "createdAt": "2020-08-06T05:43:32Z", "path": "processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilities.java", "diffHunk": "@@ -38,6 +38,7 @@\n   boolean hasSpatialIndexes();\n   Capable hasMultipleValues();\n   boolean isFilterable();\n+  Capable isNullable();", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTI2NQ==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469539265", "bodyText": "I agree, and have renamed this to hasNulls, but haven't changed the segment metadata ColumnAnalysis yet...\nI view segment metadata as the computed equivalent of an SQL schema, and have exposed in with the intention of populating the IS_NULLABLE column in the information schema columns table, and access via DruidSchema will allow the SQL planner to make better plans and skip null checking and such, so I thought it still appropriate to leave this as isNullable. I don't feel super strongly about this though, so if you disagree I can change it.", "author": "clintropolis", "createdAt": "2020-08-12T20:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1OTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5ODIyMA==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469598220", "bodyText": "I do feel that it shouldn't be called isNullable. I think we should avoid the word \"nullable\" in core Druid to refer to this concept, because one day, we might want to introduce the SQL-style concept of nullable vs non-nullable columns. That concept is more of a definition thing than a reality thing, and will be confusing to introduce to core if we have the reality-thing using the word \"nullable\".\nAlso, if we did introduce it to core, we'd probably want to report both (a column that is nullable table-wide might not actually have nulls in a specific segment, and that's useful to know).", "author": "gianm", "createdAt": "2020-08-12T23:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1OTA0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilities.java b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilities.java\nindex 4852629b4d..86e88107e9 100644\n--- a/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilities.java\n+++ b/processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilities.java\n\n@@ -26,19 +26,66 @@ import org.apache.druid.java.util.common.StringUtils;\n import javax.annotation.Nullable;\n \n /**\n+ * This interface is used to expose information about columns that is interesting to know for all matters dealing with\n+ * reading from columns, including query planning and optimization, creating readers to merge segments at ingestion\n+ * time, and probably nearly anything else you can imagine.\n  */\n public interface ColumnCapabilities\n {\n+  /**\n+   * Column type, good to know so caller can know what to expect and which optimal selector to use\n+   */\n   ValueType getType();\n-  boolean isDictionaryEncoded();\n+\n+  /**\n+   * Is the column dictionary encoded? If so, a DimensionDictionarySelector may be used instead of using a value\n+   * selector, allowing algorithms to operate on primitive integer dictionary ids rather than the looked up dictionary\n+   * values\n+   */\n+  Capable isDictionaryEncoded();\n+\n+  /**\n+   * If the column is dictionary encoded, are those values sorted? Useful to know for optimizations that can defer\n+   * looking up values and allowing sorting with the dictionary ids directly\n+   */\n   Capable areDictionaryValuesSorted();\n+\n+  /**\n+   * If the column is dictionary encoded, is there a 1:1 mapping of dictionary ids to values? If this is true, it\n+   * unlocks optimizations such as allowing for things like grouping directly on dictionary ids and deferred value\n+   * lookup\n+   */\n   Capable areDictionaryValuesUnique();\n-  boolean isRunLengthEncoded();\n+\n+  /**\n+   * String columns are sneaky, and might have multiple values, this is to allow callers to know and appropriately\n+   * prepare themselves\n+   */\n+  Capable hasMultipleValues();\n+\n+  /**\n+   * Does the column have an inverted index bitmap for each value? If so, these may be employed to 'pre-filter' the\n+   * column by examining if the values match the filter and intersecting the bitmaps, to avoid having to scan and\n+   * evaluate if every row matches the filter\n+   */\n   boolean hasBitmapIndexes();\n+\n+  /**\n+   * Does the column have spatial indexes available to allow use with spatial filtering?\n+   */\n   boolean hasSpatialIndexes();\n-  Capable hasMultipleValues();\n+\n+  /**\n+   * All Druid primitive columns support filtering, maybe with or without indexes, but by default complex columns\n+   * do not support direct filtering, unless provided by through a custom implementation.\n+   */\n   boolean isFilterable();\n-  Capable isNullable();\n+\n+  /**\n+   * Does this column contain null values? If so, callers, especially for primitive numeric columns, will need to check\n+   * for null value rows and act accordingly\n+   */\n+  Capable hasNulls();\n \n   enum Capable\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1OTkxMw==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466159913", "bodyText": "It would be better to use !bitmap.isEmpty(), because bitmap.size() isn't always cached and could potentially require walking the bitmap. Similar comment for the other serde types.", "author": "gianm", "createdAt": "2020-08-06T05:46:16Z", "path": "processing/src/main/java/org/apache/druid/segment/serde/DoubleNumericColumnPartSerdeV2.java", "diffHunk": "@@ -152,13 +152,17 @@ public Deserializer getDeserializer()\n \n       buffer.position(initialPos + offset);\n       final ImmutableBitmap bitmap;\n+      final boolean isNullable;\n       if (buffer.hasRemaining()) {\n         bitmap = bitmapSerdeFactory.getObjectStrategy().fromByteBufferWithSize(buffer);\n+        isNullable = bitmap.size() > 0;", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/serde/DoubleNumericColumnPartSerdeV2.java b/processing/src/main/java/org/apache/druid/segment/serde/DoubleNumericColumnPartSerdeV2.java\nindex 52e1e3c17a..53d43f4b84 100644\n--- a/processing/src/main/java/org/apache/druid/segment/serde/DoubleNumericColumnPartSerdeV2.java\n+++ b/processing/src/main/java/org/apache/druid/segment/serde/DoubleNumericColumnPartSerdeV2.java\n\n@@ -152,17 +152,17 @@ public class DoubleNumericColumnPartSerdeV2 implements ColumnPartSerde\n \n       buffer.position(initialPos + offset);\n       final ImmutableBitmap bitmap;\n-      final boolean isNullable;\n+      final boolean hasNulls;\n       if (buffer.hasRemaining()) {\n         bitmap = bitmapSerdeFactory.getObjectStrategy().fromByteBufferWithSize(buffer);\n-        isNullable = bitmap.size() > 0;\n+        hasNulls = !bitmap.isEmpty();\n       } else {\n         bitmap = bitmapSerdeFactory.getBitmapFactory().makeEmptyImmutableBitmap();\n-        isNullable = false;\n+        hasNulls = false;\n       }\n       builder.setType(ValueType.DOUBLE)\n              .setHasMultipleValues(false)\n-             .setNullable(isNullable)\n+             .setHasNulls(hasNulls)\n              .setNumericColumnSupplier(new DoubleNumericColumnSupplier(column, bitmap));\n     };\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2MDIyOQ==", "url": "https://github.com/apache/druid/pull/10219#discussion_r466160229", "bodyText": "What if it's a multi-value column with no explicit nulls, but some empty rows? Two questions in that scenario:\n\nShould a column like that report \"yes\" or \"no\" for having nulls? I'm guessing \"yes\" makes sense, because if you filter on col is null then that should match empty rows. So it stands to reason that it has nulls in some sense, even though you won't see them if you walk through the column.\nWhat will firstDictionaryEntry be?", "author": "gianm", "createdAt": "2020-08-06T05:47:13Z", "path": "processing/src/main/java/org/apache/druid/segment/serde/DictionaryEncodedColumnPartSerde.java", "diffHunk": "@@ -329,6 +331,7 @@ public void read(ByteBuffer buffer, ColumnBuilder builder, ColumnConfig columnCo\n         );\n         builder\n             .setHasMultipleValues(hasMultipleValues)\n+            .setNullable(firstDictionaryEntry == null)", "originalCommit": "1126f1579f4d284778aa385b0e9379df34d581d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU5Nw==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469539597", "bodyText": "I modified a column capabilities test to cover this condition, it still reports as having nulls if it ingests an empty list to a multi-value column.", "author": "clintropolis", "createdAt": "2020-08-12T20:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2MDIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/segment/serde/DictionaryEncodedColumnPartSerde.java b/processing/src/main/java/org/apache/druid/segment/serde/DictionaryEncodedColumnPartSerde.java\nindex 27be3e16eb..1005c9a6ef 100644\n--- a/processing/src/main/java/org/apache/druid/segment/serde/DictionaryEncodedColumnPartSerde.java\n+++ b/processing/src/main/java/org/apache/druid/segment/serde/DictionaryEncodedColumnPartSerde.java\n\n@@ -331,7 +331,7 @@ public class DictionaryEncodedColumnPartSerde implements ColumnPartSerde\n         );\n         builder\n             .setHasMultipleValues(hasMultipleValues)\n-            .setNullable(firstDictionaryEntry == null)\n+            .setHasNulls(firstDictionaryEntry == null)\n             .setDictionaryEncodedColumnSupplier(dictionaryEncodedColumnSupplier);\n \n         if (!Feature.NO_BITMAP_INDEX.isSet(rFlags)) {\n"}}, {"oid": "1dddd40f2022fbdbfc9743174fe11719ad01a99b", "url": "https://github.com/apache/druid/commit/1dddd40f2022fbdbfc9743174fe11719ad01a99b", "message": "Merge remote-tracking branch 'upstream/master' into column-nullable", "committedDate": "2020-08-11T20:58:46Z", "type": "commit"}, {"oid": "0455c2f518d005991f2ad00ed1aed3552872662c", "url": "https://github.com/apache/druid/commit/0455c2f518d005991f2ad00ed1aed3552872662c", "message": "adjustments", "committedDate": "2020-08-12T11:42:54Z", "type": "commit"}, {"oid": "5d8908542fd501ba9b5467563de974e2ff5309ec", "url": "https://github.com/apache/druid/commit/5d8908542fd501ba9b5467563de974e2ff5309ec", "message": "cleanup", "committedDate": "2020-08-12T12:09:23Z", "type": "commit"}, {"oid": "9087a738c5b1306ae7fe942e1ce80f04fd9a1046", "url": "https://github.com/apache/druid/commit/9087a738c5b1306ae7fe942e1ce80f04fd9a1046", "message": "fix spotbugs", "committedDate": "2020-08-12T20:02:52Z", "type": "commit"}, {"oid": "82ff3e452eae3ae1e77ce854e22f563d874bb055", "url": "https://github.com/apache/druid/commit/82ff3e452eae3ae1e77ce854e22f563d874bb055", "message": "treat unknown as true in segmentmetadata", "committedDate": "2020-08-12T21:04:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5MjMzNQ==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469592335", "bodyText": "Could you please rename this to hasNulls, for this reason: #10219 (comment)?", "author": "gianm", "createdAt": "2020-08-12T22:57:01Z", "path": "processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java", "diffHunk": "@@ -335,6 +339,8 @@ private ColumnAnalysis analyzeComplexColumn(\n   {\n     try (final ComplexColumn complexColumn = columnHolder != null ? (ComplexColumn) columnHolder.getColumn() : null) {\n       final boolean hasMultipleValues = capabilities != null && capabilities.hasMultipleValues().isTrue();\n+      // if we don't know for sure, then we should plan to check for nulls\n+      final boolean nullable = capabilities != null && capabilities.hasNulls().isMaybeTrue();", "originalCommit": "82ff3e452eae3ae1e77ce854e22f563d874bb055", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd6b07d2c635fbe52f9ce044ad508fba96e0a55", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java b/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\nindex a84b95b0f8..2388004d62 100644\n--- a/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\n+++ b/processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java\n\n@@ -339,8 +339,7 @@ public class SegmentAnalyzer\n   {\n     try (final ComplexColumn complexColumn = columnHolder != null ? (ComplexColumn) columnHolder.getColumn() : null) {\n       final boolean hasMultipleValues = capabilities != null && capabilities.hasMultipleValues().isTrue();\n-      // if we don't know for sure, then we should plan to check for nulls\n-      final boolean nullable = capabilities != null && capabilities.hasNulls().isMaybeTrue();\n+      final boolean hasNulls = capabilities != null && capabilities.hasNulls().isMaybeTrue();\n       long size = 0;\n \n       if (analyzingSize() && complexColumn != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5MzI0OQ==", "url": "https://github.com/apache/druid/pull/10219#discussion_r469593249", "bodyText": "This comment doesn't make a lot of sense in the context of SegmentAnalyzer. It shouldn't \"know\" what the fields are being used for, so it shouldn't \"know\" they're going to be used to check for nulls somewhere higher up the chain.\nMaybe a better thing to do would be:\n\nDefine \"hasNulls\" as meaning \"definitely has nulls, or can't determine\". This should be in the docs for the segmentMetadata query too.\nNow this comment could read: \"If we don't know for sure, return true to adhere to the definition of hasNulls\"", "author": "gianm", "createdAt": "2020-08-12T22:59:51Z", "path": "processing/src/main/java/org/apache/druid/query/metadata/SegmentAnalyzer.java", "diffHunk": "@@ -192,6 +193,7 @@ private ColumnAnalysis analyzeNumericColumn(\n     return new ColumnAnalysis(\n         capabilities.getType().name(),\n         capabilities.hasMultipleValues().isTrue(),\n+        capabilities.hasNulls().isMaybeTrue(), // if we don't know for sure, then we should plan to check for nulls", "originalCommit": "82ff3e452eae3ae1e77ce854e22f563d874bb055", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "bdd6b07d2c635fbe52f9ce044ad508fba96e0a55", "url": "https://github.com/apache/druid/commit/bdd6b07d2c635fbe52f9ce044ad508fba96e0a55", "message": "rename to hasNulls, add docs", "committedDate": "2020-08-12T23:51:43Z", "type": "commit"}, {"oid": "09d452b82efed4cde8cc62957c72bedf439d61fc", "url": "https://github.com/apache/druid/commit/09d452b82efed4cde8cc62957c72bedf439d61fc", "message": "fixup", "committedDate": "2020-08-13T03:40:16Z", "type": "commit"}, {"oid": "336dbbb630563f9081e548a45e7d979935f53451", "url": "https://github.com/apache/druid/commit/336dbbb630563f9081e548a45e7d979935f53451", "message": "test the dim indexer selector isNull fix for numeric columns", "committedDate": "2020-08-13T05:32:38Z", "type": "commit"}, {"oid": "b8c1145feb382ee50c1c7e0db84a16beb0093629", "url": "https://github.com/apache/druid/commit/b8c1145feb382ee50c1c7e0db84a16beb0093629", "message": "fixes", "committedDate": "2020-08-13T10:07:14Z", "type": "commit"}, {"oid": "2a21abb884ef9be7453840206752fcde5ec80a8e", "url": "https://github.com/apache/druid/commit/2a21abb884ef9be7453840206752fcde5ec80a8e", "message": "oof", "committedDate": "2020-08-13T11:44:04Z", "type": "commit"}]}