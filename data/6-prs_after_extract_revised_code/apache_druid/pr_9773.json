{"pr_number": 9773, "pr_title": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "pr_createdAt": "2020-04-25T08:50:43Z", "pr_url": "https://github.com/apache/druid/pull/9773", "timeline": [{"oid": "523124ad2d45048aecb2d6c93b5f804720d9f4dd", "url": "https://github.com/apache/druid/commit/523124ad2d45048aecb2d6c93b5f804720d9f4dd", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-04-25T08:49:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3ODM0OQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r416778349", "bodyText": "What do you think about keeping this interface the same and instead changing the private members left and right to DruidRel<?>\nWhenever left and right is set - we can do something like this.left = getCheapestDruidRel(RelNode);\nAs it's written, I wonder if it's possible for us to estimate that a subquery is not required in the computeSelfCost function, but the DruidRel used to build the native query actually uses a subquery.", "author": "suneet-s", "createdAt": "2020-04-28T17:04:23Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -328,17 +327,27 @@ private static JoinType toDruidJoinType(JoinRelType calciteJoinType)\n     }\n   }\n \n-  private static boolean computeLeftRequiresSubquery(final DruidRel<?> left)\n+  private static boolean computeLeftRequiresSubquery(final List<DruidRel<?>> leftList)", "originalCommit": "523124ad2d45048aecb2d6c93b5f804720d9f4dd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9475845bc4e2a19b02de6592adf6987ae126f61f", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\nindex 0a775f549e..1a4578f5d4 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n\n@@ -327,27 +316,17 @@ public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n     }\n   }\n \n-  private static boolean computeLeftRequiresSubquery(final List<DruidRel<?>> leftList)\n+  private static boolean computeLeftRequiresSubquery(final DruidRel<?> left)\n   {\n     // Left requires a subquery unless it's a scan or mapping on top of any table or a join.\n-    for (DruidRel<?> left : leftList) {\n-      if (!DruidRels.isScanOrMapping(left, true)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    return !DruidRels.isScanOrMapping(left, true);\n   }\n \n-  private static boolean computeRightRequiresSubquery(final List<DruidRel<?>> rightList)\n+  private static boolean computeRightRequiresSubquery(final DruidRel<?> right)\n   {\n     // Right requires a subquery unless it's a scan or mapping on top of a global datasource.\n-    for (DruidRel<?> right : rightList) {\n-      if (!(DruidRels.isScanOrMapping(right, false)\n-            && DruidRels.dataSourceIfLeafRel(right).filter(DataSource::isGlobal).isPresent())) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    return !(DruidRels.isScanOrMapping(right, false)\n+             && DruidRels.dataSourceIfLeafRel(right).filter(DataSource::isGlobal).isPresent());\n   }\n \n   /**\n"}}, {"oid": "5a7795b7099fd7d9650a024961c9b03ffddff521", "url": "https://github.com/apache/druid/commit/5a7795b7099fd7d9650a024961c9b03ffddff521", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T01:37:23Z", "type": "commit"}, {"oid": "9475845bc4e2a19b02de6592adf6987ae126f61f", "url": "https://github.com/apache/druid/commit/9475845bc4e2a19b02de6592adf6987ae126f61f", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T01:39:06Z", "type": "commit"}, {"oid": "19bb16cf4d72264fec98b8f46cc9a030956dd874", "url": "https://github.com/apache/druid/commit/19bb16cf4d72264fec98b8f46cc9a030956dd874", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T02:41:24Z", "type": "commit"}, {"oid": "cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "url": "https://github.com/apache/druid/commit/cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T03:47:40Z", "type": "commit"}, {"oid": "7911b2096677593195cb054a2a5a8497807c6ece", "url": "https://github.com/apache/druid/commit/7911b2096677593195cb054a2a5a8497807c6ece", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T22:16:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051095", "bodyText": "This \"due to the order of applying/popping rules\" sounds a bit sketchy. Does it mean that a good plan and bad plan will have equal cost, and we'll pick the good plan due to order-based tiebreaking? If so, I'm not sure it would be safe to rely on that. Ideally the good plans should be cheaper than the bad plans, which ensures we pick them.", "author": "gianm", "createdAt": "2020-05-06T19:51:05Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MzMyMQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421173321", "bodyText": "After thinking about this for a while, I'm thinking that a less-sketchy method would be to remove the rules that push filters past joins. It's similar to how #9648 (temporarily) addressed issues related to bad join orderings by just nuking the rules that reordered joins. It makes sense since we don't have a good way to guide the optimizer at this point.\nWe'll want to reintroduce these rules when we've made improvements to the cost estimators that allow all these rules to operate at their full power.\nIn this case, I think the relevant rules are FilterJoinRule.FILTER_ON_JOIN and FilterJoinRule.JOIN. I'm not sure if we can actually fully disable them, though. We might need parts of them. So we might need to copy them and dumb them down a bit? I'm not sure if this will be necessary, but it's an option if necessary.", "author": "gianm", "createdAt": "2020-05-07T00:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzkyOA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917928", "bodyText": "Done. Updated PR description with details.", "author": "maytasm", "createdAt": "2020-05-08T03:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\nindex 7886493350..1655d73e54 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n\n@@ -293,17 +293,23 @@ public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost = partialQuery.estimateCost();\n+    double cost;\n+\n+    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n+      cost = CostEstimates.COST_JOIN_SUBQUERY;\n+    } else {\n+      cost = partialQuery.estimateCost();\n+    }\n+\n+    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n+      cost += CostEstimates.COST_JOIN_SUBQUERY;\n+    }\n+\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n-    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n-    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).\n-    double multiplier = DruidRels.isScanOrMapping(this, true)\n-                        ? 1\n-                        : 1 / CostEstimates.MULTIPLIER_FILTER;\n-    return planner.getCostFactory().makeCost(cost, 0, 0).multiplyBy(multiplier);\n+\n+    return planner.getCostFactory().makeCost(cost, 0, 0);\n   }\n \n   private static JoinType toDruidJoinType(JoinRelType calciteJoinType)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTY1OQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051659", "bodyText": "Could you also add a super-long version of this (just in case)? Such as:\n        \"SELECT dim1\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l3 ON foo.dim2 = l3.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l4 ON foo.dim2 = l4.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l5 ON foo.dim2 = l5.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l6 ON foo.dim2 = l6.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l7 ON foo.dim2 = l7.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l8 ON foo.dim2 = l8.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l9 ON foo.dim2 = l9.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l10 ON foo.dim2 = l10.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l11 ON foo.dim2 = l11.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l12 ON foo.dim2 = l12.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l13 ON foo.dim2 = l13.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l14 ON foo.dim2 = l14.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l15 ON foo.dim2 = l15.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l16 ON foo.dim2 = l16.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l17 ON foo.dim2 = l17.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l18 ON foo.dim2 = l18.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l19 ON foo.dim2 = l19.k\\n\"\n        + \"WHERE l.v = 'xa'\\n\",\nThe reason I'm suggesting this is we want to make sure the approach we're using doesn't change behavior as the stack gets deeper.", "author": "gianm", "createdAt": "2020-05-06T19:52:07Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8346,6 +8346,166 @@ public void testLeftJoinTwoLookupsUsingJoinOperator() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithOuterLimit() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT dim1\\n\"\n+        + \"FROM foo\\n\"\n+        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n+        + \"WHERE l.v = 'xa'\\n\"\n+        + \"LIMIT 100\\n\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(\n+                    join(\n+                        join(\n+                            new TableDataSource(CalciteTests.DATASOURCE1),\n+                            new LookupDataSource(\"lookyloo\"),\n+                            \"j0.\",\n+                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"j0.k\")),\n+                            JoinType.INNER\n+                        ),\n+                        new LookupDataSource(\"lookyloo\"),\n+                        \"_j0.\",\n+                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_j0.k\")),\n+                        JoinType.INNER\n+                    )\n+                )\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .limit(100)\n+                .filters(selector(\"j0.v\", \"xa\", null))\n+                .columns(\"dim1\")\n+                .context(QUERY_CONTEXT_DEFAULT)\n+                .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\"},\n+            new Object[]{\"1\"}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithoutLimit() throws Exception\n+  {\n+    testQuery(", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzk0Nw==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917947", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-08T03:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTY1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "chunk": "diff --git a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\nindex 888b8c4d72..19d6c79e3a 100644\n--- a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n+++ b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n\n@@ -8506,6 +8506,164 @@ public class CalciteQueryTest extends BaseCalciteQueryTest\n     );\n   }\n \n+  @Test\n+  public void testManyManyInnerJoinOnManyManyLookup() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT dim1\\n\"\n+        + \"FROM foo\\n\"\n+        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l3 ON foo.dim2 = l3.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l4 ON foo.dim2 = l4.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l5 ON foo.dim2 = l5.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l6 ON foo.dim2 = l6.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l7 ON foo.dim2 = l7.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l8 ON foo.dim2 = l8.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l9 ON foo.dim2 = l9.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l10 ON foo.dim2 = l10.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l11 ON foo.dim2 = l11.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l12 ON foo.dim2 = l12.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l13 ON foo.dim2 = l13.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l14 ON foo.dim2 = l14.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l15 ON foo.dim2 = l15.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l16 ON foo.dim2 = l16.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l17 ON foo.dim2 = l17.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l18 ON foo.dim2 = l18.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l19 ON foo.dim2 = l19.k\\n\"\n+        + \"WHERE l.v = 'xa'\\n\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(\n+                    join(\n+                        join(\n+                            join(\n+                                join(\n+                                    join(\n+                                        join(\n+                                            join(\n+                                                join(\n+                                                    join(\n+                                                        join(\n+                                                            join(\n+                                                                join(\n+                                                                    join(\n+                                                                        join(\n+                                                                            join(\n+                                                                                join(\n+                                                                                    join(\n+                                                                                        join(\n+                                                                                            join(\n+                                                                                                new TableDataSource(CalciteTests.DATASOURCE1),\n+                                                                                                new LookupDataSource(\"lookyloo\"),\n+                                                                                                \"j0.\",\n+                                                                                                equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"j0.k\")),\n+                                                                                                JoinType.INNER\n+                                                                                                ),\n+                                                                                            new LookupDataSource(\"lookyloo\"),\n+                                                                                            \"_j0.\",\n+                                                                                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_j0.k\")),\n+                                                                                            JoinType.INNER\n+                                                                                        ),\n+                                                                                        new LookupDataSource(\"lookyloo\"),\n+                                                                                        \"__j0.\",\n+                                                                                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"__j0.k\")),\n+                                                                                        JoinType.INNER\n+                                                                                    ),\n+                                                                                    new LookupDataSource(\"lookyloo\"),\n+                                                                                    \"___j0.\",\n+                                                                                    equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"___j0.k\")),\n+                                                                                    JoinType.INNER\n+                                                                                ),\n+                                                                                new LookupDataSource(\"lookyloo\"),\n+                                                                                \"____j0.\",\n+                                                                                equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"____j0.k\")),\n+                                                                                JoinType.INNER\n+                                                                            ),\n+                                                                            new LookupDataSource(\"lookyloo\"),\n+                                                                            \"_____j0.\",\n+                                                                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_____j0.k\")),\n+                                                                            JoinType.INNER\n+                                                                        ),\n+                                                                        new LookupDataSource(\"lookyloo\"),\n+                                                                        \"______j0.\",\n+                                                                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"______j0.k\")),\n+                                                                        JoinType.INNER\n+                                                                    ),\n+                                                                    new LookupDataSource(\"lookyloo\"),\n+                                                                    \"_______j0.\",\n+                                                                    equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_______j0.k\")),\n+                                                                    JoinType.INNER\n+                                                                ),\n+                                                                new LookupDataSource(\"lookyloo\"),\n+                                                                \"________j0.\",\n+                                                                equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"________j0.k\")),\n+                                                                JoinType.INNER\n+                                                            ),\n+                                                            new LookupDataSource(\"lookyloo\"),\n+                                                            \"_________j0.\",\n+                                                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_________j0.k\")),\n+                                                            JoinType.INNER\n+                                                        ),\n+                                                        new LookupDataSource(\"lookyloo\"),\n+                                                        \"__________j0.\",\n+                                                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"__________j0.k\")),\n+                                                        JoinType.INNER\n+                                                    ),\n+                                                    new LookupDataSource(\"lookyloo\"),\n+                                                    \"___________j0.\",\n+                                                    equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"___________j0.k\")),\n+                                                    JoinType.INNER\n+                                                ),\n+                                                new LookupDataSource(\"lookyloo\"),\n+                                                \"____________j0.\",\n+                                                equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"____________j0.k\")),\n+                                                JoinType.INNER\n+                                            ),\n+                                            new LookupDataSource(\"lookyloo\"),\n+                                            \"_____________j0.\",\n+                                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_____________j0.k\")),\n+                                            JoinType.INNER\n+                                        ),\n+                                        new LookupDataSource(\"lookyloo\"),\n+                                        \"______________j0.\",\n+                                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"______________j0.k\")),\n+                                        JoinType.INNER\n+                                    ),\n+                                    new LookupDataSource(\"lookyloo\"),\n+                                    \"_______________j0.\",\n+                                    equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_______________j0.k\")),\n+                                    JoinType.INNER\n+                                ),\n+                                new LookupDataSource(\"lookyloo\"),\n+                                \"________________j0.\",\n+                                equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"________________j0.k\")),\n+                                JoinType.INNER\n+                            ),\n+                            new LookupDataSource(\"lookyloo\"),\n+                            \"_________________j0.\",\n+                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_________________j0.k\")),\n+                            JoinType.INNER\n+                        ),\n+                        new LookupDataSource(\"lookyloo\"),\n+                        \"__________________j0.\",\n+                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"__________________j0.k\")),\n+                        JoinType.INNER\n+                    )\n+                )\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .filters(selector(\"j0.v\", \"xa\", null))\n+                .columns(\"dim1\")\n+                .context(QUERY_CONTEXT_DEFAULT)\n+                .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\"},\n+            new Object[]{\"1\"}\n+        )\n+    );\n+  }\n+\n   @Test\n   public void testInnerJoinQueryOfLookup() throws Exception\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDIzOQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054239", "bodyText": "Could you add a comment about why this is being done here?", "author": "gianm", "createdAt": "2020-05-06T19:56:31Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -183,6 +183,10 @@ public RelWriter explainTerms(final RelWriter pw)\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory().makeCost(partialQuery.estimateCost(), 0, 0);\n+    double cost = partialQuery.estimateCost();\n+    double multiplier = DruidRels.isScanOrMapping(this, true)", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzk3OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917978", "bodyText": "No longer need this. Removed", "author": "maytasm", "createdAt": "2020-05-08T03:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java\nindex d0226cf289..dd6aad3caf 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java\n\n@@ -183,10 +183,6 @@ public class DruidQueryRel extends DruidRel<DruidQueryRel>\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost = partialQuery.estimateCost();\n-    double multiplier = DruidRels.isScanOrMapping(this, true)\n-                        ? 1\n-                        : CostEstimates.MULTIPLIER_QUERY_NOT_SCAN_OR_MAPPING;\n-    return planner.getCostFactory().makeCost(cost, 0, 0).multiplyBy(multiplier);\n+    return planner.getCostFactory().makeCost(partialQuery.estimateCost(), 0, 0);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDk1NQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054955", "bodyText": "It seems like this happens even if there is no filter. Is that right?", "author": "gianm", "createdAt": "2020-05-06T19:57:49Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).\n+    double multiplier = DruidRels.isScanOrMapping(this, true)\n+                        ? 1\n+                        : 1 / CostEstimates.MULTIPLIER_FILTER;", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxODAyMg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421918022", "bodyText": "No longer need this. Removed", "author": "maytasm", "createdAt": "2020-05-08T03:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\nindex 7886493350..1655d73e54 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java\n\n@@ -293,17 +293,23 @@ public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost = partialQuery.estimateCost();\n+    double cost;\n+\n+    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n+      cost = CostEstimates.COST_JOIN_SUBQUERY;\n+    } else {\n+      cost = partialQuery.estimateCost();\n+    }\n+\n+    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n+      cost += CostEstimates.COST_JOIN_SUBQUERY;\n+    }\n+\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n-    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n-    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).\n-    double multiplier = DruidRels.isScanOrMapping(this, true)\n-                        ? 1\n-                        : 1 / CostEstimates.MULTIPLIER_FILTER;\n-    return planner.getCostFactory().makeCost(cost, 0, 0).multiplyBy(multiplier);\n+\n+    return planner.getCostFactory().makeCost(cost, 0, 0);\n   }\n \n   private static JoinType toDruidJoinType(JoinRelType calciteJoinType)\n"}}, {"oid": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "url": "https://github.com/apache/druid/commit/c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "message": "address comments", "committedDate": "2020-05-08T03:34:22Z", "type": "commit"}, {"oid": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "url": "https://github.com/apache/druid/commit/0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "message": "address comments", "committedDate": "2020-05-08T03:37:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyMDI5MA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421920290", "bodyText": "These left right thing is not needed. But I copied this whole code from Calcite and made minimum change (which is just the classifyFilters method). Hence, keeping these variables here as I don't want to refactor Calcite stuff more than needed.", "author": "maytasm", "createdAt": "2020-05-08T03:45:05Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.calcite.plan.RelOptUtil.conjunctions;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule\n+{\n+  /** Copied from {@link FilterJoinRule#NOT_ENUMERABLE} */\n+  private static final Predicate NOT_ENUMERABLE = (join, joinType, exp) ->\n+      join.getConvention() != EnumerableConvention.INSTANCE;\n+\n+  /**\n+   * Rule that pushes predicates from a Filter into the Join below them.\n+   * Similar to {@link FilterJoinRule#FILTER_ON_JOIN} but does not push predicate to the child\n+   */\n+  public static final FilterJoinRule FILTER_ON_JOIN_EXCLUDE_PUSH_TO_CHILD =\n+      new FilterIntoJoinExcludePushToChildRule(RelFactories.LOGICAL_BUILDER, NOT_ENUMERABLE);\n+\n+  FilterJoinExcludePushToChildRule(RelOptRuleOperand operand,\n+                                             String id,\n+                                             boolean smart,\n+                                             RelBuilderFactory relBuilderFactory,\n+                                             Predicate predicate) {\n+    super(operand, id, smart, relBuilderFactory, predicate);\n+  }\n+\n+  /**\n+   * Rule that tries to push filter expressions into a join\n+   * condition. Exlucde pushing into the inputs (child) of the join.\n+   */\n+  public static class FilterIntoJoinExcludePushToChildRule extends FilterJoinExcludePushToChildRule\n+  {\n+    public FilterIntoJoinExcludePushToChildRule(RelBuilderFactory relBuilderFactory, Predicate predicate) {\n+      super(\n+          operand(Filter.class,\n+                  operand(Join.class, RelOptRule.any())),\n+          \"FilterJoinExcludePushToChildRule:filter\", true, relBuilderFactory,\n+          predicate);\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      Filter filter = call.rel(0);\n+      Join join = call.rel(1);\n+      perform(call, filter, join);\n+    }\n+  }\n+\n+  /**\n+   * Copied from {@link FilterJoinRule#perform}\n+   * The difference is that this method will not not push filters to the children in classifyFilters\n+   */\n+  @Override\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+                         Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+    final List<RexNode> origJoinFilters = ImmutableList.copyOf(joinFilters);\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+        ? getConjunctions(filter)\n+        : new ArrayList<>();\n+    final ImmutableList<RexNode> origAboveFilters =\n+        ImmutableList.copyOf(aboveFilters);\n+\n+    // Simplify Outer Joins\n+    JoinRelType joinType = join.getJoinType();\n+    if (!origAboveFilters.isEmpty() && join.getJoinType() != JoinRelType.INNER) {\n+      joinType = RelOptUtil.simplifyJoin(join, origAboveFilters, joinType);\n+    }\n+\n+    final List<RexNode> leftFilters = new ArrayList<>();", "originalCommit": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java b/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\nindex 0a798be178..bd3e6e20ae 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\n\n@@ -43,8 +43,6 @@ import org.apache.calcite.tools.RelBuilderFactory;\n import java.util.ArrayList;\n import java.util.List;\n \n-import static org.apache.calcite.plan.RelOptUtil.conjunctions;\n-\n public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule\n {\n   /** Copied from {@link FilterJoinRule#NOT_ENUMERABLE} */\n"}}, {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "url": "https://github.com/apache/druid/commit/f3dc681414f9b10bc9d37805d0965d6aceba58b1", "message": "fix checkstyle", "committedDate": "2020-05-08T19:42:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Nzc4OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425277788", "bodyText": "CAST, not CASE (spelling)\npassed the check (spelling)", "author": "gianm", "createdAt": "2020-05-14T16:37:48Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0ODMzNg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425448336", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Nzc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\nindex 235bd2fe2c..f516ab7a1d 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n\n@@ -194,10 +194,12 @@ public class DruidJoinRule extends RelOptRule\n \n     for (RexNode subCondition : subConditions) {\n       if (RexUtil.isLiteral(subCondition, true)) {\n-        if (subCondition instanceof RexCall) {\n+        if (subCondition.isA(SqlKind.CAST)) {\n           // This is CAST(literal) which is always OK.\n-          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          // We know that this is CAST(literal) as it passed the check from RexUtil.isLiteral\n           RexCall call = (RexCall) subCondition;\n+          // We have to verify the types of the cast here, because if the underlying literal and the cast output type\n+          // are different, then skipping the cast might change the meaning of the subcondition.\n           literalSubConditions.add((RexLiteral) call.operands.get(0));\n         } else {\n           // Literals are always OK.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3ODUwMg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425278502", "bodyText": "A bit nicer to do if (subCondition.isA(SqlKind.CAST)), since it's more explicit as to what we're actually looking for.", "author": "gianm", "createdAt": "2020-05-14T16:39:01Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0ODUxOA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425448518", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3ODUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\nindex 235bd2fe2c..f516ab7a1d 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n\n@@ -194,10 +194,12 @@ public class DruidJoinRule extends RelOptRule\n \n     for (RexNode subCondition : subConditions) {\n       if (RexUtil.isLiteral(subCondition, true)) {\n-        if (subCondition instanceof RexCall) {\n+        if (subCondition.isA(SqlKind.CAST)) {\n           // This is CAST(literal) which is always OK.\n-          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          // We know that this is CAST(literal) as it passed the check from RexUtil.isLiteral\n           RexCall call = (RexCall) subCondition;\n+          // We have to verify the types of the cast here, because if the underlying literal and the cast output type\n+          // are different, then skipping the cast might change the meaning of the subcondition.\n           literalSubConditions.add((RexLiteral) call.operands.get(0));\n         } else {\n           // Literals are always OK.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMDg5Nw==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425300897", "bodyText": "We have to verify the types of the cast here, because if the underlying literal and the cast output type are different, then skipping the cast might change the meaning of the subcondition. Try looking at the type of the RexCall and comparing it to the type of the underlying RexLiteral. I think some logic like this would work:\n\nIf the types are the same, unwrap the cast and use the underlying literal.\nIf the types are not the same, return Optional.empty() indicating the condition is not supported.\n\nAlternatively, actually apply the cast in step (2) instead of rejecting the condition. I'm not sure how exactly you would do this or whether it is necessary. If it turns out to be necessary, perhaps check out what ReduceExpressionsRule does.", "author": "gianm", "createdAt": "2020-05-14T17:13:00Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          RexCall call = (RexCall) subCondition;\n+          literalSubConditions.add((RexLiteral) call.operands.get(0));", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2NTExNQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425465115", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMDg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\nindex 235bd2fe2c..f516ab7a1d 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java\n\n@@ -194,10 +194,12 @@ public class DruidJoinRule extends RelOptRule\n \n     for (RexNode subCondition : subConditions) {\n       if (RexUtil.isLiteral(subCondition, true)) {\n-        if (subCondition instanceof RexCall) {\n+        if (subCondition.isA(SqlKind.CAST)) {\n           // This is CAST(literal) which is always OK.\n-          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          // We know that this is CAST(literal) as it passed the check from RexUtil.isLiteral\n           RexCall call = (RexCall) subCondition;\n+          // We have to verify the types of the cast here, because if the underlying literal and the cast output type\n+          // are different, then skipping the cast might change the meaning of the subcondition.\n           literalSubConditions.add((RexLiteral) call.operands.get(0));\n         } else {\n           // Literals are always OK.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMTI2Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425301266", "bodyText": "Please add a javadoc here explaining where the code came from, what modifications you made, and what might need to happen to make this no longer necessary (so we can use the builtin rule instead).", "author": "gianm", "createdAt": "2020-05-14T17:13:38Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NDI1Mg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425454252", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMTI2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java b/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\nindex bd3e6e20ae..ca9ed46ab3 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java\n\n@@ -43,6 +43,21 @@ import org.apache.calcite.tools.RelBuilderFactory;\n import java.util.ArrayList;\n import java.util.List;\n \n+/**\n+ * This class is a copy (with modification) of {@link FilterJoinRule}. Specifically, this class contains a\n+ * subset of code from {@link FilterJoinRule} for the codepath involving {@link FilterJoinRule#FILTER_ON_JOIN}\n+ * Everything has been keep as-is from {@link FilterJoinRule} except for the modification\n+ * of {@link #classifyFilters(List, JoinRelType, boolean, List)} method called in the\n+ * {@link #perform(RelOptRuleCall, Filter, Join)} method of this class.\n+ * The {@link #classifyFilters(List, JoinRelType, boolean, List)} method is based of {@link RelOptUtil#classifyFilters}.\n+ * The difference is that the modfied method use in thsi class will not not push filters to the children.\n+ * Hence, filters will either stay where they are or are pushed to the join (if they originated from above the join).\n+ *\n+ * This modification is needed due to the bug described in https://github.com/apache/druid/pull/9773\n+ * This class and it's modification can be removed, switching back to the default Rule provided in Calcite's\n+ * {@link FilterJoinRule} when https://github.com/apache/druid/issues/9843 is resolved.\n+ */\n+\n public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule\n {\n   /** Copied from {@link FilterJoinRule#NOT_ENUMERABLE} */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjE0Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302146", "bodyText": "Unfortunately (spelling)", "author": "gianm", "createdAt": "2020-05-14T17:15:08Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NTYzMQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425455631", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\nindex 19d6c79e3a..116df5f5b2 100644\n--- a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n+++ b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n\n@@ -9098,7 +9098,7 @@ public class CalciteQueryTest extends BaseCalciteQueryTest\n   }\n \n   // This SQL currently does not result in an optimum plan.\n-  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n+  // Unfortunately, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n   // Hence, comma join will result in a cross join with filter on outermost\n   @Test\n   public void testCommaJoinTableLookupTableMismatchedTypes() throws Exception\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjM1Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302356", "bodyText": "Please update the docs to point out that people should avoid comma joins for this reason.", "author": "gianm", "createdAt": "2020-05-14T17:15:30Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n+  // Hence, comma join will result in a cross join with filter on outermost", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NTY4OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425455688", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjM1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "chunk": "diff --git a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\nindex 19d6c79e3a..116df5f5b2 100644\n--- a/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n+++ b/sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java\n\n@@ -9098,7 +9098,7 @@ public class CalciteQueryTest extends BaseCalciteQueryTest\n   }\n \n   // This SQL currently does not result in an optimum plan.\n-  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n+  // Unfortunately, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n   // Hence, comma join will result in a cross join with filter on outermost\n   @Test\n   public void testCommaJoinTableLookupTableMismatchedTypes() throws Exception\n"}}, {"oid": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "url": "https://github.com/apache/druid/commit/9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "message": "address comments", "committedDate": "2020-05-14T22:06:36Z", "type": "commit"}, {"oid": "177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "url": "https://github.com/apache/druid/commit/177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "message": "address comments", "committedDate": "2020-05-14T22:26:54Z", "type": "commit"}]}