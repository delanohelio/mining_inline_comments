{"pr_number": 10697, "pr_title": "Supporting filters in the left base table for join datasources", "pr_createdAt": "2020-12-21T14:23:59Z", "pr_url": "https://github.com/apache/druid/pull/10697", "timeline": [{"oid": "779f476c51c175c8abacab0c72d32557d48629c5", "url": "https://github.com/apache/druid/commit/779f476c51c175c8abacab0c72d32557d48629c5", "message": "where filter left first draft", "committedDate": "2021-03-02T12:19:48Z", "type": "commit"}, {"oid": "989a4dd3098f69111028a38c2a8fd2d77220d5c5", "url": "https://github.com/apache/druid/commit/989a4dd3098f69111028a38c2a8fd2d77220d5c5", "message": "Revert changes in calcite test", "committedDate": "2021-03-02T12:19:48Z", "type": "commit"}, {"oid": "d3a8659972a65e5f613061906625552f5397eac3", "url": "https://github.com/apache/druid/commit/d3a8659972a65e5f613061906625552f5397eac3", "message": "Refactor a bit", "committedDate": "2021-03-02T12:19:48Z", "type": "commit"}, {"oid": "935265237c155e75c9283d01e258eabf70a190dd", "url": "https://github.com/apache/druid/commit/935265237c155e75c9283d01e258eabf70a190dd", "message": "Fixing the Tests", "committedDate": "2021-03-02T12:19:48Z", "type": "commit"}, {"oid": "75bc6c70c2320ae71bd3df74c2f105537468b8e7", "url": "https://github.com/apache/druid/commit/75bc6c70c2320ae71bd3df74c2f105537468b8e7", "message": "Changes", "committedDate": "2021-03-02T12:19:48Z", "type": "commit"}, {"oid": "538244aaa1a31f1c10fa62131e5e8657e94569f2", "url": "https://github.com/apache/druid/commit/538244aaa1a31f1c10fa62131e5e8657e94569f2", "message": "Adding tests", "committedDate": "2021-03-03T09:41:11Z", "type": "commit"}, {"oid": "538244aaa1a31f1c10fa62131e5e8657e94569f2", "url": "https://github.com/apache/druid/commit/538244aaa1a31f1c10fa62131e5e8657e94569f2", "message": "Adding tests", "committedDate": "2021-03-03T09:41:11Z", "type": "forcePushed"}, {"oid": "b0a900674cf90ac29ff2217bae7e85017013664f", "url": "https://github.com/apache/druid/commit/b0a900674cf90ac29ff2217bae7e85017013664f", "message": "Add tests for correlated queries", "committedDate": "2021-03-04T06:07:45Z", "type": "commit"}, {"oid": "c681bac6cd364ac0ecc68b77b539061c865a9782", "url": "https://github.com/apache/druid/commit/c681bac6cd364ac0ecc68b77b539061c865a9782", "message": "Add comment", "committedDate": "2021-03-04T06:13:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjkzMTk5MA==", "url": "https://github.com/apache/druid/pull/10697#discussion_r586931990", "bodyText": "this was probably an accident?", "author": "clintropolis", "createdAt": "2021-03-04T01:06:19Z", "path": "processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java", "diffHunk": "@@ -98,12 +102,13 @@ private DataSourceAnalysis(\n     this.dataSource = dataSource;\n     this.baseDataSource = baseDataSource;\n     this.baseQuery = baseQuery;\n+    this.joinBaseTableFilter = joinBaseTableFilter;\n     this.preJoinableClauses = preJoinableClauses;\n   }\n \n   public static DataSourceAnalysis forDataSource(final DataSource dataSource)\n   {\n-    // Strip outer queries, retaining querySegmentSpecs as we go down (lowest will become the 'baseQuerySegmentSpec').\n+    // Strip outer queries, retaining querySegmentSpecs as we go down (lowest will become the 'baseQuerySegmentSpec'o).", "originalCommit": "538244aaa1a31f1c10fa62131e5e8657e94569f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java b/processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java\nindex 9516a2c533..061554f3d0 100644\n--- a/processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java\n+++ b/processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java\n\n@@ -108,7 +108,7 @@ public class DataSourceAnalysis\n \n   public static DataSourceAnalysis forDataSource(final DataSource dataSource)\n   {\n-    // Strip outer queries, retaining querySegmentSpecs as we go down (lowest will become the 'baseQuerySegmentSpec'o).\n+    // Strip outer queries, retaining querySegmentSpecs as we go down (lowest will become the 'baseQuerySegmentSpec').\n     Query<?> baseQuery = null;\n     DataSource current = dataSource;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzI5MDgwNw==", "url": "https://github.com/apache/druid/pull/10697#discussion_r587290807", "bodyText": "nit: typo donw -> done?", "author": "clintropolis", "createdAt": "2021-03-04T09:14:16Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -648,6 +651,52 @@ private VirtualColumns getVirtualColumns(final boolean includeDimensions)\n     return VirtualColumns.create(columns);\n   }\n \n+  /**\n+   * Returns a pair of DataSource and Filtration object created on the query filter. In case the, data source is\n+   * a join datasource, the datasource may be altered and left filter of join datasource may\n+   * be rid of time filters.\n+   * TODO: should we optimize the base table filter just like we do with query filters\n+   */\n+  @VisibleForTesting\n+  static Pair<DataSource, Filtration> getFiltration(\n+      DataSource dataSource,\n+      DimFilter filter,\n+      VirtualColumnRegistry virtualColumnRegistry\n+  )\n+  {\n+    if (!(dataSource instanceof JoinDataSource)) {\n+      return Pair.of(dataSource, toFiltration(filter, virtualColumnRegistry));\n+    }\n+    JoinDataSource joinDataSource = (JoinDataSource) dataSource;\n+    if (joinDataSource.getLeftFilter() == null) {\n+      return Pair.of(dataSource, toFiltration(filter, virtualColumnRegistry));\n+    }\n+    //TODO: We should avoid promoting the time filter as interval for right outer and full outer joins. This is not\n+    // donw now as we apply the intervals to left base table today irrespective of the join type.", "originalCommit": "c681bac6cd364ac0ecc68b77b539061c865a9782", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "chunk": "diff --git a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java\nindex 3011cb50eb..a12ba3444c 100644\n--- a/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java\n+++ b/sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java\n\n@@ -672,7 +672,7 @@ public class DruidQuery\n       return Pair.of(dataSource, toFiltration(filter, virtualColumnRegistry));\n     }\n     //TODO: We should avoid promoting the time filter as interval for right outer and full outer joins. This is not\n-    // donw now as we apply the intervals to left base table today irrespective of the join type.\n+    // done now as we apply the intervals to left base table today irrespective of the join type.\n \n     // If the join is left or inner, we can pull the intervals up to the query. This is done\n     // so that broker can prune the segments to query.\n"}}, {"oid": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "url": "https://github.com/apache/druid/commit/b51e4eb87135084d6036d1e989c8cd609bd51d80", "message": "Fix typos", "committedDate": "2021-03-04T11:43:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkxODM3MA==", "url": "https://github.com/apache/druid/pull/10697#discussion_r587918370", "bodyText": "No what?", "author": "gianm", "createdAt": "2021-03-04T23:51:05Z", "path": "processing/src/main/java/org/apache/druid/segment/join/HashJoinSegmentStorageAdapter.java", "diffHunk": "@@ -69,8 +70,25 @@\n       final List<JoinableClause> clauses,\n       final JoinFilterPreAnalysis joinFilterPreAnalysis\n   )\n+  {\n+    this(baseAdapter, null, clauses, joinFilterPreAnalysis);\n+  }\n+\n+  /**\n+   * @param baseAdapter           A StorageAdapter for the left-hand side base segment\n+   * @param baseFilter            A filter for the left-hand side base segment\n+   * @param clauses               The right-hand side clauses. The caller is responsible for ensuring that there are no", "originalCommit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTY0ODY0Ng==", "url": "https://github.com/apache/druid/pull/10697#discussion_r589648646", "bodyText": "copy-paste error. will fix it in another patch.", "author": "abhishekagarwal87", "createdAt": "2021-03-08T18:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkxODM3MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkyNDk4Mw==", "url": "https://github.com/apache/druid/pull/10697#discussion_r587924983", "bodyText": "This may not work right if left is a DruidJoinQueryRel or DruidOuterQueryRel instead of a DruidQueryRel (since leftFilter is only supported for regular tables).", "author": "gianm", "createdAt": "2021-03-05T00:00:30Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -97,18 +98,19 @@ public void onMatch(RelOptRuleCall call)\n \n     final DruidRel<?> newLeft;\n     final DruidRel<?> newRight;\n+    final Filter leftFilter;\n     final List<RexNode> newProjectExprs = new ArrayList<>();\n \n     // Already verified to be present in \"matches\", so just call \"get\".\n     // Can't be final, because we're going to reassign it up to a couple of times.\n     ConditionAnalysis conditionAnalysis = analyzeCondition(join.getCondition(), join.getLeft().getRowType()).get();\n \n-    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT\n-        && left.getPartialDruidQuery().getWhereFilter() == null) {\n+    if (left.getPartialDruidQuery().stage() == PartialDruidQuery.Stage.SELECT_PROJECT) {", "originalCommit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODU2MzA1MQ==", "url": "https://github.com/apache/druid/pull/10697#discussion_r588563051", "bodyText": "oops. good catch. will fix this.", "author": "abhishekagarwal87", "createdAt": "2021-03-05T18:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkyNDk4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkyNzkyMA==", "url": "https://github.com/apache/druid/pull/10697#discussion_r587927920", "bodyText": "The javadoc doesn't seem right, it doesn't accept a JoinConditionAnalysis.\nFwiw, also, I don't really like adding \"everything minus one\" constructors when a new parameter is added. It minimizes the amount of code to update, but it leaves things messier, and it makes it more likely that someone will forget to use the new parameter when it is actually important to use. IMO it is better to remove this constructor and update all the call sites to use the new one.", "author": "gianm", "createdAt": "2021-03-05T00:08:24Z", "path": "processing/src/main/java/org/apache/druid/query/JoinDataSource.java", "diffHunk": "@@ -108,10 +122,26 @@ public static JoinDataSource create(\n       final DataSource right,\n       final String rightPrefix,\n       final JoinConditionAnalysis conditionAnalysis,\n-      final JoinType joinType\n+      final JoinType joinType,\n+      final DimFilter leftFilter\n+  )\n+  {\n+    return new JoinDataSource(left, right, rightPrefix, conditionAnalysis, joinType, leftFilter);\n+  }\n+\n+  /**\n+   * Create a join dataSource from an existing {@link JoinConditionAnalysis}.", "originalCommit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkyODU2NQ==", "url": "https://github.com/apache/druid/pull/10697#discussion_r587928565", "bodyText": "nit: Nested Pairs probably mean it's time for a named class.", "author": "gianm", "createdAt": "2021-03-05T00:10:12Z", "path": "processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java", "diffHunk": "@@ -156,7 +166,7 @@ public static DataSourceAnalysis forDataSource(final DataSource dataSource)\n     // going-up order. So reverse them.\n     Collections.reverse(preJoinableClauses);\n \n-    return Pair.of(current, preJoinableClauses);\n+    return Pair.of(Pair.of(current, currentDimFilter), preJoinableClauses);", "originalCommit": "b51e4eb87135084d6036d1e989c8cd609bd51d80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}