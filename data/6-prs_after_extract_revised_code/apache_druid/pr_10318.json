{"pr_number": 10318, "pr_title": "Fix handling of 'join' on top of 'union' datasources.", "pr_createdAt": "2020-08-24T18:28:44Z", "pr_url": "https://github.com/apache/druid/pull/10318", "timeline": [{"oid": "5b1e19fee490cf1af6d79eb214d654a7dc083a5e", "url": "https://github.com/apache/druid/commit/5b1e19fee490cf1af6d79eb214d654a7dc083a5e", "message": "Fix handling of 'join' on top of 'union' datasources.\n\nThe problem is that unions are typically rewritten into a series of\nindividual queries on the underlying tables, but this isn't done when\nthe union is wrapped in a join.\n\nThe main changes are in UnionQueryRunner:\n\n1) Replace an instanceof UnionQueryRunner check with DataSourceAnalysis.\n2) Replace a \"query.withDataSource\" call with a new function, \"Queries.withBaseDataSource\".\n\nTogether, these enable UnionQueryRunner to \"see through\" a join.", "committedDate": "2020-08-24T18:27:15Z", "type": "commit"}, {"oid": "a6373fd243c55d1737bfc7313432b7b2f6480d8c", "url": "https://github.com/apache/druid/commit/a6373fd243c55d1737bfc7313432b7b2f6480d8c", "message": "Tests.", "committedDate": "2020-08-25T05:47:27Z", "type": "commit"}, {"oid": "2bc0c3b4b585afab4865057245a7d0266fa4a94b", "url": "https://github.com/apache/druid/commit/2bc0c3b4b585afab4865057245a7d0266fa4a94b", "message": "Adjust heap sizes for integration tests.", "committedDate": "2020-08-25T07:51:12Z", "type": "commit"}, {"oid": "2bc0c3b4b585afab4865057245a7d0266fa4a94b", "url": "https://github.com/apache/druid/commit/2bc0c3b4b585afab4865057245a7d0266fa4a94b", "message": "Adjust heap sizes for integration tests.", "committedDate": "2020-08-25T07:51:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477104655", "bodyText": "can we use more explicit condition such as analysis.getBaseDataSource() instanceof UnionDataSource than this analysis.getBaseTableDataSources().get().size() != 1?  May be the assumption around number of tables will not be valid in future.", "author": "abhishekagarwal87", "createdAt": "2020-08-26T07:52:57Z", "path": "processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java", "diffHunk": "@@ -41,30 +42,27 @@ public UnionQueryRunner(\n   public Sequence<T> run(final QueryPlus<T> queryPlus, final ResponseContext responseContext)\n   {\n     Query<T> query = queryPlus.getQuery();\n-    DataSource dataSource = query.getDataSource();\n-    if (dataSource instanceof UnionDataSource) {\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(query.getDataSource());\n+\n+    if (analysis.isConcreteTableBased() && analysis.getBaseTableDataSources().get().size() != 1) {", "originalCommit": "2bc0c3b4b585afab4865057245a7d0266fa4a94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0MzA4MQ==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477443081", "bodyText": "Hmm, I was trying to avoid using instanceof checks outside of the DataSourceAnalysis class, and instead stick to cleanly defined interfaces as much as possible. So, I designed dataSourceAnalysis.getBaseTableDataSources() to encapsulate this logic (it has the instanceof check you're talking about).\nDo you think it'd be better to instead move the logic to UnionQueryRunner?", "author": "gianm", "createdAt": "2020-08-26T16:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2Mjc2OQ==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477462769", "bodyText": "In that case, It would also be fine to have a static method isUnionDataSource(DataSource) within DataSourceAnalysis class itself that can be used here as well as in dataSourceAnalysis.getBaseTableDataSources()", "author": "abhishekagarwal87", "createdAt": "2020-08-26T17:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NTUwOA==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477485508", "bodyText": "Hmm, in thinking about your comment I realized there is a bug here. The code doesn't work right if you have a UnionDataSource of a single TableDataSource. I'll fix it and add a test for this, and while doing so, I'll consider your comments about how to structure the code.\nThanks for the comments!", "author": "gianm", "createdAt": "2020-08-26T17:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwMjI5NQ==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477502295", "bodyText": "I pushed up a new commit that changes the approach a bit; let me know what you think. The getBaseTableDataSources() concept is gone and replaced by two separate methods, getBaseTableDataSource() and getBaseUnionDataSource().", "author": "gianm", "createdAt": "2020-08-26T18:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTk0MA==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477555940", "bodyText": "Looks good now.", "author": "abhishekagarwal87", "createdAt": "2020-08-26T20:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTc1NA==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477579754", "bodyText": "Great!", "author": "gianm", "createdAt": "2020-08-26T20:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "02aabcd637e36b4a8373803f688af43ee7ad3b14", "chunk": "diff --git a/processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java b/processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java\nindex 3dea908779..db864351be 100644\n--- a/processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java\n+++ b/processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java\n\n@@ -45,28 +47,48 @@ public class UnionQueryRunner<T> implements QueryRunner<T>\n \n     final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(query.getDataSource());\n \n-    if (analysis.isConcreteTableBased() && analysis.getBaseTableDataSources().get().size() != 1) {\n+    if (analysis.isConcreteTableBased() && analysis.getBaseUnionDataSource().isPresent()) {\n       // Union of tables.\n \n-      return new MergeSequence<>(\n-          query.getResultOrdering(),\n-          Sequences.simple(\n-              Lists.transform(\n-                  analysis.getBaseTableDataSources().get(),\n-                  (Function<DataSource, Sequence<T>>) singleSource ->\n-                      baseRunner.run(\n-                          queryPlus.withQuery(\n-                              Queries.withBaseDataSource(query, singleSource)\n-                                     // assign the subqueryId. this will be used to validate that every query servers\n-                                     // have responded per subquery in RetryQueryRunner\n-                                     .withDefaultSubQueryId()\n-                          ),\n-                          responseContext\n-                      )\n-              )\n-          )\n-      );\n+      final UnionDataSource unionDataSource = analysis.getBaseUnionDataSource().get();\n+\n+      if (unionDataSource.getDataSources().isEmpty()) {\n+        // Shouldn't happen, because UnionDataSource doesn't allow empty unions.\n+        throw new ISE(\"Unexpectedly received empty union\");\n+      } else if (unionDataSource.getDataSources().size() == 1) {\n+        // Single table. Run as a normal query.\n+        return baseRunner.run(\n+            queryPlus.withQuery(\n+                Queries.withBaseDataSource(\n+                    query,\n+                    Iterables.getOnlyElement(unionDataSource.getDataSources())\n+                )\n+            ),\n+            responseContext\n+        );\n+      } else {\n+        // Split up the tables and merge their results.\n+        return new MergeSequence<>(\n+            query.getResultOrdering(),\n+            Sequences.simple(\n+                Lists.transform(\n+                    unionDataSource.getDataSources(),\n+                    (Function<DataSource, Sequence<T>>) singleSource ->\n+                        baseRunner.run(\n+                            queryPlus.withQuery(\n+                                Queries.withBaseDataSource(query, singleSource)\n+                                       // assign the subqueryId. this will be used to validate that every query servers\n+                                       // have responded per subquery in RetryQueryRunner\n+                                       .withDefaultSubQueryId()\n+                            ),\n+                            responseContext\n+                        )\n+                )\n+            )\n+        );\n+      }\n     } else {\n+      // Not a union of tables. Do nothing special.\n       return baseRunner.run(queryPlus, responseContext);\n     }\n   }\n"}}, {"oid": "02aabcd637e36b4a8373803f688af43ee7ad3b14", "url": "https://github.com/apache/druid/commit/02aabcd637e36b4a8373803f688af43ee7ad3b14", "message": "Different approach, more tests.", "committedDate": "2020-08-26T18:24:10Z", "type": "commit"}, {"oid": "8ecb6138e89a24d7eafde7aba8fc8e5691446223", "url": "https://github.com/apache/druid/commit/8ecb6138e89a24d7eafde7aba8fc8e5691446223", "message": "Merge branch 'master' into fix-join-union", "committedDate": "2020-08-26T18:24:37Z", "type": "commit"}, {"oid": "d5d3e75b74ccd4e8be4113c58630912da314802e", "url": "https://github.com/apache/druid/commit/d5d3e75b74ccd4e8be4113c58630912da314802e", "message": "Tweak.", "committedDate": "2020-08-26T18:25:46Z", "type": "commit"}, {"oid": "575b30d63e601d7b395161da0e9d3ceeb60f2806", "url": "https://github.com/apache/druid/commit/575b30d63e601d7b395161da0e9d3ceeb60f2806", "message": "Styling.", "committedDate": "2020-08-26T18:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTc1Mg==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477555752", "bodyText": "is it optimization because of which this else if is not folded into else?", "author": "abhishekagarwal87", "createdAt": "2020-08-26T20:00:52Z", "path": "processing/src/main/java/org/apache/druid/query/UnionQueryRunner.java", "diffHunk": "@@ -41,34 +44,51 @@ public UnionQueryRunner(\n   public Sequence<T> run(final QueryPlus<T> queryPlus, final ResponseContext responseContext)\n   {\n     Query<T> query = queryPlus.getQuery();\n-    DataSource dataSource = query.getDataSource();\n-    if (dataSource instanceof UnionDataSource) {\n \n-      return new MergeSequence<>(\n-          query.getResultOrdering(),\n-          Sequences.simple(\n-              Lists.transform(\n-                  ((UnionDataSource) dataSource).getDataSources(),\n-                  new Function<DataSource, Sequence<T>>()\n-                  {\n-                    @Override\n-                    public Sequence<T> apply(DataSource singleSource)\n-                    {\n-                      return baseRunner.run(\n-                          queryPlus.withQuery(\n-                              query.withDataSource(singleSource)\n-                                   // assign the subqueryId. this will be used to validate that every query servers\n-                                   // have responded per subquery in RetryQueryRunner\n-                                   .withDefaultSubQueryId()\n-                          ),\n-                          responseContext\n-                      );\n-                    }\n-                  }\n-              )\n-          )\n-      );\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(query.getDataSource());\n+\n+    if (analysis.isConcreteTableBased() && analysis.getBaseUnionDataSource().isPresent()) {\n+      // Union of tables.\n+\n+      final UnionDataSource unionDataSource = analysis.getBaseUnionDataSource().get();\n+\n+      if (unionDataSource.getDataSources().isEmpty()) {\n+        // Shouldn't happen, because UnionDataSource doesn't allow empty unions.\n+        throw new ISE(\"Unexpectedly received empty union\");\n+      } else if (unionDataSource.getDataSources().size() == 1) {", "originalCommit": "575b30d63e601d7b395161da0e9d3ceeb60f2806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4MDAxMg==", "url": "https://github.com/apache/druid/pull/10318#discussion_r477580012", "bodyText": "Yeah, the idea is let's not create a MergeSequence if there's only going to be 1 thing.", "author": "gianm", "createdAt": "2020-08-26T20:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTc1Mg=="}], "type": "inlineReview", "revised_code": null}]}