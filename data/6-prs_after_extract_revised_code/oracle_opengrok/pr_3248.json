{"pr_number": 3248, "pr_title": "do not deep copy history entries", "pr_createdAt": "2020-09-25T06:44:46Z", "pr_url": "https://github.com/oracle/opengrok/pull/3248", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMjg2OA==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494812868", "bodyText": "What is the contract here? Can repository.getHistory(srcFile) return null? If not, then maybe we can rewrite it to:\nHistory hist;\nif (renamed) {\n    hist = repository.getHistory(srcFile);\n} else {\n    hist = new History(historyEntries);\n}", "author": "ahornace", "createdAt": "2020-09-25T07:55:12Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java", "diffHunk": "@@ -103,38 +103,34 @@ private void doFileHistory(String filename, List<HistoryEntry> historyEntries,\n             Repository repository, File srcFile, File root, boolean renamed)\n             throws HistoryException {\n \n-        History hist = null;\n+        File file = new File(root, filename);\n+        // Only store directory history for the top-level directory.\n+        if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);\n+            return;\n+        }\n \n+        History hist = null;\n         /*\n          * If the file was renamed (in the changesets that are being indexed),\n          * its history is not stored in the historyEntries so it needs to be acquired\n          * directly from the repository.\n-         * This ensures that complete history of the file (across renames)\n-         * will be saved.\n+         * This ensures that complete history of the file (across renames) will be saved.\n          */\n         if (renamed) {\n             hist = repository.getHistory(srcFile);", "originalCommit": "0bc21b878b44a8c725436bd1dc50df2a1e044b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MDE3MA==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494890170", "bodyText": "I thought about the null return value too. It seems rather than returning null History the underlying methods will throw HistoryException.", "author": "vladak", "createdAt": "2020-09-25T10:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMjg2OA=="}], "type": "inlineReview", "revised_code": {"commit": "7079ff6bf150e95b3e840ff01f74d5f7a2e922f4", "chunk": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\nindex efc197aa0a..1ef106a27e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n\n@@ -106,22 +106,20 @@ class FileHistoryCache implements HistoryCache {\n         File file = new File(root, filename);\n         // Only store directory history for the top-level directory.\n         if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n-            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}: not top level directory\", file);\n             return;\n         }\n \n-        History hist = null;\n         /*\n          * If the file was renamed (in the changesets that are being indexed),\n          * its history is not stored in the historyEntries so it needs to be acquired\n          * directly from the repository.\n          * This ensures that complete history of the file (across renames) will be saved.\n          */\n+        History hist;\n         if (renamed) {\n             hist = repository.getHistory(srcFile);\n-        }\n-\n-        if (hist == null) {\n+        } else {\n             hist = new History(historyEntries);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMzM0Ng==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494813346", "bodyText": "Why the space before !? Just curious :D", "author": "ahornace", "createdAt": "2020-09-25T07:56:05Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/Repository.java", "diffHunk": "@@ -279,24 +279,25 @@ boolean hasFileBasedTags() {\n      * tags to changesets which actually exist in the history of given file.\n      * Must be implemented repository-specific.\n      *\n-     * @see getTagList\n-     * @param hist History we want to assign tags to.\n+     * @see #getTagList\n+     * @param hist History object we want to assign tags to.\n      */\n     void assignTagsInHistory(History hist) {\n         if (hist == null) {\n             return;\n         }\n+\n         if (this.getTagList() == null) {\n             throw new IllegalStateException(\"getTagList() is null\");\n         }\n+\n         Iterator<TagEntry> it = this.getTagList().descendingIterator();\n         TagEntry lastTagEntry = null;\n-        // Go through all commits of given file\n         for (HistoryEntry ent : hist.getHistoryEntries()) {\n             // Assign all tags created since the last revision\n-            // Revision in this HistoryEntry must be already specified!\n-            // TODO is there better way to do this? We need to \"repeat\"\n-            // last element returned by call to next()\n+            // Revision in this HistoryEntry must be already specified !", "originalCommit": "0bc21b878b44a8c725436bd1dc50df2a1e044b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MTAwOQ==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494891009", "bodyText": "with the space the whole TODO comment gets highlighted in IDEA.", "author": "vladak", "createdAt": "2020-09-25T10:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxMzM0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxNDg2MQ==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494814861", "bodyText": "Could you please explain what was the use case?\nWe need to do deep copy in order to have different tags per each commit.", "author": "ahornace", "createdAt": "2020-09-25T07:58:52Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java", "diffHunk": "@@ -463,15 +456,8 @@ public void store(History history, Repository repository)\n                     list = new ArrayList<>();\n                     map.put(s, list);\n                 }\n-                /*\n-                 * We need to do deep copy in order to have different tags", "originalCommit": "0bc21b878b44a8c725436bd1dc50df2a1e044b6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg5MjQ2OQ==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494892469", "bodyText": "I think the author of the original code forgot that the tags were reset in doFileHistory(). Assigning the tags to history entries used shared across files would lead to wrong results.", "author": "vladak", "createdAt": "2020-09-25T10:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgxNDg2MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODg4Mw==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r494998883", "bodyText": "a reason in the message could be helpful for debugging", "author": "tulinkry", "createdAt": "2020-09-25T13:46:36Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java", "diffHunk": "@@ -103,38 +103,32 @@ private void doFileHistory(String filename, List<HistoryEntry> historyEntries,\n             Repository repository, File srcFile, File root, boolean renamed)\n             throws HistoryException {\n \n-        History hist = null;\n+        File file = new File(root, filename);\n+        // Only store directory history for the top-level directory.\n+        if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);", "originalCommit": "4dcf7e91f2b5e0b468736092ef85d0d5e14b9965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA2NDI5Nw==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495064297", "bodyText": "sure, fixed", "author": "vladak", "createdAt": "2020-09-25T15:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5ODg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7079ff6bf150e95b3e840ff01f74d5f7a2e922f4", "chunk": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\nindex dd3340c99d..1ef106a27e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n\n@@ -106,7 +106,7 @@ class FileHistoryCache implements HistoryCache {\n         File file = new File(root, filename);\n         // Only store directory history for the top-level directory.\n         if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n-            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}: not top level directory\", file);\n             return;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495000106", "bodyText": "hist could be null when hist = repository.getHistory(srcFile) returns null which was handled in the previous code", "author": "tulinkry", "createdAt": "2020-09-25T13:48:29Z", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java", "diffHunk": "@@ -103,38 +103,32 @@ private void doFileHistory(String filename, List<HistoryEntry> historyEntries,\n             Repository repository, File srcFile, File root, boolean renamed)\n             throws HistoryException {\n \n-        History hist = null;\n+        File file = new File(root, filename);\n+        // Only store directory history for the top-level directory.\n+        if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);\n+            return;\n+        }\n \n         /*\n          * If the file was renamed (in the changesets that are being indexed),\n          * its history is not stored in the historyEntries so it needs to be acquired\n          * directly from the repository.\n-         * This ensures that complete history of the file (across renames)\n-         * will be saved.\n+         * This ensures that complete history of the file (across renames) will be saved.\n          */\n+        History hist;\n         if (renamed) {\n             hist = repository.getHistory(srcFile);\n+        } else {\n+            hist = new History(historyEntries);\n         }\n \n-        File file = new File(root, filename);\n-\n-        if (hist == null) {\n-            hist = new History();\n-\n-            // File based history cache does not store files for individual\n-            // changesets so strip them unless it is history for the repository.\n-            for (HistoryEntry ent : historyEntries) {\n-                if (file.isDirectory() && filename.equals(repository.getDirectoryName())) {\n-                    ent.stripTags();\n-                } else {\n-                    ent.strip();\n-                }\n-            }\n-\n-            // add all history entries\n-            hist.setHistoryEntries(historyEntries);\n-        } else {\n-            for (HistoryEntry ent : hist.getHistoryEntries()) {\n+        // File based history cache does not store files for individual\n+        // changesets so strip them unless it is history for the repository.\n+        for (HistoryEntry ent : hist.getHistoryEntries()) {", "originalCommit": "4dcf7e91f2b5e0b468736092ef85d0d5e14b9965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwNzQ4OA==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495007488", "bodyText": "If it's part of the contract that it can return null, then it would be better to rewrite it to return Optional.", "author": "ahornace", "createdAt": "2020-09-25T13:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA2MTI2NA==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495061264", "bodyText": "Sounds to me like a complication. If the history cannot be retrieved, the HistoryException should be thrown.", "author": "vladak", "createdAt": "2020-09-25T15:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA2OTg5Mg==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495069892", "bodyText": "There's no word about null on \n  \n    \n      opengrok/opengrok-indexer/src/main/java/org/opengrok/indexer/history/Repository.java\n    \n    \n        Lines 92 to 98\n      in\n      ecb1ce8\n    \n    \n    \n    \n\n        \n          \n               /** \n        \n\n        \n          \n                * Check if the repository supports {@code getHistory()} requests for whole \n        \n\n        \n          \n                * directories at once. \n        \n\n        \n          \n                * \n        \n\n        \n          \n                * @return {@code true} if the repository can get history for directories \n        \n\n        \n          \n                */ \n        \n\n        \n          \n               abstract boolean hasHistoryForDirectories(); \n        \n    \n  \n\n\nand looking at a few repository implementations they do throw the HistoryException, e.g. \n  \n    \n      opengrok/opengrok-indexer/src/main/java/org/opengrok/indexer/history/MercurialHistoryParser.java\n    \n    \n        Lines 76 to 101\n      in\n      ecb1ce8\n    \n    \n    \n    \n\n        \n          \n           History parse(File file, String changeset) throws HistoryException { \n        \n\n        \n          \n               isDir = file.isDirectory(); \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                   Executor executor = repository.getHistoryLogExecutor(file, changeset); \n        \n\n        \n          \n                   int status = executor.exec(true, this); \n        \n\n        \n          \n            \n        \n\n        \n          \n                   if (status != 0) { \n        \n\n        \n          \n                       throw new HistoryException(\"Failed to get history for: \\\"\" + \n        \n\n        \n          \n                                                  file.getAbsolutePath() + \n        \n\n        \n          \n                                                  \"\\\" Exit code: \" + status); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } catch (IOException e) { \n        \n\n        \n          \n                   throw new HistoryException(\"Failed to get history for: \\\"\" + \n        \n\n        \n          \n                                              file.getAbsolutePath() + \"\\\"\", e); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               // If a changeset to start from is specified, remove that changeset \n        \n\n        \n          \n               // from the list, since only the ones following it should be returned. \n        \n\n        \n          \n               // Also check that the specified changeset was found, otherwise throw \n        \n\n        \n          \n               // an exception. \n        \n\n        \n          \n               if (changeset != null) { \n        \n\n        \n          \n                   repository.removeAndVerifyOldestChangeset(entries, changeset); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               return new History(entries, renamedFiles); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI wonder if it is possible to enforce the class methods not to return null. The @NotNull annotation seems to be meant for something else ? Otherwise, provide a wrapper to check for null and throw the exception.", "author": "vladak", "createdAt": "2020-09-25T15:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3NDg3Mg==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495074872", "bodyText": "https://github.com/JetBrains/java-annotations has @NotNull that might work.", "author": "vladak", "createdAt": "2020-09-25T15:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwOTM3OA==", "url": "https://github.com/oracle/opengrok/pull/3248#discussion_r495109378", "bodyText": "It's ok, I didn't see this conversation #3248 (comment)", "author": "tulinkry", "createdAt": "2020-09-25T16:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDEwNg=="}], "type": "inlineReview", "revised_code": {"commit": "7079ff6bf150e95b3e840ff01f74d5f7a2e922f4", "chunk": "diff --git a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\nindex dd3340c99d..1ef106a27e 100644\n--- a/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n+++ b/opengrok-indexer/src/main/java/org/opengrok/indexer/history/FileHistoryCache.java\n\n@@ -106,7 +106,7 @@ class FileHistoryCache implements HistoryCache {\n         File file = new File(root, filename);\n         // Only store directory history for the top-level directory.\n         if (file.isDirectory() && !filename.equals(repository.getDirectoryName())) {\n-            LOGGER.log(Level.FINE, \"Not storing history cache for {0}\", file);\n+            LOGGER.log(Level.FINE, \"Not storing history cache for {0}: not top level directory\", file);\n             return;\n         }\n \n"}}, {"oid": "7079ff6bf150e95b3e840ff01f74d5f7a2e922f4", "url": "https://github.com/oracle/opengrok/commit/7079ff6bf150e95b3e840ff01f74d5f7a2e922f4", "message": "use @NotNull annotation for getHistory()", "committedDate": "2020-10-10T16:15:33Z", "type": "forcePushed"}, {"oid": "152093a8a99f27f0d0394de3db86fa80e0bf11c0", "url": "https://github.com/oracle/opengrok/commit/152093a8a99f27f0d0394de3db86fa80e0bf11c0", "message": "use @NotNull annotation for getHistory()", "committedDate": "2020-10-26T15:08:46Z", "type": "forcePushed"}, {"oid": "470a66b7332a849a6dd0bd236f0ed3fdddc75fd1", "url": "https://github.com/oracle/opengrok/commit/470a66b7332a849a6dd0bd236f0ed3fdddc75fd1", "message": "do not deep copy history entries", "committedDate": "2020-10-27T19:47:51Z", "type": "commit"}, {"oid": "c6fdd299bc41bc40bd94119bd2aad86839e25270", "url": "https://github.com/oracle/opengrok/commit/c6fdd299bc41bc40bd94119bd2aad86839e25270", "message": "use @NotNull annotation for getHistory()", "committedDate": "2020-10-27T19:48:48Z", "type": "commit"}, {"oid": "c6fdd299bc41bc40bd94119bd2aad86839e25270", "url": "https://github.com/oracle/opengrok/commit/c6fdd299bc41bc40bd94119bd2aad86839e25270", "message": "use @NotNull annotation for getHistory()", "committedDate": "2020-10-27T19:48:48Z", "type": "forcePushed"}]}