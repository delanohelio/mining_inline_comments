{"pr_number": 2641, "pr_title": "Support queryReplicationStatus() on non-leader Active Node.", "pr_createdAt": "2020-07-18T22:49:51Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2641", "timeline": [{"oid": "20469b160f9f302cd0634811caece580526b792c", "url": "https://github.com/CorfuDB/CorfuDB/commit/20469b160f9f302cd0634811caece580526b792c", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-20T19:10:34Z", "type": "forcePushed"}, {"oid": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "url": "https://github.com/CorfuDB/CorfuDB/commit/885eb3bff6b5f8440469a6e1f95049d1d48017f7", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-21T01:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNjk4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459126980", "bodyText": "this TODO was going to be exactly my question. Are you returning 0, 1?", "author": "annym", "createdAt": "2020-07-22T22:49:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n         }\n+        // TODO pankti - boolean cannot be parsed to int", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMjc4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459232783", "bodyText": "I changed it a bit but I think it will be best to change the metadata schema a bit and not have string for all types...", "author": "pankti-m", "createdAt": "2020-07-23T06:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNjk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex c013fa31f90..5fa00174635 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -664,9 +665,17 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n     public int queryReplicationStatus() {\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n             return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n+        } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n+            // TODO pankti - boolean cannot be parsed to int\n+            String dataConsistentOnStandby = logReplicationMetadataManager.getDataConsistentOnStandby();\n+            if (Objects.equals(dataConsistentOnStandby, \"true\")) {\n+                return 1;\n+            }\n+            return 0;\n         }\n-        // TODO pankti - boolean cannot be parsed to int\n-        return Integer.parseInt(logReplicationMetadataManager.getDataConsistentOnStandby());\n+        log.error(\"Received Replication Status Query in Incorrect Role {}.\",\n+            localClusterDescriptor.getRole());\n+        return INVALID_REPLICATION_STATUS;\n     }\n \n     public void shutdown() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzQyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459127420", "bodyText": "we should probably have an else (localClusterDescriptor.getRole() == ClusterRole.Standby). Because what if the role of that node is INVALID, we probably shouldn't return anything and log an error/warning.", "author": "annym", "createdAt": "2020-07-22T22:50:28Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex c013fa31f90..5fa00174635 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -664,9 +665,17 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n     public int queryReplicationStatus() {\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n             return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n+        } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n+            // TODO pankti - boolean cannot be parsed to int\n+            String dataConsistentOnStandby = logReplicationMetadataManager.getDataConsistentOnStandby();\n+            if (Objects.equals(dataConsistentOnStandby, \"true\")) {\n+                return 1;\n+            }\n+            return 0;\n         }\n-        // TODO pankti - boolean cannot be parsed to int\n-        return Integer.parseInt(logReplicationMetadataManager.getDataConsistentOnStandby());\n+        log.error(\"Received Replication Status Query in Incorrect Role {}.\",\n+            localClusterDescriptor.getRole());\n+        return INVALID_REPLICATION_STATUS;\n     }\n \n     public void shutdown() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTExMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459129112", "bodyText": "this commented code can be removed right? and also please move the comment up to where the runtime is now being created so we keep this reminder around for future references.", "author": "annym", "createdAt": "2020-07-22T22:55:16Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,7 +80,12 @@ public class LogReplicationSourceManager implements DataReceiver {\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n-    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n \n     @VisibleForTesting\n     private int countACKs = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459129629", "bodyText": "can we have the poll interval as a static field? we might want to also move this param to be configurable as we might need to adjust according to UI / SM polling frequency.", "author": "annym", "createdAt": "2020-07-22T22:56:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+\n+        this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n+                dataSender, readProcessor, logReplicationFSMWorkers);\n+\n+        this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller.scheduleWithFixedDelay(new TsPollingTask(), 0, 15, TimeUnit.SECONDS);", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDA0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459130048", "bodyText": "Also, it might be nice to give this thread some name that allows us to easily identify it.", "author": "annym", "createdAt": "2020-07-22T22:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNjkyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459216920", "bodyText": "to make it configurable, will we have to make it a parameter of the serverContext?", "author": "pankti-m", "createdAt": "2020-07-23T05:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MzM3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459853373", "bodyText": "Yes, if its too late to address in this PR you can add it to our issues list.", "author": "annym", "createdAt": "2020-07-24T05:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTYyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,7 +80,12 @@ public class LogReplicationSourceManager implements DataReceiver {\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n-    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n \n     @VisibleForTesting\n     private int countACKs = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDgxNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459130816", "bodyText": "this code seems to be repeated, right? We can call this(params, metadataManager, new DataSender(client)) from the above constructor and remove the repeated code?", "author": "annym", "createdAt": "2020-07-22T23:00:10Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +67,108 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(0);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n+        this.parameters = params;\n \n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n+        this.config = parameters.getReplicationConfig();\n+        if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n+            // Avoid FSM being initialized if there are no streams to replicate\n+            throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n+        }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n+        DataSender dataSender = new CorfuDataSender(client);\n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+\n+        this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n+                dataSender, readProcessor, logReplicationFSMWorkers);\n+\n+        this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller.scheduleWithFixedDelay(new TsPollingTask(), 0, 15, TimeUnit.SECONDS);\n     }\n \n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,7 +80,12 @@ public class LogReplicationSourceManager implements DataReceiver {\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n-    ScheduledExecutorService lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor();\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n \n     @VisibleForTesting\n     private int countACKs = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMjE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459132145", "bodyText": "missing -> how many entries 'remain' to be...", "author": "annym", "createdAt": "2020-07-22T23:04:21Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries to be sent for all replicated streams.", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -261,7 +240,7 @@ public class LogReplicationSourceManager implements DataReceiver {\n      *\n      * @return max tail of all streams to be replicated for the given runtime\n      */\n-    private long queryStreamTail() {\n+    private long getMaxReplicatedStreamsTail() {\n         Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n         long maxTail = Address.NON_ADDRESS;\n         for (String s : config.getStreamsToReplicate()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMjgyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459132828", "bodyText": "probably this is a good use case to have an API to query the tails of a specific set of streams. Not that we have to do this now or on this PR, but we can keep this in mind!", "author": "annym", "createdAt": "2020-07-22T23:06:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -261,7 +240,7 @@ public class LogReplicationSourceManager implements DataReceiver {\n      *\n      * @return max tail of all streams to be replicated for the given runtime\n      */\n-    private long queryStreamTail() {\n+    private long getMaxReplicatedStreamsTail() {\n         Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n         long maxTail = Address.NON_ADDRESS;\n         for (String s : config.getStreamsToReplicate()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDQ5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459134496", "bodyText": "maybe the name of this method could be more suggestive, so when reading the calculateRemainingEntriesToSend it's easier to understand the flow, perhaps queryMaxReplicatedStreamsTail? (or something in that line)", "author": "annym", "createdAt": "2020-07-22T23:11:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMTg3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459221873", "bodyText": "I changed it to getMaxReplicatedStreamsTail.  Let me know if it is clearer.", "author": "pankti-m", "createdAt": "2020-07-23T05:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -261,7 +240,7 @@ public class LogReplicationSourceManager implements DataReceiver {\n      *\n      * @return max tail of all streams to be replicated for the given runtime\n      */\n-    private long queryStreamTail() {\n+    private long getMaxReplicatedStreamsTail() {\n         Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n         long maxTail = Address.NON_ADDRESS;\n         for (String s : config.getStreamsToReplicate()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459135791", "bodyText": "Can we add a comment stating that this way of calculating the remaining entries to send might not be accurate...\nAlso, will we include the other precise option we discussed about?", "author": "annym", "createdAt": "2020-07-22T23:15:55Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +242,58 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long queryStreamTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries to be sent for all replicated streams.\n+     *\n+     * @param\n+     */\n+    private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long timestamp = queryStreamTail();\n+        long remainingEntriesToSend = timestamp - ackedTimestamp;", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzk2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459223965", "bodyText": "yes, I was not sure how to calculate that, but I think it should be in the same way - getAllTails().getStreamTails().filter(.....)", "author": "pankti-m", "createdAt": "2020-07-23T05:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1Mzc3MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459853771", "bodyText": "Instead of the tails we need to query the address maps for each streams to replicate.", "author": "annym", "createdAt": "2020-07-24T05:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNTc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2f16dc66372..dcaf4b348be 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -261,7 +240,7 @@ public class LogReplicationSourceManager implements DataReceiver {\n      *\n      * @return max tail of all streams to be replicated for the given runtime\n      */\n-    private long queryStreamTail() {\n+    private long getMaxReplicatedStreamsTail() {\n         Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n         long maxTail = Address.NON_ADDRESS;\n         for (String s : config.getStreamsToReplicate()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459154680", "bodyText": "I'm curious, if we update the topologyConfigId, do we always need to reset all other values? Let's say a new standby is added.. is this still needed?", "author": "annym", "createdAt": "2020-07-23T00:21:37Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -91,61 +91,64 @@ public long query(CorfuStoreMetadata.Timestamp timestamp, LogReplicationMetadata\n     }\n \n     public long getTopologyConfigId() {\n-        return query(null, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        return query(null, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n     }\n \n-    public String getVersion() { return queryString(null, LogReplicationMetadataType.VERSION); }\n+    public String getVersion() { return queryString(null, LogReplicationMetadataKey.KeyType.VERSION); }\n \n     public long getLastSnapStartTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n     }\n \n \n     public long getLastSnapTransferDoneTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n     }\n \n     public long getLastSrcBaseSnapshotTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n     }\n \n     public long getLastSnapSeqNum() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_SEQ_NUM);\n     }\n \n     public long getLastProcessedLogTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_LOG_PROCESSED);\n+        return query(null, LogReplicationMetadataKey.KeyType.LAST_LOG_ENTRY_PROCESSED);\n     }\n \n-    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, long val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType type, long val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(Long.toString(val)).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n-    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, String val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType key, String val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(val).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n     public void setupTopologyConfigId(long topologyConfigId) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n-        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n             log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n-            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(namespace);\n \n-        for (LogReplicationMetadataType key : LogReplicationMetadataType.values()) {\n+        // TODO pankti: Change to set the topology config id and not other fields.  This cannot be changed now as it\n+        // fails later if anything is found not set.\n+        for (LogReplicationMetadataKey.KeyType type : LogReplicationMetadataKey.KeyType.values()) {\n             long val = Address.NON_ADDRESS;\n-            if (key == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n+            if (type == LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID) {\n                 val = topologyConfigId;\n             }\n-            appendUpdate(txBuilder, key, val);\n+            if (type != LogReplicationMetadataKey.KeyType.UNRECOGNIZED) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNTI3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459225277", "bodyText": "good question.  No we should not set everything, but that was being done when I made the change.  I removed it to only set topologyConfigId but later somewhere(I think negotiation response) we have a validation for version field not being empty, where it failed.  We should clean this up and fix it.\nI am thinking version is a valid thing to set in metadata so I can expose it in LogReplicationConfig alongwith streamsToReplicate.  But yes, here we should only set topologyConfigId.\nAlso, afaik topologyConfigId does not change when a standby is added.", "author": "pankti-m", "createdAt": "2020-07-23T05:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE5NDAzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461194038", "bodyText": "I think we should not update other values in this function, because it causes more TX conflicts, and discovery service will shutdown. If the version filed is empty, we should initialize version somewhere...", "author": "zhangn49", "createdAt": "2020-07-27T21:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI5NzI5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461297298", "bodyText": "If the active cluster doesn't change, the source of data doesn't change, we don't need to reset the log replication metadata. So, we should have two API s:\n\njust  updateTopologyConfigId, if the active cluster doesn't change.\nupdate Topology Id and reset logReplicationMetadata if the active cluster change, as the source of data change.", "author": "xiaoqin2012", "createdAt": "2020-07-28T03:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "addc71bef331cfbb64a0be476e681efccc5ab88c", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex 0772bdaee21..17dad6f7461 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -100,12 +104,11 @@ public class LogReplicationMetadataManager {\n         return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n     }\n \n-\n     public long getLastSnapTransferDoneTimestamp() {\n         return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n     }\n \n-    public long getLastSrcBaseSnapshotTimestamp() {\n+    public long getLastAppliedBaseSnapshotTimestamp() {\n         return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NzYyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459157622", "bodyText": "We can remove this commented code.", "author": "annym", "createdAt": "2020-07-23T00:33:01Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java", "diffHunk": "@@ -161,6 +161,10 @@ public LogReplicationEntry processMsgAndBuffer(LogReplicationEntry dataMessage)\n         return null;\n     }\n \n+    /*private int calculateRemainingEntriesToReplicate() {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java\nindex d9d75bd1cb2..5881d35a6db 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/SinkBufferManager.java\n\n@@ -161,10 +161,6 @@ public abstract class SinkBufferManager {\n         return null;\n     }\n \n-    /*private int calculateRemainingEntriesToReplicate() {\n-        if (LogReplicationSinkManager.RxState.)\n-    }*/\n-\n     /**\n      * Get the previous inorder message's sequence.\n      * @param entry\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODc3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459158775", "bodyText": "Do we need an executor service for the standby? Cause it would only be updated to true (or 100) once the snapshot is applied, right? so we can just do it directly, instead of having a thread for this every 15 seconds... anyways its not changing.", "author": "annym", "createdAt": "2020-07-23T00:37:28Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -79,6 +84,13 @@\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n+    /*\n+     * Periodic Thread which reads the sequence number of entries processed\n+     */\n+    private ScheduledExecutorService lastReplicatedEntryPoller = Executors.newSingleThreadScheduledExecutor();", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNzE3NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459227175", "bodyText": "good idea.", "author": "pankti-m", "createdAt": "2020-07-23T05:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex 214815d5a05..51bad2ae394 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -84,11 +80,6 @@ public class LogReplicationSinkManager implements DataReceiver {\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n-    /*\n-     * Periodic Thread which reads the sequence number of entries processed\n-     */\n-    private ScheduledExecutorService lastReplicatedEntryPoller = Executors.newSingleThreadScheduledExecutor();\n-\n     private AtomicBoolean dataConsistent = new AtomicBoolean(true);\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MDE0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459160145", "bodyText": "rxState needs to be thread safe right?\nAlso, do we really need this distinction? anyways if it is in LOG_ENTRY_SYNC , data_consistent was set to true (maybe we need to confirm that it is set to true even if on re-instantiation it enters directly in log entry sync)", "author": "annym", "createdAt": "2020-07-23T00:43:05Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -386,4 +402,24 @@ public void shutdown() {\n         SNAPSHOT_SYNC,\n         LOG_ENTRY_SYNC\n     }\n+\n+    /**\n+     * In Snapshot Sync, if the StreamsSnapshotWriter is in the apply phase, the data is not yet\n+     * consistent and cannot be read by applications.  Data is always consistent during Log Entry Sync,\n+     * so always return true in that case.\n+     * @return boolean\n+     */\n+    private boolean isDataConsistent() {\n+        if (RxState.LOG_ENTRY_SYNC == rxState) {", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex 214815d5a05..51bad2ae394 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -402,24 +389,4 @@ public class LogReplicationSinkManager implements DataReceiver {\n         SNAPSHOT_SYNC,\n         LOG_ENTRY_SYNC\n     }\n-\n-    /**\n-     * In Snapshot Sync, if the StreamsSnapshotWriter is in the apply phase, the data is not yet\n-     * consistent and cannot be read by applications.  Data is always consistent during Log Entry Sync,\n-     * so always return true in that case.\n-     * @return boolean\n-     */\n-    private boolean isDataConsistent() {\n-        if (RxState.LOG_ENTRY_SYNC == rxState) {\n-            return true;\n-        }\n-        return dataConsistent.get();\n-    }\n-\n-    private class ReplicatedEntryPollingTask implements Runnable {\n-        public void run() {\n-            logReplicationMetadataManager.setDataConsistentOnStandby(\n-                String.valueOf(isDataConsistent()));\n-        }\n-    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MTExMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459161111", "bodyText": "Pankti, do we have any test?", "author": "annym", "createdAt": "2020-07-23T00:46:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +647,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());", "originalCommit": "885eb3bff6b5f8440469a6e1f95049d1d48017f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwMjA5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459202098", "bodyText": "no.. I did not add any tests for this change", "author": "pankti-m", "createdAt": "2020-07-23T03:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE2MTExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex c013fa31f90..5fa00174635 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -664,9 +665,17 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n     public int queryReplicationStatus() {\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n             return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n+        } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n+            // TODO pankti - boolean cannot be parsed to int\n+            String dataConsistentOnStandby = logReplicationMetadataManager.getDataConsistentOnStandby();\n+            if (Objects.equals(dataConsistentOnStandby, \"true\")) {\n+                return 1;\n+            }\n+            return 0;\n         }\n-        // TODO pankti - boolean cannot be parsed to int\n-        return Integer.parseInt(logReplicationMetadataManager.getDataConsistentOnStandby());\n+        log.error(\"Received Replication Status Query in Incorrect Role {}.\",\n+            localClusterDescriptor.getRole());\n+        return INVALID_REPLICATION_STATUS;\n     }\n \n     public void shutdown() {\n"}}, {"oid": "e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "url": "https://github.com/CorfuDB/CorfuDB/commit/e6927f85dd00e76a1cf2bd8e1a49a3bb2e185851", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T06:15:43Z", "type": "forcePushed"}, {"oid": "86a7762a977595715cf79214e59c879f74a7a8bf", "url": "https://github.com/CorfuDB/CorfuDB/commit/86a7762a977595715cf79214e59c879f74a7a8bf", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T17:04:02Z", "type": "forcePushed"}, {"oid": "6a7f5abb89e68b88cd5edab548637f916f62a511", "url": "https://github.com/CorfuDB/CorfuDB/commit/6a7f5abb89e68b88cd5edab548637f916f62a511", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T18:41:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459652267", "bodyText": "Do we still need this function?", "author": "zhangn49", "createdAt": "2020-07-23T18:39:42Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -648,46 +648,29 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  Writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n-    public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n-        } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-        }\n-    }\n+    public void prepareToBecomeStandby() { }", "originalCommit": "86a7762a977595715cf79214e59c879f74a7a8bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjcyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459666720", "bodyText": "We do not do anything here, but the SiteManager has a workflow for prepareToBecomeStandby().  So the SM adapter calls this function.  We can change the adapter to not invoke and remove this function, but I thought it is better to keep it in case something needs to be added here in future.", "author": "pankti-m", "createdAt": "2020-07-23T19:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1NTU4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r460255583", "bodyText": "Pankti I was thinking given this, it might be safe to have a logging? .. not that we would do anything, but at least if they claim to have started the workflow we can confirm.", "author": "annym", "createdAt": "2020-07-24T19:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MjI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6a7f5abb89e68b88cd5edab548637f916f62a511", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex 5e7930ab551..dc5173cb446 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -664,7 +662,7 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n     @Override\n     public int queryReplicationStatus() {\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n-            return Integer.parseInt(logReplicationMetadataManager.getReplicationStatus());\n+            return Integer.parseInt(logReplicationMetadataManager.getReplicationRemainingPercent());\n         } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n             return Integer.parseInt(logReplicationMetadataManager.getDataConsistentOnStandby());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459657297", "bodyText": "Looks like remainingEntriesToSend is not used?", "author": "zhangn49", "createdAt": "2020-07-23T18:48:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,16 +221,61 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp\n+     * Note: This method of calculating the remaining entries to send is inaccurate because we consider the tail\n+     * of all streams(replicated and otherwise) in Corfu and compare it with the current entry sent.  It is possible\n+     * that the tail is far ahead but replicated streams have few entries to send.\n+     */\n+    private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long timestamp = getMaxReplicatedStreamsTail();\n+        long remainingEntriesToSend = timestamp - ackedTimestamp;\n+        int percentDone = (int) (ackedTimestamp/timestamp * 100);", "originalCommit": "6a7f5abb89e68b88cd5edab548637f916f62a511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODA4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459668086", "bodyText": "right.  I intended to use it somehow to calculate the remaining entries in a more accurate way, but it is not needed now.  Will remove.", "author": "pankti-m", "createdAt": "2020-07-23T19:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NzI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 5ea422ffe12..b901eb8504d 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -263,7 +263,6 @@ public class LogReplicationSourceManager implements DataReceiver {\n      */\n     private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n         long timestamp = getMaxReplicatedStreamsTail();\n-        long remainingEntriesToSend = timestamp - ackedTimestamp;\n         int percentDone = (int) (ackedTimestamp/timestamp * 100);\n         return percentDone;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1OTQ4NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459659484", "bodyText": "Can we have a short comment on this dataConsistent?", "author": "zhangn49", "createdAt": "2020-07-23T18:52:31Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -79,6 +81,8 @@\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n+    private AtomicInteger dataConsistent = new AtomicInteger(1);", "originalCommit": "6a7f5abb89e68b88cd5edab548637f916f62a511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODY2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459668667", "bodyText": "I have it in initCommonParams() where it first gets initialized but can move it here.", "author": "pankti-m", "createdAt": "2020-07-23T19:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1OTQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex 50fb5abba7c..64a125221af 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -81,6 +81,9 @@ public class LogReplicationSinkManager implements DataReceiver {\n     @Getter\n     private ObservableValue rxMessageCount = new ObservableValue(rxMessageCounter);\n \n+    // 1 indicates data is consistent on the local(standby) cluster, 0 indicates it is not.\n+    // In Snapshot Sync, if the StreamsSnapshotWriter is in the apply phase, the data is not yet\n+    // consistent and cannot be read by applications.  Data is always consistent during Log Entry Sync\n     private AtomicInteger dataConsistent = new AtomicInteger(1);\n \n     /**\n"}}, {"oid": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "url": "https://github.com/CorfuDB/CorfuDB/commit/4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-23T19:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NjMwMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459786301", "bodyText": "I am a little confused about why the dataConsistent is initialized as 1.\nIf a SNAPSHOT_MESSAGE comes, dataConsistent is still 1. Is it correct?", "author": "zhangn49", "createdAt": "2020-07-23T23:40:49Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -311,14 +313,17 @@ private void applySnapshotSync(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(0);\n+                logReplicationMetadataManager.setDataConsistentOnStandby(String.valueOf(dataConsistent));", "originalCommit": "4ff6b7041f13a0f5ca789ba2f351f3f79153d5f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMzYyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r459813620", "bodyText": "Yes, dataConsistent is 1 in any phase other than apply phase of the snapshot sync.  This is because only during apply phase we have an intermediate state where replicated data is being applied and applications can read inconsistent data.", "author": "pankti-m", "createdAt": "2020-07-24T01:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4NjMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "addc71bef331cfbb64a0be476e681efccc5ab88c", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex 64a125221af..6dbbcf93ef7 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -306,10 +384,11 @@ public class LogReplicationSinkManager implements DataReceiver {\n     }\n \n     /**\n-     * Process SNAPSHOT transfer messages\n-     * @param message\n+     * Process transferred SNAPSHOT messages\n+     *\n+     * @param message received entry message\n      */\n-    private void applySnapshotSync(LogReplicationEntry message) {\n+    private void processSnapshotMessage(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n"}}, {"oid": "addc71bef331cfbb64a0be476e681efccc5ab88c", "url": "https://github.com/CorfuDB/CorfuDB/commit/addc71bef331cfbb64a0be476e681efccc5ab88c", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-25T22:23:17Z", "type": "forcePushed"}, {"oid": "e0b70b2971593b447f9c933c83f0af84a4b56bb2", "url": "https://github.com/CorfuDB/CorfuDB/commit/e0b70b2971593b447f9c933c83f0af84a4b56bb2", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-25T23:41:40Z", "type": "forcePushed"}, {"oid": "683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "url": "https://github.com/CorfuDB/CorfuDB/commit/683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-26T01:29:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNzQxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461117411", "bodyText": "Why don't we return here?", "author": "zhangn49", "createdAt": "2020-07-27T19:26:30Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -95,60 +95,63 @@ public long query(CorfuStoreMetadata.Timestamp timestamp, LogReplicationMetadata\n     }\n \n     public long getTopologyConfigId() {\n-        return query(null, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        return query(null, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n     }\n \n-    public String getVersion() { return queryString(null, LogReplicationMetadataType.VERSION); }\n+    public String getVersion() { return queryString(null, LogReplicationMetadataKey.KeyType.VERSION); }\n \n     public long getLastSnapStartTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n     }\n \n     public long getLastSnapTransferDoneTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n     }\n \n     public long getLastAppliedBaseSnapshotTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n     }\n \n     public long getLastSnapSeqNum() {\n-        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM);\n+        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_SEQ_NUM);\n     }\n \n     public long getLastProcessedLogTimestamp() {\n-        return query(null, LogReplicationMetadataType.LAST_LOG_PROCESSED);\n+        return query(null, LogReplicationMetadataKey.KeyType.LAST_LOG_ENTRY_PROCESSED);\n     }\n \n-    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, long val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType type, long val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(Long.toString(val)).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n-    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, String val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n+    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType key, String val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(val).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n     public void setupTopologyConfigId(long topologyConfigId) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n-        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n+        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n             log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n-            return;", "originalCommit": "683566e7eb4d4b694027262a9c7e09c2ab50bbc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE5NDc3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461194773", "bodyText": "I think it will bring some concurrent updates to some extent.", "author": "zhangn49", "createdAt": "2020-07-27T21:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExNzQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "31dc845d397c2c677b1720574629f03c01bc9393", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex 17dad6f7461..bd10624333b 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -95,63 +95,63 @@ public class LogReplicationMetadataManager {\n     }\n \n     public long getTopologyConfigId() {\n-        return query(null, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n+        return query(null, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n     }\n \n-    public String getVersion() { return queryString(null, LogReplicationMetadataKey.KeyType.VERSION); }\n+    public String getVersion() { return queryString(null, LogReplicationMetadataType.VERSION); }\n \n     public long getLastSnapStartTimestamp() {\n-        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_START);\n+        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED);\n     }\n \n     public long getLastSnapTransferDoneTimestamp() {\n-        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_TRANSFERRED);\n+        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED);\n     }\n \n     public long getLastAppliedBaseSnapshotTimestamp() {\n-        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_APPLIED);\n+        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED);\n     }\n \n     public long getLastSnapSeqNum() {\n-        return query(null, LogReplicationMetadataKey.KeyType.SNAPSHOT_SEQ_NUM);\n+        return query(null, LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM);\n     }\n \n     public long getLastProcessedLogTimestamp() {\n-        return query(null, LogReplicationMetadataKey.KeyType.LAST_LOG_ENTRY_PROCESSED);\n+        return query(null, LogReplicationMetadataType.LAST_LOG_ENTRY_PROCESSED);\n     }\n \n-    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType type, long val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type).build();\n+    public void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType type, long val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(type.getVal()).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(Long.toString(val)).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n-    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataKey.KeyType key, String val) {\n-        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key).build();\n+    private void appendUpdate(TxBuilder txBuilder, LogReplicationMetadataType key, String val) {\n+        LogReplicationMetadataKey txKey = LogReplicationMetadataKey.newBuilder().setKey(key.getVal()).build();\n         LogReplicationMetadataVal txVal = LogReplicationMetadataVal.newBuilder().setVal(val).build();\n         txBuilder.update(metadataTableName, txKey, txVal, null);\n     }\n \n     public void setupTopologyConfigId(long topologyConfigId) {\n         CorfuStoreMetadata.Timestamp timestamp = corfuStore.getTimestamp();\n-        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID);\n+        long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n-            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n+            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId {} is not larger than the persistedTopologyConfigID {}\",\n+                topologyConfigId, persistedTopologyConfigId);\n+            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n         // TODO pankti: Change to set the topology config id and not other fields.  This cannot be changed now as it\n         // fails later if anything is found not set.\n-        for (LogReplicationMetadataKey.KeyType type : LogReplicationMetadataKey.KeyType.values()) {\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n             long val = Address.NON_ADDRESS;\n-            if (type == LogReplicationMetadataKey.KeyType.TOPOLOGY_CONFIG_ID) {\n+            if (type == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n                 val = topologyConfigId;\n             }\n-            if (type != LogReplicationMetadataKey.KeyType.UNRECOGNIZED) {\n-                appendUpdate(txBuilder, type, val);\n-            }\n+            appendUpdate(txBuilder, type, val);\n          }\n \n         txBuilder.commit(timestamp);\n"}}, {"oid": "31dc845d397c2c677b1720574629f03c01bc9393", "url": "https://github.com/CorfuDB/CorfuDB/commit/31dc845d397c2c677b1720574629f03c01bc9393", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T01:41:20Z", "type": "forcePushed"}, {"oid": "d7e300c9a33a8fa79f4ad19fb290139d1ce8c578", "url": "https://github.com/CorfuDB/CorfuDB/commit/d7e300c9a33a8fa79f4ad19fb290139d1ce8c578", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T21:49:01Z", "type": "forcePushed"}, {"oid": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "url": "https://github.com/CorfuDB/CorfuDB/commit/70a6226e297abbadcc0a92c03d35d15de8b2f86f", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-28T23:28:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954102", "bodyText": "Remove not used code.", "author": "xiaoqin2012", "createdAt": "2020-07-28T23:39:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjI0MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582241", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDEwMg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 4e0104b0ca7..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,6 +83,13 @@ public class LogReplicationSourceManager implements DataReceiver {\n      */\n     private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n \n+    /*\n+     * Sync Type for which last Ack was Received.  Set to Log Entry Type as the initial FSM state is\n+     * Log Entry Sync\n+     */\n+    private LogReplicationMetadata.ReplicationStatusVal.SyncType lastSyncType =\n+            LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY;\n+\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDk4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954987", "bodyText": "For snapshot messages, should it be msgSeqNum? All snapshot messages have the same timestamp.", "author": "xiaoqin2012", "createdAt": "2020-07-28T23:41:56Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDU0OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462584548", "bodyText": "we are going to change this implementation before merging the PR", "author": "pankti-m", "createdAt": "2020-07-29T20:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDk4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e96a7df7b17765518a44909363ab3b7260064e7b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 4e0104b0ca7..2eb917ec62a 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -270,13 +270,13 @@ public class LogReplicationSourceManager implements DataReceiver {\n      * remaining to be sent.\n      * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n      */\n-    private int calculateRemainingEntriesToSend(long ackedTimestamp) {\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n         long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n \n         if (ackedTimestamp == Address.NON_ADDRESS) {\n             return FULL_REPLICATION_REMAINING_PERCENT;\n         }\n-        int remainingEntriesToSend = 0;\n+        long remainingEntriesToSend = 0;\n         for (String stream : config.getStreamsToReplicate()) {\n             UUID streamId = CorfuRuntime.getStreamID(stream);\n             StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461953502", "bodyText": "Can we use thread name : last-ackd-ts-reader?", "author": "zhangn49", "createdAt": "2020-07-28T23:37:08Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n \n         this.logReplicationFSM = new LogReplicationFSM(this.runtime, config, params.getRemoteClusterDescriptor(),\n                 dataSender, readProcessor, logReplicationFSMWorkers);\n+\n         this.logReplicationFSM.setTopologyConfigId(params.getTopologyConfigId());\n+\n+        this.metadataManager = metadataManager;\n+        lastAckedTsPoller = Executors.newSingleThreadScheduledExecutor(\n+            new ThreadFactoryBuilder().setNameFormat(\"Last Ackd Ts Reader\").build());", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462009321", "bodyText": "+1 maybe ack-timestamp-poller or ack-timestamp-reader", "author": "annym", "createdAt": "2020-07-29T03:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4Mjk5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582994", "bodyText": "done.  changed to ack-timestamp-reader", "author": "pankti-m", "createdAt": "2020-07-29T20:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MzUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 4e0104b0ca7..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,6 +83,13 @@ public class LogReplicationSourceManager implements DataReceiver {\n      */\n     private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n \n+    /*\n+     * Sync Type for which last Ack was Received.  Set to Log Entry Type as the initial FSM state is\n+     * Log Entry Sync\n+     */\n+    private LogReplicationMetadata.ReplicationStatusVal.SyncType lastSyncType =\n+            LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY;\n+\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461953966", "bodyText": "Should we remove these lines? as well as the above comments?", "author": "zhangn49", "createdAt": "2020-07-28T23:38:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;\n+\n+    private static int FULL_REPLICATION_REMAINING_PERCENT = 100;\n+\n     @VisibleForTesting\n     private int countACKs = 0;\n \n     @VisibleForTesting\n     private ObservableAckMsg ackMessages = new ObservableAckMsg();\n \n     /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n+     * @param params Log Replication parameters\n+     * @param client LogReplication client, which is a data sender, both snapshot and log entry, this represents\n+     *              the application callback for data transmission\n+     * @param metadataManager Replication Metadata Manager\n      */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params) {\n-\n-        this(runtime, dataSender, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client,\n+                                       LogReplicationMetadataManager metadataManager) {\n+        this(params, metadataManager, new CorfuDataSender(client));\n     }\n \n-    public LogReplicationSourceManager(LogReplicationRuntimeParameters params, LogReplicationClient client) {\n-        this(CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n+    @VisibleForTesting\n+    public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n+                                       LogReplicationMetadataManager metadataManager,\n+                                       DataSender dataSender) {\n+\n+        // If this runtime has opened other streams, it appends non opaque entries and because\n+        // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n+        // for log replication exclusively.\n+        this.runtime = CorfuRuntime.fromParameters(CorfuRuntimeParameters.builder()\n                 .trustStore(params.getTrustStore())\n                 .tsPasswordFile(params.getTsPasswordFile())\n                 .keyStore(params.getKeyStore())\n                 .ksPasswordFile(params.getKsPasswordFile())\n-                .tlsEnabled(params.isTlsEnabled()).build())\n-        .parseConfigurationString(params.getLocalCorfuEndpoint()).connect(), client, params);\n-    }\n-\n-    /**\n-     * Constructor LogReplicationSourceManager\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param client Log replication client\n-     * @param params Log Replication parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime, LogReplicationClient client, LogReplicationRuntimeParameters params) {\n-        this(runtime, new CorfuDataSender(client), params);\n-    }\n-\n-    /**\n-     * Constructor Source (default)\n-     *\n-     * @param runtime Corfu Runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (data transformation)\n-     * @param params Log Replication Parameters\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params) {\n-        // Default to single dedicated thread for state machine workers (perform state tasks)\n-        this(runtime, dataSender, readProcessor, params, Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n-                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build()));\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n-        this(runtime, dataSender, new DefaultReadProcessor(runtime), params, logReplicationFSMWorkers);\n-    }\n-\n-    /**\n-     * Constructor Source to provide ExecutorServices for FSM\n-     *\n-     * For multi-cluster log replication multiple managers can share a common thread pool.\n-     *\n-     * @param runtime corfu runtime\n-     * @param dataSender implementation of a data sender, both snapshot and log entry, this represents\n-     *                   the application callback for data transmission\n-     * @param readProcessor implementation for reads processor (transformation)\n-     * @param params Log Replication Parameters\n-     * @param logReplicationFSMWorkers worker thread pool (state tasks)\n-     */\n-    public LogReplicationSourceManager(CorfuRuntime runtime,\n-                                       DataSender dataSender,\n-                                       ReadProcessor readProcessor,\n-                                       LogReplicationRuntimeParameters params,\n-                                       ExecutorService logReplicationFSMWorkers) {\n+                .tlsEnabled(params.isTlsEnabled()).build());\n+        runtime.parseConfigurationString(params.getLocalCorfuEndpoint()).connect();\n \n         this.parameters = params;\n+\n         this.config = parameters.getReplicationConfig();\n         if (config.getStreamsToReplicate() == null || config.getStreamsToReplicate().isEmpty()) {\n             // Avoid FSM being initialized if there are no streams to replicate\n             throw new IllegalArgumentException(\"Invalid Log Replication: Streams to replicate is EMPTY\");\n         }\n \n+        ExecutorService logReplicationFSMWorkers = Executors.newFixedThreadPool(DEFAULT_FSM_WORKER_THREADS, new\n+                ThreadFactoryBuilder().setNameFormat(\"state-machine-worker\").build());\n+        ReadProcessor readProcessor = new DefaultReadProcessor(runtime);\n+\n         // If this runtime has opened other streams, it appends non opaque entries and because\n         // the cache is shared we end up doing deserialization. We need guarantees that this runtime is dedicated\n         // for log replication exclusively.\n-        this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n-        this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();\n+        //this.runtime = CorfuRuntime.fromParameters(runtime.getParameters());\n+        //this.runtime.parseConfigurationString(runtime.getLayoutServers().get(0)).connect();", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODM2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462008364", "bodyText": "+1", "author": "annym", "createdAt": "2020-07-29T02:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjAxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462582011", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 4e0104b0ca7..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,6 +83,13 @@ public class LogReplicationSourceManager implements DataReceiver {\n      */\n     private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n \n+    /*\n+     * Sync Type for which last Ack was Received.  Set to Log Entry Type as the initial FSM state is\n+     * Log Entry Sync\n+     */\n+    private LogReplicationMetadata.ReplicationStatusVal.SyncType lastSyncType =\n+            LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY;\n+\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDUwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954504", "bodyText": "Will we add retry to each tx commit in metadata manager? I think we should have a max retry limit here.", "author": "zhangn49", "createdAt": "2020-07-28T23:40:22Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -137,21 +145,36 @@ public void setupTopologyConfigId(long topologyConfigId) {\n         long persistedTopologyConfigId = query(timestamp, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID);\n \n         if (topologyConfigId <= persistedTopologyConfigId) {\n-            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId \" + topologyConfigId + \" is not larger than the persistedTopologyConfigID \" + persistedTopologyConfigId);\n+            log.warn(\"Skip setupTopologyConfigId. the current topologyConfigId {} is not larger than the persistedTopologyConfigID {}\",\n+                topologyConfigId, persistedTopologyConfigId);\n             return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n-        for (LogReplicationMetadataType key : LogReplicationMetadataType.values()) {\n-            long val = Address.NON_ADDRESS;\n-            if (key == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n-                val = topologyConfigId;\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            if (type == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n+                appendUpdate(txBuilder, type, topologyConfigId);\n+                try {\n+                    IRetry.build(IntervalRetry.class, () -> {", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e96a7df7b17765518a44909363ab3b7260064e7b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex 86c58fecfe2..d49c3402e1b 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -153,28 +158,13 @@ public class LogReplicationMetadataManager {\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n         for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            long val = Address.NON_ADDRESS;\n             if (type == LogReplicationMetadataType.TOPOLOGY_CONFIG_ID) {\n-                appendUpdate(txBuilder, type, topologyConfigId);\n-                try {\n-                    IRetry.build(IntervalRetry.class, () -> {\n-                        try {\n-                            log.info(\"Committing Topology Update\");\n-                            txBuilder.commit(timestamp);\n-                        } catch (Exception e) {\n-                            log.error(\"Error while updating topology {}\", e);\n-                            if (e instanceof TransactionAbortedException) {\n-                                log.error(\"Transaction Aborted {}\", e);\n-                                throw new RetryNeededException();\n-                            }\n-                        }\n-                        return null;\n-                    }).run();\n-                } catch(InterruptedException e) {\n-                    log.error(\"Unrecoverable exception when updating topology Config. {}\", e);\n-                    throw new UnrecoverableCorfuInterruptedError(e);\n-                }\n+                val = topologyConfigId;\n             }\n+            appendUpdate(txBuilder, type, val);\n          }\n+        txBuilder.commit(timestamp);\n         log.info(\"Update topologyConfigId, new metadata {}\", this);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDc4Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461954782", "bodyText": "Is this correct to remove?", "author": "zhangn49", "createdAt": "2020-07-28T23:41:20Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -281,7 +304,6 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n         if (siteConfigID != persistSiteConfigID || ts != persistSnapStart || ts != persistSnapTranferDone) {\n             log.warn(\"topologyConfigId \" + siteConfigID + \" != \" + \" persist \" + persistSiteConfigID +  \" ts \" + ts +\n                     \" != \" + \"persistSnapTransferDone \" + persistSnapTranferDone);\n-            return;", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzAyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462597028", "bodyText": "no.. dont know how it got removed..", "author": "pankti-m", "createdAt": "2020-07-29T21:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex 86c58fecfe2..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -304,6 +294,7 @@ public class LogReplicationMetadataManager {\n         if (siteConfigID != persistSiteConfigID || ts != persistSnapStart || ts != persistSnapTranferDone) {\n             log.warn(\"topologyConfigId \" + siteConfigID + \" != \" + \" persist \" + persistSiteConfigID +  \" ts \" + ts +\n                     \" != \" + \"persistSnapTransferDone \" + persistSnapTranferDone);\n+            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTA2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461955064", "bodyText": "Is this correct to remove?", "author": "zhangn49", "createdAt": "2020-07-28T23:42:11Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -253,15 +277,14 @@ public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n-            return;", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTk3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462595977", "bodyText": "good catch.", "author": "pankti-m", "createdAt": "2020-07-29T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex 86c58fecfe2..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -277,6 +266,7 @@ public class LogReplicationMetadataManager {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n+            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTkxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461955918", "bodyText": "Should we init topologyConfigId in this function?", "author": "zhangn49", "createdAt": "2020-07-28T23:44:52Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -130,31 +128,37 @@ public LogReplicationSinkManager(String localCorfuEndpoint, LogReplicationConfig\n     @VisibleForTesting\n     public LogReplicationSinkManager(String localCorfuEndpoint, LogReplicationConfig config,\n                                      LogReplicationMetadataManager metadataManager, String pluginConfigFilePath) {\n-        this.logReplicationMetadataManager = metadataManager;\n         this.runtime =  CorfuRuntime.fromParameters(CorfuRuntime.CorfuRuntimeParameters.builder().build())\n                 .parseConfigurationString(localCorfuEndpoint).connect();\n         this.pluginConfigFilePath = pluginConfigFilePath;\n+        initCommonParams(metadataManager, config);\n+    }\n \n-        /*\n-         * When the server is up, it will be at LOG_ENTRY_SYNC state by default.\n-         * The sender will query receiver's status and decide what type of replication to start with.\n-         * It will transit to SNAPSHOT_SYNC state if it received a SNAPSHOT_START message from the sender.\n-         */\n-        this.rxState = RxState.LOG_ENTRY_SYNC;\n+    private void initCommonParams(LogReplicationMetadataManager metadataManager, LogReplicationConfig config) {", "originalCommit": "70a6226e297abbadcc0a92c03d35d15de8b2f86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNzM5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462607396", "bodyText": "topologyConfigId is not set for the test constructor.  But good catch, it is now not getting set in the first constructor also.  Adding it back.", "author": "pankti-m", "createdAt": "2020-07-29T21:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NTkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "e96a7df7b17765518a44909363ab3b7260064e7b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex 6dbbcf93ef7..2ab2efd9277 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -144,7 +144,7 @@ public class LogReplicationSinkManager implements DataReceiver {\n         this.rxState = RxState.LOG_ENTRY_SYNC;\n \n         // Set the data consistent status.\n-        logReplicationMetadataManager.setDataConsistentOnStandby(String.valueOf(dataConsistent.get()));\n+        logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n         initWriterAndBufferMgr();\n     }\n \n"}}, {"oid": "e96a7df7b17765518a44909363ab3b7260064e7b", "url": "https://github.com/CorfuDB/CorfuDB/commit/e96a7df7b17765518a44909363ab3b7260064e7b", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-29T01:46:58Z", "type": "forcePushed"}, {"oid": "3b5a84dac4f787ac072b979e2843c94450b85682", "url": "https://github.com/CorfuDB/CorfuDB/commit/3b5a84dac4f787ac072b979e2843c94450b85682", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-29T02:08:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTEwNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461999107", "bodyText": "We can leave this for later, but we might need to change this API a bit, because in line with my previous comment, there can be multiple standby's, so we might want to return a map if no cluster Id is specified (so we return the status for all standby's), and accept the cluster Id as argument for another API.", "author": "annym", "createdAt": "2020-07-29T02:21:44Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +659,38 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODAwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462518002", "bodyText": "we will have to do it now if we change the key in the replication status metadata protobuf", "author": "pankti-m", "createdAt": "2020-07-29T18:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex 35560aa6953..6ba5fcdb93c 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -679,18 +680,16 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n      * snapshot sync is in the apply phase)\n      */\n     @Override\n-    public int queryReplicationStatus() {\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus(String clusterId) {\n+        LogReplicationMetadata.ReplicationStatusVal status;\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n-            return (int)logReplicationMetadataManager.getReplicationRemainingPercent();\n+            return logReplicationMetadataManager.getReplicationRemainingPercent(clusterId);\n         } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n-            if (logReplicationMetadataManager.getDataConsistentOnStandby()) {\n-                return 1;\n-            }\n-            return 0;\n+            return logReplicationMetadataManager.getDataConsistentOnStandby();\n         }\n-        log.error(\"Received Replication Status Query in Incorrect Role {}.\",\n-            localClusterDescriptor.getRole());\n-        return INVALID_REPLICATION_STATUS;\n+        log.error(\"Received Replication Status Query for Cluster id {} in Incorrect Role {}.\",\n+            clusterId, localClusterDescriptor.getRole());\n+        return null;\n     }\n \n     public void shutdown() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTI5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r461999298", "bodyText": "Should this be returning our proto ReplicationStatusVal?", "author": "annym", "createdAt": "2020-07-29T02:22:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +659,38 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n     public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMzkwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462523906", "bodyText": "ultimately yes.  But we will have to change the Cluster Manager adapter interfaces for that..", "author": "pankti-m", "createdAt": "2020-07-29T19:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex 35560aa6953..6ba5fcdb93c 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -679,18 +680,16 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n      * snapshot sync is in the apply phase)\n      */\n     @Override\n-    public int queryReplicationStatus() {\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus(String clusterId) {\n+        LogReplicationMetadata.ReplicationStatusVal status;\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n-            return (int)logReplicationMetadataManager.getReplicationRemainingPercent();\n+            return logReplicationMetadataManager.getReplicationRemainingPercent(clusterId);\n         } else if (ClusterRole.STANDBY == localClusterDescriptor.getRole()) {\n-            if (logReplicationMetadataManager.getDataConsistentOnStandby()) {\n-                return 1;\n-            }\n-            return 0;\n+            return logReplicationMetadataManager.getDataConsistentOnStandby();\n         }\n-        log.error(\"Received Replication Status Query in Incorrect Role {}.\",\n-            localClusterDescriptor.getRole());\n-        return INVALID_REPLICATION_STATUS;\n+        log.error(\"Received Replication Status Query for Cluster id {} in Incorrect Role {}.\",\n+            clusterId, localClusterDescriptor.getRole());\n+        return null;\n     }\n \n     public void shutdown() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDc5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462000794", "bodyText": "nit -> Skip update of current version {} to {}, as they are the same.", "author": "annym", "createdAt": "2020-07-29T02:28:38Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -160,7 +173,8 @@ public void updateVersion(String version) {\n         String  persistedVersion = queryString(timestamp, LogReplicationMetadataType.VERSION);\n \n         if (persistedVersion.equals(version)) {\n-            log.warn(\"Skip update the current version {} with new version {} as they are the same\", persistedVersion, version);\n+            log.warn(\"Skip update the current version {} with new version {} as they are the same\",", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NDg0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462594842", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -173,7 +172,7 @@ public class LogReplicationMetadataManager {\n         String  persistedVersion = queryString(timestamp, LogReplicationMetadataType.VERSION);\n \n         if (persistedVersion.equals(version)) {\n-            log.warn(\"Skip update the current version {} with new version {} as they are the same\",\n+            log.warn(\"Skip update of the current version {} to {} as they are the same\",\n                 persistedVersion, version);\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTEyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462001126", "bodyText": "typo -> STARTED", "author": "annym", "createdAt": "2020-07-29T02:29:54Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -217,14 +231,14 @@ public boolean setSrcBaseSnapshotStart(long topologyConfigId, long ts) {\n         // Update the topologyConfigId to fence all other transactions that update the metadata at the same time\n         appendUpdate(txBuilder, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID, topologyConfigId);\n \n-        // Setup the LAST_SNAPSHOT_STARTED\n+        // Setup the LAST_LAST_SNAPSHOT_STARTEDED", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NTI2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462595260", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTEyNg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -231,7 +230,7 @@ public class LogReplicationMetadataManager {\n         // Update the topologyConfigId to fence all other transactions that update the metadata at the same time\n         appendUpdate(txBuilder, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID, topologyConfigId);\n \n-        // Setup the LAST_LAST_SNAPSHOT_STARTEDED\n+        // Setup the LAST_LAST_SNAPSHOT_STARTED\n         appendUpdate(txBuilder, LogReplicationMetadataType.LAST_SNAPSHOT_STARTED, ts);\n \n         // Reset other metadata\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTIwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462001204", "bodyText": "same typo -> STARTED", "author": "annym", "createdAt": "2020-07-29T02:30:11Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -253,15 +267,14 @@ public void setLastSnapTransferDoneTimestamp(long topologyConfigId, long ts) {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n-            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n \n         //Update the topologyConfigId to fence all other transactions that update the metadata at the same time\n         appendUpdate(txBuilder, LogReplicationMetadataType.TOPOLOGY_CONFIG_ID, topologyConfigId);\n \n-        //Setup the LAST_SNAPSHOT_STARTED\n+        //Setup the LAST_LAST_SNAPSHOT_STARTEDED", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -267,6 +266,7 @@ public class LogReplicationMetadataManager {\n         if (topologyConfigId != persistedTopologyConfigId || ts <= persistedTopologyConfigId) {\n             log.warn(\"The metadata is older than the persisted one. Set snapshotStart topologyConfigId \" + topologyConfigId + \" ts \" + ts +\n                     \" persisteSiteConfigID \" + persistedTopologyConfigId + \" persistSnapStart \" + persistSnapStart);\n+            return;\n         }\n \n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjAzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002036", "bodyText": "maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.", "author": "annym", "createdAt": "2020-07-29T02:33:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMDcyNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462600725", "bodyText": "From here we will only return the protobuf.. will have to add the log message in the adapter", "author": "pankti-m", "createdAt": "2020-07-29T21:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjAzNg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -313,47 +314,55 @@ public class LogReplicationMetadataManager {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n-    public void setReplicationRemainingPercent(long percentComplete) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+    public void setReplicationRemainingPercent(String clusterId, long percentComplete,\n+                                               ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete)\n+                .setType(type).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public long getReplicationRemainingPercent() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+    private Map<String, ReplicationStatusVal> getReplicationRemainingPercent() {\n+\n+        Map<String, ReplicationStatusVal> replicationStatusMap = new HashMap<>();\n+        QueryResult<CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>> entries =\n+                corfuStore.query(NAMESPACE).executeQuery(REPLICATION_STATUS_TABLE, (x) -> {return true;});\n+\n+        for(CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>entry : entries.getResult()) {\n+            replicationStatusMap.put(entry.getKey().getClusterId(), entry.getPayload());\n+        }\n+        return replicationStatusMap;\n+    }\n+\n+    public ReplicationStatusVal getReplicationRemainingPercent(String clusterId) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n         if (record == null) {\n-            return 0;\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getReplicationCompletion();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public boolean getDataConsistentOnStandby() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+    public ReplicationStatusVal getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n \n-        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n-        // the standby rebooted?  In that case it is consistent\n+        // Initially, snapshot sync is pending so the data is not consistent.\n         if (record == null) {\n-            return false;\n+            log.warn(\"No Key for Data Consistent found.  DataConsistent Status is not set.\");\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getDataConsistent();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjY2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002664", "bodyText": "Also here we can print some warning message or something for us to know its not yet persisted.", "author": "annym", "createdAt": "2020-07-29T02:35:34Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNTAyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462605022", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -313,47 +314,55 @@ public class LogReplicationMetadataManager {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n-    public void setReplicationRemainingPercent(long percentComplete) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+    public void setReplicationRemainingPercent(String clusterId, long percentComplete,\n+                                               ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete)\n+                .setType(type).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public long getReplicationRemainingPercent() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+    private Map<String, ReplicationStatusVal> getReplicationRemainingPercent() {\n+\n+        Map<String, ReplicationStatusVal> replicationStatusMap = new HashMap<>();\n+        QueryResult<CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>> entries =\n+                corfuStore.query(NAMESPACE).executeQuery(REPLICATION_STATUS_TABLE, (x) -> {return true;});\n+\n+        for(CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>entry : entries.getResult()) {\n+            replicationStatusMap.put(entry.getKey().getClusterId(), entry.getPayload());\n+        }\n+        return replicationStatusMap;\n+    }\n+\n+    public ReplicationStatusVal getReplicationRemainingPercent(String clusterId) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n         if (record == null) {\n-            return 0;\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getReplicationCompletion();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public boolean getDataConsistentOnStandby() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+    public ReplicationStatusVal getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n \n-        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n-        // the standby rebooted?  In that case it is consistent\n+        // Initially, snapshot sync is pending so the data is not consistent.\n         if (record == null) {\n-            return false;\n+            log.warn(\"No Key for Data Consistent found.  DataConsistent Status is not set.\");\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getDataConsistent();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjg2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002861", "bodyText": "Even If the standby rebooted it should be persisted, right? unless it rebooted right before updating this value. (Maybe we should ensure it is atomically updated when the last snapshot entry is written)", "author": "annym", "createdAt": "2020-07-29T02:36:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMzcyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462603726", "bodyText": "oh yes.. I think the todo is not required.  The last snapshot timestamp will have been set on reboot, unless it stopped just before updating this field.  In that case, will the transfer resume?", "author": "pankti-m", "createdAt": "2020-07-29T21:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -313,47 +314,55 @@ public class LogReplicationMetadataManager {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n-    public void setReplicationRemainingPercent(long percentComplete) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+    public void setReplicationRemainingPercent(String clusterId, long percentComplete,\n+                                               ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete)\n+                .setType(type).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public long getReplicationRemainingPercent() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+    private Map<String, ReplicationStatusVal> getReplicationRemainingPercent() {\n+\n+        Map<String, ReplicationStatusVal> replicationStatusMap = new HashMap<>();\n+        QueryResult<CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>> entries =\n+                corfuStore.query(NAMESPACE).executeQuery(REPLICATION_STATUS_TABLE, (x) -> {return true;});\n+\n+        for(CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>entry : entries.getResult()) {\n+            replicationStatusMap.put(entry.getKey().getClusterId(), entry.getPayload());\n+        }\n+        return replicationStatusMap;\n+    }\n+\n+    public ReplicationStatusVal getReplicationRemainingPercent(String clusterId) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n         if (record == null) {\n-            return 0;\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getReplicationCompletion();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public boolean getDataConsistentOnStandby() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+    public ReplicationStatusVal getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n \n-        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n-        // the standby rebooted?  In that case it is consistent\n+        // Initially, snapshot sync is pending so the data is not consistent.\n         if (record == null) {\n-            return false;\n+            log.warn(\"No Key for Data Consistent found.  DataConsistent Status is not set.\");\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getDataConsistent();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzEwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462003103", "bodyText": "break;", "author": "annym", "createdAt": "2020-07-29T02:37:27Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getDataConsistent();\n+    }\n+\n     @Override\n     public String toString() {\n-        String s = new String();\n-        s.concat(LogReplicationMetadataType.TOPOLOGY_CONFIG_ID.getVal() + \" \" + getTopologyConfigId() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_STARTED.getVal() + \" \" + getLastSnapStartTimestamp() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED.getVal() + \" \" + getLastSnapTransferDoneTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED.getVal() + \" \" + getLastAppliedBaseSnapshotTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM.getVal() + \" \" + getLastSnapSeqNum() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_LOG_PROCESSED.getVal() + \" \" + getLastProcessedLogTimestamp() + \" \");\n-\n-        return s;\n+        StringBuilder builder = new StringBuilder();\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            builder.append(type).append(\": \");\n+            switch (type) {\n+                case TOPOLOGY_CONFIG_ID:\n+                    builder.append(getTopologyConfigId());\n+                    break;\n+                case LAST_SNAPSHOT_STARTED:\n+                   builder.append(getLastSnapStartTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_TRANSFERRED:\n+                   builder.append(getLastSnapTransferDoneTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_APPLIED:\n+                   builder.append(getLastAppliedBaseSnapshotTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_SEQ_NUM:\n+                   builder.append(getLastSnapSeqNum());\n+                   break;\n+                case LAST_LOG_ENTRY_PROCESSED:\n+                   builder.append(getLastProcessedLogTimestamp());\n+                   break;\n+                case REMAINING_REPLICATION_PERCENT:\n+                    builder.append(getReplicationRemainingPercent());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNjEyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462606121", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -313,47 +314,55 @@ public class LogReplicationMetadataManager {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n-    public void setReplicationRemainingPercent(long percentComplete) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+    public void setReplicationRemainingPercent(String clusterId, long percentComplete,\n+                                               ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete)\n+                .setType(type).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public long getReplicationRemainingPercent() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+    private Map<String, ReplicationStatusVal> getReplicationRemainingPercent() {\n+\n+        Map<String, ReplicationStatusVal> replicationStatusMap = new HashMap<>();\n+        QueryResult<CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>> entries =\n+                corfuStore.query(NAMESPACE).executeQuery(REPLICATION_STATUS_TABLE, (x) -> {return true;});\n+\n+        for(CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>entry : entries.getResult()) {\n+            replicationStatusMap.put(entry.getKey().getClusterId(), entry.getPayload());\n+        }\n+        return replicationStatusMap;\n+    }\n+\n+    public ReplicationStatusVal getReplicationRemainingPercent(String clusterId) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n         if (record == null) {\n-            return 0;\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getReplicationCompletion();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public boolean getDataConsistentOnStandby() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+    public ReplicationStatusVal getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n \n-        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n-        // the standby rebooted?  In that case it is consistent\n+        // Initially, snapshot sync is pending so the data is not consistent.\n         if (record == null) {\n-            return false;\n+            log.warn(\"No Key for Data Consistent found.  DataConsistent Status is not set.\");\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getDataConsistent();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMzM5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462003394", "bodyText": "missing DATA_CONSISTENT_ON_STANDBY?", "author": "annym", "createdAt": "2020-07-29T02:38:40Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -301,21 +313,85 @@ public void setSnapshotApplied(LogReplicationEntry entry) {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n+    public void setReplicationRemainingPercent(long percentComplete) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public long getReplicationRemainingPercent() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record == null) {\n+            return 0;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getReplicationCompletion();\n+    }\n+\n+    public void setDataConsistentOnStandby(boolean isConsistent) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n+        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n+        txBuilder.commit();\n+    }\n+\n+    public boolean getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n+                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+\n+        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n+        // the standby rebooted?  In that case it is consistent\n+        if (record == null) {\n+            return false;\n+        }\n+        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n+        return val.getDataConsistent();\n+    }\n+\n     @Override\n     public String toString() {\n-        String s = new String();\n-        s.concat(LogReplicationMetadataType.TOPOLOGY_CONFIG_ID.getVal() + \" \" + getTopologyConfigId() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_STARTED.getVal() + \" \" + getLastSnapStartTimestamp() +\" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_TRANSFERRED.getVal() + \" \" + getLastSnapTransferDoneTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_APPLIED.getVal() + \" \" + getLastAppliedBaseSnapshotTimestamp() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_SNAPSHOT_SEQ_NUM.getVal() + \" \" + getLastSnapSeqNum() + \" \");\n-        s.concat(LogReplicationMetadataType.LAST_LOG_PROCESSED.getVal() + \" \" + getLastProcessedLogTimestamp() + \" \");\n-\n-        return s;\n+        StringBuilder builder = new StringBuilder();\n+        for (LogReplicationMetadataType type : LogReplicationMetadataType.values()) {\n+            builder.append(type).append(\": \");\n+            switch (type) {\n+                case TOPOLOGY_CONFIG_ID:\n+                    builder.append(getTopologyConfigId());\n+                    break;\n+                case LAST_SNAPSHOT_STARTED:\n+                   builder.append(getLastSnapStartTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_TRANSFERRED:\n+                   builder.append(getLastSnapTransferDoneTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_APPLIED:\n+                   builder.append(getLastAppliedBaseSnapshotTimestamp());\n+                   break;\n+                case LAST_SNAPSHOT_SEQ_NUM:\n+                   builder.append(getLastSnapSeqNum());\n+                   break;\n+                case LAST_LOG_ENTRY_PROCESSED:\n+                   builder.append(getLastProcessedLogTimestamp());\n+                   break;\n+                case REMAINING_REPLICATION_PERCENT:\n+                    builder.append(getReplicationRemainingPercent());\n+                default:", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\nindex d49c3402e1b..b6d3d767253 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java\n\n@@ -313,47 +314,55 @@ public class LogReplicationMetadataManager {\n                 \" persistSiteConfigID \" + persistSiteConfigID + \" persistSnapStart \" + persistSnapStart);\n     }\n \n-    public void setReplicationRemainingPercent(long percentComplete) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete).build();\n+    public void setReplicationRemainingPercent(String clusterId, long percentComplete,\n+                                               ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setReplicationCompletion(percentComplete)\n+                .setType(type).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public long getReplicationRemainingPercent() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.REPLICATION_COMPLETION).build();\n+    private Map<String, ReplicationStatusVal> getReplicationRemainingPercent() {\n+\n+        Map<String, ReplicationStatusVal> replicationStatusMap = new HashMap<>();\n+        QueryResult<CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>> entries =\n+                corfuStore.query(NAMESPACE).executeQuery(REPLICATION_STATUS_TABLE, (x) -> {return true;});\n+\n+        for(CorfuStoreEntry<ReplicationStatusKey, ReplicationStatusVal, ReplicationStatusVal>entry : entries.getResult()) {\n+            replicationStatusMap.put(entry.getKey().getClusterId(), entry.getPayload());\n+        }\n+        return replicationStatusMap;\n+    }\n+\n+    public ReplicationStatusVal getReplicationRemainingPercent(String clusterId) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n         if (record == null) {\n-            return 0;\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getReplicationCompletion();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n         TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n         txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n         txBuilder.commit();\n     }\n \n-    public boolean getDataConsistentOnStandby() {\n-        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setKey(\n-                ReplicationStatusKey.Status.IS_DATA_CONSISTENT).build();\n+    public ReplicationStatusVal getDataConsistentOnStandby() {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n         CorfuRecord record = corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n \n-        // TODO: Initially, snapshot sync is pending so the data is not consistent.  But what if everything was applied and\n-        // the standby rebooted?  In that case it is consistent\n+        // Initially, snapshot sync is pending so the data is not consistent.\n         if (record == null) {\n-            return false;\n+            log.warn(\"No Key for Data Consistent found.  DataConsistent Status is not set.\");\n+            return null;\n         }\n-        ReplicationStatusVal val = (ReplicationStatusVal)record.getPayload();\n-        return val.getDataConsistent();\n+        return (ReplicationStatusVal)record.getPayload();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462005155", "bodyText": "This class has a receive method where we first receive messages. And there we have some logic to process a SNAPSHOT_START marker, so I think we should set dataConsistent to false in processSnapshotStart. As we now we're starting the transfer of a snapshot sync, so from that point until the snapshot_end is received and applied is when we'll set to true.", "author": "annym", "createdAt": "2020-07-29T02:45:25Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -398,14 +401,17 @@ private void processSnapshotMessage(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(false);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjcyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462006728", "bodyText": "So we can remove it from here and set it on the reception of the start marker.", "author": "annym", "createdAt": "2020-07-29T02:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxMjgyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462612829", "bodyText": "but the data will be consistent and can be read during the transfer, right?  Only when it is being applied, it is not consistent.", "author": "pankti-m", "createdAt": "2020-07-29T21:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTE1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex d6ce9bfdd95..13eaca4402b 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -403,12 +404,10 @@ public class LogReplicationSinkManager implements DataReceiver {\n                 snapshotWriter.apply(message);\n                 break;\n             case SNAPSHOT_END:\n-                dataConsistent.set(false);\n-                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n+                setDataConsistent(false);\n                 snapshotWriter.snapshotTransferDone(message);\n                 completeSnapshotApply(message);\n-                dataConsistent.set(true);\n-                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n+                setDataConsistent(true);\n                 break;\n             default:\n                 log.warn(\"Message type {} should not be applied as snapshot sync.\", message.getMetadata().getMessageMetadataType());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTUzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462005531", "bodyText": "To keep a sense of atomicity maybe we can have a private method setDataConsistency(boolean consistent) something like that where we update the local variable and the persisted...", "author": "annym", "createdAt": "2020-07-29T02:47:00Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java", "diffHunk": "@@ -398,14 +401,17 @@ private void processSnapshotMessage(LogReplicationEntry message) {\n         switch (message.getMetadata().getMessageMetadataType()) {\n             case SNAPSHOT_MESSAGE:\n                 snapshotWriter.apply(message);\n-                return;\n+                break;\n             case SNAPSHOT_END:\n+                dataConsistent.set(false);\n+                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n                 snapshotWriter.snapshotTransferDone(message);\n                 completeSnapshotApply(message);\n-                return;\n+                dataConsistent.set(true);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjM5Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462616396", "bodyText": "sure", "author": "pankti-m", "createdAt": "2020-07-29T22:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTUzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\nindex d6ce9bfdd95..13eaca4402b 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationSinkManager.java\n\n@@ -403,12 +404,10 @@ public class LogReplicationSinkManager implements DataReceiver {\n                 snapshotWriter.apply(message);\n                 break;\n             case SNAPSHOT_END:\n-                dataConsistent.set(false);\n-                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n+                setDataConsistent(false);\n                 snapshotWriter.snapshotTransferDone(message);\n                 completeSnapshotApply(message);\n-                dataConsistent.set(true);\n-                logReplicationMetadataManager.setDataConsistentOnStandby(dataConsistent.get());\n+                setDataConsistent(true);\n                 break;\n             default:\n                 log.warn(\"Message type {} should not be applied as snapshot sync.\", message.getMetadata().getMessageMetadataType());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDgzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462000835", "bodyText": "Perhaps we can add some validation that this indeed a correct percent from 0 to 100. We just store it as a string later and then parse back as an integer. If it's incorrect it will throw a NumberFormatException", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:28:51Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);\n+            remainingEntriesToSend += map.getLongCardinality();\n+        }\n+        return remainingEntriesToSend;\n+    }\n+\n+    /**\n+     * Task which periodically updates the metadata table with replication completion percentage\n+     */\n+    private class TsPollingTask implements Runnable {\n+        @Override\n+        public void run() {\n+            long remainingReplicationStatus = calculateRemainingEntriesToSend(lastAckedTimestamp.get());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5Mzg1Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462593856", "bodyText": "This protobuf has changed and takes a long now.. so there is no conversion.", "author": "pankti-m", "createdAt": "2020-07-29T21:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMjgwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462002804", "bodyText": "Does not seem to be used", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:36:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -21,12 +21,12 @@\n import java.util.UUID;\n \n /**\n- * This class manages Log Replication for multiple remote (standby) cluster's.\n+ * This class manages Log Replication for multiple remote (standby) clusters.\n  */\n @Slf4j\n public class CorfuReplicationManager {\n \n-    public final static int PERCENTAGE_BASE = 100;\n+    public final static int PERCENTAGE_HUNDRED = 100;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java\nindex fcd1ad3baa0..fe44a78b6e6 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java\n\n@@ -26,8 +26,6 @@ import java.util.UUID;\n @Slf4j\n public class CorfuReplicationManager {\n \n-    public final static int PERCENTAGE_HUNDRED = 100;\n-\n     // Keep map of remote cluster ID and the associated log replication runtime (an abstract\n     // client to that cluster)\n     private Map<String, CorfuLogReplicationRuntime> runtimeToRemoteCluster = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODQxMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462008412", "bodyText": "I just want to clarify. ackedTimestamp is the last timestamp acked by the receiver that we receive when the entry is replicated, so it should be smaller than the maxReplicatedStreamTail, for the range to be valid right?", "author": "PavelZaytsev", "createdAt": "2020-07-29T02:57:48Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MTUwMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462591503", "bodyText": "good question.  This range is used in StreamAddressSpace.getAddressesInRange() below on line 284.  That function takes a range where start>end.", "author": "pankti-m", "createdAt": "2020-07-29T21:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTc2OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462009769", "bodyText": "no need to do this for this review, but we might add an issue to track the fact that we should move this configuration out to the config file.", "author": "annym", "createdAt": "2020-07-29T03:02:38Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -61,119 +70,89 @@\n      */\n     private final LogReplicationConfig config;\n \n+    /*\n+     * Log Replication MetadataManager.\n+     */\n+    private final LogReplicationMetadataManager metadataManager;\n+\n+    /*\n+     * Last ack'd timestamp from Receiver\n+     */\n+    private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n+\n+    /*\n+     * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n+     */\n+    ScheduledExecutorService lastAckedTsPoller;\n+\n+    /*\n+     * Interval at which the thread reads the last Acked Timestamp\n+     */\n+    private static int ACKED_TS_READ_INTERVAL_SECONDS = 15;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MDg5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462580898", "bodyText": "I will add it in the follow up PR #2657", "author": "pankti-m", "createdAt": "2020-07-29T20:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwOTc2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -80,6 +83,13 @@ public class LogReplicationSourceManager implements DataReceiver {\n      */\n     private AtomicLong lastAckedTimestamp = new AtomicLong(Address.NON_ADDRESS);\n \n+    /*\n+     * Sync Type for which last Ack was Received.  Set to Log Entry Type as the initial FSM state is\n+     * Log Entry Sync\n+     */\n+    private LogReplicationMetadata.ReplicationStatusVal.SyncType lastSyncType =\n+            LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY;\n+\n     /*\n      * Periodic Thread which reads the last Acked Timestamp and writes it to the metadata table\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMTAwOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462011008", "bodyText": "Actually, this is a bit weird. But I realized it the other day while looking at other things. This method for the Source is not really never called. All the logic for processing ACKs is taken care in the SnapshotSender and LogEntrySender respectively, so it is there where we should be setting this lastAckedTimestamp.", "author": "annym", "createdAt": "2020-07-29T03:07:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjIyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012222", "bodyText": "Actually, I think we have a major concern here and its that SnapshotSender does not really accumulate intermediate SNAPSHOT_REPLICATED, so it only updates at the end.. But you can bypass that (for now) by updating when you send something...", "author": "annym", "createdAt": "2020-07-29T03:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMTAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjU3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012577", "bodyText": "s -> streamName", "author": "annym", "createdAt": "2020-07-29T03:14:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTM3Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462585373", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T20:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjc2OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462012768", "bodyText": "if tailMap.contains(streamUuid)?", "author": "annym", "createdAt": "2020-07-29T03:14:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NjU5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462586597", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMjc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462016463", "bodyText": "Is this true? what if the maxReplicatedStreamTail is -1, that means there is no data so remaining is 0%, right?", "author": "annym", "createdAt": "2020-07-29T03:29:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjU3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462016576", "bodyText": "We should add tests to cover all these cases!", "author": "annym", "createdAt": "2020-07-29T03:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4OTk2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462589964", "bodyText": "Added the case for maxTail = -1.\nYes for tests.", "author": "pankti-m", "createdAt": "2020-07-29T21:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNjQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzM1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017350", "bodyText": "No need, the address map you requested is already confined to that range, you can directly: addressSpace.getAddressMap().getLongCardinality()", "author": "annym", "createdAt": "2020-07-29T03:32:59Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MjM0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462592349", "bodyText": "done", "author": "pankti-m", "createdAt": "2020-07-29T21:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzQ3Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017477", "bodyText": "should we add a logging before returning?", "author": "annym", "createdAt": "2020-07-29T03:33:35Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -247,17 +226,75 @@ public LogReplicationEntry receive(LogReplicationEntry message) {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n+            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n         } else {\n             log.debug(\"Received data message of type {} not an ACK\", message.getMetadata().getMessageMetadataType());\n         }\n-\n         return null;\n     }\n+\n+    /**\n+     * For the given replication runtime, query max stream tail for all streams to be replicated.\n+     *\n+     * @return max tail of all streams to be replicated for the given runtime\n+     */\n+    private long getMaxReplicatedStreamsTail() {\n+        Map<UUID, Long> tailMap = runtime.getAddressSpaceView().getAllTails().getStreamTails();\n+        long maxTail = Address.NON_ADDRESS;\n+        for (String s : config.getStreamsToReplicate()) {\n+            UUID streamUuid = CorfuRuntime.getStreamID(s);\n+            if (tailMap.get(streamUuid) != null) {\n+                long streamTail = tailMap.get(streamUuid);\n+                maxTail = Math.max(maxTail, streamTail);\n+            }\n+        }\n+        return maxTail;\n+    }\n+\n+    /**\n+     * Given a timestamp acked by the receiver, calculate how many entries remain to be sent for all replicated streams.\n+     *\n+     * @param ackedTimestamp Timestamp ack'd by the receiver\n+     *\n+     * For Log Entry Sync, this function returns the total number of entries remaining to be sent across all replicated\n+     * streams.\n+     * For Snapshot Sync, each entry sent is a snapshot.  So this function returns the total number of snapshots\n+     * remaining to be sent.\n+     * If the ack'd timestamp is uninitialized, it returns 100%, which means no replication has been done.\n+     */\n+    private long calculateRemainingEntriesToSend(long ackedTimestamp) {\n+        long maxReplicatedStreamTail = getMaxReplicatedStreamsTail();\n+\n+        if (ackedTimestamp == Address.NON_ADDRESS) {\n+            return FULL_REPLICATION_REMAINING_PERCENT;\n+        }\n+        long remainingEntriesToSend = 0;\n+        for (String stream : config.getStreamsToReplicate()) {\n+            UUID streamId = CorfuRuntime.getStreamID(stream);\n+            StreamAddressRange range = new StreamAddressRange(streamId, maxReplicatedStreamTail, ackedTimestamp);\n+            StreamAddressSpace addressSpace = runtime.getSequencerView().getStreamAddressSpace(range);\n+            Roaring64NavigableMap map = addressSpace.getAddressesInRange(range);\n+            remainingEntriesToSend += map.getLongCardinality();\n+        }\n+        return remainingEntriesToSend;", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MzE5Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462593193", "bodyText": "we can add a trace.. because this thread runs every 15seconds right now and other levels will flood the log.", "author": "pankti-m", "createdAt": "2020-07-29T21:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\nindex 2eb917ec62a..bda8468fdd3 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java\n\n@@ -226,12 +231,14 @@ public class LogReplicationSourceManager implements DataReceiver {\n         // Process ACKs from Application, for both, log entry and snapshot sync.\n         if(message.getMetadata().getMessageMetadataType() == MessageType.LOG_ENTRY_REPLICATED) {\n             log.debug(\"Log entry sync ACK received on timestamp {}\", message.getMetadata().getTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.LOG_ENTRY);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.LOG_ENTRY_SYNC_REPLICATED,\n                 new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp())));\n         } else if (message.getMetadata().getMessageMetadataType() == MessageType.SNAPSHOT_REPLICATED) {\n             log.debug(\"Snapshot sync ACK received on base timestamp {}\", message.getMetadata().getSnapshotTimestamp());\n-            lastAckedTimestamp.set(message.getMetadata().getTimestamp());\n+            setAckedTsAndSyncType(message.getMetadata().getTimestamp(),\n+                    LogReplicationMetadata.ReplicationStatusVal.SyncType.SNAPSHOT);\n             logReplicationFSM.input(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_COMPLETE,\n                     new LogReplicationEventMetadata(message.getMetadata().getSyncRequestId(), message.getMetadata().getTimestamp(),\n                             message.getMetadata().getTimestamp())));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzc0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462017747", "bodyText": "Where is this being used?", "author": "annym", "createdAt": "2020-07-29T03:34:39Z", "path": "test/src/test/java/org/corfudb/integration/LogReplicationIT.java", "diffHunk": "@@ -1380,6 +1377,11 @@ private void verifyPersistedLogEntryMetadata() {\n         assertThat(expectedAckTimestamp == lastLogProcessed).isTrue();\n     }\n \n+    private void verifyRemainingReplicationPercent(long remainingPercent) {", "originalCommit": "3b5a84dac4f787ac072b979e2843c94450b85682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjY1NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r462616654", "bodyText": "I did not remove so that it can be used later when we add tests", "author": "pankti-m", "createdAt": "2020-07-29T22:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNzc0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d8915819849936664d64ecd85853c30a9296398b", "chunk": "diff --git a/test/src/test/java/org/corfudb/integration/LogReplicationIT.java b/test/src/test/java/org/corfudb/integration/LogReplicationIT.java\nindex 4605cd52e28..55e12d181db 100644\n--- a/test/src/test/java/org/corfudb/integration/LogReplicationIT.java\n+++ b/test/src/test/java/org/corfudb/integration/LogReplicationIT.java\n\n@@ -1377,11 +1377,6 @@ public class LogReplicationIT extends AbstractIT implements Observer {\n         assertThat(expectedAckTimestamp == lastLogProcessed).isTrue();\n     }\n \n-    private void verifyRemainingReplicationPercent(long remainingPercent) {\n-        long replicationStatus = logReplicationMetadataManager.getReplicationRemainingPercent();\n-        assertTrue(Objects.equals(replicationStatus, remainingPercent));\n-    }\n-\n     public enum WAIT {\n         ON_ACK,\n         ON_ACK_TS,\n"}}, {"oid": "d8915819849936664d64ecd85853c30a9296398b", "url": "https://github.com/CorfuDB/CorfuDB/commit/d8915819849936664d64ecd85853c30a9296398b", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-30T01:01:40Z", "type": "forcePushed"}, {"oid": "4995f5222b57ea20528dc2e336e532affae0c17a", "url": "https://github.com/CorfuDB/CorfuDB/commit/4995f5222b57ea20528dc2e336e532affae0c17a", "message": "Cleanup Snapshot Sync ACK handling\n\n- Remove LogReplicationSource logic for handling ACKs (not used)", "committedDate": "2020-07-30T20:03:29Z", "type": "forcePushed"}, {"oid": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "url": "https://github.com/CorfuDB/CorfuDB/commit/4b3c2c042cebde1c55ccbc7969989adc597b21df", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-07-31T20:55:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMjk5Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r463902992", "bodyText": "It's not guaranteed to always place the local cluster in the 0th index position right?\nAm I mistaken?", "author": "hisundar", "createdAt": "2020-08-01T01:24:13Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java", "diffHunk": "@@ -45,7 +46,8 @@ public void prepareToBecomeStandby() {\n         corfuReplicationDiscoveryService.prepareToBecomeStandby();\n     }\n \n-    public int queryReplicationStatus() {\n-        return corfuReplicationDiscoveryService.queryReplicationStatus();\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus() {\n+        return corfuReplicationDiscoveryService.queryReplicationStatus(\n+            topologyConfig.getClusters(0).getId());", "originalCommit": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java\nindex 4280ab8ba0a..1ba25c2c527 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/plugins/CorfuReplicationClusterManagerBaseAdapter.java\n\n@@ -46,8 +48,7 @@ public abstract class CorfuReplicationClusterManagerBaseAdapter implements Corfu\n         corfuReplicationDiscoveryService.prepareToBecomeStandby();\n     }\n \n-    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus() {\n-        return corfuReplicationDiscoveryService.queryReplicationStatus(\n-            topologyConfig.getClusters(0).getId());\n+    public Map<String, LogReplicationMetadata.ReplicationStatusVal> queryReplicationStatus() {\n+        return corfuReplicationDiscoveryService.queryReplicationStatus();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwMzM5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2641#discussion_r463903394", "bodyText": "I only see one type - is it possible to overload the queryReplicationStatus to return the full map?", "author": "hisundar", "createdAt": "2020-08-01T01:27:36Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -660,46 +664,36 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     /**\n-     * Query all replicated stream log tails and remember the max\n-     * and query each standbySite information according to the ackInformation decide all manay total\n-     * msg needs to send out.\n+     * No work needs to be done here.  If in the Active state, writes to all replicated streams have stopped at this time.\n+     * Following this, the ClusterManagerAdapter can query the status of ongoing snapshot sync on the\n+     * local(active) cluster.\n      */\n     @Override\n     public void prepareToBecomeStandby() {\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE && replicationManager != null) {\n-            replicationManager.prepareClusterRoleChange();\n+        if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n+            log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.warn(\"Illegal prepareToBecomeStandby when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n+            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n         }\n     }\n \n     /**\n-     * Query all replicated stream log tails and calculate the number of messages to be sent.\n-     * If the max tail has changed, return 0%.\n+     * Active Cluster - Read the shared metadata table to find the status of any ongoing snapshot or log entry sync\n+     * and return a completion percentage.\n+     * Standby Cluster - Read the shared metadata table and find if data is consistent(returns false if\n+     * snapshot sync is in the apply phase)\n      */\n     @Override\n-    public int queryReplicationStatus() {\n-        //TODO make sure caller should query all nodes in the cluster and pick the max of these 3 values\n-        if (localClusterDescriptor.getRole() == ClusterRole.ACTIVE) {\n-            if (!isLeader.get()) {\n-                log.warn(\"Illegal queryReplicationStatus when node is not a leader \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            if (replicationManager == null) {\n-                log.warn(\"Illegal queryReplicationStatus when replication manager is null \" +\n-                        \"in an ACTIVE Cluster{} \", localClusterDescriptor.getClusterId());\n-                return 0;\n-            }\n-\n-            return replicationManager.queryReplicationStatus();\n-        } else {\n-            log.warn(\"Illegal queryReplicationStatus when cluster{} with role {}\",\n-                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n-            return INVALID_REPLICATION_STATUS;\n+    public LogReplicationMetadata.ReplicationStatusVal queryReplicationStatus(String clusterId) {", "originalCommit": "4b3c2c042cebde1c55ccbc7969989adc597b21df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\nindex 9d8738b8502..b1e42e0e566 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java\n\n@@ -673,7 +673,8 @@ public class CorfuReplicationDiscoveryService implements Runnable, CorfuReplicat\n         if (ClusterRole.ACTIVE == localClusterDescriptor.getRole()) {\n             log.info(\"Received a Request to Become Standby\");\n         } else {\n-            log.error(\"Received a Request to Become Standby in current role {}\", localClusterDescriptor.getRole());\n+            log.warn(\"Illegal prepareToBecomeStandby when cluster {} with role {}\",\n+                    localClusterDescriptor.getClusterId(), localClusterDescriptor.getRole());\n         }\n     }\n \n"}}, {"oid": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "url": "https://github.com/CorfuDB/CorfuDB/commit/052970b14bbad9f8e0c8a401351736b0c7bd8e65", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-08-01T02:41:10Z", "type": "commit"}, {"oid": "052970b14bbad9f8e0c8a401351736b0c7bd8e65", "url": "https://github.com/CorfuDB/CorfuDB/commit/052970b14bbad9f8e0c8a401351736b0c7bd8e65", "message": "Support queryReplicationStatus() on non-leader node.", "committedDate": "2020-08-01T02:41:10Z", "type": "forcePushed"}]}