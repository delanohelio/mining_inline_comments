{"pr_number": 2612, "pr_title": "Unify Read APIs", "pr_createdAt": "2020-07-10T07:53:07Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2612", "timeline": [{"oid": "465e0259fa53be7abb29177738059eccbbea5cad", "url": "https://github.com/CorfuDB/CorfuDB/commit/465e0259fa53be7abb29177738059eccbbea5cad", "message": "Unify Read APIs\n\nMerged the multi-address read with the single read API.", "committedDate": "2020-07-13T21:42:09Z", "type": "forcePushed"}, {"oid": "b59eeb17c96bf5b9a98ec4cb076cea74533965f1", "url": "https://github.com/CorfuDB/CorfuDB/commit/b59eeb17c96bf5b9a98ec4cb076cea74533965f1", "message": "Unify Read APIs\n\nMerged the multi-address read with the single read API.", "committedDate": "2020-07-16T01:46:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r455552780", "bodyText": "This is actually a bug on master, if a multi read encounters a data corruption exception, it will keep timing out. This patches fixes this bug.", "author": "Maithem", "createdAt": "2020-07-16T07:00:47Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "originalCommit": "17752408d4c35d689d7e152502be3ace50474299", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MTQyMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456051420", "bodyText": "Why it will keep timing out? Because it does not pass the current read address?", "author": "zhangn49", "createdAt": "2020-07-16T20:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3MTk5OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456071999", "bodyText": "Yes, the message is invalid without passing a long, so the server will fail every time i tries to respond with that message type. The the client's request will start timing out and retrying.", "author": "Maithem", "createdAt": "2020-07-16T20:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3MjkxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456072917", "bodyText": "Another issue that makes it hard to debug is exceptions throwing inside the netty pipeline stages are not propagated to the producer of the channel write (i.e. client sending message/server sending a response).", "author": "Maithem", "createdAt": "2020-07-16T20:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3OTM0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456079342", "bodyText": "@Maithem I was helping Chetan debugging a similar issue yesterday where pipeline exceptions were not propagated to producer, failing silently. Eventually I found the problem when waiting on the future returned by channel.writeAndFlush(). So I think in the routers, we need to attach a listener to the future returned by channel.writeAndFlush(). For server's router, the listener can log an error if it fails, on client side, the returned future can be chained with this writeAndFlush future. We can do this in the new RPC project.", "author": "WenbinZhu", "createdAt": "2020-07-16T21:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MjMzNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456082334", "bodyText": "Yep, its annoying.\nThe void promise was apparently done for \"performance\" reasons, but I remember removing it last year and I couldn't see any performance difference.\nWe need to do something like this:\nchannel.writeAndFlush(sendBuf).addListener(res -> {\n            if (!res.isSuccess()) {\n                // fail with unavailable?\n                CompletableFuture<TurboAPI.BaseCommand> resp = pendingRequests.remove(requestId);\n                if (resp != null && !resp.isDone()) {\n                    // res.cause()\n                    resp.completeExceptionally(res.getThrowable());\n                }\n            }\n        });", "author": "Maithem", "createdAt": "2020-07-16T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c5d3adaaaf2fb5a4a7b9586191cfdd9688a29dba", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\nindex 3a246c67d8b..29a820b9f2b 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n\n@@ -287,31 +288,35 @@ public class LogUnitServer extends AbstractServer {\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n+    }\n \n-        ReadResponse rr = new ReadResponse();\n-        long currentRead = -1;\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                currentRead = address;\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading addresses {}\", msg.getPayload().getAddresses(), e);\n-            r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.ERROR_DATA_CORRUPTION, currentRead));\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;\n+        ILogData logData = dataCache.get(address, cacheable);\n+        if (logData == null) {\n+          rr.put(address, LogData.getEmpty(address));\n+        } else {\n+          rr.put(address, (LogData) logData);\n         }\n+      }\n+      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+    } catch (DataCorruptionException e) {\n+      log.error(\n+          \"Data corruption exception while reading addresses {}\",\n+          msg.getPayload().getAddresses(),\n+          e);\n+      r.sendResponse(\n+          ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.ERROR_DATA_CORRUPTION, currentRead));\n     }\n+  }\n \n     @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n     public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n"}}, {"oid": "c5d3adaaaf2fb5a4a7b9586191cfdd9688a29dba", "url": "https://github.com/CorfuDB/CorfuDB/commit/c5d3adaaaf2fb5a4a7b9586191cfdd9688a29dba", "message": "Unify Read APIs\n\nMerged the multi-address read with the single read API.", "committedDate": "2020-07-16T07:02:25Z", "type": "forcePushed"}, {"oid": "c99da581ad2e419fcd375b8c3112b61fc66220e8", "url": "https://github.com/CorfuDB/CorfuDB/commit/c99da581ad2e419fcd375b8c3112b61fc66220e8", "message": "Unify Read APIs\n\nMerged the multi-address read with the single read API.", "committedDate": "2020-07-16T07:05:01Z", "type": "forcePushed"}, {"oid": "3aa12186a287eb4034b89ae8a50c08ecb0ec122e", "url": "https://github.com/CorfuDB/CorfuDB/commit/3aa12186a287eb4034b89ae8a50c08ecb0ec122e", "message": "Unify Read APIs\n\nMerged the multi-address read with the single read API.", "committedDate": "2020-07-16T07:47:57Z", "type": "forcePushed"}, {"oid": "058085211daba9f85b313f57808cd89012b328dd", "url": "https://github.com/CorfuDB/CorfuDB/commit/058085211daba9f85b313f57808cd89012b328dd", "message": "Unify Read APIs + InspectAddresses Bug\n\n- Merged the multi-address read with the single read API.\n- Fix response type returned by inspectAddresses on data\n  corruption.", "committedDate": "2020-07-16T23:01:37Z", "type": "forcePushed"}, {"oid": "80eb8b91e2a26e624ccd7f919b9f13bec141600e", "url": "https://github.com/CorfuDB/CorfuDB/commit/80eb8b91e2a26e624ccd7f919b9f13bec141600e", "message": "Unify Read APIs + InspectAddresses Bug\n\n- Merged the multi-address read with the single read API.\n- Fix response type returned by inspectAddresses on data\n  corruption.", "committedDate": "2020-07-17T00:02:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MDYyNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459790624", "bodyText": "Can we use long instead of Long and get rid of the currentRead variable?", "author": "WenbinZhu", "createdAt": "2020-07-23T23:55:39Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;", "originalCommit": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NjI3Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459866272", "bodyText": "Done.", "author": "Maithem", "createdAt": "2020-07-24T06:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MDYyNA=="}], "type": "inlineReview", "revised_code": {"commit": "13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\nindex 31b5fb1aeb8..39b449afbd6 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n\n@@ -296,49 +295,49 @@ public class LogUnitServer extends AbstractServer {\n     }\n \n     ReadResponse rr = new ReadResponse();\n-    long currentRead = Address.NON_ADDRESS;\n-    try {\n-      for (Long address : msg.getPayload().getAddresses()) {\n-        currentRead = address;\n+\n+    for (long address : msg.getPayload().getAddresses()) {\n+      try {\n         ILogData logData = dataCache.get(address, cacheable);\n         if (logData == null) {\n           rr.put(address, LogData.getEmpty(address));\n         } else {\n           rr.put(address, (LogData) logData);\n         }\n+      } catch (DataCorruptionException e) {\n+        log.error(\n+            \"Data corruption exception while reading addresses {}\",\n+            msg.getPayload().getAddresses(),\n+            e);\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n+        return;\n       }\n-      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-    } catch (DataCorruptionException e) {\n-      log.error(\n-          \"Data corruption exception while reading addresses {}\",\n-          msg.getPayload().getAddresses(),\n-          e);\n-      r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentRead));\n     }\n+    r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n   }\n \n-    @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n-    public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n-                                 ChannelHandlerContext ctx, IServerRouter r) {\n-        List<Long> addresses = msg.getPayload().getAddresses();\n-        log.trace(\"inspectAddresses: {}\", addresses);\n-        InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n-\n-    long currentAddress = Address.NON_ADDRESS;\n-        try {\n-            for (long address : addresses) {\n-                currentAddress = address;\n-                if (!streamLog.contains(address)) {\n-                    inspectResponse.add(address);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.INSPECT_ADDRESSES_RESPONSE.payloadMsg(inspectResponse));\n-        } catch (TrimmedException te) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());\n-        } catch (DataCorruptionException dce) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentAddress));\n+  @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n+  public void inspectAddresses(\n+      CorfuPayloadMsg<InspectAddressesRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    List<Long> addresses = msg.getPayload().getAddresses();\n+    log.trace(\"inspectAddresses: {}\", addresses);\n+    InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n+\n+    for (long address : addresses) {\n+      try {\n+        if (!streamLog.contains(address)) {\n+          inspectResponse.add(address);\n         }\n+      } catch (TrimmedException te) {\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());\n+        return;\n+      } catch (DataCorruptionException dce) {\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n+        return;\n+      }\n     }\n+    r.sendResponse(ctx, msg, CorfuMsgType.INSPECT_ADDRESSES_RESPONSE.payloadMsg(inspectResponse));\n+  }\n \n     /**\n      * Handles requests for known entries in specified range.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MjM0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459792349", "bodyText": "address is primitive long, do we really need currentAddress?", "author": "WenbinZhu", "createdAt": "2020-07-24T00:01:50Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;\n+        ILogData logData = dataCache.get(address, cacheable);\n+        if (logData == null) {\n+          rr.put(address, LogData.getEmpty(address));\n+        } else {\n+          rr.put(address, (LogData) logData);\n         }\n+      }\n+      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+    } catch (DataCorruptionException e) {\n+      log.error(\n+          \"Data corruption exception while reading addresses {}\",\n+          msg.getPayload().getAddresses(),\n+          e);\n+      r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentRead));\n     }\n+  }\n \n     @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n     public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n                                  ChannelHandlerContext ctx, IServerRouter r) {\n-        log.trace(\"inspectAddresses: {}\", msg.getPayload().getAddresses());\n+        List<Long> addresses = msg.getPayload().getAddresses();\n+        log.trace(\"inspectAddresses: {}\", addresses);\n         InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n+\n+    long currentAddress = Address.NON_ADDRESS;\n         try {\n-            for (long address : msg.getPayload().getAddresses()) {\n+            for (long address : addresses) {\n+                currentAddress = address;", "originalCommit": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1MDA2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r460350067", "bodyText": "Done.", "author": "Maithem", "createdAt": "2020-07-25T01:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MjM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\nindex 31b5fb1aeb8..39b449afbd6 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java\n\n@@ -296,49 +295,49 @@ public class LogUnitServer extends AbstractServer {\n     }\n \n     ReadResponse rr = new ReadResponse();\n-    long currentRead = Address.NON_ADDRESS;\n-    try {\n-      for (Long address : msg.getPayload().getAddresses()) {\n-        currentRead = address;\n+\n+    for (long address : msg.getPayload().getAddresses()) {\n+      try {\n         ILogData logData = dataCache.get(address, cacheable);\n         if (logData == null) {\n           rr.put(address, LogData.getEmpty(address));\n         } else {\n           rr.put(address, (LogData) logData);\n         }\n+      } catch (DataCorruptionException e) {\n+        log.error(\n+            \"Data corruption exception while reading addresses {}\",\n+            msg.getPayload().getAddresses(),\n+            e);\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n+        return;\n       }\n-      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-    } catch (DataCorruptionException e) {\n-      log.error(\n-          \"Data corruption exception while reading addresses {}\",\n-          msg.getPayload().getAddresses(),\n-          e);\n-      r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentRead));\n     }\n+    r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n   }\n \n-    @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n-    public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n-                                 ChannelHandlerContext ctx, IServerRouter r) {\n-        List<Long> addresses = msg.getPayload().getAddresses();\n-        log.trace(\"inspectAddresses: {}\", addresses);\n-        InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n-\n-    long currentAddress = Address.NON_ADDRESS;\n-        try {\n-            for (long address : addresses) {\n-                currentAddress = address;\n-                if (!streamLog.contains(address)) {\n-                    inspectResponse.add(address);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.INSPECT_ADDRESSES_RESPONSE.payloadMsg(inspectResponse));\n-        } catch (TrimmedException te) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());\n-        } catch (DataCorruptionException dce) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentAddress));\n+  @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n+  public void inspectAddresses(\n+      CorfuPayloadMsg<InspectAddressesRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    List<Long> addresses = msg.getPayload().getAddresses();\n+    log.trace(\"inspectAddresses: {}\", addresses);\n+    InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n+\n+    for (long address : addresses) {\n+      try {\n+        if (!streamLog.contains(address)) {\n+          inspectResponse.add(address);\n         }\n+      } catch (TrimmedException te) {\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());\n+        return;\n+      } catch (DataCorruptionException dce) {\n+        r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n+        return;\n+      }\n     }\n+    r.sendResponse(ctx, msg, CorfuMsgType.INSPECT_ADDRESSES_RESPONSE.payloadMsg(inspectResponse));\n+  }\n \n     /**\n      * Handles requests for known entries in specified range.\n"}}, {"oid": "13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "url": "https://github.com/CorfuDB/CorfuDB/commit/13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "message": "Unify Read APIs + InspectAddresses Bug\n\n- Merged the multi-address read with the single read API.\n- Fix response type returned by inspectAddresses on data\n  corruption.", "committedDate": "2020-07-24T06:16:36Z", "type": "commit"}, {"oid": "13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "url": "https://github.com/CorfuDB/CorfuDB/commit/13c2d4a28b53fadd6253ee6d87d38a4557761ea0", "message": "Unify Read APIs + InspectAddresses Bug\n\n- Merged the multi-address read with the single read API.\n- Fix response type returned by inspectAddresses on data\n  corruption.", "committedDate": "2020-07-24T06:16:36Z", "type": "forcePushed"}]}