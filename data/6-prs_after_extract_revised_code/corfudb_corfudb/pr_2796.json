{"pr_number": 2796, "pr_title": "Protobuf RPC Schema and Protobuf handshake", "pr_createdAt": "2020-10-20T23:26:47Z", "pr_url": "https://github.com/CorfuDB/CorfuDB/pull/2796", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2MjI4OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509662289", "bodyText": "You don't need this check. It's already done above.", "author": "vjeko", "createdAt": "2020-10-21T20:21:09Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,47 +66,32 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n-\n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-        UUID clientId = null;\n-        UUID serverId = null;\n-\n-        if (m instanceof RequestMsg) {\n-            RequestMsg request = ((RequestMsg) m);\n-            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n-\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-\n-            clientId = getUUID(handshakeRequest.getClientId());\n-            serverId = getUUID(handshakeRequest.getServerId());\n-        } else {\n-            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n                 log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // The message was unregistered, we are dropping it.\n                 log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n \n             return;\n         }\n \n+        log.debug(\"channelRead: Handshake message received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n+\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+\n+        HandshakeRequestMsg handshakeRequest = ((RequestMsg) m).getPayload().getHandshakeRequest();\n+        UUID clientId = getUUID(handshakeRequest.getClientId());\n+        UUID serverId = getUUID(handshakeRequest.getServerId());\n+\n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n         if (serverId.equals(UUID.fromString(\"00000000-0000-0000-0000-000000000000\"))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDI3OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509664279", "bodyText": "Also, can we change state to handshake? It clearer this way and more consistent.", "author": "vjeko", "createdAt": "2020-10-21T20:23:48Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,47 +66,32 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n-\n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-        UUID clientId = null;\n-        UUID serverId = null;\n-\n-        if (m instanceof RequestMsg) {\n-            RequestMsg request = ((RequestMsg) m);\n-            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n-\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-\n-            clientId = getUUID(handshakeRequest.getClientId());\n-            serverId = getUUID(handshakeRequest.getServerId());\n-        } else {\n-            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n                 log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // The message was unregistered, we are dropping it.\n                 log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n \n             return;\n         }\n \n+        log.debug(\"channelRead: Handshake message received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n+\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+\n+        HandshakeRequestMsg handshakeRequest = ((RequestMsg) m).getPayload().getHandshakeRequest();\n+        UUID clientId = getUUID(handshakeRequest.getClientId());\n+        UUID serverId = getUUID(handshakeRequest.getServerId());\n+\n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n         if (serverId.equals(UUID.fromString(\"00000000-0000-0000-0000-000000000000\"))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NzYxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509667614", "bodyText": "Is the first RequestMsg always going to be a handshake request? It might be a good idea to check anyways.", "author": "vjeko", "createdAt": "2020-10-21T20:27:14Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,47 +66,32 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n-\n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-        UUID clientId = null;\n-        UUID serverId = null;\n-\n-        if (m instanceof RequestMsg) {\n-            RequestMsg request = ((RequestMsg) m);\n-            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n-\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-\n-            clientId = getUUID(handshakeRequest.getClientId());\n-            serverId = getUUID(handshakeRequest.getServerId());\n-        } else {\n-            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n                 log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // The message was unregistered, we are dropping it.\n                 log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n \n             return;\n         }\n \n+        log.debug(\"channelRead: Handshake message received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n+\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+\n+        HandshakeRequestMsg handshakeRequest = ((RequestMsg) m).getPayload().getHandshakeRequest();\n+        UUID clientId = getUUID(handshakeRequest.getClientId());\n+        UUID serverId = getUUID(handshakeRequest.getServerId());\n+\n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n         if (serverId.equals(UUID.fromString(\"00000000-0000-0000-0000-000000000000\"))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2ODMzMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509668330", "bodyText": "You should really try to avoid unassigned variables. Take a look at my comment about the return statement below.", "author": "vjeko", "createdAt": "2020-10-21T20:28:24Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,47 +66,32 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n-\n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-        UUID clientId = null;\n-        UUID serverId = null;\n-\n-        if (m instanceof RequestMsg) {\n-            RequestMsg request = ((RequestMsg) m);\n-            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n-\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-\n-            clientId = getUUID(handshakeRequest.getClientId());\n-            serverId = getUUID(handshakeRequest.getServerId());\n-        } else {\n-            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n                 log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // The message was unregistered, we are dropping it.\n                 log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n \n             return;\n         }\n \n+        log.debug(\"channelRead: Handshake message received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n+\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+\n+        HandshakeRequestMsg handshakeRequest = ((RequestMsg) m).getPayload().getHandshakeRequest();\n+        UUID clientId = getUUID(handshakeRequest.getClientId());\n+        UUID serverId = getUUID(handshakeRequest.getServerId());\n+\n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n         if (serverId.equals(UUID.fromString(\"00000000-0000-0000-0000-000000000000\"))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MDYzNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509670637", "bodyText": "You should make this a precondition check as well. Currently you have:\n\nif (A) {\n  X...\n} else {\n  Y...\n}\n\nZ...\n\nYou can re-organize this:\nif (!A) {\n  Y...\n}\n\nX...\nZ...\n\nThis way you avoid unassigned variables.", "author": "vjeko", "createdAt": "2020-10-21T20:32:12Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                // The message was unregistered, we are dropping it.\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n+\n             return;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,47 +66,32 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n-\n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-        UUID clientId = null;\n-        UUID serverId = null;\n-\n-        if (m instanceof RequestMsg) {\n-            RequestMsg request = ((RequestMsg) m);\n-            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n-\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-\n-            clientId = getUUID(handshakeRequest.getClientId());\n-            serverId = getUUID(handshakeRequest.getServerId());\n-        } else {\n-            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n                 log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // The message was unregistered, we are dropping it.\n                 log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n \n             return;\n         }\n \n+        log.debug(\"channelRead: Handshake message received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n+\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+\n+        HandshakeRequestMsg handshakeRequest = ((RequestMsg) m).getPayload().getHandshakeRequest();\n+        UUID clientId = getUUID(handshakeRequest.getClientId());\n+        UUID serverId = getUUID(handshakeRequest.getServerId());\n+\n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n         if (serverId.equals(UUID.fromString(\"00000000-0000-0000-0000-000000000000\"))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4MzIzOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509683238", "bodyText": "You should make this a precondition check and return. This will reduce the amount of if-else nesting.", "author": "vjeko", "createdAt": "2020-10-21T20:47:57Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -231,7 +244,14 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             log.debug(\"write: Handshake already completed, not appending corfu message to queue\");\n             super.write(ctx, msg, promise);", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 680d9439d82..f3e4e327dc5 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -233,14 +218,13 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n-            throws Exception {\n-        if (this.state.failed()) {\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (this.handshakeState.failed()) {\n             // If handshake failed, discard messages.\n             return;\n         }\n \n-        if (this.state.completed()) {\n+        if (this.handshakeState.completed()) {\n             log.debug(\"write: Handshake already completed, not appending corfu message to queue\");\n             super.write(ctx, msg, promise);\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzQ1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697451", "bodyText": "Style: space after if.", "author": "vjeko", "createdAt": "2020-10-21T21:07:25Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzU4OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697588", "bodyText": "Style.", "author": "vjeko", "createdAt": "2020-10-21T21:07:34Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509700067", "bodyText": "Check not needed.", "author": "vjeko", "createdAt": "2020-10-21T21:10:47Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4MDQ0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510280446", "bodyText": "@vjeko Is there a reason why this is checked multiple times in the original code? I was under the impression that the handshake state could change between the first check and the second, so this was needed to avoid message loss.", "author": "zfrenette", "createdAt": "2020-10-22T16:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNTkzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509705936", "bodyText": "Avoid unassigned variables.", "author": "vjeko", "createdAt": "2020-10-21T21:17:56Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNjgzNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509706835", "bodyText": "Is there a reason why return is omitted here? In this case, you still go on and do your handshake computation.", "author": "vjeko", "createdAt": "2020-10-21T21:18:59Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {\n+            try {\n+                CorfuMsg msg = (CorfuMsg) m;\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, msg);\n+                } else {\n                     log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received is not a valid CorfuMsg type.\");\n                 }\n+            } catch (Exception ex) {\n+                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n             }\n-            return;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwOTU2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509709564", "bodyText": "I would make this your base-case. It should simplify your logic.", "author": "vjeko", "createdAt": "2020-10-21T21:22:15Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 1f1beaff759..77a76ff62a5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -80,58 +80,44 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-            throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n-            return;\n-        }\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+            }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+            return;\n+        } else if (!(m instanceof ResponseMsg)) {\n+            log.error(\"channelRead: Message received is not a CorfuMsg or ResponseMsg type. Message - {}\", m);\n             return;\n         }\n \n-        UUID serverId = null;\n-        String corfuVersion = null;\n+        ResponseMsg response = ((ResponseMsg) m);\n \n-        if(m instanceof ResponseMsg) {\n-            ResponseMsg response = ((ResponseMsg) m);\n+        if (!response.getPayload().hasHandshakeResponse()) {\n+            log.warn(\"channelRead: Non-Handshake Response received. Message - {}\", response);\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, m);\n+            }\n \n-            if(response.getPayload().hasHandshakeResponse()) {\n-                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                        READ_TIMEOUT_HANDLER);\n+            return;\n+        }\n \n-                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n-                corfuVersion = handshakeResponse.getCorfuVersion();\n-                serverId = getUUID(handshakeResponse.getServerId());\n+        log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\", READ_TIMEOUT_HANDLER);\n \n-                // Remove the handler from the pipeline. Also remove the reference of the context from\n-                // the handler so that it does not disconnect the channel.\n-                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-            } else {\n-                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, m);\n-                }\n-            }\n-        } else {\n-            try {\n-                CorfuMsg msg = (CorfuMsg) m;\n-                if (this.handshakeState.completed()) {\n-                    // Only send upstream if handshake is complete.\n-                    super.channelRead(ctx, msg);\n-                } else {\n-                    log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                }\n-            } catch (Exception ex) {\n-                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n-            }\n-        }\n+        // Remove the handler from the pipeline. Also remove the reference of the context from\n+        // the handler so that it does not disconnect the channel.\n+        ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n+        HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+        String corfuVersion = handshakeResponse.getCorfuVersion();\n+        UUID serverId = getUUID(handshakeResponse.getServerId());\n \n         // Validate handshake, but first verify if node identifier is set to default (all 0's)\n         // which indicates node id matching is not required.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzQ0NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509787445", "bodyText": "You might want to throw an InvalidStateException insated in the default block.", "author": "vjeko", "createdAt": "2020-10-21T23:12:52Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 2ddcdc262c8..cf29f0cbfff 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -31,7 +31,6 @@ import java.util.stream.Collectors;\n  * objects defined in common.proto and their Java counterparts. These are used\n  * by the majority of the service RPCs.\n  */\n-\n @Slf4j\n public class CorfuProtocolCommon {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MjE2NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792165", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:27:10Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 2ddcdc262c8..cf29f0cbfff 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -31,7 +31,6 @@ import java.util.stream.Collectors;\n  * objects defined in common.proto and their Java counterparts. These are used\n  * by the majority of the service RPCs.\n  */\n-\n @Slf4j\n public class CorfuProtocolCommon {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjc2MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792760", "bodyText": "It might make sense to fail early and fail loudly here. An exception?", "author": "vjeko", "createdAt": "2020-10-21T23:29:01Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 2ddcdc262c8..cf29f0cbfff 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -31,7 +31,6 @@ import java.util.stream.Collectors;\n  * objects defined in common.proto and their Java counterparts. These are used\n  * by the majority of the service RPCs.\n  */\n-\n @Slf4j\n public class CorfuProtocolCommon {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792880", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:29:26Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try(DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 2ddcdc262c8..cf29f0cbfff 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -31,7 +31,6 @@ import java.util.stream.Collectors;\n  * objects defined in common.proto and their Java counterparts. These are used\n  * by the majority of the service RPCs.\n  */\n-\n @Slf4j\n public class CorfuProtocolCommon {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MzQ5NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509793494", "bodyText": "No need for an empty line.", "author": "vjeko", "createdAt": "2020-10-21T23:31:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\nindex b18dad0b63c..7c7f9f47307 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\n\n@@ -28,7 +28,6 @@ import java.util.UUID;\n  * in base.proto. These provide the interface for performing the RPCs\n  * handled by the Base server, as well as the handshake.\n  */\n-\n @Slf4j\n public class CorfuProtocolBase {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTAyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795026", "bodyText": "Can't you do HeaderMsg.newBuilder().mergeFrom(header).setPriority(PriorityLevel.HIGH);?", "author": "vjeko", "createdAt": "2020-10-21T23:36:35Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolMessage {\n+    public static final ProtocolVersion CURRENT_VERSION = ProtocolVersion.V0;\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UuidMsg clusterId,\n+                                         UuidMsg clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return HeaderMsg.newBuilder()\n+                .setVersion(CURRENT_VERSION)\n+                .setRequestId(requestId)\n+                .setPriority(priority)\n+                .setEpoch(epoch)\n+                .setClusterId(clusterId)\n+                .setClientId(clientId)\n+                .setIgnoreClusterId(ignoreClusterId)\n+                .setIgnoreEpoch(ignoreEpoch)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UUID clusterId,\n+                                         UUID clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestId, priority, epoch, getUuidMsg(clusterId),\n+                getUuidMsg(clientId), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Used by the server as a convenient way to copy reusable field values.\n+     *\n+     * @param header            the original request header\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(HeaderMsg header, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(header.getRequestId(),\n+                header.getPriority(),\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                ignoreClusterId,\n+                ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Use by the server to increase the priority of certain requests.\n+     *\n+     * @param header   the original request header\n+     */\n+    public static HeaderMsg getHighPriorityHeaderMsg(HeaderMsg header) {\n+        return getHeaderMsg(header.getRequestId(),\n+                PriorityLevel.HIGH,\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                header.getIgnoreClusterId(),\n+                header.getIgnoreEpoch());", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\nindex 0119ece1de8..7e3be159b2d 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n\n@@ -21,7 +21,6 @@ import static org.corfudb.protocols.CorfuProtocolCommon.*;\n  * as well as the main request and response (Protobuf) messages sent by the\n  * client and server.\n  */\n-\n @Slf4j\n public class CorfuProtocolMessage {\n     public static final ProtocolVersion CURRENT_VERSION = ProtocolVersion.V0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTc1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795759", "bodyText": "Try-with-resource might be a better approach:\ntry (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {", "author": "vjeko", "createdAt": "2020-10-21T23:39:06Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\nindex 735f1f1c5cc..ddef57a9321 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n\n@@ -28,25 +28,24 @@ public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n         if (msgMark == LEGACY_CORFU_MSG_MARK) {\n             list.add(CorfuMsg.deserialize(byteBuf));\n-        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n-                list.add(request);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                    list.add(request);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing request \"\n+                            + \"from ByteBufInputStream of byteBuf.\", e);\n+                }\n             }\n-        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n-                list.add(response);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n+                    list.add(response);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n+                }\n             }\n         } else {\n             throw new IllegalStateException(\"decode: Received an incorrectly marked message.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTk0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795947", "bodyText": "Same here -- try-with-resource.", "author": "vjeko", "createdAt": "2020-10-21T23:39:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {\n+                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                list.add(request);\n+            } catch (Exception e) {\n+                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n+            } finally {\n+                msgInputStream.close();\n+            }\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\nindex 735f1f1c5cc..ddef57a9321 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n\n@@ -28,25 +28,24 @@ public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n         if (msgMark == LEGACY_CORFU_MSG_MARK) {\n             list.add(CorfuMsg.deserialize(byteBuf));\n-        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n-                list.add(request);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                    list.add(request);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing request \"\n+                            + \"from ByteBufInputStream of byteBuf.\", e);\n+                }\n             }\n-        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n-                list.add(response);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n+                    list.add(response);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n+                }\n             }\n         } else {\n             throw new IllegalStateException(\"decode: Received an incorrectly marked message.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjI0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796244", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:40:30Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\nindex 735f1f1c5cc..ddef57a9321 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n\n@@ -28,25 +28,24 @@ public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n         if (msgMark == LEGACY_CORFU_MSG_MARK) {\n             list.add(CorfuMsg.deserialize(byteBuf));\n-        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n-                list.add(request);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                    list.add(request);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing request \"\n+                            + \"from ByteBufInputStream of byteBuf.\", e);\n+                }\n             }\n-        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n-            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n-            try {\n-                ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n-                list.add(response);\n-            } catch (Exception e) {\n-                log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n-            } finally {\n-                msgInputStream.close();\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK) {\n+            try (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {\n+                try {\n+                    ResponseMsg response = ResponseMsg.parseFrom(msgInputStream);\n+                    list.add(response);\n+                } catch (Exception e) {\n+                    log.error(\"decode: An exception occurred during parsing response from ByteBufInputStream.\", e);\n+                }\n             }\n         } else {\n             throw new IllegalStateException(\"decode: Received an incorrectly marked message.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjYzMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796633", "bodyText": "throws does not seem to be necessary.", "author": "vjeko", "createdAt": "2020-10-21T23:41:51Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex 433ad1ae662..f7c106495f5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -7,7 +7,6 @@ import io.netty.handler.codec.MessageToByteEncoder;\n import java.io.IOException;\n import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.IOUtils;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQxMA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797410", "bodyText": "try-with-resource?", "author": "vjeko", "createdAt": "2020-10-21T23:44:36Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex 433ad1ae662..f7c106495f5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -7,7 +7,6 @@ import io.netty.handler.codec.MessageToByteEncoder;\n import java.io.IOException;\n import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.IOUtils;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797428", "bodyText": "try-with-resource?", "author": "vjeko", "createdAt": "2020-10-21T23:44:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {\n+                    log.warn(\"encode[{}]: Exception occurred when encoding request {}, caused by {}\",\n+                            request.getHeader().getRequestId(), request.getHeader(), e.getCause(), e);\n+                } finally {\n+                    IOUtils.closeQuietly(requestOutputStream);\n+                }\n+            } else if (object instanceof ResponseMsg) {\n+                ResponseMsg response = (ResponseMsg) object;\n+                ByteBufOutputStream responseOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzNTI4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510335286", "bodyText": "Good idea. Will do.", "author": "zfrenette", "createdAt": "2020-10-22T17:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex 433ad1ae662..f7c106495f5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -7,7 +7,6 @@ import io.netty.handler.codec.MessageToByteEncoder;\n import java.io.IOException;\n import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.IOUtils;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODMyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509798323", "bodyText": "Style: missing space.", "author": "vjeko", "createdAt": "2020-10-21T23:47:32Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {", "originalCommit": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex 433ad1ae662..f7c106495f5 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -7,7 +7,6 @@ import io.netty.handler.codec.MessageToByteEncoder;\n import java.io.IOException;\n import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n-import org.apache.commons.io.IOUtils;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n"}}, {"oid": "2c0b73903e2701cad9c10e549f0d4eeff57f877a", "url": "https://github.com/CorfuDB/CorfuDB/commit/2c0b73903e2701cad9c10e549f0d4eeff57f877a", "message": "CorfuStore: Stream tails per table api needed for search\n\nMinor fix to getRecord() to handle null values.\nUse getOrCreate on SharedMetricRegistry for compatability with 3.1.0", "committedDate": "2020-10-22T22:02:16Z", "type": "forcePushed"}, {"oid": "db6c5e8bb0f73ccb5219701127c9692b969babce", "url": "https://github.com/CorfuDB/CorfuDB/commit/db6c5e8bb0f73ccb5219701127c9692b969babce", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-22T23:03:09Z", "type": "forcePushed"}, {"oid": "e31e8e8fcc9e88972fc485f27323fa7b3c00c76a", "url": "https://github.com/CorfuDB/CorfuDB/commit/e31e8e8fcc9e88972fc485f27323fa7b3c00c76a", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-26T23:50:51Z", "type": "forcePushed"}, {"oid": "6825f6572b1059a89600514235cdb1607a52f58b", "url": "https://github.com/CorfuDB/CorfuDB/commit/6825f6572b1059a89600514235cdb1607a52f58b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-27T14:58:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772276", "bodyText": "Codacy found an issue: The method 'channelRead(ChannelHandlerContext, Object)' has an NPath complexity of 288, current threshold is 200", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:13Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,50 +80,44 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 77a76ff62a5..93e6bf8e1a4 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -81,7 +81,9 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-        if (this.handshakeState.failed()) return;\n+        if (this.handshakeState.failed()) {\n+            return;\n+        }\n \n         if (m instanceof CorfuMsg) {\n             CorfuMsg msg = (CorfuMsg) m;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772286", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolMessage' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:14Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+@Slf4j\n+public class CorfuProtocolMessage {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\nindex 7e3be159b2d..c2d6fca341b 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n\n@@ -13,7 +13,7 @@ import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n \n import java.util.UUID;\n \n-import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n \n /**\n  * This class provides methods for creating the Protobuf objects defined\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMwMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772302", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.corfudb.protocols.CorfuProtocolCommon'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:16Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\nindex 7e3be159b2d..c2d6fca341b 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n\n@@ -13,7 +13,7 @@ import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n \n import java.util.UUID;\n \n-import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n \n /**\n  * This class provides methods for creating the Protobuf objects defined\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772321", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolCommon' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:17Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,211 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex cf29f0cbfff..680a1adfcc9 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -7,20 +7,21 @@ import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n import org.corfudb.protocols.wireprotocol.Token;\n-import org.corfudb.runtime.proto.Common.LayoutMsg;\n-import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n-import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n-import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n-import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n-import org.corfudb.runtime.proto.Common.TokenMsg;\n-import org.corfudb.runtime.proto.Common.UuidMsg;\n-import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n import org.corfudb.runtime.view.Layout;\n import org.corfudb.runtime.view.stream.StreamAddressSpace;\n import org.roaringbitmap.longlong.Roaring64NavigableMap;\n \n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.EnumMap;\n import java.util.List;\n import java.util.UUID;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjM1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772355", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolBase' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "author": "corfudb-bot", "createdAt": "2020-10-27T15:06:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+@Slf4j\n+public class CorfuProtocolBase {", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\nindex 7c7f9f47307..262395148d2 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java\n\n@@ -30,6 +30,8 @@ import java.util.UUID;\n  */\n @Slf4j\n public class CorfuProtocolBase {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolBase() {}\n \n     /**\n      * Returns a PING request message that can be sent by the client.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513549836", "bodyText": "I noticed that some other 1-line if clause below are inside curly braces, maybe we should add to make style consistent?", "author": "xcchang", "createdAt": "2020-10-28T15:42:19Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNDUwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513804505", "bodyText": "+1 we seem to expand all the if statements with curly braces. If ever a check is enforced on this it might help to keep things consistent.", "author": "hisundar", "createdAt": "2020-10-28T22:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4OTMxNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514689314", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex f3e4e327dc5..1322695f3cf 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,7 +66,9 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-        if (this.handshakeState.failed()) return;\n+        if (this.handshakeState.failed()) {\n+            return;\n+        }\n \n         if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n             log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513557349", "bodyText": "should we expand this? I think only the getUuidMsg is used", "author": "xcchang", "createdAt": "2020-10-28T15:51:35Z", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4ODg5NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514688895", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\nindex 7e3be159b2d..c2d6fca341b 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java\n\n@@ -13,7 +13,7 @@ import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n \n import java.util.UUID;\n \n-import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n \n /**\n  * This class provides methods for creating the Protobuf objects defined\n"}}, {"oid": "2673f515f96423392e648ae7999ce732741ecc3c", "url": "https://github.com/CorfuDB/CorfuDB/commit/2673f515f96423392e648ae7999ce732741ecc3c", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-29T17:41:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805306", "bodyText": "should this be m.toString() won't just printing m display just the address of the object and not its contents?", "author": "hisundar", "createdAt": "2020-10-28T22:43:33Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NDg0NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514474844", "bodyText": "I believe that .toString() is automatically invoked in the case of complex objects: See the section \"How can I log the string contents of a single (possibly complex) object?\" in http://www.slf4j.org/faq.html", "author": "zfrenette", "createdAt": "2020-10-29T18:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex f3e4e327dc5..1322695f3cf 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,7 +66,9 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-        if (this.handshakeState.failed()) return;\n+        if (this.handshakeState.failed()) {\n+            return;\n+        }\n \n         if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n             log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805361", "bodyText": "do you want this to be m.toString()?", "author": "hisundar", "createdAt": "2020-10-28T22:43:43Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);", "originalCommit": "6825f6572b1059a89600514235cdb1607a52f58b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NzkxNw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514477917", "bodyText": "See my comment above", "author": "zfrenette", "createdAt": "2020-10-29T18:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2673f515f96423392e648ae7999ce732741ecc3c", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex f3e4e327dc5..1322695f3cf 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -66,7 +66,9 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-        if (this.handshakeState.failed()) return;\n+        if (this.handshakeState.failed()) {\n+            return;\n+        }\n \n         if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n             log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514603842", "bodyText": "can we add the missing java doc for this method?", "author": "hisundar", "createdAt": "2020-10-29T22:28:49Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,33 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,", "originalCommit": "2673f515f96423392e648ae7999ce732741ecc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzMyMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687321", "bodyText": "Done", "author": "zfrenette", "createdAt": "2020-10-30T01:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\nindex ddef57a9321..6213b90a163 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n\n@@ -20,6 +22,15 @@ import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG\n @Slf4j\n public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Decodes an inbound corfu message from a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param byteBuf                 the underlying ByteBuf\n+     * @param list                    a list of decoded objects given to the\n+     *                                next pipeline handler\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514604586", "bodyText": "can we consider adding the missing java doc for this method?", "author": "hisundar", "createdAt": "2020-10-29T22:30:45Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n-    protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n-                          ByteBuf byteBuf) throws Exception {\n+    protected void encode(ChannelHandlerContext channelHandlerContext, Object object, ByteBuf byteBuf) {", "originalCommit": "2673f515f96423392e648ae7999ce732741ecc3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzIyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687229", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-10-30T01:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex f7c106495f5..a91bbcdbd52 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -23,6 +23,14 @@ public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n+    /**\n+     * Encodes an outbound corfu message into a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param object                  the object being encoded\n+     * @param byteBuf                 the underlying ByteBuf\n+     */\n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext, Object object, ByteBuf byteBuf) {\n         try {\n"}}, {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "url": "https://github.com/CorfuDB/CorfuDB/commit/8b2e1495801fd780d8a9ae682c49477941fe9b35", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-30T01:49:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515234057", "bodyText": "let's add a log line here, otherwise, it'd be pretty hard to know if a handshake failed", "author": "xnull", "createdAt": "2020-10-30T16:46:45Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,33 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-\n-        if (this.state.failed()) {\n+        if (this.handshakeState.failed()) {", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTk4Mw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515321983", "bodyText": "Done. Added a log line in both the server and client handshake handlers.", "author": "zfrenette", "createdAt": "2020-10-30T19:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "61a057f8b427b71c07ff630292a1c10d0333cf59", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 1322695f3cf..fbbd0f452ed 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -67,6 +67,7 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515236506", "bodyText": "Please don't add more logs here, ServerHandshakeHandler already a huge problem in terms of log generation.", "author": "xnull", "createdAt": "2020-10-30T16:50:29Z", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -121,16 +111,26 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         log.debug(\"channelRead: Sending handshake response: Node Id: {} Corfu Version: {}\",\n                 this.nodeId, this.corfuVersion);\n \n-        CorfuMsg handshakeResponse = CorfuMsgType.HANDSHAKE_RESPONSE\n-                .payloadMsg(new HandshakeResponse(this.nodeId, this.corfuVersion));\n-        ctx.writeAndFlush(handshakeResponse);\n \n-        // Flush messages in queue\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(((RequestMsg) m).getHeader(),\n+                getHandshakeResponseMsg(this.nodeId, this.corfuVersion));\n+\n+        ctx.writeAndFlush(response);\n+\n+        // Flush messages in queues\n         log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n+        log.debug(\"channelRead: There are [{}] responseMessages in queue to be flushed.\", this.responseMessages.size());", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjA4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322085", "bodyText": "Done. These have been removed.", "author": "zfrenette", "createdAt": "2020-10-30T19:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "61a057f8b427b71c07ff630292a1c10d0333cf59", "chunk": "diff --git a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\nindex 1322695f3cf..fbbd0f452ed 100644\n--- a/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n+++ b/infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java\n\n@@ -120,9 +121,6 @@ public class ServerHandshakeHandler extends ChannelDuplexHandler {\n         ctx.writeAndFlush(response);\n \n         // Flush messages in queues\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        log.debug(\"channelRead: There are [{}] responseMessages in queue to be flushed.\", this.responseMessages.size());\n-\n         while (!messages.isEmpty()) {\n             ctx.writeAndFlush(messages.poll());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515239880", "bodyText": "this looks weird, why not reuse SequencerStatus and get rid of SequencerMetrics? or vise versa", "author": "xnull", "createdAt": "2020-10-30T16:55:53Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3Njk0Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515276946", "bodyText": "Here we mimicked how the SequencerMetrics Java object is currently represented. Our goal was to allow for the possibility of (easily) extending the message should the RPC ever evolve. If more information about the Sequencer is ever needed, fields in the message wrapper can be added without significant changes.", "author": "zfrenette", "createdAt": "2020-10-30T17:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "61a057f8b427b71c07ff630292a1c10d0333cf59", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 680a1adfcc9..ebf295c7e0e 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -145,7 +145,7 @@ public class CorfuProtocolCommon {\n      *\n      * @param addressSpace   the desired (Java) StreamAddressSpace\n      */\n-    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n         StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n         addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515241976", "bodyText": "There is a rule: never write an error in the log if you throw an exception. They are mutually exclusive.", "author": "xnull", "createdAt": "2020-10-30T16:59:14Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            // Log the error and rethrow the exception\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTQxOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515319418", "bodyText": "Sounds good. I'll stick to logging the error for the time being. Will update shortly.", "author": "zfrenette", "createdAt": "2020-10-30T19:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjIyMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322222", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-10-30T19:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "61a057f8b427b71c07ff630292a1c10d0333cf59", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 680a1adfcc9..ebf295c7e0e 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -145,7 +145,7 @@ public class CorfuProtocolCommon {\n      *\n      * @param addressSpace   the desired (Java) StreamAddressSpace\n      */\n-    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n         StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n         addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515248733", "bodyText": "I'm concerned about the enclosed try blocks. Also, as I know we never used DataOutputStream, so not sure if we need it here.\nQuestions:\n\nwhy treamAddressSpaceMsg#addressMap is a string when it should be a map?\nIOException is a very hard exception to deal with, it would be great not to have it (but of course we shouldn't just silently ignore it)", "author": "xnull", "createdAt": "2020-10-30T17:10:01Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "originalCommit": "8b2e1495801fd780d8a9ae682c49477941fe9b35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2OTY5Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515269697", "bodyText": "The map stored in a StreamAddressSpaceMsg is a RoaringBitmap, which we represent in Protobuf as a sequence of bytes. I am not sure how we would otherwise represent it. Currently, DataOutputStream is used in ICorfuPayload to serialize the RoaringBitmap into a ByteBuf.  I tried emulating the approach by using DataOutputStream as an intermediate step since I wasn't able to serialize the map directly into a ByteString, which is how Protobuf represents a sequence of bytes.\nAs for the IO exception, the only things that seem appropriate in response to the serialization error is 1) logging an error and continuing silently, or 2), throwing an exception. Is there a more appropriate response that we haven't considered?", "author": "zfrenette", "createdAt": "2020-10-30T17:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjI4MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322281", "bodyText": "For the sake of consistency, I'd say the best approach that I know, could be:\npublic static Optional<StreamAddressSpaceMsg> getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n        \n        Optional<ByteString> maybeAddressMap = Optional.empty();\n        try (ByteString.Output bso = ByteString.newOutput()) {\n            try (DataOutputStream dos = new DataOutputStream(bso)) {\n                addressSpace.getAddressMap().serialize(dos);\n                maybeAddressMap = Optional.of(bso.toByteString());\n            }\n        } catch (IOException ex) {\n            String msg = \"getStreamAddressSpaceMsg: error=[{}] while serializing roaring64NavigableMap\";\n            log.error(msg, ex.getCause(), ex);\n        }\n        \n        return maybeAddressMap.map(addressMap ->{\n            StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n            addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n            addressSpaceMsgBuilder.setAddressMap(addressMap);\n            return addressSpaceMsgBuilder.build();\n        });\n    }\n\nBTW, who's using getStreamAddressSpaceMsg? I didn't find anything in Corfu which uses it", "author": "xnull", "createdAt": "2020-10-30T19:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDMxMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515324311", "bodyText": "This method in the API isn't used yet. It will be used by the SequencerClient/Server and LogUnitServer when the PRs replacing the implementation of these RPCs are ready to go. For example, the SequencerClient will invoke this method when performing a bootstrap to convert the streamAddressSpaceMap into a Protobuf representation before sending it over the wire.", "author": "zfrenette", "createdAt": "2020-10-30T19:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}], "type": "inlineReview", "revised_code": {"commit": "61a057f8b427b71c07ff630292a1c10d0333cf59", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 680a1adfcc9..ebf295c7e0e 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -145,7 +145,7 @@ public class CorfuProtocolCommon {\n      *\n      * @param addressSpace   the desired (Java) StreamAddressSpace\n      */\n-    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n         StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n         addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n \n"}}, {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59", "url": "https://github.com/CorfuDB/CorfuDB/commit/61a057f8b427b71c07ff630292a1c10d0333cf59", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-10-30T19:12:53Z", "type": "forcePushed"}, {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "url": "https://github.com/CorfuDB/CorfuDB/commit/64c340b533b7c60139dd7cb0efeb33b297ccccda", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-02T19:40:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295385", "bodyText": "Would be great to use enum instead of static variables, like:\nenum MessageMarker {\n  LEGACY_CORFU_MSG_MARK(0x1), PROTO_CORFU_REQUEST_MSG_MARK(0x2), PROTO_CORFU_RESPONSE_MSG_MARK(0x3)\n\n  private final byte value;\n}", "author": "xnull", "createdAt": "2020-11-02T22:33:16Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTgyOQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295829", "bodyText": "Also you don't need \"CORFU\" prefix in their names (it reduces length a bit)", "author": "xnull", "createdAt": "2020-11-02T22:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjQzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352432", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 311b3f5980b..91e960115d6 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -2,6 +2,7 @@ package org.corfudb.protocols;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516301676", "bodyText": "please rename e to something meaningful", "author": "xnull", "createdAt": "2020-11-02T22:42:52Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                Roaring64NavigableMap rm = addressSpace.getAddressMap();\n+                // Improve compression\n+                rm.runOptimize();\n+                rm.serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while serializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try (DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {\n+            roaring64NavigableMap.deserialize(dis);\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while deserializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return new StreamAddressSpace(msg.getTrimMark(), roaring64NavigableMap);\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressRange object.\n+     *\n+     * @param streamAddressRange   the desired (Java) StreamAddressRange\n+     */\n+    public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange streamAddressRange) {\n+        return StreamAddressRangeMsg.newBuilder()\n+                .setStreamId(getUuidMsg(streamAddressRange.getStreamID()))\n+                .setStart(streamAddressRange.getStart())\n+                .setEnd(streamAddressRange.getEnd())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressResponse object from its log tail and List\n+     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n+     * represented in Protobuf.\n+     *\n+     * @param tail   the log tail\n+     * @param map    a list of address map entries represented in Protobuf\n+     */\n+    public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<UuidToStreamAddressSpacePairMsg> map) {\n+        return new StreamsAddressResponse(tail, map.stream()\n+                .collect(Collectors.<UuidToStreamAddressSpacePairMsg, UUID, StreamAddressSpace>toMap(\n+                        e -> getUUID(e.getStreamUuid()),", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzIwNQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353205", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 311b3f5980b..91e960115d6 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -2,6 +2,7 @@ package org.corfudb.protocols;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n import lombok.extern.slf4j.Slf4j;\n import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308358", "bodyText": "we'd have a race condition here, in a multithreaded environment having a LinkedList. causing race conditions.\n\n\nCould you please replace it with a BlockingQueue?\n\n\nNext step - I don't see the motivation for having a queue here, can we replace it with ConcurrentHashMap? or concurrent set (ConcurrentHashMap.newKeySet())?\n\n\nSince you touched it, could you please also replace messages with a concurrent version or a concurrenthashmap? In this class and in serverhandler?", "author": "xnull", "createdAt": "2020-11-02T22:54:26Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,12 +137,16 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n+\n+        // Flush messages in queues\n         while (!messages.isEmpty()) {\n             ctx.writeAndFlush(messages.poll());\n         }\n \n+        while (!requestMessages.isEmpty()) {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjYzMg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352632", "bodyText": "Done! Used a ConcurrentHashMap as suggested.", "author": "zfrenette", "createdAt": "2020-11-03T00:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 9e180ca6e46..ef6b5fd39f2 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -138,14 +139,11 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n \n-        // Flush messages in queues\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n-\n-        while (!requestMessages.isEmpty()) {\n-            ctx.writeAndFlush(requestMessages.poll());\n-        }\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);\n+        messages.clear();\n+        requestMessages.forEach(ctx::writeAndFlush);\n+        requestMessages.clear();\n \n         // Remove this handler from the pipeline; handshake is completed.\n         log.info(\"channelRead: Removing handshake handler from pipeline.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308926", "bodyText": "Let's make \"00000000-0000-0000-0000-000000000000\" a constant, put it in to a utility class and use the constant instead of a string", "author": "xnull", "createdAt": "2020-11-02T22:55:23Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -145,19 +157,19 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n      * Channel event that is triggered when a new connected channel is created.\n      *\n      * @param ctx channel handler context\n-     * @throws Exception\n      */\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx)\n-        throws Exception {\n-        log.info(\"channelActive: Outgoing connection established to: {} from id={}\", ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        log.info(\"channelActive: Outgoing connection established to: {} from id={}\",\n+                ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+\n+        // Note: Some fields in the header are unused during the handshake process.\n+        HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n+                UUID.fromString(\"00000000-0000-0000-0000-000000000000\"), this.clientId, false, true);", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzM1MA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353350", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex 9e180ca6e46..ef6b5fd39f2 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -165,7 +163,7 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n \n         // Note: Some fields in the header are unused during the handshake process.\n         HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n-                UUID.fromString(\"00000000-0000-0000-0000-000000000000\"), this.clientId, false, true);\n+                DEFAULT_UUID, this.clientId, false, true);\n         RequestMsg request = getRequestMsg(header, getHandshakeRequestMsg(this.clientId, this.nodeId));\n \n         ctx.writeAndFlush(request);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516310587", "bodyText": "Would be great to have an enum here (I mentioned above) and replace if conditions with switch statement", "author": "xnull", "createdAt": "2020-11-02T22:58:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -1,25 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n+import java.io.IOException;\n import java.util.List;\n-\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Decodes an inbound corfu message from a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param byteBuf                 the underlying ByteBuf\n+     * @param list                    a list of decoded objects given to the\n+     *                                next pipeline handler\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjcwNA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352704", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T00:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\nindex 6213b90a163..25a5673f7a8 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java\n\n@@ -9,13 +9,10 @@ import io.netty.handler.codec.ByteToMessageDecoder;\n import java.io.IOException;\n import java.util.List;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon.MessageMarker;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n-import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n-import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n-\n /**\n  * Created by mwei on 10/1/15.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516311464", "bodyText": "why object? Can it be a proto message?", "author": "xnull", "createdAt": "2020-11-02T22:59:43Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,74 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {", "originalCommit": "64c340b533b7c60139dd7cb0efeb33b297ccccda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjgxMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516312813", "bodyText": "This is because it has to work for multiple Protobuf types: RequestMsg and ResponseMsg. And for the time being, it also has to work with legacy CorfuMsg types.", "author": "zfrenette", "createdAt": "2020-11-02T23:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\nindex a91bbcdbd52..3afd7cd2022 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java\n\n@@ -10,9 +10,9 @@ import lombok.extern.slf4j.Slf4j;\n import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n-import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n-import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.MessageMarker.LEGACY_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.MessageMarker.PROTO_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.MessageMarker.PROTO_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n"}}, {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "url": "https://github.com/CorfuDB/CorfuDB/commit/2b32e68f880358f0ab0566e491a9f81e56a590ee", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T00:11:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364331", "bodyText": "This is a tricky part: imagine another thread is adding messages at the same time when you clean the set, as a result, you would delete messages (with clear method) from the set without executing \"writeAndFlush\".\nthe code should be:\nSet< CorfuMsg> messagesToFlush = new HashSet<>(messages);\nmessagesToFlush.forEach(msg ->{\n  messages.remove(msg);\n  ctx.writeAndFlush(msg);\n});", "author": "xnull", "createdAt": "2020-11-03T00:38:19Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjI1OQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396259", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "author": "zfrenette", "createdAt": "2020-11-03T02:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364491", "bodyText": "same here", "author": "xnull", "createdAt": "2020-11-03T00:38:39Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);\n+        messages.clear();\n+        requestMessages.forEach(ctx::writeAndFlush);\n+        requestMessages.clear();", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjQ1NQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396455", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "author": "zfrenette", "createdAt": "2020-11-03T02:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516382598", "bodyText": "Can you put return on a new line?", "author": "WenbinZhu", "createdAt": "2020-11-03T01:25:23Z", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    @AllArgsConstructor\n+    public enum MessageMarker {\n+        LEGACY_MSG_MARK(0x1),\n+        PROTO_REQUEST_MSG_MARK(0x2),\n+        PROTO_RESPONSE_MSG_MARK(0x3);\n+\n+        private final int value;\n+\n+        public byte asByte() {\n+            return (byte) value;\n+        }\n+\n+        public static Map<Byte, MessageMarker> typeMap =\n+                Arrays.<MessageMarker>stream(MessageMarker.values())\n+                    .collect(Collectors.toMap(MessageMarker::asByte, Function.identity()));\n+    }\n+\n+    public static final UUID DEFAULT_UUID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDExMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410113", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA=="}], "type": "inlineReview", "revised_code": {"commit": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\nindex 91e960115d6..585346f08ff 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java\n\n@@ -151,9 +151,12 @@ public class CorfuProtocolCommon {\n      */\n     public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n         switch (msg.getSequencerStatus()) {\n-            case READY: return SequencerMetrics.READY;\n-            case NOT_READY: return SequencerMetrics.NOT_READY;\n-            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            case READY:\n+                return SequencerMetrics.READY;\n+            case NOT_READY:\n+                return SequencerMetrics.NOT_READY;\n+            case UNKNOWN:\n+                return SequencerMetrics.UNKNOWN;\n             default:\n                 throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n                         + \"Status=\" + msg.getSequencerStatus());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516394223", "bodyText": "Add the reason for dropping message?", "author": "WenbinZhu", "createdAt": "2020-11-03T02:14:41Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDEyOA==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410128", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex ef6b5fd39f2..6b74408cce9 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -83,17 +83,19 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n+            log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             return;\n         }\n \n         if (m instanceof CorfuMsg) {\n             CorfuMsg msg = (CorfuMsg) m;\n             if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n+                // If handshake completed successfully, but still a message came through this handler,\n+                // send on to the next handler in order to avoid message loss.\n                 super.channelRead(ctx, msg);\n             } else {\n-                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+                log.debug(\"channelRead: Dropping the message as the handshake \"\n+                        + \"was not completed. Message - {}\", msg.getMsgType().name());\n             }\n \n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516397947", "bodyText": "I think the original comment is more clear, can you restore that?", "author": "WenbinZhu", "createdAt": "2020-11-03T02:31:18Z", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.", "originalCommit": "2b32e68f880358f0ab0566e491a9f81e56a590ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDE1MQ==", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410151", "bodyText": "Done.", "author": "zfrenette", "createdAt": "2020-11-03T03:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "chunk": "diff --git a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\nindex ef6b5fd39f2..6b74408cce9 100644\n--- a/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n+++ b/runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java\n\n@@ -83,17 +83,19 @@ public class ClientHandshakeHandler extends ChannelDuplexHandler {\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n+            log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             return;\n         }\n \n         if (m instanceof CorfuMsg) {\n             CorfuMsg msg = (CorfuMsg) m;\n             if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n+                // If handshake completed successfully, but still a message came through this handler,\n+                // send on to the next handler in order to avoid message loss.\n                 super.channelRead(ctx, msg);\n             } else {\n-                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n+                log.debug(\"channelRead: Dropping the message as the handshake \"\n+                        + \"was not completed. Message - {}\", msg.getMsgType().name());\n             }\n \n             return;\n"}}, {"oid": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f55d3e1f35d97404f571eb24b4ef157575ba978b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T03:25:53Z", "type": "commit"}, {"oid": "f55d3e1f35d97404f571eb24b4ef157575ba978b", "url": "https://github.com/CorfuDB/CorfuDB/commit/f55d3e1f35d97404f571eb24b4ef157575ba978b", "message": "Add Protobuf RPC schema and update handshake\n\nIntroduces the Protobuf schema for RPCs and updates the handshake\nprocess to exchange Protobuf messages. Done as part of an effort to\nsupport rolling upgrades.", "committedDate": "2020-11-03T03:25:53Z", "type": "forcePushed"}]}