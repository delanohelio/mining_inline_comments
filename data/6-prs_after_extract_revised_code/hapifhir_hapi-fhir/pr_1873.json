{"pr_number": 1873, "pr_title": "Improve Period range indexing", "pr_createdAt": "2020-05-26T20:32:52Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1873", "timeline": [{"oid": "d802434928204dfdf2a63675b49546a921716678", "url": "https://github.com/hapifhir/hapi-fhir/commit/d802434928204dfdf2a63675b49546a921716678", "message": "Fix #1871 - Handle period range searches better", "committedDate": "2020-05-26T20:01:00Z", "type": "commit"}, {"oid": "27bef521c94aceee6ebbdace4bd9d89c9f79c970", "url": "https://github.com/hapifhir/hapi-fhir/commit/27bef521c94aceee6ebbdace4bd9d89c9f79c970", "message": "Add changelog", "committedDate": "2020-05-26T20:32:00Z", "type": "commit"}, {"oid": "447f5745d8318fd90f38bb8b9d3b715eb31759ab", "url": "https://github.com/hapifhir/hapi-fhir/commit/447f5745d8318fd90f38bb8b9d3b715eb31759ab", "message": "FIx tests", "committedDate": "2020-05-26T22:18:39Z", "type": "commit"}, {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "url": "https://github.com/hapifhir/hapi-fhir/commit/9e5be6f5c6ab47c0f09947bdb809bf156629badf", "message": "Add test logging", "committedDate": "2020-05-26T23:42:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431476421", "bodyText": "Why not 0000-01-01 and 9999-12-31 ?", "author": "fil512", "createdAt": "2020-05-27T22:22:41Z", "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java", "diffHunk": "@@ -50,6 +54,8 @@\n \t\t\"http://hl7.org/fhir/StructureDefinition/*\")));\n \n \tpublic static final String DEFAULT_WEBSOCKET_CONTEXT_PATH = \"/websocket\";\n+\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1700-01-01\";", "originalCommit": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjkyOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431476929", "bodyText": "Someone might want to store genealogy data (or even ancestral disease information) that predates this date.", "author": "fil512", "createdAt": "2020-05-27T22:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzE1NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431477155", "bodyText": "On the other hand, we should check that these dates work okay on the main databases, esp the timestamp versions of them.", "author": "fil512", "createdAt": "2020-05-27T22:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxNjU1OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431716558", "bodyText": "Did a bit of digging into supported limits in databases:\n\n\nJDBC Timestamp Datatype Low Value -4713 and High Value 9999\nMySQL 8: the range for DATETIME values is '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999`\nPostgresql 12: Timestamp [without time zone] Low Value 4713 BC and High Value 294276 AD\nOracle: Timestamp Low Value 4712 BC and High Value 9999 CE\nH2: datetime2 Low Value -4713 and High Value 9999\n\n\nI'm gonna go with 1001 - 9000 for safety", "author": "jamesagnew", "createdAt": "2020-05-28T09:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "chunk": "diff --git a/hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java b/hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java\nindex 141b164dc9..d417823174 100644\n--- a/hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java\n+++ b/hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java\n\n@@ -54,8 +54,21 @@ public class ModelConfig {\n \t\t\"http://hl7.org/fhir/StructureDefinition/*\")));\n \n \tpublic static final String DEFAULT_WEBSOCKET_CONTEXT_PATH = \"/websocket\";\n-\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1700-01-01\";\n-\tprotected static final String DEFAULT_PERIOD_INDEX_END_OF_TIME = \"2600-01-01\";\n+\n+\t/*\n+\t * <p>\n+\t * Note the following database documented limitations:\n+\t *    <ul>\n+\t *       <li>JDBC Timestamp Datatype Low Value -4713 and High Value 9999</li>\n+\t *       <li>MySQL 8: the range for DATETIME values is '1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999`</li>\n+\t *       <li>Postgresql 12: Timestamp [without time zone] Low Value 4713 BC and High Value 294276 AD</li>\n+\t *       <li>Oracle: Timestamp Low Value 4712 BC and High Value 9999 CE</li>\n+\t *       <li>H2: datetime2 Low Value -4713 and High Value 9999</li>\n+\t *     </ul>\n+\t * </p>\n+\t */\n+\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1001-01-01\";\n+\tprotected static final String DEFAULT_PERIOD_INDEX_END_OF_TIME = \"9000-01-01\";\n \t/**\n \t * update setter javadoc if default changes\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODQyMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431478422", "bodyText": "I'm surprised you didn't need the DatePredicate logic.  I guess those queries just never worked?", "author": "fil512", "createdAt": "2020-05-27T22:27:52Z", "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/BaseSearchParamExtractor.java", "diffHunk": "@@ -677,6 +677,16 @@ private void addDate_Period(String theResourceType, Set<ResourceIndexedSearchPar\n \t\tString endAsString = extractValueAsString(myPeriodEndValueChild, theValue);\n \n \t\tif (start != null || end != null) {\n+\n+\t\t\tif (start == null) {\n+\t\t\t\tstart = myModelConfig.getPeriodIndexStartOfTime().getValue();\n+\t\t\t\tstartAsString = myModelConfig.getPeriodIndexStartOfTime().getValueAsString();\n+\t\t\t}\n+\t\t\tif (end == null) {\n+\t\t\t\tend = myModelConfig.getPeriodIndexEndOfTime().getValue();", "originalCommit": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2MTkyOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431761928", "bodyText": "Yup. I'm happy about that aspect of this change, no modifications to the search predicate logic were required.\nIt's not as bad as it maybe seemed- Date range searches almost all worked, there are only 2 cases that didn't:\n\nIndexed period with a lower bound and no upper bound, and then a search by date where the selector is gt ( a value > the lower bound)\nIndexed period with an upper bound and no lower bound, and then a search by date where the selector is lt ( a value < the upper bound)", "author": "jamesagnew", "createdAt": "2020-05-28T11:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODQyMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODg2OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431478868", "bodyText": "Did this case just not work, so the assert was commented out?", "author": "fil512", "createdAt": "2020-05-27T22:29:07Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4Test.java", "diffHunk": "@@ -1118,143 +1118,6 @@ public void testCreateWrongType() {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testDatePeriodParamEndOnly() {\n-\t\t{\n-\t\t\tEncounter enc = new Encounter();\n-\t\t\tenc.addIdentifier().setSystem(\"testDatePeriodParam\").setValue(\"02\");\n-\t\t\tenc.getPeriod().getEndElement().setValueAsString(\"2001-01-02\");\n-\t\t\tmyEncounterDao.create(enc, mySrd);\n-\t\t}\n-\t\tSearchParameterMap params;\n-\t\tList<Encounter> encs;\n-\n-\t\tparams = new SearchParameterMap();\n-\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(null, \"2001-01-03\"));\n-\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n-\t\tencs = toList(myEncounterDao.search(params));\n-\t\tassertEquals(1, encs.size());\n-\n-\t\tparams = new SearchParameterMap();\n-\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(\"2001-01-01\", \"2001-01-03\"));\n-\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n-\t\t// encs = toList(ourEncounterDao.search(params));\n-\t\t// assertEquals(1, encs.size());", "originalCommit": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc1OTg4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431759883", "bodyText": "These tests weren't actually removed, I just moved them from FhirResourceDaoR4Test to FhirResourceDaoR4SearchNoFtTest.java in order to make them easier to find (that's where all the tests for the other search datatypes were, no idea why the date ones were here!)", "author": "jamesagnew", "createdAt": "2020-05-28T11:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2MjEzOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431762139", "bodyText": "Uncommented in the other class, and it does work now!", "author": "jamesagnew", "createdAt": "2020-05-28T11:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODg2OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTUwMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431479501", "bodyText": "Does this work now if you uncomment it?  Should it work?", "author": "fil512", "createdAt": "2020-05-27T22:30:40Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -1690,6 +1691,338 @@ public void testSearchDateWrongParam() {\n \n \t}\n \n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDateTime_NoUpperBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getStartElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// ge -> above the lower bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> above the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDate_NoUpperBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getStartElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// ge -> above the lower bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> above the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDateTime_NoLowerBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getEndElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// le -> above the upper bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> above the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\n+\t\t// ge -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDate_NoLowerBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getEndElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// le -> above the upper bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> above the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\n+\t\t// ge -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDatePeriodParamEndOnly() {\n+\t\t{\n+\t\t\tEncounter enc = new Encounter();\n+\t\t\tenc.addIdentifier().setSystem(\"testDatePeriodParam\").setValue(\"02\");\n+\t\t\tenc.getPeriod().getEndElement().setValueAsString(\"2001-01-02\");\n+\t\t\tmyEncounterDao.create(enc, mySrd);\n+\t\t}\n+\t\tSearchParameterMap params;\n+\t\tList<Encounter> encs;\n+\n+\t\tparams = new SearchParameterMap();\n+\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(null, \"2001-01-03\"));\n+\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n+\t\tencs = toList(myEncounterDao.search(params));\n+\t\tassertEquals(1, encs.size());\n+\n+\t\tparams = new SearchParameterMap();\n+\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(\"2001-01-01\", \"2001-01-03\"));\n+\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n+\t\t// encs = toList(ourEncounterDao.search(params));\n+\t\t// assertEquals(1, encs.size());", "originalCommit": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc1OTAyMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431759022", "bodyText": "Ah good call! It totally does.", "author": "jamesagnew", "createdAt": "2020-05-28T11:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc2MjMwMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431762300", "bodyText": "Indeed it does!", "author": "jamesagnew", "createdAt": "2020-05-28T11:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java b/hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java\nindex 3e47b3ec2c..e35bc418ff 100644\n--- a/hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java\n+++ b/hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java\n\n@@ -1698,8 +1697,8 @@ public class FhirResourceDaoR4SearchNoFtTest extends BaseJpaR4Test {\n \t\tenc.getPeriod().getStartElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n \t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n \n-\t\trunInTransaction(()->{\n-\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\trunInTransaction(() -> {\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t -> t.toString()).collect(Collectors.joining(\"\\n * \")));\n \t\t});\n \n \t\t// ge -> above the lower bound\n"}}, {"oid": "9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "url": "https://github.com/hapifhir/hapi-fhir/commit/9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "message": "Address review comments", "committedDate": "2020-05-28T11:20:21Z", "type": "commit"}]}