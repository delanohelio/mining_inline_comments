{"pr_number": 2177, "pr_title": "Remove all references to Person from EMPI.", "pr_createdAt": "2020-11-17T02:20:23Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/2177", "timeline": [{"oid": "c64ca813739ffa111458f1684a5f783e3149ede4", "url": "https://github.com/hapifhir/hapi-fhir/commit/c64ca813739ffa111458f1684a5f783e3149ede4", "message": "Removed obsolete tests", "committedDate": "2020-11-27T22:11:52Z", "type": "commit"}, {"oid": "da3df490890b22bc48ae320d5efc3d1d1c98b420", "url": "https://github.com/hapifhir/hapi-fhir/commit/da3df490890b22bc48ae320d5efc3d1d1c98b420", "message": "Fixed build failures", "committedDate": "2020-11-27T23:00:24Z", "type": "commit"}, {"oid": "db28a94eee60b0096390775565cdeec72337144d", "url": "https://github.com/hapifhir/hapi-fhir/commit/db28a94eee60b0096390775565cdeec72337144d", "message": "Resolved alerts", "committedDate": "2020-11-30T14:09:38Z", "type": "commit"}, {"oid": "3f3b811b16f5f19df1e7d104393f4aa2bbc2a351", "url": "https://github.com/hapifhir/hapi-fhir/commit/3f3b811b16f5f19df1e7d104393f4aa2bbc2a351", "message": "Fixed Foreign Key references", "committedDate": "2020-11-30T22:21:56Z", "type": "commit"}, {"oid": "d63c580e82da79ec426eabf2758831a219f1a8f9", "url": "https://github.com/hapifhir/hapi-fhir/commit/d63c580e82da79ec426eabf2758831a219f1a8f9", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-01T18:18:42Z", "type": "commit"}, {"oid": "417ae55cb4a5eba7462138f4fa3ccfcf6f2a3d1d", "url": "https://github.com/hapifhir/hapi-fhir/commit/417ae55cb4a5eba7462138f4fa3ccfcf6f2a3d1d", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-02T14:29:47Z", "type": "commit"}, {"oid": "ffee7a894ff0a1f4d48cfbb17ed8a31e6c60a84f", "url": "https://github.com/hapifhir/hapi-fhir/commit/ffee7a894ff0a1f4d48cfbb17ed8a31e6c60a84f", "message": "Removed person refs", "committedDate": "2020-12-02T22:41:42Z", "type": "commit"}, {"oid": "6d74f4f39899a182bea792a834b4bd6fec641fa7", "url": "https://github.com/hapifhir/hapi-fhir/commit/6d74f4f39899a182bea792a834b4bd6fec641fa7", "message": "Fixed alert", "committedDate": "2020-12-03T02:00:49Z", "type": "commit"}, {"oid": "4352e0a61fa89058b5bab14493d857adb4f4b60c", "url": "https://github.com/hapifhir/hapi-fhir/commit/4352e0a61fa89058b5bab14493d857adb4f4b60c", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-03T16:28:21Z", "type": "commit"}, {"oid": "499a68a093f8dd25b04b32c2199389c290ed1659", "url": "https://github.com/hapifhir/hapi-fhir/commit/499a68a093f8dd25b04b32c2199389c290ed1659", "message": "Reviewed docs and added change entry", "committedDate": "2020-12-03T20:53:06Z", "type": "commit"}, {"oid": "5c40afb0c905ea93bd7d1f156fa77d3a4eddb4fb", "url": "https://github.com/hapifhir/hapi-fhir/commit/5c40afb0c905ea93bd7d1f156fa77d3a4eddb4fb", "message": "Updated doc headers", "committedDate": "2020-12-03T21:11:10Z", "type": "commit"}, {"oid": "51b3fb05250cbd209c0aa60555285fa8e83b4ba3", "url": "https://github.com/hapifhir/hapi-fhir/commit/51b3fb05250cbd209c0aa60555285fa8e83b4ba3", "message": "Synced Provider impl bw R4 and Dstu3", "committedDate": "2020-12-04T16:57:40Z", "type": "commit"}, {"oid": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "url": "https://github.com/hapifhir/hapi-fhir/commit/f5f7f2df14f732c131b360087deaa0b4827b05b5", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-07T16:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNzMyMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537707323", "bodyText": "I recommend renaming to: myNewGoldenResource", "author": "fil512", "createdAt": "2020-12-07T17:53:04Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java", "diffHunk": "@@ -99,56 +107,67 @@\n \n \t/** This link created a new person **/\n \t@Column(name = \"NEW_PERSON\")\n-\tprivate Boolean myNewPerson;\n+\tprivate Boolean myHadToCreateNewResource;", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 6534658003..6e551ac1de 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n\n@@ -106,8 +97,8 @@ public class MdmLink {\n \tprivate Boolean myEidMatch;\n \n \t/** This link created a new person **/\n-\t@Column(name = \"NEW_PERSON\")\n-\tprivate Boolean myHadToCreateNewResource;\n+\t@Column(name = \"NEW_GOLDEN_RESOURCE\")\n+\tprivate Boolean myHadToCreateNewGoldenResource;\n \n \t@Column(name = \"VECTOR\")\n \tprivate Long myVector;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwODc0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537708748", "bodyText": "these can be removed", "author": "fil512", "createdAt": "2020-12-07T17:55:09Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java", "diffHunk": "@@ -31,34 +31,35 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiLoader {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiLoader.class);\n+public class MdmLoader {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmLoader.class);\n \n \t@Autowired\n-\tIEmpiSettings myEmpiProperties;\n+\tIMdmSettings myMdmSettings;\n \t@Autowired\n-\tEmpiProviderLoader myEmpiProviderLoader;\n+\tMdmProviderLoader myMdmProviderLoader;\n \t@Autowired\n-\tEmpiSubscriptionLoader myEmpiSubscriptionLoader;\n+\tMdmSubscriptionLoader myMdmSubscriptionLoader;\n \t@Autowired\n-\tEmpiSearchParameterLoader myEmpiSearchParameterLoader;\n+\tMdmSearchParameterLoader myMdmSearchParameterLoader;\n \n \t@EventListener(classes = {ContextRefreshedEvent.class})\n \t// This @Order is here to ensure that MatchingQueueSubscriberLoader has initialized before we initialize this.\n-\t// Otherwise the EMPI subscriptions won't get loaded into the SubscriptionRegistry\n+\t// Otherwise the MDM subscriptions won't get loaded into the SubscriptionRegistry\n \t@Order\n \tpublic void updateSubscriptions() {\n-\t\tif (!myEmpiProperties.isEnabled()) {\n+\t\tif (!myMdmSettings.isEnabled()) {\n \t\t\treturn;\n \t\t}\n \n-\t\tmyEmpiProviderLoader.loadProvider();\n-\t\tourLog.info(\"EMPI provider registered\");\n+\t\tmyMdmProviderLoader.loadProvider();\n+\t\tourLog.info(\"MDM provider registered\");\n \n-\t\tmyEmpiSubscriptionLoader.daoUpdateEmpiSubscriptions();\n-\t\tourLog.info(\"EMPI subscriptions updated\");\n+\t\tmyMdmSubscriptionLoader.daoUpdateMdmSubscriptions();\n+\t\tourLog.info(\"MDM subscriptions updated\");\n \n-\t\tmyEmpiSearchParameterLoader.daoUpdateEmpiSearchParameters();\n-\t\tourLog.info(\"EMPI search parameters updated\");\n+\t\t//TODO GGG MDM: Do we need these search parameters, or equivalent, anymore? Don't think so... ask @fil512\n+\t\tmyMdmSearchParameterLoader.daoUpdateMdmSearchParameters();", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\nindex 57b5b076a3..84a9c860cf 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmLoader.java\n\n@@ -40,8 +40,6 @@ public class MdmLoader {\n \tMdmProviderLoader myMdmProviderLoader;\n \t@Autowired\n \tMdmSubscriptionLoader myMdmSubscriptionLoader;\n-\t@Autowired\n-\tMdmSearchParameterLoader myMdmSearchParameterLoader;\n \n \t@EventListener(classes = {ContextRefreshedEvent.class})\n \t// This @Order is here to ensure that MatchingQueueSubscriberLoader has initialized before we initialize this.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwOTE1Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537709156", "bodyText": "remove this class", "author": "fil512", "createdAt": "2020-12-07T17:55:38Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java", "diffHunk": "@@ -32,40 +32,42 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiSearchParameterLoader {\n-\tpublic static final String EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID = \"person-assurance\";\n-\tpublic static final String EMPI_PERSON_ACTIVE_SEARCH_PARAMETER_ID = \"person-active\";\n+public class MdmSearchParameterLoader {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\ndeleted file mode 100644\nindex 1d7233d5ea..0000000000\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-package ca.uhn.fhir.jpa.mdm.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.ConfigurationException;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.mdm.api.MdmConstants;\n-import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n-import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.r4.model.Enumerations;\n-import org.hl7.fhir.r4.model.SearchParameter;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-@Service\n-public class MdmSearchParameterLoader {\n-\n-\tpublic static final String MDM_PERSON_ASSURANCE_SEARCH_PARAMETER_ID = \"person-assurance\";\n-\tpublic static final String MDM_PERSON_ACTIVE_SEARCH_PARAMETER_ID = \"person-active\";\n-\n-\t@Autowired\n-\tpublic FhirContext myFhirContext;\n-\t@Autowired\n-\tpublic DaoRegistry myDaoRegistry;\n-\n-\tsynchronized public void daoUpdateMdmSearchParameters() {\n-\t\tIBaseResource goldenResourceAssurance;\n-\t\tIBaseResource goldenResourceActive;\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase DSTU3:\n-\t\t\t\tgoldenResourceAssurance = buildAssuranceMdmSearchParameterDstu3();\n-\t\t\t\tgoldenResourceActive = buildActiveMdmSearchParameterDstu3();\n-\t\t\t\tbreak;\n-\t\t\tcase R4:\n-\t\t\t\tgoldenResourceAssurance = buildAssuranceMdmSearchParameterR4();\n-\t\t\t\tgoldenResourceActive = buildActiveMdmSearchParameterR4();\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new ConfigurationException(\"MDM not supported for FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\n-\t\tIFhirResourceDao<IBaseResource> searchParameterDao = myDaoRegistry.getResourceDao(\"SearchParameter\");\n-\t\tsearchParameterDao.update(goldenResourceAssurance);\n-\t\tsearchParameterDao.update(goldenResourceActive);\n-\t}\n-\n-\tprivate org.hl7.fhir.dstu3.model.SearchParameter buildAssuranceMdmSearchParameterDstu3() {\n-\t\torg.hl7.fhir.dstu3.model.SearchParameter retval = new org.hl7.fhir.dstu3.model.SearchParameter();\n-\t\tretval.setId(MDM_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n-\t\tretval.setStatus(org.hl7.fhir.dstu3.model.Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n-\t\tretval.setCode(\"assurance\");\n-\t\tretval.addBase(\"Person\");\n-\t\tretval.setType(org.hl7.fhir.dstu3.model.Enumerations.SearchParamType.TOKEN);\n-\t\tretval.setDescription(\"The assurance level of the link on a Person\");\n-\t\tretval.setExpression(\"Person.link.assurance\");\n-\t\treturn retval;\n-\t}\n-\n-\tprivate SearchParameter buildAssuranceMdmSearchParameterR4() {\n-\t\tSearchParameter retval = new SearchParameter();\n-\t\tretval.setId(MDM_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n-\t\tretval.setStatus(Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n-\t\tretval.setCode(\"assurance\");\n-\t\tretval.addBase(\"Person\");\n-\t\tretval.setType(Enumerations.SearchParamType.TOKEN);\n-\t\tretval.setDescription(\"The assurance level of the link on a Person\");\n-\t\tretval.setExpression(\"Person.link.assurance\");\n-\t\treturn retval;\n-\t}\n-\n-\tprivate org.hl7.fhir.dstu3.model.SearchParameter buildActiveMdmSearchParameterDstu3() {\n-\t\torg.hl7.fhir.dstu3.model.SearchParameter retval = new org.hl7.fhir.dstu3.model.SearchParameter();\n-\t\tretval.setId(MDM_PERSON_ACTIVE_SEARCH_PARAMETER_ID);\n-\t\tretval.setStatus(org.hl7.fhir.dstu3.model.Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n-\t\tretval.setCode(\"active\");\n-\t\tretval.addBase(\"Person\");\n-\t\tretval.setType(org.hl7.fhir.dstu3.model.Enumerations.SearchParamType.TOKEN);\n-\t\tretval.setDescription(\"The active status of a Person\");\n-\t\tretval.setExpression(\"Person.active\");\n-\t\treturn retval;\n-\t}\n-\n-\tprivate SearchParameter buildActiveMdmSearchParameterR4() {\n-\t\tSearchParameter retval = new SearchParameter();\n-\t\tretval.setId(MDM_PERSON_ACTIVE_SEARCH_PARAMETER_ID);\n-\t\tretval.setStatus(Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n-\t\tretval.setCode(\"active\");\n-\t\tretval.addBase(\"Person\");\n-\t\tretval.setType(Enumerations.SearchParamType.TOKEN);\n-\t\tretval.setDescription(\"The active status of a Person\");\n-\t\tretval.setExpression(\"Person.active\");\n-\t\treturn retval;\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDQ0Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537710446", "bodyText": "Git is seeing these as delete / add which makes it harder to review.  If possible, it's better to rename and move classes in a git aware fashion so it can track the deltas.  It's possible that git just isn't able to do this...", "author": "fil512", "createdAt": "2020-12-07T17:57:22Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,338 @@\n+package ca.uhn.fhir.jpa.mdm.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IMdmLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n+import ca.uhn.fhir.mdm.api.MdmMatchOutcome;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class MdmLinkDaoSvc {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\nindex fe093af485..08b4268c35 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/dao/MdmLinkDaoSvc.java\n\n@@ -60,24 +60,24 @@ public class MdmLinkDaoSvc {\n \tprivate FhirContext myFhirContext;\n \n \t@Transactional\n-\tpublic MdmLink createOrUpdateLinkEntity(IBaseResource theGoldenResource, IBaseResource theTargetResource, MdmMatchOutcome theMatchOutcome, MdmLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n+\tpublic MdmLink createOrUpdateLinkEntity(IBaseResource theGoldenResource, IBaseResource theSourceResource, MdmMatchOutcome theMatchOutcome, MdmLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n \t\tLong goldenResourcePid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n \n-\t\tMdmLink mdmLink = getOrCreateMdmLinkByGoldenResourcePidAndTargetResourcePid(goldenResourcePid, targetResourcePid);\n+\t\tMdmLink mdmLink = getOrCreateMdmLinkByGoldenResourcePidAndSourceResourcePid(goldenResourcePid, sourceResourcePid);\n \t\tmdmLink.setLinkSource(theLinkSource);\n \t\tmdmLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n \t\t// Preserve these flags for link updates\n \t\tmdmLink.setEidMatch(theMatchOutcome.isEidMatch() | mdmLink.isEidMatch());\n-\t\tmdmLink.setHadToCreateNewResource(theMatchOutcome.isCreatedNewResource() | mdmLink.getHadToCreateNewResource());\n-\t\tmdmLink.setMdmTargetType(myFhirContext.getResourceType(theTargetResource));\n+\t\tmdmLink.setHadToCreateNewGoldenResource(theMatchOutcome.isCreatedNewResource() | mdmLink.getHadToCreateNewGoldenResource());\n+\t\tmdmLink.setMdmSourceType(myFhirContext.getResourceType(theSourceResource));\n \t\tif (mdmLink.getScore() != null) {\n \t\t\tmdmLink.setScore(Math.max(theMatchOutcome.score, mdmLink.getScore()));\n \t\t} else {\n \t\t\tmdmLink.setScore(theMatchOutcome.score);\n \t\t}\n \n-\t\tString message = String.format(\"Creating MdmLink from %s to %s -> %s\", theGoldenResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\tString message = String.format(\"Creating MdmLink from %s to %s -> %s\", theGoldenResource.getIdElement().toUnqualifiedVersionless(), theSourceResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n \t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n \t\tourLog.debug(message);\n \t\tsave(mdmLink);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMTQ2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537711465", "bodyText": "What's the plan with these TODOs?  Will they be addressed in a future PR?", "author": "fil512", "createdAt": "2020-12-07T17:58:49Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java", "diffHunk": "@@ -45,72 +45,71 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n @Service\n-public class EmpiStorageInterceptor implements IEmpiStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiStorageInterceptor.class);\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n \t@Autowired\n \tprivate ExpungeEverythingService myExpungeEverythingService;\n \t@Autowired\n-\tprivate EmpiLinkDeleteSvc myEmpiLinkDeleteSvc;\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n \t@Autowired\n \tprivate FhirContext myFhirContext;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualPersonManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO EMPI find a better way to identify EMPI calls\n+\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tforbidIfEmpiManagedTagIsPresent(theBaseResource);\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n \t}\n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualPersonManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theNewResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theNewResource);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (EmpiUtil.isEmpiManagedPerson(myFhirContext, theNewResource) &&\n-\t\t\tmyPersonHelper.isDeactivated(theNewResource)) {\n-\t\t\tourLog.debug(\"Deleting empi links to deactivated Person {}\", theNewResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myEmpiLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theNewResource);\n+\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex 7481cc148c..ba5d09ae97 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n\n@@ -69,7 +69,7 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n+\t\t// TODO GGG MDM find a better way to identify internal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzkxMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537713910", "bodyText": "I was initially thrown by the term \"deactivated\" but I think it's a good term here.  It does make me wonder if there's a better one.  What do other mdm systems call this...?", "author": "fil512", "createdAt": "2020-12-07T18:02:10Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java", "diffHunk": "@@ -45,72 +45,71 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n @Service\n-public class EmpiStorageInterceptor implements IEmpiStorageInterceptor {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(EmpiStorageInterceptor.class);\n+public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(MdmStorageInterceptor.class);\n \t@Autowired\n \tprivate ExpungeEverythingService myExpungeEverythingService;\n \t@Autowired\n-\tprivate EmpiLinkDeleteSvc myEmpiLinkDeleteSvc;\n+\tprivate MdmLinkDeleteSvc myMdmLinkDeleteSvc;\n \t@Autowired\n \tprivate FhirContext myFhirContext;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_CREATED)\n-\tpublic void blockManualPersonManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n+\tpublic void blockManualResourceManipulationOnCreate(IBaseResource theBaseResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO EMPI find a better way to identify EMPI calls\n+\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tforbidIfEmpiManagedTagIsPresent(theBaseResource);\n+\t\tforbidIfMdmManagedTagIsPresent(theBaseResource);\n \t}\n \n \t@Hook(Pointcut.STORAGE_PRESTORAGE_RESOURCE_UPDATED)\n-\tpublic void blockManualPersonManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theNewResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n-\n+\tpublic void blockManualGoldenResourceManipulationOnUpdate(IBaseResource theOldResource, IBaseResource theUpdatedResource, RequestDetails theRequestDetails, ServletRequestDetails theServletRequestDetails) {\n \t\t//If running in single EID mode, forbid multiple eids.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tforbidIfHasMultipleEids(theNewResource);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tforbidIfHasMultipleEids(theUpdatedResource);\n \t\t}\n \n-\t\tif (EmpiUtil.isEmpiManagedPerson(myFhirContext, theNewResource) &&\n-\t\t\tmyPersonHelper.isDeactivated(theNewResource)) {\n-\t\t\tourLog.debug(\"Deleting empi links to deactivated Person {}\", theNewResource.getIdElement().toUnqualifiedVersionless());\n-\t\t\tint deleted = myEmpiLinkDeleteSvc.deleteNonRedirectWithWithAnyReferenceTo(theNewResource);\n+\t\t//TODO GGG MDM: Check if this is actually handled already in mdm update code or not.\n+\t\tif (myGoldenResourceHelper.isDeactivated(theUpdatedResource)) {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\nindex 7481cc148c..ba5d09ae97 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/interceptor/MdmStorageInterceptor.java\n\n@@ -69,7 +69,7 @@ public class MdmStorageInterceptor implements IMdmStorageInterceptor {\n \t\t\tforbidIfHasMultipleEids(theBaseResource);\n \t\t}\n \n-\t\t// TODO GGG MDM find a better way to identify i nternal calls?\n+\t\t// TODO GGG MDM find a better way to identify internal calls?\n \t\tif (isInternalRequest(theRequestDetails)) {\n \t\t\treturn;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxNjg5Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537716893", "bodyText": "hmm.  I don't understand the question", "author": "fil512", "createdAt": "2020-12-07T18:06:43Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java", "diffHunk": "@@ -32,43 +33,48 @@\n import java.util.List;\n \n @Service\n-public class EmpiResourceFilteringSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmResourceFilteringSvc {\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n-\tEmpiSearchParamSvc myEmpiSearchParamSvc;\n+\tMdmSearchParamSvc myMdmSearchParamSvc;\n \t@Autowired\n \tFhirContext myFhirContext;\n \n \t/**\n-\t * Given a resource from the EMPI Channel, determine whether or not EMPI processing should occur on it.\n+\t * Given a resource from the MDM Channel, determine whether or not MDM processing should occur on it.\n \t *\n-\t * EMPI processing should occur if for any {@link EmpiResourceSearchParamJson) Search Param, the resource contains a value.\n+\t * MDM processing should occur if for any {@link MdmResourceSearchParamJson ) Search Param, the resource contains a value.\n \t *\n \t * If the resource has no attributes that appear in the candidate search params, processing should be skipped, as there is not\n-\t * sufficient information to perform meaningful EMPI processing. (For example, how can EMPI processing occur on a patient that has _no_ attributes?)\n+\t * sufficient information to perform meaningful MDM processing. (For example, how can MDM processing occur on a patient that has _no_ attributes?)\n \t *\n-\t * @param theResource the resource that you wish to check against EMPI rules.\n+\t * @param theResource the resource that you wish to check against MDM rules.\n \t *\n-\t * @return whether or not EMPI processing should proceed\n+\t * @return whether or not MDM processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n+\t\t//TODO GGG ask KHS: Skip the infinite loop, whoops. Better way to do this? tighter subscription criteria?", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb429b319b4164f72588810ac9102e240161803", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\nindex 07e2b7298a..af7199ea0a 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceFilteringSvc.java\n\n@@ -56,11 +56,11 @@ public class MdmResourceFilteringSvc {\n \t * @return whether or not MDM processing should proceed\n \t */\n \tpublic boolean shouldBeProcessed(IAnyResource theResource) {\n-\t\t//TODO GGG ask KHS: Skip the infinite loop, whoops. Better way to do this? tighter subscription criteria?\n \t\tif (MdmUtil.isMdmManaged(theResource)) {\n \t\t\tourLog.debug(\"MDM Message handler is dropping [{}] as it is MDM-managed.\", theResource);\n \t\t\treturn false;\n \t\t}\n+\n \t\tString resourceType = myFhirContext.getResourceType(theResource);\n \t\tList<MdmResourceSearchParamJson> candidateSearchParams = myMdmSettings.getMdmRules().getCandidateSearchParams();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxNzYwNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537717604", "bodyText": "Consider renaming to FindCandidateByExampleSvc", "author": "fil512", "createdAt": "2020-12-07T18:07:49Z", "path": "hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByScoreSvc.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package ca.uhn.fhir.jpa.mdm.svc.candidate;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.api.IMdmMatchFinderSvc;\n+import ca.uhn.fhir.mdm.api.MatchedTarget;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.mdm.dao.MdmLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.MdmLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class FindCandidateByScoreSvc extends BaseCandidateFinder {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByScoreSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByExampleSvc.java\nsimilarity index 95%\nrename from hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByScoreSvc.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByExampleSvc.java\nindex df6086d91e..bc8b43efaf 100644\n--- a/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByScoreSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/FindCandidateByExampleSvc.java\n\n@@ -41,7 +41,7 @@ import java.util.Optional;\n import java.util.stream.Collectors;\n \n @Service\n-public class FindCandidateByScoreSvc extends BaseCandidateFinder {\n+public class FindCandidateByExampleSvc extends BaseCandidateFinder {\n \tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMDAzMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537720030", "bodyText": "delete this class", "author": "fil512", "createdAt": "2020-12-07T18:11:38Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/model/CanonicalIdentityAssuranceLevel.java", "diffHunk": "@@ -1,8 +1,8 @@\n-package ca.uhn.fhir.empi.model;\n+package ca.uhn.fhir.mdm.model;\n \n /*-\n  * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n+ * HAPI FHIR - Master Data Management", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/model/CanonicalIdentityAssuranceLevel.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/model/CanonicalIdentityAssuranceLevel.java\ndeleted file mode 100644\nindex 876f6095de..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/model/CanonicalIdentityAssuranceLevel.java\n+++ /dev/null\n\n@@ -1,44 +0,0 @@\n-package ca.uhn.fhir.mdm.model;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import org.hl7.fhir.r4.model.Person;\n-\n-public enum CanonicalIdentityAssuranceLevel {\n-\tLEVEL1(\"level1\"),\n-\tLEVEL2(\"level2\"),\n-\tLEVEL3(\"level3\"),\n-\tLEVEL4(\"level4\");\n-\n-\tprivate String myCanonicalLevel;\n-\tprivate CanonicalIdentityAssuranceLevel(String theCanonicalLevel) {\n-\t\tmyCanonicalLevel = theCanonicalLevel;\n-\t}\n-\n-\tpublic Person.IdentityAssuranceLevel toR4() {\n-\t\treturn Person.IdentityAssuranceLevel.fromCode(myCanonicalLevel);\n-\t}\n-\n-\tpublic org.hl7.fhir.dstu3.model.Person.IdentityAssuranceLevel toDstu3() {\n-\t\treturn org.hl7.fhir.dstu3.model.Person.IdentityAssuranceLevel.fromCode(myCanonicalLevel);\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMTI5Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537721293", "bodyText": "Delete all mdm classes concerning assurance level", "author": "fil512", "createdAt": "2020-12-07T18:13:32Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/AssuranceLevelUtil.java", "diffHunk": "@@ -20,21 +20,21 @@\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n+import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n+import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n+import ca.uhn.fhir.mdm.model.CanonicalIdentityAssuranceLevel;\n import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n \n /**\n  * Helper class to determine assurance level based on Link Source and Match Result.\n- * This is strictly for use in populating Person links.\n+ * This is strictly for use in populating Golden Resource links.\n  */\n public final class AssuranceLevelUtil {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/AssuranceLevelUtil.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/AssuranceLevelUtil.java\ndeleted file mode 100644\nindex 3a598f6146..0000000000\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/AssuranceLevelUtil.java\n+++ /dev/null\n\n@@ -1,72 +0,0 @@\n-package ca.uhn.fhir.mdm.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Master Data Management\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.mdm.api.MdmLinkSourceEnum;\n-import ca.uhn.fhir.mdm.api.MdmMatchResultEnum;\n-import ca.uhn.fhir.mdm.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-\n-/**\n- * Helper class to determine assurance level based on Link Source and Match Result.\n- * This is strictly for use in populating Golden Resource links.\n- */\n-public final class AssuranceLevelUtil {\n-\n-\tprivate AssuranceLevelUtil() {\n-\t}\n-\n-\tpublic static CanonicalIdentityAssuranceLevel getAssuranceLevel(MdmMatchResultEnum theMatchResult, MdmLinkSourceEnum theSource) {\n-\t\tswitch (theSource) {\n-\t\t\tcase MANUAL:\n-\t\t\t\treturn getAssuranceFromManualResult(theMatchResult);\n-\t\t\tcase AUTO:\n-\t\t\t\treturn getAssuranceFromAutoResult(theMatchResult);\n-\t\t}\n-\t\tthrow new InvalidRequestException(\"Couldn't figure out an assurance level for result: \" + theMatchResult + \" and source \" + theSource);\n-\t}\n-\n-\tprivate static CanonicalIdentityAssuranceLevel getAssuranceFromAutoResult(MdmMatchResultEnum theMatchResult) {\n-\t\tswitch (theMatchResult) {\n-\t\t\tcase MATCH:\n-\t\t\t\treturn CanonicalIdentityAssuranceLevel.LEVEL2;\n-\t\t\tcase POSSIBLE_MATCH:\n-\t\t\t\treturn CanonicalIdentityAssuranceLevel.LEVEL1;\n-\t\t\tcase POSSIBLE_DUPLICATE:\n-\t\t\tcase NO_MATCH:\n-\t\t\tdefault:\n-\t\t\t\tthrow new InvalidRequestException(\"An AUTO MDM Link may not have a match result of \" + theMatchResult);\n-\t\t}\n-\t}\n-\n-\tprivate static CanonicalIdentityAssuranceLevel getAssuranceFromManualResult(MdmMatchResultEnum theMatchResult) {\n-\t\tswitch (theMatchResult) {\n-\t\t\tcase MATCH:\n-\t\t\tcase REDIRECT:\n-\t\t\t\treturn CanonicalIdentityAssuranceLevel.LEVEL3;\n-\t\t\tcase NO_MATCH:\n-\t\t\tcase POSSIBLE_DUPLICATE:\n-\t\t\tcase POSSIBLE_MATCH:\n-\t\t\tdefault:\n-\t\t\t\tthrow new InvalidRequestException(\"A MANUAL MDM Link may not have a match result of \" + theMatchResult);\n-\t\t}\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDk0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537724948", "bodyText": "Is this actually a PrimitiveTypeEqualsPredicate ?", "author": "fil512", "createdAt": "2020-12-07T18:19:12Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..7ea253ff45 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -76,7 +76,7 @@ public class GoldenResourceHelper {\n \t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n \t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n \t\tvalidateContextSupported();\n \n \t\t// get a ref to the actual ID Field\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNTY2MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537725660", "bodyText": "This should probably be a static util function so we can use it elsewhere..", "author": "fil512", "createdAt": "2020-12-07T18:20:18Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..7ea253ff45 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -76,7 +76,7 @@ public class GoldenResourceHelper {\n \t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n \t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n \t\tvalidateContextSupported();\n \n \t\t// get a ref to the actual ID Field\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzA1NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727055", "bodyText": "nitpick this class is getting kind of long.  is there a distinct responsibility in here that could be carved out into a separate class?", "author": "fil512", "createdAt": "2020-12-07T18:22:09Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue : theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n+\t\t}\n+\t}\n+\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n+\t}\n+\n+\tprivate void cloneAllExternalEidsIntoNewGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t IBase theGoldenResource, IBase theNewGoldenResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theGoldenResourceIdentifier, base, theNewGoldenResource);\n+\t\t\t\t\tourLog.debug(\"System {} differs from system in the MDM rules {}\", baseSystem, mdmSystem);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\t/**\n+\t * Updates EID on Golden Resource, based on the incoming target resource. If the incoming resource has an external EID, it is applied\n+\t * to the Golden Resource, unless that golden resource already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n+\t * <p>\n+\t * If running in multiple EID mode, then incoming EIDs are simply added to the Golden Resource without checking for matches.\n+\t *\n+\t * @param theGoldenResource The golden resource to update the external EID on.\n+\t * @param theTargetResource The target we will retrieve the external EID from.\n+\t * @return the modified {@link IBaseResource} representing the Golden Resource.\n+\t */\n+\tpublic IAnyResource updateGoldenResourceExternalEidFromTargetResource(IAnyResource theGoldenResource, IAnyResource\n+\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n+\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n+\t\tList<CanonicalEID> goldenResourceOfficialEid = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tif (incomingTargetEid.isEmpty()) {\n+\t\t\treturn theGoldenResource;\n+\t\t}\n+\n+\t\tif (goldenResourceOfficialEid.isEmpty() || !myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\"))\n+\t\t\t\t+ \" is applying this EIDs to its related Target Resource, as this Target Resource does not yet have an external EID\");\n+\t\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, incomingTargetEid);\n+\t\t} else if (!goldenResourceOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(goldenResourceOfficialEid, incomingTargetEid)) {\n+\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite Golden Resource, as this EID is already present\");\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tString.format(\"Target EIDs %s would create a duplicate golden resource, as EIDs %s already exist!\",\n+\t\t\t\t\tincomingTargetEid.toString(), goldenResourceOfficialEid.toString()));\n+\t\t}\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tpublic IBaseResource overwriteExternalEids(IBaseResource theGoldenResource, List<CanonicalEID> theNewEid) {\n+\t\tclearExternalEids(theGoldenResource);\n+\t\taddCanonicalEidsToGoldenResourceIfAbsent(theGoldenResource, theNewEid);\n+\t\treturn theGoldenResource;\n+\t}\n+\n+\tprivate void clearExternalEidsFromTheGoldenResource(BaseRuntimeChildDefinition theGoldenResourceIdentifier, IBase theGoldenResource) {\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> goldenResourceIdentifiers = theGoldenResourceIdentifier.getAccessor().getValues(theGoldenResource);\n+\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tfor (IBase base : goldenResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString mdmSystem = myMdmSettings.getMdmRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, mdmSystem)) {\n+\t\t\t\t\tourLog.debug(\"Found EID confirming to MDM rules {}. It should not be copied, skipping\", baseSystem);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n+\t\t\t\ttheGoldenResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\t\tIBase goldenResourceNewIdentifier = childIdentifier.newInstance();\n+\t\t\tterser.cloneInto(base, goldenResourceNewIdentifier, true);\n+\n+\t\t\tclonedIdentifiers.add(goldenResourceNewIdentifier);\n+\t\t}\n+\n+\t\tgoldenResourceIdentifiers.clear();\n+\t\tgoldenResourceIdentifiers.addAll(clonedIdentifiers);\n+\t}\n+\n+\tprivate void clearExternalEids(IBaseResource theGoldenResource) {\n+\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theGoldenResource);\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tclearExternalEidsFromTheGoldenResource(goldenResourceIdentifier, theGoldenResource);\n+\t}\n+\n+\t/**\n+\t * Given a list of incoming External EIDs, and a Golden Resource, apply all the EIDs to this resource, which did not already exist on it.\n+\t */\n+\tprivate void addCanonicalEidsToGoldenResourceIfAbsent(IBaseResource theGoldenResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n+\t\tList<CanonicalEID> goldenResourceExternalEids = myEIDHelper.getExternalEid(theGoldenResource);\n+\n+\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n+\t\t\tif (goldenResourceExternalEids.contains(incomingExternalEid)) {\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\tcloneEidIntoResource(theGoldenResource, incomingExternalEid);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn (T) eid.toR4();\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn (T) eid.toDSTU3();\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\n+\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn (T) new BooleanType(theFlag);\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n+\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+\t\t\tcase R4:\n+\t\t\t\treturn ((BooleanType) theFlag).booleanValue();\n+\t\t\tcase DSTU3:\n+\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType) theFlag).booleanValue();\n+\t\t}\n+\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n+\t}\n+\n+\tpublic void mergeFields(IBaseResource theFromGoldenResource, IBaseResource theToGoldenResource) {\n+\t\t//\tTODO NG - Revisit when merge rules are defined\n+\t\tcloneCompositeField(theFromGoldenResource, theToGoldenResource, FIELD_NAME_IDENTIFIER);\n+\n+//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n+//\t\t\tcase R4:\n+//\t\t\t\tmergeR4PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tcase DSTU3:\n+//\t\t\t\tmergeDstu3PersonFields(theFromGoldenResource, theToGoldenResource);\n+//\t\t\t\tbreak;\n+//\t\t\tdefault:\n+//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+//\t\t}\n+\t}\n+\n+\t/**\n+\t * An incoming resource is a potential duplicate if it matches a target that has a golden resource with an official\n+\t * EID, but the incoming resource also has an EID that does not match.\n+\t */\n+\tpublic boolean isPotentialDuplicate(IAnyResource theExistingGoldenResource, IAnyResource theComparingGoldenResource) {\n+\t\tList<CanonicalEID> externalEidsGoldenResource = myEIDHelper.getExternalEid(theExistingGoldenResource);\n+\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingGoldenResource);\n+\t\treturn !externalEidsGoldenResource.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsGoldenResource);\n+\t}\n+\n+\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n+\t\tourLog.debug(theMessage);\n+\t}\n+\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theTargetResource, MdmTransactionContext\n+\t\ttheMdmTransactionContext) {\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tupdateGoldenResourceExternalEidFromTargetResource(theGoldenResource, theTargetResource, theMdmTransactionContext);\n+\t\t}\n+\t}\n+\n+\tpublic void deactivateResource(IAnyResource theResource) {\n+\t\tMdmUtil.setGoldenResourceRedirected(theResource);\n+\t}\n+\n+\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n+\t\treturn MdmUtil.isGoldenRecordRedirected(theGoldenResource);\n+\t}\n+}", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..7ea253ff45 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -76,7 +76,7 @@ public class GoldenResourceHelper {\n \t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n \t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n \t\tvalidateContextSupported();\n \n \t\t// get a ref to the actual ID Field\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzM2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727365", "bodyText": "MdmResourceUtil?", "author": "fil512", "createdAt": "2020-12-07T18:22:39Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import org.hl7.fhir.instance.model.api.IBaseCoding;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Optional;\n+\n+public final class MdmUtil {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmResourceUtil.java\nsimilarity index 98%\nrename from hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmResourceUtil.java\nindex 0391703473..34cb723c9f 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmResourceUtil.java\n\n@@ -27,9 +27,9 @@ import org.hl7.fhir.instance.model.api.IBaseResource;\n import javax.annotation.Nonnull;\n import java.util.Optional;\n \n-public final class MdmUtil {\n+public final class MdmResourceUtil {\n \n-\tprivate MdmUtil() {\n+\tprivate MdmResourceUtil() {\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNzkxNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537727915", "bodyText": "nitpick: rename to PrimitiveTypeEqualsPredicate", "author": "fil512", "createdAt": "2020-12-07T18:23:33Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicate.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+\n+import java.lang.reflect.Field;\n+import java.util.function.BiPredicate;\n+\n+public class PrimitiveTypeComparingPredicate implements BiPredicate {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicate.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicate.java\nsimilarity index 96%\nrename from hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicate.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicate.java\nindex acd984bad9..1dd9b4493b 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicate.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicate.java\n\n@@ -25,7 +25,7 @@ import org.hl7.fhir.instance.model.api.IPrimitiveType;\n import java.lang.reflect.Field;\n import java.util.function.BiPredicate;\n \n-public class PrimitiveTypeComparingPredicate implements BiPredicate {\n+public class PrimitiveTypeEqualsPredicate implements BiPredicate {\n \n \t@Override\n \tpublic boolean test(Object theBase1, Object theBase2) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyOTU1OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537729558", "bodyText": "why is there a Patient patient?", "author": "fil512", "createdAt": "2020-12-07T18:26:05Z", "path": "hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.r4.model.Address;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.DateType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PrimitiveTypeComparingPredicateTest {\n+\n+\tprivate static FhirContext myFhirContext;\n+\n+\tprivate FhirTerser myTerser;\n+\n+\tprivate IBase myPositiveTest1;\n+\n+\tprivate IBase myPositiveTest2;\n+\n+\tprivate IBase myPositiveTest3;\n+\n+\tprivate IBase myNegativeTest;\n+\n+\tprivate PrimitiveTypeComparingPredicate cut = new PrimitiveTypeComparingPredicate();\n+\n+\t@BeforeAll\n+\tpublic static void initContext() {\n+\t\tmyFhirContext = FhirContext.forR4();\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\tmyTerser = myFhirContext.newTerser();\n+\n+\t\tmyPositiveTest1 = newPatient();\n+\t\tmyPositiveTest2 = newPatient();\n+\t\tmyPositiveTest3 = newPatient();\n+\n+\t\tPatient patient = newPatient();\n+\t\tpatient.setActive(false);\n+\t\tpatient.setMultipleBirth(new BooleanType(false));\n+\t\tmyNegativeTest = patient;", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java b/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\nsimilarity index 69%\nrename from hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java\nrename to hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\nindex 5a01d02550..6410faaa8d 100644\n--- a/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java\n+++ b/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\n\n@@ -7,8 +7,8 @@ import org.hl7.fhir.r4.model.Address;\n import org.hl7.fhir.r4.model.BooleanType;\n import org.hl7.fhir.r4.model.DateType;\n import org.hl7.fhir.r4.model.Enumerations;\n-import org.hl7.fhir.r4.model.Identifier;\n import org.hl7.fhir.r4.model.Patient;\n+import org.hl7.fhir.r4.model.Person;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTkwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537731909", "bodyText": "Nitpick: This test is misleading.  It's not testing transitivity.  It's just testing that three identical resources are all equal to each other.  It doesn't do anything beyond testing that assertTrue(cut.test(myPositiveTest1, myPositiveTest2));", "author": "fil512", "createdAt": "2020-12-07T18:29:33Z", "path": "hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.r4.model.Address;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.DateType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PrimitiveTypeComparingPredicateTest {\n+\n+\tprivate static FhirContext myFhirContext;\n+\n+\tprivate FhirTerser myTerser;\n+\n+\tprivate IBase myPositiveTest1;\n+\n+\tprivate IBase myPositiveTest2;\n+\n+\tprivate IBase myPositiveTest3;\n+\n+\tprivate IBase myNegativeTest;\n+\n+\tprivate PrimitiveTypeComparingPredicate cut = new PrimitiveTypeComparingPredicate();\n+\n+\t@BeforeAll\n+\tpublic static void initContext() {\n+\t\tmyFhirContext = FhirContext.forR4();\n+\t}\n+\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\tmyTerser = myFhirContext.newTerser();\n+\n+\t\tmyPositiveTest1 = newPatient();\n+\t\tmyPositiveTest2 = newPatient();\n+\t\tmyPositiveTest3 = newPatient();\n+\n+\t\tPatient patient = newPatient();\n+\t\tpatient.setActive(false);\n+\t\tpatient.setMultipleBirth(new BooleanType(false));\n+\t\tmyNegativeTest = patient;\n+\t}\n+\n+\tprivate Patient newPatient() {\n+\t\tPatient patient;\n+\t\tpatient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tpatient.setGender(Enumerations.AdministrativeGender.FEMALE);\n+\t\tpatient.setBirthDateElement(new DateType(\"1901-01-01\"));\n+\n+\t\tAddress address = new Address();\n+\t\taddress.addLine(\"Somwhere\");\n+\t\taddress.setCity(\"Toronto\");\n+\t\taddress.setCountry(\"Canada\");\n+\t\tpatient.setAddress(Collections.singletonList(address));\n+\t\treturn patient;\n+\t}\n+\n+\t@Test\n+\tpublic void testNegativeMatchOnTheSameType() {\n+\t\tassertFalse(cut.test(myPositiveTest1, myNegativeTest));\n+\t\tassertFalse(cut.test(myNegativeTest, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testNegativeMatchOnDifferentTypes() {\n+\t\tPatient patient = newPatient();\n+\t\tIdentifier identifier = patient.addIdentifier();\n+\t\tidentifier.setValue(\"TEST_VALUE\");\n+\t\tassertFalse(cut.test(myNegativeTest, identifier));\n+\t}\n+\n+\t@Test\n+\tpublic void testSymmetry() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest2));\n+\t\tassertTrue(cut.test(myPositiveTest2, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testReflexivity() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest1));\n+\t}\n+\n+\t@Test\n+\tpublic void testTransitivity() {\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest2));\n+\t\tassertTrue(cut.test(myPositiveTest2, myPositiveTest3));\n+\t\tassertTrue(cut.test(myPositiveTest1, myPositiveTest3));", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c7b59798332ea79bab653e2b8180290b26b3308", "chunk": "diff --git a/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java b/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\nsimilarity index 69%\nrename from hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java\nrename to hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\nindex 5a01d02550..6410faaa8d 100644\n--- a/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeComparingPredicateTest.java\n+++ b/hapi-fhir-server-mdm/src/test/java/ca/uhn/fhir/mdm/util/PrimitiveTypeEqualsPredicateTest.java\n\n@@ -7,8 +7,8 @@ import org.hl7.fhir.r4.model.Address;\n import org.hl7.fhir.r4.model.BooleanType;\n import org.hl7.fhir.r4.model.DateType;\n import org.hl7.fhir.r4.model.Enumerations;\n-import org.hl7.fhir.r4.model.Identifier;\n import org.hl7.fhir.r4.model.Patient;\n+import org.hl7.fhir.r4.model.Person;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMjk2NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r537732964", "bodyText": "This is really nice!  Will be interesting to see how it evolves as we add survivability rules!", "author": "fil512", "createdAt": "2020-12-07T18:31:13Z", "path": "hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package ca.uhn.fhir.mdm.util;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Master Data Management\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n+import ca.uhn.fhir.util.FhirTerser;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n+\n+@Service\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n+\n+\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n+\n+\t@Autowired\n+\tprivate IMdmSettings myMdmSettings;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\n+\tprivate final FhirContext myFhirContext;\n+\n+\t@Autowired\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n+\t\tmyFhirContext = theFhirContext;\n+\t}\n+\n+\t/**\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n+\t *\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n+\t */\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n+\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newGoldenResource = resourceDefinition.newInstance();\n+\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition goldenResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\n+\t\tcloneAllExternalEidsIntoNewGoldenResource(goldenResourceIdentifier, theIncomingResource, newGoldenResource);\n+\n+\t\taddHapiEidIfNoExternalEidIsPresent(newGoldenResource, goldenResourceIdentifier, theIncomingResource);\n+\n+\t\tMdmUtil.setMdmManaged(newGoldenResource);\n+\t\tMdmUtil.setGoldenResource(newGoldenResource);\n+\n+\t\treturn (T) newGoldenResource;\n+\t}\n+\n+\t/**\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new Golden Resource.\n+\t */\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewGoldenResource, BaseRuntimeChildDefinition theGoldenResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewGoldenResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheGoldenResourceIdentifier.getMutator().addValue(theNewGoldenResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n+\t}\n+\n+\t/**\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n+\t */\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n+\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n+\t}\n+\n+\t/**\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n+\t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo   Resource to clone the specified filed to\n+\t * @param field   Field name to be copied\n+\t */\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {", "originalCommit": "f5f7f2df14f732c131b360087deaa0b4827b05b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "chunk": "diff --git a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 8582a75ea2..7ea253ff45 100644\n--- a/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -76,7 +76,7 @@ public class GoldenResourceHelper {\n \t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n \t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmSourceResource(T theIncomingResource) {\n \t\tvalidateContextSupported();\n \n \t\t// get a ref to the actual ID Field\n"}}, {"oid": "af461cd343b6a0b93ff501ee91a0100646e4d37c", "url": "https://github.com/hapifhir/hapi-fhir/commit/af461cd343b6a0b93ff501ee91a0100646e4d37c", "message": "Apply doc update suggestions from code review\n\nCo-authored-by: Ken Stevens <khstevens@gmail.com>", "committedDate": "2020-12-07T19:04:04Z", "type": "commit"}, {"oid": "fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "url": "https://github.com/hapifhir/hapi-fhir/commit/fd90eb699ff1f65f37b1fffbd3e672a915086ad8", "message": "Review updates", "committedDate": "2020-12-07T23:03:56Z", "type": "commit"}, {"oid": "b503d50b6726074f923169943d418960c02c84cd", "url": "https://github.com/hapifhir/hapi-fhir/commit/b503d50b6726074f923169943d418960c02c84cd", "message": "Addressed failures", "committedDate": "2020-12-08T00:18:58Z", "type": "commit"}, {"oid": "61c1b6cfb273170f3e7224b87ce28d8cd9d39d56", "url": "https://github.com/hapifhir/hapi-fhir/commit/61c1b6cfb273170f3e7224b87ce28d8cd9d39d56", "message": "Updated docs", "committedDate": "2020-12-08T00:30:18Z", "type": "commit"}, {"oid": "d3c094438855b18cbd8c0a5e647367414a1e6e38", "url": "https://github.com/hapifhir/hapi-fhir/commit/d3c094438855b18cbd8c0a5e647367414a1e6e38", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-08T03:02:45Z", "type": "commit"}, {"oid": "6018dd053787f424a7646ac1a7b0b76beec86fd3", "url": "https://github.com/hapifhir/hapi-fhir/commit/6018dd053787f424a7646ac1a7b0b76beec86fd3", "message": "Fixed ambitious schema update", "committedDate": "2020-12-08T15:44:11Z", "type": "commit"}, {"oid": "aef84c9fe9ce9045bc132c7f568f591f796e54b7", "url": "https://github.com/hapifhir/hapi-fhir/commit/aef84c9fe9ce9045bc132c7f568f591f796e54b7", "message": "Updated docs yet again", "committedDate": "2020-12-08T16:24:40Z", "type": "commit"}, {"oid": "efb429b319b4164f72588810ac9102e240161803", "url": "https://github.com/hapifhir/hapi-fhir/commit/efb429b319b4164f72588810ac9102e240161803", "message": "Fixed todos and reverted FK check in the test", "committedDate": "2020-12-08T18:00:02Z", "type": "commit"}, {"oid": "4c7b59798332ea79bab653e2b8180290b26b3308", "url": "https://github.com/hapifhir/hapi-fhir/commit/4c7b59798332ea79bab653e2b8180290b26b3308", "message": "Addressed more code review comments", "committedDate": "2020-12-08T20:32:01Z", "type": "commit"}, {"oid": "4b610801fa30d02c27eeb2544e09834062caa9f4", "url": "https://github.com/hapifhir/hapi-fhir/commit/4b610801fa30d02c27eeb2544e09834062caa9f4", "message": "Added header", "committedDate": "2020-12-08T21:47:19Z", "type": "commit"}, {"oid": "b3a9ab20dcdffae8550b5bae1aa2132a331eb1ad", "url": "https://github.com/hapifhir/hapi-fhir/commit/b3a9ab20dcdffae8550b5bae1aa2132a331eb1ad", "message": "Updated wording assertion in exception tracing", "committedDate": "2020-12-09T00:05:21Z", "type": "commit"}, {"oid": "52fd83c654a95339fd5975d6e1b43257d10e156a", "url": "https://github.com/hapifhir/hapi-fhir/commit/52fd83c654a95339fd5975d6e1b43257d10e156a", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-12-09T14:14:58Z", "type": "commit"}, {"oid": "0dfc4597e8941367f141824865d10f98976566aa", "url": "https://github.com/hapifhir/hapi-fhir/commit/0dfc4597e8941367f141824865d10f98976566aa", "message": "comment fixes and removing dead code", "committedDate": "2020-11-05T14:24:53Z", "type": "commit"}, {"oid": "ef2041d89d5e4b6e2207f0ec625e771d9f53167c", "url": "https://github.com/hapifhir/hapi-fhir/commit/ef2041d89d5e4b6e2207f0ec625e771d9f53167c", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-05T14:25:38Z", "type": "commit"}, {"oid": "5797cd0682bf6e12aa79f6230eedb1240778704f", "url": "https://github.com/hapifhir/hapi-fhir/commit/5797cd0682bf6e12aa79f6230eedb1240778704f", "message": "* Add source_resource_id column\n* Add source_resource columm\nStill need to depracate the old columns.\nReworked a Matcher to ignore Person", "committedDate": "2020-11-05T18:07:45Z", "type": "commit"}, {"oid": "656b8aeba706ed3f7dcfd71b305629c82188f489", "url": "https://github.com/hapifhir/hapi-fhir/commit/656b8aeba706ed3f7dcfd71b305629c82188f489", "message": "Partial removal of getPersonFromTarget", "committedDate": "2020-11-05T18:41:01Z", "type": "commit"}, {"oid": "4bfc62804cd55a3c4d740219cd63c82402867295", "url": "https://github.com/hapifhir/hapi-fhir/commit/4bfc62804cd55a3c4d740219cd63c82402867295", "message": "WIP removing Person", "committedDate": "2020-11-05T19:23:53Z", "type": "commit"}, {"oid": "e9509f99634d4899ca2c9e40b9e84e1763bc8912", "url": "https://github.com/hapifhir/hapi-fhir/commit/e9509f99634d4899ca2c9e40b9e84e1763bc8912", "message": "WIP removing Person - ID cloning", "committedDate": "2020-11-05T19:46:30Z", "type": "commit"}, {"oid": "0b4f6475204ed139e2144322c4fa10c6d756633b", "url": "https://github.com/hapifhir/hapi-fhir/commit/0b4f6475204ed139e2144322c4fa10c6d756633b", "message": "EID copy magic", "committedDate": "2020-11-05T22:39:25Z", "type": "commit"}, {"oid": "aba69533600db47f8146889302a986ec51040477", "url": "https://github.com/hapifhir/hapi-fhir/commit/aba69533600db47f8146889302a986ec51040477", "message": "Mild comment :)", "committedDate": "2020-11-06T04:06:54Z", "type": "commit"}, {"oid": "71856dbd64d7126dbf6edf3433d6a23a81ba2959", "url": "https://github.com/hapifhir/hapi-fhir/commit/71856dbd64d7126dbf6edf3433d6a23a81ba2959", "message": "WIP Refactoring", "committedDate": "2020-11-06T17:29:11Z", "type": "commit"}, {"oid": "79793f9c403b059fb68274cf63952406dd635ee7", "url": "https://github.com/hapifhir/hapi-fhir/commit/79793f9c403b059fb68274cf63952406dd635ee7", "message": "WIP Refactoring 2", "committedDate": "2020-11-06T18:16:50Z", "type": "commit"}, {"oid": "063d04cc79f274da0434ab184eeca17652ecd999", "url": "https://github.com/hapifhir/hapi-fhir/commit/063d04cc79f274da0434ab184eeca17652ecd999", "message": "One more test passing. rework EID updates to support the terser method", "committedDate": "2020-11-06T19:54:37Z", "type": "commit"}, {"oid": "27afbe93b3ae19dee64116a8bc31ff49fc550840", "url": "https://github.com/hapifhir/hapi-fhir/commit/27afbe93b3ae19dee64116a8bc31ff49fc550840", "message": "Cleanup", "committedDate": "2020-11-06T20:39:33Z", "type": "commit"}, {"oid": "9422ba7a025f18273d72babf0d65b22a02c9b202", "url": "https://github.com/hapifhir/hapi-fhir/commit/9422ba7a025f18273d72babf0d65b22a02c9b202", "message": "WIP Refactoring 3", "committedDate": "2020-11-06T22:02:07Z", "type": "commit"}, {"oid": "4c0fab8cec786d435760e5bf1e271e298e3b869c", "url": "https://github.com/hapifhir/hapi-fhir/commit/4c0fab8cec786d435760e5bf1e271e298e3b869c", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-11-09T14:06:50Z", "type": "commit"}, {"oid": "5d6ede660be921ea2eb12c6223c9e1eafddb47f1", "url": "https://github.com/hapifhir/hapi-fhir/commit/5d6ede660be921ea2eb12c6223c9e1eafddb47f1", "message": "Use case #3 testing", "committedDate": "2020-11-09T16:07:58Z", "type": "commit"}, {"oid": "ac3b1e3e17adb53600637fea8e40f3dbeb8cf1c0", "url": "https://github.com/hapifhir/hapi-fhir/commit/ac3b1e3e17adb53600637fea8e40f3dbeb8cf1c0", "message": "Fixed code for use case #3 test case", "committedDate": "2020-11-09T16:46:56Z", "type": "commit"}, {"oid": "4865e8a4101e6492a2bca3706a143249ee8163ce", "url": "https://github.com/hapifhir/hapi-fhir/commit/4865e8a4101e6492a2bca3706a143249ee8163ce", "message": "Fixed code for use case #2 test case", "committedDate": "2020-11-09T20:29:50Z", "type": "commit"}, {"oid": "06446ae0bfd5b9d892ebe9bec7e671081a89def8", "url": "https://github.com/hapifhir/hapi-fhir/commit/06446ae0bfd5b9d892ebe9bec7e671081a89def8", "message": "Address review comments", "committedDate": "2020-11-09T20:29:50Z", "type": "commit"}, {"oid": "a73d0421ba81523e92bfa16d4b0f8256250f035c", "url": "https://github.com/hapifhir/hapi-fhir/commit/a73d0421ba81523e92bfa16d4b0f8256250f035c", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-09T20:31:13Z", "type": "commit"}, {"oid": "9e82602be9ef469d927fb972cd0bb554cd99031f", "url": "https://github.com/hapifhir/hapi-fhir/commit/9e82602be9ef469d927fb972cd0bb554cd99031f", "message": "Begin refactor of provider tests", "committedDate": "2020-11-09T21:14:02Z", "type": "commit"}, {"oid": "c55de80c6aec722c54cd4e696b63e57a7191a1f0", "url": "https://github.com/hapifhir/hapi-fhir/commit/c55de80c6aec722c54cd4e696b63e57a7191a1f0", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-09T21:14:06Z", "type": "commit"}, {"oid": "99e3dbaccd7d35fa6ed82805db9359799b4dbb5e", "url": "https://github.com/hapifhir/hapi-fhir/commit/99e3dbaccd7d35fa6ed82805db9359799b4dbb5e", "message": "Removed link matching from PersonHelper", "committedDate": "2020-11-09T22:35:04Z", "type": "commit"}, {"oid": "8efafa112a1271ce41d986a3431714f60fd6b17b", "url": "https://github.com/hapifhir/hapi-fhir/commit/8efafa112a1271ce41d986a3431714f60fd6b17b", "message": "Debugging case 4", "committedDate": "2020-11-09T22:54:49Z", "type": "commit"}, {"oid": "d7974a6f1d9ca01a85c082af1df41e046879c03b", "url": "https://github.com/hapifhir/hapi-fhir/commit/d7974a6f1d9ca01a85c082af1df41e046879c03b", "message": "continue refactor of providers", "committedDate": "2020-11-10T02:44:11Z", "type": "commit"}, {"oid": "625744b23dae486f60e8914beca93a3844b4833e", "url": "https://github.com/hapifhir/hapi-fhir/commit/625744b23dae486f60e8914beca93a3844b4833e", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T02:45:18Z", "type": "commit"}, {"oid": "d2e9201f1156679ee5c09d41554664212e0c944e", "url": "https://github.com/hapifhir/hapi-fhir/commit/d2e9201f1156679ee5c09d41554664212e0c944e", "message": "Code is compiling again :)", "committedDate": "2020-11-10T02:49:38Z", "type": "commit"}, {"oid": "a67b3a8298236be307b6fc05f688459c20b93871", "url": "https://github.com/hapifhir/hapi-fhir/commit/a67b3a8298236be307b6fc05f688459c20b93871", "message": "Fixed possible-matcher", "committedDate": "2020-11-10T15:46:43Z", "type": "commit"}, {"oid": "9bd222af7fc169f0068a2d1d80b169b097d11f04", "url": "https://github.com/hapifhir/hapi-fhir/commit/9bd222af7fc169f0068a2d1d80b169b097d11f04", "message": "Manual match debuggging", "committedDate": "2020-11-10T17:13:04Z", "type": "commit"}, {"oid": "ffbe35e2cddacbb74cb0bea76087e41176784182", "url": "https://github.com/hapifhir/hapi-fhir/commit/ffbe35e2cddacbb74cb0bea76087e41176784182", "message": "Partial refactor of Provider", "committedDate": "2020-11-10T17:26:20Z", "type": "commit"}, {"oid": "16022107c65844d36732e788650921e266abcf70", "url": "https://github.com/hapifhir/hapi-fhir/commit/16022107c65844d36732e788650921e266abcf70", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T17:26:22Z", "type": "commit"}, {"oid": "40fc2973e465d63b2ebd5748141cf545d5475e37", "url": "https://github.com/hapifhir/hapi-fhir/commit/40fc2973e465d63b2ebd5748141cf545d5475e37", "message": "Manual match debuggging 2", "committedDate": "2020-11-10T17:47:38Z", "type": "commit"}, {"oid": "a8b0afa626fd1ce8802dc6a9ad35e85441180352", "url": "https://github.com/hapifhir/hapi-fhir/commit/a8b0afa626fd1ce8802dc6a9ad35e85441180352", "message": "Match link passing", "committedDate": "2020-11-10T20:37:16Z", "type": "commit"}, {"oid": "bde163b7e82ecbbe1506cf9c6d036eb2d3a0f6f9", "url": "https://github.com/hapifhir/hapi-fhir/commit/bde163b7e82ecbbe1506cf9c6d036eb2d3a0f6f9", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-10T21:18:25Z", "type": "commit"}, {"oid": "4a9b853beb2558664d4e363807ff01c1c43cc49b", "url": "https://github.com/hapifhir/hapi-fhir/commit/4a9b853beb2558664d4e363807ff01c1c43cc49b", "message": "Fix compilation error", "committedDate": "2020-11-10T23:00:01Z", "type": "commit"}, {"oid": "5d1612eef4d7528dc94891c6c36e1d6ce4146c6a", "url": "https://github.com/hapifhir/hapi-fhir/commit/5d1612eef4d7528dc94891c6c36e1d6ce4146c6a", "message": "Remove target version 9", "committedDate": "2020-11-10T23:38:26Z", "type": "commit"}, {"oid": "57c0e10a53d4df989eaedcd6505f91334e8b8a20", "url": "https://github.com/hapifhir/hapi-fhir/commit/57c0e10a53d4df989eaedcd6505f91334e8b8a20", "message": "More tests", "committedDate": "2020-11-11T01:31:04Z", "type": "commit"}, {"oid": "b0f449ff5e5fbb87470aa2aed6ef886b6624a271", "url": "https://github.com/hapifhir/hapi-fhir/commit/b0f449ff5e5fbb87470aa2aed6ef886b6624a271", "message": "MergerSvcTest WIP", "committedDate": "2020-11-11T15:17:03Z", "type": "commit"}, {"oid": "331acc1b554f02bd279248d1f706b63237eb2443", "url": "https://github.com/hapifhir/hapi-fhir/commit/331acc1b554f02bd279248d1f706b63237eb2443", "message": "Attempting to perform MDM on a new resource type", "committedDate": "2020-11-11T19:15:35Z", "type": "commit"}, {"oid": "3d34502fae3a7c72d48f5545251274387e1f786e", "url": "https://github.com/hapifhir/hapi-fhir/commit/3d34502fae3a7c72d48f5545251274387e1f786e", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-11T19:15:58Z", "type": "commit"}, {"oid": "46235226cf31e53146e3c576ac4490760c00304a", "url": "https://github.com/hapifhir/hapi-fhir/commit/46235226cf31e53146e3c576ac4490760c00304a", "message": "Whack of matcher changes for vector calculation to only count _relevant_ field matchers", "committedDate": "2020-11-11T19:25:36Z", "type": "commit"}, {"oid": "71ab400006265052967838cd4e73005437805363", "url": "https://github.com/hapifhir/hapi-fhir/commit/71ab400006265052967838cd4e73005437805363", "message": "Fix matcher. Add another medication test", "committedDate": "2020-11-11T20:26:41Z", "type": "commit"}, {"oid": "2bbfb6dfaa05ab149bf9740a771594270ba6cd45", "url": "https://github.com/hapifhir/hapi-fhir/commit/2bbfb6dfaa05ab149bf9740a771594270ba6cd45", "message": "WIP", "committedDate": "2020-11-11T20:27:57Z", "type": "commit"}, {"oid": "84d9d080dff890d72f7630b8a35cc346a20fa55b", "url": "https://github.com/hapifhir/hapi-fhir/commit/84d9d080dff890d72f7630b8a35cc346a20fa55b", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-11T20:28:04Z", "type": "commit"}, {"oid": "ae3040415cdc102c6d53beb25551d9491ed2f334", "url": "https://github.com/hapifhir/hapi-fhir/commit/ae3040415cdc102c6d53beb25551d9491ed2f334", "message": "Fix vector map bug i just wrote. woopsie doopsie", "committedDate": "2020-11-11T21:36:54Z", "type": "commit"}, {"oid": "a28e9e736acbfabec2051e67676619db40ee3434", "url": "https://github.com/hapifhir/hapi-fhir/commit/a28e9e736acbfabec2051e67676619db40ee3434", "message": "WIP", "committedDate": "2020-11-11T22:25:44Z", "type": "commit"}, {"oid": "f7c47f911bd8006690206f25a9e5caf803413c6b", "url": "https://github.com/hapifhir/hapi-fhir/commit/f7c47f911bd8006690206f25a9e5caf803413c6b", "message": "Merge Service", "committedDate": "2020-11-12T20:59:00Z", "type": "commit"}, {"oid": "1d530c6517e942a0b8deca03e4c0399f2b4bd060", "url": "https://github.com/hapifhir/hapi-fhir/commit/1d530c6517e942a0b8deca03e4c0399f2b4bd060", "message": "Added tests and cleaned test code", "committedDate": "2020-11-12T22:22:04Z", "type": "commit"}, {"oid": "e490011a1f7253d0b8c790aade9cab01ed178578", "url": "https://github.com/hapifhir/hapi-fhir/commit/e490011a1f7253d0b8c790aade9cab01ed178578", "message": "Begin large rename", "committedDate": "2020-11-12T23:36:52Z", "type": "commit"}, {"oid": "687e24fa83a9d756fb15e4e92188070c748983fb", "url": "https://github.com/hapifhir/hapi-fhir/commit/687e24fa83a9d756fb15e4e92188070c748983fb", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-12T23:37:53Z", "type": "commit"}, {"oid": "f648d8ec2baa06f0730a66f4ce11f9999330f9dd", "url": "https://github.com/hapifhir/hapi-fhir/commit/f648d8ec2baa06f0730a66f4ce11f9999330f9dd", "message": "renaming in personsvc", "committedDate": "2020-11-13T14:44:15Z", "type": "commit"}, {"oid": "68fad00a299dc55a1c68c6f4b423887507c4bacf", "url": "https://github.com/hapifhir/hapi-fhir/commit/68fad00a299dc55a1c68c6f4b423887507c4bacf", "message": "Correct bug with attempting to modify an EID", "committedDate": "2020-11-13T16:45:24Z", "type": "commit"}, {"oid": "dadd5f3caf357be07340e2a5685c5e30462b9d05", "url": "https://github.com/hapifhir/hapi-fhir/commit/dadd5f3caf357be07340e2a5685c5e30462b9d05", "message": "Resolved EmpiLinkSvcTest failures", "committedDate": "2020-11-13T19:22:45Z", "type": "commit"}, {"oid": "1fc96899436ce51b5ebcfd52f79e770ab061bc1f", "url": "https://github.com/hapifhir/hapi-fhir/commit/1fc96899436ce51b5ebcfd52f79e770ab061bc1f", "message": "Renamed source to golden", "committedDate": "2020-11-13T19:28:24Z", "type": "commit"}, {"oid": "9df0c16b95cda8b5836ce3aee8403ec43c133152", "url": "https://github.com/hapifhir/hapi-fhir/commit/9df0c16b95cda8b5836ce3aee8403ec43c133152", "message": "Resolved EmpiProviderClearLinkR4Tests and misc src to gld renames", "committedDate": "2020-11-13T20:13:14Z", "type": "commit"}, {"oid": "c0bef70e12c44246326e39c7ef06211b13f84043", "url": "https://github.com/hapifhir/hapi-fhir/commit/c0bef70e12c44246326e39c7ef06211b13f84043", "message": "Add optional resource type to EMPI provider method", "committedDate": "2020-11-13T21:42:09Z", "type": "commit"}, {"oid": "fa0e87b56c69cc810b96b730876bc718d604b6c7", "url": "https://github.com/hapifhir/hapi-fhir/commit/fa0e87b56c69cc810b96b730876bc718d604b6c7", "message": "Links WIP", "committedDate": "2020-11-13T21:56:13Z", "type": "commit"}, {"oid": "176f7f041274778c7c08dd79e56b36a65ad0dadb", "url": "https://github.com/hapifhir/hapi-fhir/commit/176f7f041274778c7c08dd79e56b36a65ad0dadb", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-13T21:57:23Z", "type": "commit"}, {"oid": "1ad0246c2a60e69c016c3a41731bc07738e3db44", "url": "https://github.com/hapifhir/hapi-fhir/commit/1ad0246c2a60e69c016c3a41731bc07738e3db44", "message": "Added config fix", "committedDate": "2020-11-13T22:16:10Z", "type": "commit"}, {"oid": "0ad1b129d3dd750fddd1c79b6eb8fc0eac2f8c4e", "url": "https://github.com/hapifhir/hapi-fhir/commit/0ad1b129d3dd750fddd1c79b6eb8fc0eac2f8c4e", "message": "Links WIP 2", "committedDate": "2020-11-13T22:47:56Z", "type": "commit"}, {"oid": "514dab77840cf91d9884925108943d276a7ceffb", "url": "https://github.com/hapifhir/hapi-fhir/commit/514dab77840cf91d9884925108943d276a7ceffb", "message": "Updated resource type handling", "committedDate": "2020-11-16T16:26:31Z", "type": "commit"}, {"oid": "54f0021b29a59a139c3aec800240bb2eb32cd7fe", "url": "https://github.com/hapifhir/hapi-fhir/commit/54f0021b29a59a139c3aec800240bb2eb32cd7fe", "message": "All Batch tests now passing", "committedDate": "2020-11-16T17:50:28Z", "type": "commit"}, {"oid": "869814606d9be6bd488609d7235e7d63280ab15e", "url": "https://github.com/hapifhir/hapi-fhir/commit/869814606d9be6bd488609d7235e7d63280ab15e", "message": "Fixed code for UpdateLinkR4Test", "committedDate": "2020-11-16T20:08:34Z", "type": "commit"}, {"oid": "799f6adecbe5b54e967a5362fde886e490c890f0", "url": "https://github.com/hapifhir/hapi-fhir/commit/799f6adecbe5b54e967a5362fde886e490c890f0", "message": "Finish tests in BatchSvcImplTest", "committedDate": "2020-11-16T20:45:50Z", "type": "commit"}, {"oid": "9a481242c75f4e3a5b5e4354765bdb9f3917152a", "url": "https://github.com/hapifhir/hapi-fhir/commit/9a481242c75f4e3a5b5e4354765bdb9f3917152a", "message": "Resolved MergePersonsR4Test failures", "committedDate": "2020-11-16T22:42:09Z", "type": "commit"}, {"oid": "6fa12bb947144a3ef1c4f2c7bed91cff0e12562e", "url": "https://github.com/hapifhir/hapi-fhir/commit/6fa12bb947144a3ef1c4f2c7bed91cff0e12562e", "message": "Finish tests in EmpiResourceDaoSvcTest", "committedDate": "2020-11-16T23:26:44Z", "type": "commit"}, {"oid": "36d7dde2e1a6b184e8b522cbebc2408f13fff81d", "url": "https://github.com/hapifhir/hapi-fhir/commit/36d7dde2e1a6b184e8b522cbebc2408f13fff81d", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-16T23:27:18Z", "type": "commit"}, {"oid": "bc6940fd6aaecdd7f0c599dda4bd314eab53a326", "url": "https://github.com/hapifhir/hapi-fhir/commit/bc6940fd6aaecdd7f0c599dda4bd314eab53a326", "message": "Finish tests for provider", "committedDate": "2020-11-16T23:47:39Z", "type": "commit"}, {"oid": "dae587912d6bb431942f3debb19a9055ab518d82", "url": "https://github.com/hapifhir/hapi-fhir/commit/dae587912d6bb431942f3debb19a9055ab518d82", "message": "Update test json files", "committedDate": "2020-11-16T23:50:14Z", "type": "commit"}, {"oid": "45ec435c8f660b4f4bb67ba7f4123b852bbdde6e", "url": "https://github.com/hapifhir/hapi-fhir/commit/45ec435c8f660b4f4bb67ba7f4123b852bbdde6e", "message": "Fixed code to pass FieldMatcherTest", "committedDate": "2020-11-17T00:00:27Z", "type": "commit"}, {"oid": "406bbafafe5eb66d7cc19035d81d4e7878ef0a85", "url": "https://github.com/hapifhir/hapi-fhir/commit/406bbafafe5eb66d7cc19035d81d4e7878ef0a85", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:00:33Z", "type": "commit"}, {"oid": "511696bd84876dba6a9143aa0b78cc2919b9a84a", "url": "https://github.com/hapifhir/hapi-fhir/commit/511696bd84876dba6a9143aa0b78cc2919b9a84a", "message": "Fix validator error messages", "committedDate": "2020-11-17T00:11:19Z", "type": "commit"}, {"oid": "9940d4c4eb98072d3f6cc5a8a48ebf9600e9a286", "url": "https://github.com/hapifhir/hapi-fhir/commit/9940d4c4eb98072d3f6cc5a8a48ebf9600e9a286", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:12:08Z", "type": "commit"}, {"oid": "4d9414597b4e560f384737eafcf2da6f0260e803", "url": "https://github.com/hapifhir/hapi-fhir/commit/4d9414597b4e560f384737eafcf2da6f0260e803", "message": "Updated mocks for EID helper test", "committedDate": "2020-11-17T00:19:14Z", "type": "commit"}, {"oid": "70284b257434e639bf8b2cdd0555c2860e229db7", "url": "https://github.com/hapifhir/hapi-fhir/commit/70284b257434e639bf8b2cdd0555c2860e229db7", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:19:19Z", "type": "commit"}, {"oid": "23898579bd54490a15c389a193d9402d645a219b", "url": "https://github.com/hapifhir/hapi-fhir/commit/23898579bd54490a15c389a193d9402d645a219b", "message": "fix customresourcematcher test", "committedDate": "2020-11-17T00:42:11Z", "type": "commit"}, {"oid": "d15ce0db0835ef4313db06476f0af3c3d72639a3", "url": "https://github.com/hapifhir/hapi-fhir/commit/d15ce0db0835ef4313db06476f0af3c3d72639a3", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-17T00:42:16Z", "type": "commit"}, {"oid": "e4ce94bc7cb9c0ce4c5739bb82629073fdc90b5e", "url": "https://github.com/hapifhir/hapi-fhir/commit/e4ce94bc7cb9c0ce4c5739bb82629073fdc90b5e", "message": "Fix resourcemastchersvc tests", "committedDate": "2020-11-17T01:06:46Z", "type": "commit"}, {"oid": "676f6315e6fbe6e7edaea0f40716246da1f396a3", "url": "https://github.com/hapifhir/hapi-fhir/commit/676f6315e6fbe6e7edaea0f40716246da1f396a3", "message": "Fix tests", "committedDate": "2020-11-17T01:21:42Z", "type": "commit"}, {"oid": "c50c4edea4c849d1ee38ff2a4169e0d59014509c", "url": "https://github.com/hapifhir/hapi-fhir/commit/c50c4edea4c849d1ee38ff2a4169e0d59014509c", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-17T14:27:39Z", "type": "commit"}, {"oid": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "url": "https://github.com/hapifhir/hapi-fhir/commit/805d5b1d6c1c800295cbe99af777b53f6290dd71", "message": "Merge branch '2161-refactor-empi' into gg_20201105-remove-person-references", "committedDate": "2020-11-17T14:28:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1NzI0Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525357242", "bodyText": "Consider changing to GOLDEN_RESOURCE_PID and renaming variable to myGoldenResourcePid", "author": "nvg-smile", "createdAt": "2020-11-17T17:41:09Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -60,6 +60,13 @@\n \t@Column(name = \"PID\")\n \tprivate Long myId;\n \n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 26b540c709..c9e45b4eac 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n\n@@ -61,16 +61,18 @@ public class EmpiLink {\n \tprivate Long myId;\n \n \t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n-\t@JoinColumn(name = \"SOURCE_RESOURCE_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_SOURCE_RESOURCE\"), insertable=false, updatable=false, nullable=false)\n-\tprivate ResourceTable mySourceResource;\n+\t@JoinColumn(name = \"GOLDEN_RESOURCE_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_GOLDEN_RESOURCE\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myGoldenResource;\n \n-\t@Column(name = \"SOURCE_RESOURCE_PID\", nullable=false)\n-\tprivate Long mySourceResourcePid;\n+\t@Column(name = \"GOLDEN_RESOURCE_PID\", nullable=false)\n+\tprivate Long myGoldenResourcePid;\n \n+\t@Deprecated\n \t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n \t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n \tprivate ResourceTable myPerson;\n \n+\t@Deprecated\n \t@Column(name = \"PERSON_PID\", nullable=false)\n \tprivate Long myPersonPid;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1NzkwMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525357901", "bodyText": "Change to myGoldenResourcePid, and add rule count", "author": "nvg-smile", "createdAt": "2020-11-17T17:42:07Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -289,18 +303,27 @@ public EmpiLink setEmpiTargetType(String theEmpiTargetType) {\n \tpublic String toString() {\n \t\treturn new ToStringBuilder(this)\n \t\t\t.append(\"myId\", myId)\n-\t\t\t.append(\"myPersonPid\", myPersonPid)\n+\t\t\t.append(\"myPersonPid\", mySourceResourcePid)", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\nrename to hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\nindex 26b540c709..c9e45b4eac 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/MdmLink.java\n\n@@ -289,13 +291,13 @@ public class EmpiLink {\n \t\treturn myHadToCreateNewResource != null && myHadToCreateNewResource;\n \t}\n \n-\tpublic EmpiLink setHadToCreateNewResource(Boolean theHadToCreateNewResource) {\n+\tpublic MdmLink setHadToCreateNewResource(Boolean theHadToCreateNewResource) {\n \t\tmyHadToCreateNewResource = theHadToCreateNewResource;\n \t\treturn this;\n \t}\n \n-\tpublic EmpiLink setEmpiTargetType(String theEmpiTargetType) {\n-\t\tmyEmpiTargetType = theEmpiTargetType;\n+\tpublic MdmLink setMdmTargetType(String mdmTargetType) {\n+\t\tmyMdmTargetType = mdmTargetType;\n \t\treturn this;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODM5OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525358398", "bodyText": "Rename to myMdmSettings", "author": "nvg-smile", "createdAt": "2020-11-17T17:42:52Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java", "diffHunk": "@@ -106,51 +108,51 @@ public void matchEmpiAndUpdateLinks(ResourceModifiedMessage theMsg) {\n \t\t}\n \t}\n \n-\tprivate EmpiTransactionContext createEmpiContext(ResourceModifiedMessage theMsg) {\n+\tprivate MdmTransactionContext createEmpiContext(ResourceModifiedMessage theMsg, String theResourceType) {\n \t\tTransactionLogMessages transactionLogMessages = TransactionLogMessages.createFromTransactionGuid(theMsg.getTransactionId());\n-\t\tEmpiTransactionContext.OperationType empiOperation;\n+\t\tMdmTransactionContext.OperationType empiOperation;\n \t\tswitch (theMsg.getOperationType()) {\n \t\t\tcase CREATE:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.CREATE_RESOURCE;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase UPDATE:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.UPDATE_RESOURCE;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\tempiOperation = EmpiTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n+\t\t\t\tempiOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n \t\t\t\tbreak;\n \t\t\tcase DELETE:\n \t\t\tdefault:\n \t\t\t\tourLog.trace(\"Not creating an EmpiTransactionContext for {}\", theMsg.getOperationType());\n \t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in EMPI\");\n \t\t}\n-\t\treturn new EmpiTransactionContext(transactionLogMessages, empiOperation);\n+\t\treturn new MdmTransactionContext(transactionLogMessages, empiOperation, theResourceType);\n \t}\n \n \tprivate void validateResourceType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n+\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\nsimilarity index 60%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\nindex 814ef671df..1f9c3bdc60 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/broker/EmpiMessageHandler.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/broker/MdmMessageHandler.java\n\n@@ -68,75 +68,75 @@ public class EmpiMessageHandler implements MessageHandler {\n \n \t\tResourceModifiedMessage msg = ((ResourceModifiedJsonMessage) theMessage).getPayload();\n \t\ttry {\n-\t\t\tif (myEmpiResourceFilteringSvc.shouldBeProcessed(getResourceFromPayload(msg))) {\n-\t\t\t\tmatchEmpiAndUpdateLinks(msg);\n+\t\t\tif (myMdmResourceFilteringSvc.shouldBeProcessed(getResourceFromPayload(msg))) {\n+\t\t\t\tmatchMdmAndUpdateLinks(msg);\n \t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tourLog.error(\"Failed to handle EMPI Matching Resource:\", e);\n+\t\t\tourLog.error(\"Failed to handle MDM Matching Resource:\", e);\n \t\t\tthrow e;\n \t\t}\n \t}\n-\tpublic void matchEmpiAndUpdateLinks(ResourceModifiedMessage theMsg) {\n+\tpublic void matchMdmAndUpdateLinks(ResourceModifiedMessage theMsg) {\n \t\tString resourceType = theMsg.getId(myFhirContext).getResourceType();\n \t\tvalidateResourceType(resourceType);\n-\t\tMdmTransactionContext empiContext =  createEmpiContext(theMsg, resourceType);\n+\t\tMdmTransactionContext mdmContext =  createMdmContext(theMsg, resourceType);\n \t\ttry {\n \t\t\tswitch (theMsg.getOperationType()) {\n \t\t\t\tcase CREATE:\n-\t\t\t\t\thandleCreatePatientOrPractitioner(theMsg, empiContext);\n+\t\t\t\t\thandleCreatePatientOrPractitioner(theMsg, mdmContext);\n \t\t\t\t\tbreak;\n \t\t\t\tcase UPDATE:\n \t\t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\t\thandleUpdatePatientOrPractitioner(theMsg, empiContext);\n+\t\t\t\t\thandleUpdatePatientOrPractitioner(theMsg, mdmContext);\n \t\t\t\t\tbreak;\n \t\t\t\tcase DELETE:\n \t\t\t\tdefault:\n \t\t\t\t\tourLog.trace(\"Not processing modified message for {}\", theMsg.getOperationType());\n \t\t\t}\n \t\t}catch (Exception e) {\n-\t\t\tlog(empiContext, \"Failure during EMPI processing: \" + e.getMessage(), e);\n+\t\t\tlog(mdmContext, \"Failure during MDM processing: \" + e.getMessage(), e);\n \t\t} finally {\n \n-\t\t\t// Interceptor call: EMPI_AFTER_PERSISTED_RESOURCE_CHECKED\n+\t\t\t// Interceptor call: MDM_AFTER_PERSISTED_RESOURCE_CHECKED\n \t\t\tResourceOperationMessage outgoingMsg = new ResourceOperationMessage(myFhirContext, theMsg.getPayload(myFhirContext), theMsg.getOperationType());\n \t\t\toutgoingMsg.setTransactionId(theMsg.getTransactionId());\n \n \t\t\tHookParams params = new HookParams()\n \t\t\t\t.add(ResourceOperationMessage.class, outgoingMsg)\n-\t\t\t\t.add(TransactionLogMessages.class, empiContext.getTransactionLogMessages());\n-\t\t\tmyInterceptorBroadcaster.callHooks(Pointcut.EMPI_AFTER_PERSISTED_RESOURCE_CHECKED, params);\n+\t\t\t\t.add(TransactionLogMessages.class, mdmContext.getTransactionLogMessages());\n+\t\t\tmyInterceptorBroadcaster.callHooks(Pointcut.MDM_AFTER_PERSISTED_RESOURCE_CHECKED, params);\n \t\t}\n \t}\n \n-\tprivate MdmTransactionContext createEmpiContext(ResourceModifiedMessage theMsg, String theResourceType) {\n+\tprivate MdmTransactionContext createMdmContext(ResourceModifiedMessage theMsg, String theResourceType) {\n \t\tTransactionLogMessages transactionLogMessages = TransactionLogMessages.createFromTransactionGuid(theMsg.getTransactionId());\n-\t\tMdmTransactionContext.OperationType empiOperation;\n+\t\tMdmTransactionContext.OperationType mdmOperation;\n \t\tswitch (theMsg.getOperationType()) {\n \t\t\tcase CREATE:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.CREATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase UPDATE:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.UPDATE_RESOURCE;\n \t\t\t\tbreak;\n \t\t\tcase MANUALLY_TRIGGERED:\n-\t\t\t\tempiOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_EMPI;\n+\t\t\t\tmdmOperation = MdmTransactionContext.OperationType.SUBMIT_RESOURCE_TO_MDM;\n \t\t\t\tbreak;\n \t\t\tcase DELETE:\n \t\t\tdefault:\n-\t\t\t\tourLog.trace(\"Not creating an EmpiTransactionContext for {}\", theMsg.getOperationType());\n-\t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in EMPI\");\n+\t\t\t\tourLog.trace(\"Not creating an MdmTransactionContext for {}\", theMsg.getOperationType());\n+\t\t\t\tthrow new InvalidRequestException(\"We can't handle non-update/create operations in MDM\");\n \t\t}\n-\t\treturn new MdmTransactionContext(transactionLogMessages, empiOperation, theResourceType);\n+\t\treturn new MdmTransactionContext(transactionLogMessages, mdmOperation, theResourceType);\n \t}\n \n \tprivate void validateResourceType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new IllegalStateException(\"Unsupported resource type submitted to EMPI matching queue: \" + theResourceType);\n+\t\tif (!myMdmSettings.isSupportedMdmType(theResourceType)) {\n+\t\t\tthrow new IllegalStateException(\"Unsupported resource type submitted to MDM matching queue: \" + theResourceType);\n \t\t}\n \t}\n \n \tprivate void handleCreatePatientOrPractitioner(ResourceModifiedMessage theMsg, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(getResourceFromPayload(theMsg), theMdmTransactionContext);\n+\t\tmyMdmMatchLinkSvc.updateMdmLinksForMdmTarget(getResourceFromPayload(theMsg), theMdmTransactionContext);\n \t}\n \n \tprivate IAnyResource getResourceFromPayload(ResourceModifiedMessage theMsg) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODg1OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525358859", "bodyText": "Chance Empi prefix to Mdm and rename variables appropriately.", "author": "nvg-smile", "createdAt": "2020-11-17T17:43:36Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java", "diffHunk": "@@ -168,8 +174,8 @@ IEmpiLinkQuerySvc empiLinkQuerySvc() {\n \t}\n \n \t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl ) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl);\n+\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 177d267ec6..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n\n@@ -1,240 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.MessageHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.GoldenResourceMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tMessageHelper messageHelper(IEmpiSettings theEmpiSettings, FhirContext theFhirContext) {\n-\t\treturn new MessageHelper(theEmpiSettings, theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSourceResourceFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiSourceResourceFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIGoldenResourceMergerSvc empiPersonMergerSvc() {\n-\t\treturn new GoldenResourceMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl, theIEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {\n-\t\treturn new EmpiControllerHelper(theFhirContext, theResourceLoader, theEmpiSettings, messageHelper);\n-\t}\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {\n-\t\treturn new EmpiControllerSvcImpl();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1OTE4Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525359182", "bodyText": "Change Empi prefix to Mdm and rename variables appropriately.", "author": "nvg-smile", "createdAt": "2020-11-17T17:44:05Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java", "diffHunk": "@@ -223,8 +229,12 @@ EmpiResourceFilteringSvc empiResourceFilteringSvc() {\n \t}\n \n \t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader) { return new EmpiControllerHelper(theFhirContext, theResourceLoader); }\n+\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\ndeleted file mode 100644\nindex 177d267ec6..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiConsumerConfig.java\n+++ /dev/null\n\n@@ -1,240 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.config;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiProviderLoader;\n-import ca.uhn.fhir.empi.rules.config.EmpiRuleValidator;\n-import ca.uhn.fhir.empi.rules.svc.EmpiResourceMatcherSvc;\n-import ca.uhn.fhir.empi.util.EIDHelper;\n-import ca.uhn.fhir.empi.util.MessageHelper;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.empi.EmpiLinkDeleteSvc;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiMessageHandler;\n-import ca.uhn.fhir.jpa.empi.broker.EmpiQueueConsumerLoader;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkFactory;\n-import ca.uhn.fhir.jpa.empi.interceptor.EmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.interceptor.IEmpiStorageInterceptor;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiClearSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiControllerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiEidUpdateService;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkQuerySvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiLinkUpdaterSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchFinderSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiMatchLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiPersonDeletingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.GoldenResourceMergerSvcImpl;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceDaoSvc;\n-import ca.uhn.fhir.jpa.empi.svc.EmpiResourceFilteringSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchCriteriaBuilderSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiCandidateSearchSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByEidSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByLinkSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.FindCandidateByScoreSvc;\n-import ca.uhn.fhir.rest.server.util.ISearchParamRetriever;\n-import ca.uhn.fhir.validation.IResourceLoader;\n-import org.slf4j.Logger;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-\n-@Configuration\n-public class EmpiConsumerConfig {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Bean\n-\tIEmpiStorageInterceptor empiStorageInterceptor() {\n-\t\treturn new EmpiStorageInterceptor();\n-\t}\n-\n-\t@Bean\n-\tEmpiQueueConsumerLoader empiQueueConsumerLoader() {\n-\t\treturn new EmpiQueueConsumerLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiMessageHandler empiMessageHandler() {\n-\t\treturn new EmpiMessageHandler();\n-\t}\n-\n-\t@Bean\n-\tEmpiMatchLinkSvc empiMatchLinkSvc() {\n-\t\treturn new EmpiMatchLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiEidUpdateService eidUpdateService() {\n-\t\treturn new EmpiEidUpdateService();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceDaoSvc empiResourceDaoSvc() {\n-\t\treturn new EmpiResourceDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkSvc empiLinkSvc() {\n-\t\treturn new EmpiLinkSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tPersonHelper personHelper(FhirContext theFhirContext) {\n-\t\treturn new PersonHelper(theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tMessageHelper messageHelper(IEmpiSettings theEmpiSettings, FhirContext theFhirContext) {\n-\t\treturn new MessageHelper(theEmpiSettings, theFhirContext);\n-\t}\n-\n-\t@Bean\n-\tEmpiSubscriptionLoader empiSubscriptionLoader() {\n-\t\treturn new EmpiSubscriptionLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSearchParameterLoader empiSearchParameterLoader() {\n-\t\treturn new EmpiSearchParameterLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiSourceResourceFindingSvc empiPersonFindingSvc() {\n-\t\treturn new EmpiSourceResourceFindingSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByEidSvc findCandidateByEidSvc() {\n-\t\treturn new FindCandidateByEidSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByLinkSvc findCandidateByLinkSvc() {\n-\t\treturn new FindCandidateByLinkSvc();\n-\t}\n-\n-\t@Bean\n-\tFindCandidateByScoreSvc findCandidateByScoreSvc() {\n-\t\treturn new FindCandidateByScoreSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiProviderLoader empiProviderLoader() {\n-\t\treturn new EmpiProviderLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiRuleValidator empiRuleValidator(FhirContext theFhirContext, ISearchParamRetriever theSearchParamRetriever) {\n-\t\treturn new EmpiRuleValidator(theFhirContext, theSearchParamRetriever);\n-\t}\n-\n-\t@Bean\n-\tIEmpiMatchFinderSvc empiMatchFinderSvc() {\n-\t\treturn new EmpiMatchFinderSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIGoldenResourceMergerSvc empiPersonMergerSvc() {\n-\t\treturn new GoldenResourceMergerSvcImpl();\n-\t}\n-\n-\n-\t@Bean\n-\tIEmpiLinkQuerySvc empiLinkQuerySvc() {\n-\t\treturn new EmpiLinkQuerySvcImpl();\n-\t}\n-\n-\t@Bean\n-\tIEmpiExpungeSvc empiResetSvc(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\treturn new EmpiClearSvcImpl(theEmpiLinkDaoSvc, theEmpiPersonDeletingSvcImpl, theIEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchSvc empiCandidateSearchSvc() {\n-\t\treturn new EmpiCandidateSearchSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiCandidateSearchCriteriaBuilderSvc empiCriteriaBuilderSvc() {\n-\t\treturn new EmpiCandidateSearchCriteriaBuilderSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceMatcherSvc empiResourceComparatorSvc(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EmpiResourceMatcherSvc(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEIDHelper eidHelper(FhirContext theFhirContext, IEmpiSettings theEmpiConfig) {\n-\t\treturn new EIDHelper(theFhirContext, theEmpiConfig);\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDaoSvc empiLinkDaoSvc() {\n-\t\treturn new EmpiLinkDaoSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkFactory empiLinkFactory(IEmpiSettings theEmpiSettings) {\n-\t\treturn new EmpiLinkFactory(theEmpiSettings);\n-\t}\n-\n-\t@Bean\n-\tIEmpiLinkUpdaterSvc manualLinkUpdaterSvc() {\n-\t\treturn new EmpiLinkUpdaterSvcImpl();\n-\t}\n-\n-\t@Bean\n-\tEmpiLoader empiLoader() {\n-\t\treturn new EmpiLoader();\n-\t}\n-\n-\t@Bean\n-\tEmpiLinkDeleteSvc empiLinkDeleteSvc() {\n-\t\treturn new EmpiLinkDeleteSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiResourceFilteringSvc empiResourceFilteringSvc() {\n-\t\treturn new EmpiResourceFilteringSvc();\n-\t}\n-\n-\t@Bean\n-\tEmpiControllerHelper empiProviderHelper(FhirContext theFhirContext, IResourceLoader theResourceLoader, IEmpiSettings theEmpiSettings, MessageHelper messageHelper) {\n-\t\treturn new EmpiControllerHelper(theFhirContext, theResourceLoader, theEmpiSettings, messageHelper);\n-\t}\n-\n-\t@Bean\n-\tIEmpiControllerSvc empiControllerSvc() {\n-\t\treturn new EmpiControllerSvcImpl();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MTcxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525361719", "bodyText": "This functionality is pending further requirements elicitation?", "author": "nvg-smile", "createdAt": "2020-11-17T17:47:50Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java", "diffHunk": "@@ -78,7 +78,7 @@ private SearchParameter buildAssuranceEmpiSearchParameterR4() {\n \t\tSearchParameter retval = new SearchParameter();\n \t\tretval.setId(EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\nsimilarity index 66%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\nindex 04cbfcbebd..7d447fe61e 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/config/EmpiSearchParameterLoader.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/config/MdmSearchParameterLoader.java\n\n@@ -74,11 +74,11 @@ public class EmpiSearchParameterLoader {\n \t\treturn retval;\n \t}\n \n-\tprivate SearchParameter buildAssuranceEmpiSearchParameterR4() {\n+\tprivate SearchParameter buildAssuranceMdmSearchParameterR4() {\n \t\tSearchParameter retval = new SearchParameter();\n-\t\tretval.setId(EMPI_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n+\t\tretval.setId(MDM_PERSON_ASSURANCE_SEARCH_PARAMETER_ID);\n \t\tretval.setStatus(Enumerations.PublicationStatus.ACTIVE);\n-\t\tretval.getMeta().addTag().setSystem(EmpiConstants.SYSTEM_MDM_MANAGED).setCode(EmpiConstants.CODE_HAPI_MDM_MANAGED);\n+\t\tretval.getMeta().addTag().setSystem(MdmConstants.SYSTEM_MDM_MANAGED).setCode(MdmConstants.CODE_HAPI_MDM_MANAGED);\n \t\tretval.setCode(\"assurance\");\n \t\tretval.addBase(\"Person\");\n \t\tretval.setType(Enumerations.SearchParamType.TOKEN);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MjI5Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525362297", "bodyText": "Rename source to golden", "author": "nvg-smile", "createdAt": "2020-11-17T17:48:20Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -59,61 +60,60 @@\n \tprivate FhirContext myFhirContext;\n \n \t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MjY2Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525362663", "bodyText": "Rename source to golden", "author": "nvg-smile", "createdAt": "2020-11-17T17:48:37Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -59,61 +60,60 @@\n \tprivate FhirContext myFhirContext;\n \n \t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n-\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n+\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n \n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n \t\tempiLink.setLinkSource(theLinkSource);\n \t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n \t\t// Preserve these flags for link updates\n \t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setNewPerson(theMatchOutcome.isNewPerson() | empiLink.isNewPerson());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTarget));\n+\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n+\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n \t\tif (empiLink.getScore() != null) {\n \t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n \t\t} else {\n \t\t\tempiLink.setScore(theMatchOutcome.score);\n \t\t}\n \n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n+\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n \t\tourLog.debug(message);\n \t\tsave(empiLink);\n \t\treturn empiLink;\n \t}\n \n \t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NDg2MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525364861", "bodyText": "Rename source to golden and update comments", "author": "nvg-smile", "createdAt": "2020-11-17T17:50:19Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -162,15 +162,14 @@ public EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Lo\n \t/**\n \t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n \t *\n-\t * @param thePersonPid The Pid of the Person in the relationship\n-\t * @param theTargetPid The Pid of the target in the relationship\n+\t * @param thePersonPid   The Pid of the Person in the relationship\n+\t * @param theTargetPid   The Pid of the target in the relationship\n \t * @param theMatchResult The MatchResult you are looking for.\n-\t *\n \t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n \t */\n \tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NjY3MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525366670", "bodyText": "rename to goldenResources", "author": "nvg-smile", "createdAt": "2020-11-17T17:51:53Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -233,14 +231,20 @@ public void deleteLink(EmpiLink theEmpiLink) {\n \t * @return A list of Long representing the related Person Pids.\n \t */\n \t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnPersonPids() {\n+\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n \t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnPersonPids(all);\n+\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n \t}\n \n-\tprivate List<Long> deleteEmpiLinksAndReturnPersonPids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getPersonPid).collect(Collectors.toSet());\n-\t\tpersons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n+\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n+\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NzA2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525367065", "bodyText": "rename source to golden, update javadocs", "author": "nvg-smile", "createdAt": "2020-11-17T17:52:28Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -308,12 +308,55 @@ public EmpiLink save(EmpiLink theEmpiLink) {\n \t\treturn myEmpiLinkDao.findAll(example);\n \t}\n \n+\t/**\n+\t * Finds all links pointing from the target resource to the source resource.\n+\t *\n+\t * @param theTargetResource Resource referencing the source resource\n+\t * @param theSourceResource Resource being referenced by the source resource\n+\t *\n+\t * @return\n+\t * \t\tReturns all EMPI links pointing to the source from target resource\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODkyNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525368927", "bodyText": "May be a good idea to pull todo out of javadocs", "author": "nvg-smile", "createdAt": "2020-11-17T17:55:10Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -308,12 +308,55 @@ public EmpiLink save(EmpiLink theEmpiLink) {\n \t\treturn myEmpiLinkDao.findAll(example);\n \t}\n \n+\t/**\n+\t * Finds all links pointing from the target resource to the source resource.\n+\t *\n+\t * @param theTargetResource Resource referencing the source resource\n+\t * @param theSourceResource Resource being referenced by the source resource\n+\t *\n+\t * @return\n+\t * \t\tReturns all EMPI links pointing to the source from target resource\n+\t */\n+\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n+\t\tif (targetPid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (sourcePid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n+\t/**\n+\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n+\t * of the relationship.\n+\t *\n+\t * @param theSourceResource the source resource to find links for.\n+\t * @return all links for the source.\n+\t */\n+\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n+\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n+\t\tif (pid == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n+\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n+\t\tExample<EmpiLink> example = Example.of(exampleLink);\n+\t\treturn myEmpiLinkDao.findAll(example);\n+\t}\n+\n \t/**\n \t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n \t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n+\t *", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\ndeleted file mode 100644\nindex e484396449..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/dao/EmpiLinkDaoSvc.java\n+++ /dev/null\n\n@@ -1,362 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.dao;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.data.domain.Example;\n-import org.springframework.transaction.annotation.Propagation;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-public class EmpiLinkDaoSvc {\n-\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkDao myEmpiLinkDao;\n-\t@Autowired\n-\tprivate EmpiLinkFactory myEmpiLinkFactory;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\t@Autowired\n-\tprivate FhirContext myFhirContext;\n-\n-\t@Transactional\n-\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, @Nullable MdmTransactionContext theMdmTransactionContext) {\n-\t\tLong sourceResourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tLong targetResourcePid = myIdHelperService.getPidOrNull(theTargetResource);\n-\n-\t\tEmpiLink empiLink = getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(sourceResourcePid, targetResourcePid);\n-\t\tempiLink.setLinkSource(theLinkSource);\n-\t\tempiLink.setMatchResult(theMatchOutcome.getMatchResultEnum());\n-\t\t// Preserve these flags for link updates\n-\t\tempiLink.setEidMatch(theMatchOutcome.isEidMatch() | empiLink.isEidMatch());\n-\t\tempiLink.setHadToCreateNewResource(theMatchOutcome.isNewPerson() | empiLink.getHadToCreateNewResource());\n-\t\tempiLink.setEmpiTargetType(myFhirContext.getResourceType(theTargetResource));\n-\t\tif (empiLink.getScore() != null) {\n-\t\t\tempiLink.setScore(Math.max(theMatchOutcome.score, empiLink.getScore()));\n-\t\t} else {\n-\t\t\tempiLink.setScore(theMatchOutcome.score);\n-\t\t}\n-\n-\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", theSourceResource.getIdElement().toUnqualifiedVersionless(), theTargetResource.getIdElement().toUnqualifiedVersionless(), theMatchOutcome);\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(message);\n-\t\tourLog.debug(message);\n-\t\tsave(empiLink);\n-\t\treturn empiLink;\n-\t}\n-\n-\t@Nonnull\n-\tpublic EmpiLink getOrCreateEmpiLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tOptional<EmpiLink> oExisting = getLinkBySourceResourcePidAndTargetResourcePid(theSourceResourcePid, theTargetResourcePid);\n-\t\tif (oExisting.isPresent()) {\n-\t\t\treturn oExisting.get();\n-\t\t} else {\n-\t\t\tEmpiLink newLink = myEmpiLinkFactory.newEmpiLink();\n-\t\t\tnewLink.setGoldenResourcePid(theSourceResourcePid);\n-\t\t\tnewLink.setPersonPid(theSourceResourcePid);\n-\t\t\tnewLink.setTargetPid(theTargetResourcePid);\n-\t\t\treturn newLink;\n-\t\t}\n-\t}\n-\n-\tpublic Optional<EmpiLink> getLinkBySourceResourcePidAndTargetResourcePid(Long theSourceResourcePid, Long theTargetResourcePid) {\n-\t\tif (theTargetResourcePid == null || theSourceResourcePid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink link = myEmpiLinkFactory.newEmpiLink();\n-\t\tlink.setTargetPid(theTargetResourcePid);\n-\t\tlink.setGoldenResourcePid(theSourceResourcePid);\n-\t\tExample<EmpiLink> example = Example.of(link);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a Target Pid, and a match result, return all links that match these criteria.\n-\t *\n-\t * @param theTargetPid   the target of the relationship.\n-\t * @param theMatchResult the Match Result of the relationship\n-\t * @return a list of {@link EmpiLink} entities matching these criteria.\n-\t */\n-\tpublic List<EmpiLink> getEmpiLinksByTargetPidAndMatchResult(Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Given a target Pid, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTargetPid The Pid of the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTargetPid(Long theTargetPid) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given an IBaseResource, return its Matched EmpiLink. There can only ever be at most one of these, but its possible\n-\t * the target has no matches, and may return an empty optional.\n-\t *\n-\t * @param theTarget The IBaseResource representing the target you wish to find the matching link for.\n-\t * @return the {@link EmpiLink} that contains the Match information for the target.\n-\t */\n-\tpublic Optional<EmpiLink> getMatchedLinkForTarget(IBaseResource theTarget) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTarget);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setTargetPid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Given a person a target and a match result, return the matching EmpiLink, if it exists.\n-\t *\n-\t * @param thePersonPid   The Pid of the Person in the relationship\n-\t * @param theTargetPid   The Pid of the target in the relationship\n-\t * @param theMatchResult The MatchResult you are looking for.\n-\t * @return an Optional {@link EmpiLink} containing the matched link if it exists.\n-\t */\n-\tpublic Optional<EmpiLink> getEmpiLinksByPersonPidTargetPidAndMatchResult(Long thePersonPid, Long theTargetPid, EmpiMatchResultEnum theMatchResult) {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setGoldenResourcePid(thePersonPid);\n-\t\texampleLink.setTargetPid(theTargetPid);\n-\t\texampleLink.setMatchResult(theMatchResult);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Get all {@link EmpiLink} which have {@link EmpiMatchResultEnum#POSSIBLE_DUPLICATE} as their match result.\n-\t *\n-\t * @return A list of EmpiLinks that hold potential duplicate persons.\n-\t */\n-\tpublic List<EmpiLink> getPossibleDuplicates() {\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink();\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.POSSIBLE_DUPLICATE);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\tpublic Optional<EmpiLink> findEmpiLinkByTarget(IBaseResource theTargetResource) {\n-\t\t@Nullable Long pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findOne(example);\n-\t}\n-\n-\t/**\n-\t * Delete a given EmpiLink. Note that this does not clear out the Person, or the Person's related links.\n-\t * It is a simple entity delete.\n-\t *\n-\t * @param theEmpiLink the EmpiLink to delete.\n-\t */\n-\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n-\tpublic void deleteLink(EmpiLink theEmpiLink) {\n-\t\tmyEmpiLinkDao.delete(theEmpiLink);\n-\t}\n-\n-\t/**\n-\t * Given a Golden Resource , return all links in which they are the source Person of the {@link EmpiLink}\n-\t *\n-\t * @param theGoldenResource The {@link IBaseResource} Person who's links you would like to retrieve.\n-\t * @return A list of all {@link EmpiLink} entities in which theGoldenResource is the source Person.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByGoldenResource(IBaseResource theGoldenResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theGoldenResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Delete all {@link EmpiLink} entities, and return all resource PIDs from the source of the relationship.\n-\t *\n-\t * @return A list of Long representing the related Person Pids.\n-\t */\n-\t@Transactional\n-\tpublic List<Long> deleteAllEmpiLinksAndReturnGoldenResourcePids() {\n-\t\tList<EmpiLink> all = myEmpiLinkDao.findAll();\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(all);\n-\t}\n-\n-\tprivate List<Long> deleteEmpiLinksAndReturnGoldenResourcePids(List<EmpiLink> theLinks) {\n-\t\tSet<Long> persons = theLinks.stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toSet());\n-\t\t//TODO GGG this is probably invalid... we are essentially looking for GOLDEN -> GOLDEN links, which are either POSSIBLE_DUPLICATE\n-\t\t//and REDIRECT\n-\t\t//persons.addAll(theLinks.stream().filter(link -> \"Person\".equals(link.getEmpiTargetType())).map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tpersons.addAll(theLinks.stream()\n-\t\t\t.filter(link -> link.getMatchResult().equals(EmpiMatchResultEnum.REDIRECT)\n-\t\t\t\t|| link.getMatchResult().equals(EmpiMatchResultEnum.POSSIBLE_DUPLICATE))\n-\t\t\t.map(EmpiLink::getTargetPid).collect(Collectors.toSet()));\n-\t\tourLog.info(\"Deleting {} EMPI link records...\", theLinks.size());\n-\t\tmyEmpiLinkDao.deleteAll(theLinks);\n-\t\tourLog.info(\"{} EMPI link records deleted\", theLinks.size());\n-\t\treturn new ArrayList<>(persons);\n-\t}\n-\n-\t/**\n-\t * Given a valid {@link String}, delete all {@link EmpiLink} entities for that type, and get the Pids\n-\t * for the Person resources which were the sources of the links.\n-\t *\n-\t * @param theTargetType the type of relationship you would like to delete.\n-\t * @return A list of longs representing the Pids of the Person resources used as the sources of the relationships that were deleted.\n-\t */\n-\tpublic List<Long> deleteAllEmpiLinksOfTypeAndReturnPersonPids(String theTargetType) {\n-\t\tEmpiLink link = new EmpiLink();\n-\t\tlink.setEmpiTargetType(theTargetType);\n-\t\tExample<EmpiLink> exampleLink = Example.of(link);\n-\t\tList<EmpiLink> allOfType = myEmpiLinkDao.findAll(exampleLink);\n-\t\treturn deleteEmpiLinksAndReturnGoldenResourcePids(allOfType);\n-\t}\n-\n-\t/**\n-\t * Persist an EmpiLink to the database.\n-\t *\n-\t * @param theEmpiLink the link to save.\n-\t * @return the persisted {@link EmpiLink} entity.\n-\t */\n-\tpublic EmpiLink save(EmpiLink theEmpiLink) {\n-\t\tif (theEmpiLink.getCreated() == null) {\n-\t\t\ttheEmpiLink.setCreated(new Date());\n-\t\t}\n-\t\ttheEmpiLink.setUpdated(new Date());\n-\t\treturn myEmpiLinkDao.save(theEmpiLink);\n-\t}\n-\n-\n-\t/**\n-\t * Given an example {@link EmpiLink}, return all links from the database which match the example.\n-\t *\n-\t * @param theExampleLink The EmpiLink containing the data we would like to search for.\n-\t * @return a list of {@link EmpiLink} entities which match the example.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinkByExample(Example<EmpiLink> theExampleLink) {\n-\t\treturn myEmpiLinkDao.findAll(theExampleLink);\n-\t}\n-\n-\t/**\n-\t * Given a target {@link IBaseResource}, return all {@link EmpiLink} entities in which this target is the target\n-\t * of the relationship. This will show you all links for a given Patient/Practitioner.\n-\t *\n-\t * @param theTargetResource the target resource to find links for.\n-\t * @return all links for the target.\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTarget(IBaseResource theTargetResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(pid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all links pointing from the target resource to the source resource.\n-\t *\n-\t * @param theTargetResource Resource referencing the source resource\n-\t * @param theSourceResource Resource being referenced by the source resource\n-\t *\n-\t * @return\n-\t * \t\tReturns all EMPI links pointing to the source from target resource\n-\t */\n-\tpublic List<EmpiLink> findEmpiLinksByTargetAndSource(IBaseResource theTargetResource, IBaseResource theSourceResource) {\n-\t\tLong targetPid = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tif (targetPid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tLong sourcePid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (sourcePid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setTargetPid(targetPid).setGoldenResourcePid(sourcePid);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Finds all {@link EmpiLink} entities in which theSourceResource's PID is the source\n-\t * of the relationship.\n-\t *\n-\t * @param theSourceResource the source resource to find links for.\n-\t * @return all links for the source.\n-\t */\n-\tpublic List<EmpiLink> findEmpiMatchLinksBySource(IBaseResource theSourceResource) {\n-\t\tLong pid = myIdHelperService.getPidOrNull(theSourceResource);\n-\t\tif (pid == null) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tEmpiLink exampleLink = myEmpiLinkFactory.newEmpiLink().setGoldenResourcePid(pid);\n-\t\texampleLink.setMatchResult(EmpiMatchResultEnum.MATCH);\n-\t\tExample<EmpiLink> example = Example.of(exampleLink);\n-\t\treturn myEmpiLinkDao.findAll(example);\n-\t}\n-\n-\t/**\n-\t * Factory delegation method, whenever you need a new EmpiLink, use this factory method.\n-\t * //TODO Should we make the constructor private for EmpiLink? or work out some way to ensure they can only be instantiated via factory.\n-\t *\n-\t * @return A new {@link EmpiLink}.\n-\t */\n-\tpublic EmpiLink newEmpiLink() {\n-\t\treturn myEmpiLinkFactory.newEmpiLink();\n-\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQ3OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369478", "bodyText": "Fix empi/person in the naming", "author": "nvg-smile", "createdAt": "2020-11-17T17:55:56Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java", "diffHunk": "@@ -42,15 +42,17 @@\n \n \tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n \tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n+\tfinal IEmpiSettings myEmpiSettings;\n \n \t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl) {\n+\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex 1c84c64322..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\tfinal IEmpiSettings myEmpiSettings;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t\tmyEmpiSettings = theIEmpiSettings;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllMdmLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTY2Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369666", "bodyText": "Address empi", "author": "nvg-smile", "createdAt": "2020-11-17T17:56:15Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java", "diffHunk": "@@ -60,15 +62,15 @@ public long expungeAllEmpiLinksOfTargetType(String theResourceType, ServletReque\n \t}\n \n \tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!EmpiUtil.supportedTargetType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.EMPI_CLEAR + \" does not support resource type: \" + theResourceType);\n+\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n+\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n \t\t}\n \t}\n \n \t@Override\n \tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n \t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnPersonPids();\n+\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\ndeleted file mode 100644\nindex 1c84c64322..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiClearSvcImpl.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.IEmpiExpungeSvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.jpa.api.model.DeleteMethodOutcome;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.List;\n-\n-/**\n- * This class is responsible for clearing out existing EMPI links, as well as deleting all persons related to those EMPI Links.\n- *\n- */\n-public class EmpiClearSvcImpl implements IEmpiExpungeSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tfinal EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tfinal EmpiPersonDeletingSvc myEmpiPersonDeletingSvcImpl;\n-\tfinal IEmpiSettings myEmpiSettings;\n-\n-\t@Autowired\n-\tpublic EmpiClearSvcImpl(EmpiLinkDaoSvc theEmpiLinkDaoSvc, EmpiPersonDeletingSvc theEmpiPersonDeletingSvcImpl, IEmpiSettings theIEmpiSettings) {\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyEmpiPersonDeletingSvcImpl = theEmpiPersonDeletingSvcImpl;\n-\t\tmyEmpiSettings = theIEmpiSettings;\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllMdmLinksOfTargetType(String theResourceType, ServletRequestDetails theRequestDetails) {\n-\t\tthrowExceptionIfInvalidTargetType(theResourceType);\n-\t\tourLog.info(\"Clearing all EMPI Links for resource type {}...\", theResourceType);\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksOfTypeAndReturnPersonPids(theResourceType);\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-\n-\tprivate void throwExceptionIfInvalidTargetType(String theResourceType) {\n-\t\tif (!myEmpiSettings.isSupportedMdmType(theResourceType)) {\n-\t\t\tthrow new InvalidRequestException(ProviderConstants.MDM_CLEAR + \" does not support resource type: \" + theResourceType);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic long expungeAllEmpiLinks(ServletRequestDetails theRequestDetails) {\n-\t\tourLog.info(\"Clearing all EMPI Links...\");\n-\t\tList<Long> personPids = myEmpiLinkDaoSvc.deleteAllEmpiLinksAndReturnGoldenResourcePids();\n-\t\tDeleteMethodOutcome deleteOutcome = myEmpiPersonDeletingSvcImpl.expungePersonPids(personPids, theRequestDetails);\n-\t\tourLog.info(\"EMPI clear operation complete.  Removed {} EMPI links and expunged {} Person resources.\", personPids.size(), deleteOutcome.getExpungedResourcesCount());\n-\t\treturn personPids.size();\n-\t}\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTgyNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525369826", "bodyText": "rename params", "author": "nvg-smile", "createdAt": "2020-11-17T17:56:29Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java", "diffHunk": "@@ -47,53 +47,53 @@\n \t@Autowired\n \tEmpiControllerHelper myEmpiControllerHelper;\n \t@Autowired\n-\tIEmpiPersonMergerSvc myEmpiPersonMergerSvc;\n+\tIGoldenResourceMergerSvc myEmpiPersonMergerSvc;\n \t@Autowired\n \tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n \t@Autowired\n \tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n \n \t@Override\n-\tpublic IAnyResource mergePersons(String theFromPersonId, String theToPersonId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestPersonFromIdOrThrowException(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n+\tpublic IAnyResource mergeGoldenResources(String theFromPersonId, String theToPersonId, MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\ndeleted file mode 100644\nindex 0036d1b008..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiControllerSvcImpl.java\n+++ /dev/null\n\n@@ -1,100 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkJson;\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiControllerSvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiLinkUpdaterSvc;\n-import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.provider.EmpiControllerHelper;\n-import ca.uhn.fhir.empi.provider.EmpiControllerUtil;\n-import ca.uhn.fhir.rest.server.provider.ProviderConstants;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.jetbrains.annotations.Nullable;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.stream.Stream;\n-\n-/**\n- * This class acts as a layer between EmpiProviders and EMPI services to support a REST API that's not a FHIR Operation API.\n- */\n-@Service\n-public class EmpiControllerSvcImpl implements IEmpiControllerSvc {\n-\t@Autowired\n-\tEmpiControllerHelper myEmpiControllerHelper;\n-\t@Autowired\n-\tIGoldenResourceMergerSvc myEmpiPersonMergerSvc;\n-\t@Autowired\n-\tIEmpiLinkQuerySvc myEmpiLinkQuerySvc;\n-\t@Autowired\n-\tIEmpiLinkUpdaterSvc myIEmpiLinkUpdaterSvc;\n-\n-\t@Override\n-\tpublic IAnyResource mergeGoldenResources(String theFromPersonId, String theToPersonId, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIAnyResource fromPerson = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPersonId);\n-\t\tIAnyResource toPerson = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPersonId);\n-\t\tmyEmpiControllerHelper.validateMergeResources(fromPerson, toPerson);\n-\t\tmyEmpiControllerHelper.validateSameVersion(fromPerson, theFromPersonId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(toPerson, theToPersonId);\n-\n-\t\treturn myEmpiPersonMergerSvc.mergeGoldenResources(fromPerson, toPerson, theMdmTransactionContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> queryLinks(@Nullable String thePersonId, @Nullable String theTargetId, @Nullable String theMatchResult, @Nullable String theLinkSource, MdmTransactionContext theEmpiContext) {\n-\t\tIIdType personId = EmpiControllerUtil.extractPersonIdDtOrNull(ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, thePersonId);\n-\t\tIIdType targetId = EmpiControllerUtil.extractTargetIdDtOrNull(ProviderConstants.MDM_QUERY_LINKS_RESOURCE_ID, theTargetId);\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tEmpiLinkSourceEnum linkSource = EmpiControllerUtil.extractLinkSourceOrNull(theLinkSource);\n-\n-\t\treturn myEmpiLinkQuerySvc.queryLinks(personId, targetId, matchResult, linkSource, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic Stream<EmpiLinkJson> getDuplicateGoldenResources(MdmTransactionContext theEmpiContext) {\n-\t\treturn myEmpiLinkQuerySvc.getDuplicatePersons(theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic IAnyResource updateLink(String theGoldenResourceId, String theTargetId, String theMatchResult, MdmTransactionContext theEmpiContext) {\n-\t\tEmpiMatchResultEnum matchResult = EmpiControllerUtil.extractMatchResultOrNull(theMatchResult);\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, theGoldenResourceId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestTargetFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, theTargetId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(person, theGoldenResourceId);\n-\t\tmyEmpiControllerHelper.validateSameVersion(target, theTargetId);\n-\n-\t\treturn myIEmpiLinkUpdaterSvc.updateLink(person, target, matchResult, theEmpiContext);\n-\t}\n-\n-\t@Override\n-\tpublic void notDuplicateGoldenResource(String thePersonId, String theTargetPersonId, MdmTransactionContext theEmpiContext) {\n-\t\tIAnyResource person = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, thePersonId);\n-\t\tIAnyResource target = myEmpiControllerHelper.getLatestGoldenResourceFromIdOrThrowException(ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, theTargetPersonId);\n-\n-\t\tmyIEmpiLinkUpdaterSvc.notDuplicatePerson(person, target, theEmpiContext);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDkwOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525370908", "bodyText": "Remove EMPI / SourceResource", "author": "nvg-smile", "createdAt": "2020-11-17T17:58:05Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -51,7 +51,7 @@\n \t@Autowired\n \tprivate IEmpiLinkSvc myEmpiLinkSvc;\n \t@Autowired\n-\tprivate EmpiPersonFindingSvc myEmpiPersonFindingSvc;\n+\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 51%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..6399066531 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n\n@@ -43,84 +43,84 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiEidUpdateService {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmEidUpdateService {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\tprivate IMdmLinkSvc myMdmLinkSvc;\n \t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n+\tprivate MdmGoldenResourceFindingSvc myMdmGoldenResourceFindingSvc;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tprivate MdmLinkDaoSvc myMdmLinkDaoSvc;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n+\tvoid handleMdmUpdate(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tMdmUpdateContext updateContext = new MdmUpdateContext(theMatchedGoldenResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n \t\t\t// Copy over any new external EIDs which don't already exist.\n \t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n \t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\t\t\tmyMdmLinkSvc.updateLink(updateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedGoldenResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedGoldenResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedGoldenResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedGoldenResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mzk2Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525373963", "bodyText": "Introduce a boolean flag to remove comments, along the lines of \"isOverwritableEidResource\", may be?", "author": "nvg-smile", "createdAt": "2020-11-17T18:02:42Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 51%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..6399066531 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n\n@@ -43,84 +43,84 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiEidUpdateService {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmEidUpdateService {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\tprivate IMdmLinkSvc myMdmLinkSvc;\n \t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n+\tprivate MdmGoldenResourceFindingSvc myMdmGoldenResourceFindingSvc;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tprivate MdmLinkDaoSvc myMdmLinkDaoSvc;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n+\tvoid handleMdmUpdate(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tMdmUpdateContext updateContext = new MdmUpdateContext(theMatchedGoldenResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n \t\t\t// Copy over any new external EIDs which don't already exist.\n \t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n \t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\t\t\tmyMdmLinkSvc.updateLink(updateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedGoldenResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedGoldenResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedGoldenResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedGoldenResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NDEwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525374109", "bodyText": "Fix SourceResource", "author": "nvg-smile", "createdAt": "2020-11-17T18:02:57Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n-\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theEmpiTransactionContext, theUpdateContext.getExistingPerson());\n+\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n \t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedPersonCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getPersonPid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 51%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..6399066531 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n\n@@ -43,84 +43,84 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiEidUpdateService {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmEidUpdateService {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\tprivate IMdmLinkSvc myMdmLinkSvc;\n \t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n+\tprivate MdmGoldenResourceFindingSvc myMdmGoldenResourceFindingSvc;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tprivate MdmLinkDaoSvc myMdmLinkDaoSvc;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n+\tvoid handleMdmUpdate(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tMdmUpdateContext updateContext = new MdmUpdateContext(theMatchedGoldenResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n \t\t\t// Copy over any new external EIDs which don't already exist.\n \t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n \t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\t\t\tmyMdmLinkSvc.updateLink(updateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedGoldenResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedGoldenResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedGoldenResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedGoldenResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NDk3Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525374972", "bodyText": "Do we need to update EmpiMatchOutcome into MdmMatchOutcome and fix enum literals?", "author": "nvg-smile", "createdAt": "2020-11-17T18:04:26Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java", "diffHunk": "@@ -61,68 +61,70 @@\n \t@Autowired\n \tprivate IEmpiSettings myEmpiSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext) {\n-\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedPersonCandidate, theResource);\n-\n+\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n-\t\t\tmyPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\t// Copy over any new external EIDs which don't already exist.\n+\t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n+\t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedPersonCandidate, theEmpiTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedPerson(), theEmpiTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedPersonCandidate theMatchedPersonCandidate, EmpiTransactionContext theEmpiTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n \t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myPersonHelper.getLinkCount(theUpdateContext.getMatchedPerson()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n-\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theEmpiTransactionContext, theUpdateContext.getExistingPerson());\n+\t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n+\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedPerson(), theResource, theMatchedPersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n \t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedPersonCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getPersonPid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n-\tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext, IAnyResource theOldPerson) {\n-\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createPersonFromEmpiTarget(theResource);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n+\t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n+\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\n+\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n-\tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tlog(theEmpiTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theEmpiTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n-\t\tlog(theEmpiTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theEmpiTransactionContext);\n+\tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n+\t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n+\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nsimilarity index 51%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\nindex 7c3bcb2d43..6399066531 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiEidUpdateService.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmEidUpdateService.java\n\n@@ -43,84 +43,84 @@ import java.util.List;\n import java.util.Optional;\n \n @Service\n-public class EmpiEidUpdateService {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmEidUpdateService {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n+\tprivate IMdmLinkSvc myMdmLinkSvc;\n \t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n+\tprivate MdmGoldenResourceFindingSvc myMdmGoldenResourceFindingSvc;\n \t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n+\tprivate GoldenResourceHelper myGoldenResourceHelper;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tprivate MdmLinkDaoSvc myMdmLinkDaoSvc;\n \t@Autowired\n-\tprivate IEmpiSettings myEmpiSettings;\n+\tprivate IMdmSettings myMdmSettings;\n \n-\tvoid handleEmpiUpdate(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tEmpiUpdateContext updateContext = new EmpiUpdateContext(theMatchedSourceResourceCandidate, theResource);\n+\tvoid handleMdmUpdate(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext) {\n+\t\tMdmUpdateContext updateContext = new MdmUpdateContext(theMatchedGoldenResourceCandidate, theResource);\n \t\tif (updateContext.isRemainsMatchedToSamePerson()) {\n \t\t\t// Copy over any new external EIDs which don't already exist.\n \t\t\t// TODO NG - Eventually this call will use terser to clone data in, once the surviorship rules for copying data will be confirmed\n \t\t\t// myPersonHelper.updatePersonFromUpdatedEmpiTarget(updateContext.getMatchedPerson(), theResource, theEmpiTransactionContext);\n \t\t\tif (!updateContext.isIncomingResourceHasAnEid() || updateContext.isHasEidsInCommon()) {\n \t\t\t\t//update to patient that uses internal EIDs only.\n-\t\t\t\tmyEmpiLinkSvc.updateLink(updateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\t\t\tmyMdmLinkSvc.updateLink(updateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\t\t} else if (!updateContext.isHasEidsInCommon()) {\n-\t\t\t\thandleNoEidsInCommon(theResource, theMatchedSourceResourceCandidate, theMdmTransactionContext, updateContext);\n+\t\t\t\thandleNoEidsInCommon(theResource, theMatchedGoldenResourceCandidate, theMdmTransactionContext, updateContext);\n \t\t\t}\n \t\t} else {\n \t\t\t//This is a new linking scenario. we have to break the existing link and link to the new person. For now, we create duplicate.\n \t\t\t//updated patient has an EID that matches to a new candidate. Link them, and set the persons possible duplicates\n-\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedSourceResource(), theMdmTransactionContext);\n+\t\t\tlinkToNewPersonAndFlagAsDuplicate(theResource, updateContext.getExistingPerson(), updateContext.getMatchedGoldenResource(), theMdmTransactionContext);\n \t\t}\n \t}\n \n-\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedSourceResourceCandidate theMatchedSourceResourceCandidate, MdmTransactionContext theMdmTransactionContext, EmpiUpdateContext theUpdateContext) {\n+\tprivate void handleNoEidsInCommon(IAnyResource theResource, MatchedGoldenResourceCandidate theMatchedGoldenResourceCandidate, MdmTransactionContext theMdmTransactionContext, MdmUpdateContext theUpdateContext) {\n \t\t// the user is simply updating their EID. We propagate this change to the Person.\n \t\t//overwrite. No EIDS in common, but still same person.\n-\t\tif (myEmpiSettings.isPreventMultipleEids()) {\n-\t\t\tif (myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(theUpdateContext.getMatchedSourceResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t// if (myPersonHelper.getLinkCount(theUpdateContext.getMatchedSourceResource()) <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n-\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\tif (myMdmSettings.isPreventMultipleEids()) {\n+\t\t\tif (myMdmLinkDaoSvc.findMdmMatchLinksBySource(theUpdateContext.getMatchedGoldenResource()).size() <= 1) { // If there is only 0/1 link on the person, we can safely overwrite the EID.\n+\t\t\t\thandleExternalEidOverwrite(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t\t} else { // If the person has multiple patients tied to it, we can't just overwrite the EID, so we split the person.\n \t\t\t\tcreateNewPersonAndFlagAsDuplicate(theResource, theMdmTransactionContext, theUpdateContext.getExistingPerson());\n \t\t\t}\n \t\t} else {\n-\t\t\tmyPersonHelper.handleExternalEidAddition(theUpdateContext.getMatchedSourceResource(), theResource, theMdmTransactionContext);\n+\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(theUpdateContext.getMatchedGoldenResource(), theResource, theMdmTransactionContext);\n \t\t}\n-\t\tmyEmpiLinkSvc.updateLink(theUpdateContext.getMatchedSourceResource(), theResource, theMatchedSourceResourceCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theUpdateContext.getMatchedGoldenResource(), theResource, theMatchedGoldenResourceCandidate.getMatchResult(), MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void handleExternalEidOverwrite(IAnyResource thePerson, IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tmyPersonHelper.overwriteExternalEids(thePerson, eidFromResource);\n+\t\t\tmyGoldenResourceHelper.overwriteExternalEids(thePerson, eidFromResource);\n \t\t}\n \t}\n \n-\tprivate boolean candidateIsSameAsEmpiLinkPerson(EmpiLink theExistingMatchLink, MatchedSourceResourceCandidate thePersonCandidate) {\n-\t\treturn theExistingMatchLink.getSourceResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n+\tprivate boolean candidateIsSameAsMdmLinkPerson(MdmLink theExistingMatchLink, MatchedGoldenResourceCandidate thePersonCandidate) {\n+\t\treturn theExistingMatchLink.getGoldenResourcePid().equals(thePersonCandidate.getCandidatePersonPid().getIdAsLong());\n \t}\n \n \tprivate void createNewPersonAndFlagAsDuplicate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext, IAnyResource theOldPerson) {\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tIAnyResource newPerson = myPersonHelper.createGoldenResourceFromMdmTarget(theResource);\n+\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n \n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(newPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void linkToNewPersonAndFlagAsDuplicate(IAnyResource theResource, IAnyResource theOldPerson, IAnyResource theNewPerson, MdmTransactionContext theMdmTransactionContext) {\n \t\tlog(theMdmTransactionContext, \"Changing a match link!\");\n-\t\tmyEmpiLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.deleteLink(theOldPerson, theResource, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theResource, MdmMatchOutcome.NEW_PERSON_MATCH, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\tmyEmpiLinkSvc.updateLink(theNewPerson, theOldPerson, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n+\t\tmyMdmLinkSvc.updateLink(theNewPerson, theOldPerson, MdmMatchOutcome.POSSIBLE_DUPLICATE, MdmLinkSourceEnum.AUTO, theMdmTransactionContext);\n \t}\n \n \tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NjE2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525376169", "bodyText": "Remove obsolete code", "author": "nvg-smile", "createdAt": "2020-11-17T18:06:04Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java", "diffHunk": "@@ -102,33 +101,36 @@ private boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theT\n \t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n \t}\n \n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n+//\t@Override\n+//\t@Transactional\n+//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex 79100f79a7..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n\n@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.Optional;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theMdmTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\n-//\t\tswitch (matchResultEnum) {\n-//\t\t\tcase MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase NO_MATCH:\n-//\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_DUPLICATE:\n-//\t\t\t\tbreak;\n-//\t\t}\n-\t\tmyEmpiResourceDaoSvc.upsertSourceResource(thePerson, theMdmTransactionContext.getResourceType());\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-//\t@Override\n-//\t@Transactional\n-//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n-//\n-//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n-//\n-//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-//\t\t\t.map(this::personLinkFromEmpiLink)\n-//\t\t\t.collect(Collectors.toList());\n-//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-//\t\tif (newLinks.size() > origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t} else if (newLinks.size() < origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t}\n-//\n-//\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n-\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkBySourceResourcePidAndTargetResourcePid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(theSourceResource, theTargetResource, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NjMxNA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525376314", "bodyText": "handle S/R", "author": "nvg-smile", "createdAt": "2020-11-17T18:06:19Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java", "diffHunk": "@@ -102,33 +101,36 @@ private boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theT\n \t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n \t}\n \n-\t@Override\n-\t@Transactional\n-\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tint origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-\n-\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksByPerson(thePersonResource);\n-\n-\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-\t\t\t.map(this::personLinkFromEmpiLink)\n-\t\t\t.collect(Collectors.toList());\n-\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-\t\tif (newLinks.size() > origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t} else if (newLinks.size() < origLinkCount) {\n-\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-\t\t}\n-\n-\t}\n+//\t@Override\n+//\t@Transactional\n+//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n+//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n+//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n+//\n+//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n+//\n+//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n+//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n+//\t\t\t.map(this::personLinkFromEmpiLink)\n+//\t\t\t.collect(Collectors.toList());\n+//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n+//\t\tif (newLinks.size() > origLinkCount) {\n+//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n+//\t\t} else if (newLinks.size() < origLinkCount) {\n+//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n+//\t\t}\n+//\n+//\t}\n \n \t@Override\n-\tpublic void deleteLink(IAnyResource theExistingPerson, IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tmyPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theExistingPerson, theResource);\n+\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n+//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n+\n+\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n \t\tif (oEmpiLink.isPresent()) {\n \t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theEmpiTransactionContext, \"Deleting EmpiLink [\" + theExistingPerson.getIdElement().toVersionless() + \" -> \" + theResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n+\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\ndeleted file mode 100644\nindex 79100f79a7..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcImpl.java\n+++ /dev/null\n\n@@ -1,191 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import javax.transaction.Transactional;\n-import java.util.Optional;\n-\n-/**\n- * This class is in charge of managing EmpiLinks between Persons and target resources\n- */\n-@Service\n-public class EmpiLinkSvcImpl implements IEmpiLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n-\t@Autowired\n-\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\t@Autowired\n-\tprivate PersonHelper myPersonHelper;\n-\t@Autowired\n-\tprivate IdHelperService myIdHelperService;\n-\n-\t@Override\n-\t@Transactional\n-\tpublic void updateLink(IAnyResource thePerson, IAnyResource theTarget, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tIIdType resourceId = theTarget.getIdElement().toUnqualifiedVersionless();\n-\n-\t\tif (theMatchOutcome.isPossibleDuplicate() && personsLinkedAsNoMatch(thePerson, theTarget)) {\n-\t\t\tlog(theMdmTransactionContext, thePerson.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" is linked as NO_MATCH with \" +\n-\t\t\t\ttheTarget.getIdElement().toUnqualifiedVersionless() +\n-\t\t\t\t\" not linking as POSSIBLE_DUPLICATE.\");\n-\t\t\treturn;\n-\t\t}\n-\t\tEmpiMatchResultEnum matchResultEnum = theMatchOutcome.getMatchResultEnum();\n-\t\tvalidateRequestIsLegal(thePerson, theTarget, matchResultEnum, theLinkSource);\n-\n-//\t\tswitch (matchResultEnum) {\n-//\t\t\tcase MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tmyEmpiResourceDaoSvc.updatePerson(thePerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_MATCH:\n-//\t\t\t\tmyPersonHelper.addOrUpdateLink(thePerson, resourceId, AssuranceLevelUtil.getAssuranceLevel(matchResultEnum, theLinkSource), theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase NO_MATCH:\n-//\t\t\t\tmyPersonHelper.removeLink(thePerson, resourceId, theEmpiTransactionContext);\n-//\t\t\t\tbreak;\n-//\t\t\tcase POSSIBLE_DUPLICATE:\n-//\t\t\t\tbreak;\n-//\t\t}\n-\t\tmyEmpiResourceDaoSvc.upsertSourceResource(thePerson, theMdmTransactionContext.getResourceType());\n-\t\tcreateOrUpdateLinkEntity(thePerson, theTarget, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate boolean personsLinkedAsNoMatch(IAnyResource thePerson, IAnyResource theTarget) {\n-\t\tLong personId = myIdHelperService.getPidOrThrowException(thePerson);\n-\t\tLong targetId = myIdHelperService.getPidOrThrowException(theTarget);\n-\t\t// TODO perf collapse into one query\n-\t\treturn myEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(personId, targetId, EmpiMatchResultEnum.NO_MATCH).isPresent() ||\n-\t\t\tmyEmpiLinkDaoSvc.getEmpiLinksByPersonPidTargetPidAndMatchResult(targetId, personId, EmpiMatchResultEnum.NO_MATCH).isPresent();\n-\t}\n-\n-//\t@Override\n-//\t@Transactional\n-//\tpublic void syncEmpiLinksToPersonLinks(IAnyResource thePersonResource, EmpiTransactionContext theEmpiTransactionContext) {\n-//\t\t// int origLinkCount = myPersonHelper.getLinkCount(thePersonResource);\n-//\t\tint origLinkCount = myEmpiLinkDaoSvc.findEmpiMatchLinksBySource(thePersonResource).size();\n-//\n-//\t\tList<EmpiLink> empiLinks = myEmpiLinkDaoSvc.findEmpiLinksBySourceResource(thePersonResource);\n-//\n-//\t\tList<IBaseBackboneElement> newLinks = empiLinks.stream()\n-//\t\t\t.filter(link -> link.isMatch() || link.isPossibleMatch() || link.isRedirect())\n-//\t\t\t.map(this::personLinkFromEmpiLink)\n-//\t\t\t.collect(Collectors.toList());\n-//\t\tmyPersonHelper.setLinks(thePersonResource, newLinks);\n-//\t\tif (newLinks.size() > origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links increased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t} else if (newLinks.size() < origLinkCount) {\n-//\t\t\tlog(theEmpiTransactionContext, thePersonResource.getIdElement().toVersionless() + \" links decreased from \" + origLinkCount + \" to \" + newLinks.size());\n-//\t\t}\n-//\n-//\t}\n-\n-\t@Override\n-\tpublic void deleteLink(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t// myPersonHelper.removeLink(theExistingPerson, theResource.getIdElement(), theEmpiTransactionContext);\n-//\t\t myEmpiLinkDaoSvc.deleteEmpiLinks(theSourceResource, theTargetResource);\n-\n-\t\tOptional<EmpiLink> oEmpiLink = getEmpiLinkForPersonTargetPair(theSourceResource, theTargetResource);\n-\t\tif (oEmpiLink.isPresent()) {\n-\t\t\tEmpiLink empiLink = oEmpiLink.get();\n-\t\t\tlog(theMdmTransactionContext, \"Deleting EmpiLink [\" + theSourceResource.getIdElement().toVersionless() + \" -> \" + theTargetResource.getIdElement().toVersionless() + \"] with result: \" + empiLink.getMatchResult());\n-\t\t\tmyEmpiLinkDaoSvc.deleteLink(empiLink);\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement personLinkFromEmpiLink(EmpiLink empiLink) {\n-\t\tIIdType resourceId = myIdHelperService.resourceIdFromPidOrThrowException(empiLink.getTargetPid());\n-\t\tCanonicalIdentityAssuranceLevel assuranceLevel = AssuranceLevelUtil.getAssuranceLevel(empiLink.getMatchResult(), empiLink.getLinkSource());\n-\t\treturn myPersonHelper.newPersonLink(resourceId, assuranceLevel);\n-\t}\n-\n-\t/**\n-\t * Helper function which runs various business rules about what types of requests are allowed.\n-\t */\n-\tprivate void validateRequestIsLegal(IAnyResource thePerson, IAnyResource theResource, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource) {\n-\t\tOptional<EmpiLink> oExistingLink = getEmpiLinkForPersonTargetPair(thePerson, theResource);\n-\t\tif (oExistingLink.isPresent() && systemIsAttemptingToModifyManualLink(theLinkSource, oExistingLink.get())) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to modify links on manually created links\");\n-\t\t}\n-\n-\t\tif (systemIsAttemptingToAddNoMatch(theLinkSource, theMatchResult)) {\n-\t\t\tthrow new InternalErrorException(\"EMPI system is not allowed to automatically NO_MATCH a resource\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Helper function which detects when the EMPI system is attempting to add a NO_MATCH link, which is not allowed.\n-\t */\n-\tprivate boolean systemIsAttemptingToAddNoMatch(EmpiLinkSourceEnum theLinkSource, EmpiMatchResultEnum theMatchResult) {\n-\t\treturn theLinkSource == EmpiLinkSourceEnum.AUTO && theMatchResult == EmpiMatchResultEnum.NO_MATCH;\n-\t}\n-\n-\t/**\n-\t * Helper function to let us catch when System EMPI rules are attempting to override a manually defined link.\n-\t */\n-\tprivate boolean systemIsAttemptingToModifyManualLink(EmpiLinkSourceEnum theIncomingSource, EmpiLink theExistingSource) {\n-\t\treturn theIncomingSource == EmpiLinkSourceEnum.AUTO && theExistingSource.isManual();\n-\t}\n-\n-\tprivate Optional<EmpiLink> getEmpiLinkForPersonTargetPair(IAnyResource thePerson, IAnyResource theCandidate) {\n-\t\tif (thePerson.getIdElement().getIdPart() == null || theCandidate.getIdElement().getIdPart() == null) {\n-\t\t\treturn Optional.empty();\n-\t\t} else {\n-\t\t\treturn myEmpiLinkDaoSvc.getLinkBySourceResourcePidAndTargetResourcePid(\n-\t\t\t\tmyIdHelperService.getPidOrNull(thePerson),\n-\t\t\t\tmyIdHelperService.getPidOrNull(theCandidate)\n-\t\t\t);\n-\t\t}\n-\t}\n-\n-\tprivate void createOrUpdateLinkEntity(IBaseResource theSourceResource, IBaseResource theTargetResource, EmpiMatchOutcome theMatchOutcome, EmpiLinkSourceEnum theLinkSource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tmyEmpiLinkDaoSvc.createOrUpdateLinkEntity(theSourceResource, theTargetResource, theMatchOutcome, theLinkSource, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NzQxMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377412", "bodyText": "rename EMPI previx", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:01Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java", "diffHunk": "@@ -63,48 +63,49 @@\n \t * Does nothing if resource is determined to be not managed by EMPI.\n \t *\n \t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n-\t * @param theEmpiTransactionContext\n+\t * @param theMdmTransactionContext\n \t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n \t */\n-\tpublic EmpiTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n+\tpublic MdmTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n \t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n-\t\t\treturn doEmpiUpdate(theResource, theEmpiTransactionContext);\n+\t\t\treturn doEmpiUpdate(theResource, theMdmTransactionContext);\n \t\t} else {\n \t\t\treturn null;\n \t\t}\n \t}\n \n-\tprivate EmpiTransactionContext doEmpiUpdate(IAnyResource theResource, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tCandidateList candidateList = myEmpiPersonFindingSvc.findPersonCandidates(theResource);\n+\tprivate MdmTransactionContext doEmpiUpdate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\tCandidateList candidateList = myEmpiSourceResourceFindingSvc.findSourceResourceCandidates(theResource);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\ndeleted file mode 100644\nindex 4e7a86d409..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvc.java\n+++ /dev/null\n\n@@ -1,165 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.CandidateList;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.EmpiSourceResourceFindingSvc;\n-import ca.uhn.fhir.jpa.empi.svc.candidate.MatchedSourceResourceCandidate;\n-import ca.uhn.fhir.rest.server.TransactionLogMessages;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * EmpiMatchLinkSvc is the entrypoint for HAPI's EMPI system. An incoming resource can call\n- * updateEmpiLinksForEmpiTarget and the underlying EMPI system will take care of matching it to a person, or creating a\n- * new Person if a suitable one was not found.\n- */\n-@Service\n-public class EmpiMatchLinkSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\t@Autowired\n-\tprivate IEmpiLinkSvc myEmpiLinkSvc;\n-\t@Autowired\n-\tprivate EmpiSourceResourceFindingSvc myEmpiSourceResourceFindingSvc;\n-\t@Autowired\n-\tprivate PersonHelper myGoldenResourceHelper;\n-\t@Autowired\n-\tprivate EmpiEidUpdateService myEidUpdateService;\n-\n-\t/**\n-\t * Given an Empi Target (consisting of either a Patient or a Practitioner), find a suitable Person candidate for them,\n-\t * or create one if one does not exist. Performs matching based on rules defined in empi-rules.json.\n-\t * Does nothing if resource is determined to be not managed by EMPI.\n-\t *\n-\t * @param theResource the incoming EMPI target, which is either a Patient or Practitioner.\n-\t * @param theMdmTransactionContext\n-\t * @return an {@link TransactionLogMessages} which contains all informational messages related to EMPI processing of this resource.\n-\t */\n-\tpublic MdmTransactionContext updateEmpiLinksForEmpiTarget(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tif (EmpiUtil.isEmpiAccessible(theResource)) {\n-\t\t\treturn doEmpiUpdate(theResource, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\tprivate MdmTransactionContext doEmpiUpdate(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tCandidateList candidateList = myEmpiSourceResourceFindingSvc.findSourceResourceCandidates(theResource);\n-\n-\t\tif (candidateList.isEmpty()) {\n-\t\t\thandleEmpiWithNoCandidates(theResource, theMdmTransactionContext);\n-\t\t} else if (candidateList.exactlyOneMatch()) {\n-\t\t\thandleEmpiWithSingleCandidate(theResource, candidateList.getOnlyMatch(), theMdmTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiWithMultipleCandidates(theResource, candidateList, theMdmTransactionContext);\n-\t\t}\n-\t\treturn theMdmTransactionContext;\n-\t}\n-\n-\tprivate void handleEmpiWithMultipleCandidates(IAnyResource theResource, CandidateList theCandidateList, MdmTransactionContext theMdmTransactionContext) {\n-\t\tMatchedSourceResourceCandidate firstMatch = theCandidateList.getFirstMatch();\n-\t\tLong samplePersonPid = firstMatch.getCandidatePersonPid().getIdAsLong();\n-\t\tboolean allSamePerson = theCandidateList.stream()\n-\t\t\t.allMatch(candidate -> candidate.getCandidatePersonPid().getIdAsLong().equals(samplePersonPid));\n-\n-\t\tif (allSamePerson) {\n-\t\t\tlog(theMdmTransactionContext, \"EMPI received multiple match candidates, but they are all linked to the same person.\");\n-\t\t\thandleEmpiWithSingleCandidate(theResource, firstMatch, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\tlog(theMdmTransactionContext, \"EMPI received multiple match candidates, that were linked to different Persons. Setting POSSIBLE_DUPLICATES and POSSIBLE_MATCHES.\");\n-\t\t\t//Set them all as POSSIBLE_MATCH\n-\t\t\tList<IAnyResource> persons = new ArrayList<>();\n-\t\t\tfor (MatchedSourceResourceCandidate matchedSourceResourceCandidate : theCandidateList.getCandidates()) {\n-\t\t\t\tIAnyResource person = myEmpiSourceResourceFindingSvc\n-\t\t\t\t\t.getSourceResourceFromMatchedSourceResourceCandidate(matchedSourceResourceCandidate, theMdmTransactionContext.getResourceType());\n-\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_MATCH;\n-\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\tmyEmpiLinkSvc.updateLink(person, theResource, outcome, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\t\tpersons.add(person);\n-\t\t\t}\n-\n-\t\t\t//Set all Persons as POSSIBLE_DUPLICATE of the last person.\n-\t\t\tIAnyResource firstPerson = persons.get(0);\n-\t\t\tpersons.subList(1, persons.size())\n-\t\t\t\t.forEach(possibleDuplicatePerson -> {\n-\t\t\t\t\tEmpiMatchOutcome outcome = EmpiMatchOutcome.POSSIBLE_DUPLICATE;\n-\t\t\t\t\toutcome.setEidMatch(theCandidateList.isEidMatch());\n-\t\t\t\t\tmyEmpiLinkSvc.updateLink(firstPerson, possibleDuplicatePerson, outcome, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithNoCandidates(IAnyResource theResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, String.format(\"There were no matched candidates for EMPI, creating a new %s.\", theResource.getIdElement().getResourceType()));\n-\t\tIAnyResource newPerson = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theResource);\n-\t\t// TODO GGG :)\n-\t\t// 1. Get the right helper\n-\t\t// 2. Create source resoruce for the EMPI target\n-\t\t// 3. UPDATE EMPI LINK TABLE\n-\n-\t\tmyEmpiLinkSvc.updateLink(newPerson, theResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t}\n-\n-\tprivate void handleEmpiCreate(IAnyResource theTargetResource, MatchedSourceResourceCandidate thePersonCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tIAnyResource sourceResource = myEmpiSourceResourceFindingSvc.getSourceResourceFromMatchedSourceResourceCandidate(thePersonCandidate, theMdmTransactionContext.getResourceType());\n-\n-\t\tif (myGoldenResourceHelper.isPotentialDuplicate(sourceResource, theTargetResource)) {\n-\t\t\tlog(theMdmTransactionContext, \"Duplicate detected based on the fact that both resources have different external EIDs.\");\n-\t\t\tIAnyResource newSourceResource = myGoldenResourceHelper.createGoldenResourceFromMdmTarget(theTargetResource);\n-\t\t\tmyEmpiLinkSvc.updateLink(newSourceResource, theTargetResource, EmpiMatchOutcome.NEW_PERSON_MATCH, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t\tmyEmpiLinkSvc.updateLink(newSourceResource, sourceResource, EmpiMatchOutcome.POSSIBLE_DUPLICATE, EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\tif (thePersonCandidate.isMatch()) {\n-\t\t\t\tmyGoldenResourceHelper.handleExternalEidAddition(sourceResource, theTargetResource, theMdmTransactionContext);\n-\t\t\t\t// myPersonHelper.updatePersonFromNewlyCreatedEmpiTarget(person, theResource, theEmpiTransactionContext);\n-\t\t\t}\n-\t\t\tmyEmpiLinkSvc.updateLink(sourceResource, theTargetResource, thePersonCandidate.getMatchResult(), EmpiLinkSourceEnum.AUTO, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void handleEmpiWithSingleCandidate(IAnyResource theResource, MatchedSourceResourceCandidate thePersonCandidate, MdmTransactionContext theMdmTransactionContext) {\n-\t\tlog(theMdmTransactionContext, \"EMPI has narrowed down to one candidate for matching.\");\n-\t\tif (theMdmTransactionContext.getRestOperation().equals(MdmTransactionContext.OperationType.UPDATE_RESOURCE)) {\n-\t\t\tmyEidUpdateService.handleEmpiUpdate(theResource, thePersonCandidate, theMdmTransactionContext);\n-\t\t} else {\n-\t\t\thandleEmpiCreate(theResource, thePersonCandidate, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3NzgyMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377820", "bodyText": "Remove import", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:42Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java", "diffHunk": "@@ -22,96 +22,89 @@\n \n import ca.uhn.fhir.empi.api.EmpiConstants;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n+import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n import ca.uhn.fhir.rest.api.server.IBundleProvider;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n import ca.uhn.fhir.rest.param.TokenParam;\n import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nsimilarity index 77%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nindex 039b222c0e..90adb25613 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\n\n@@ -20,8 +20,8 @@ package ca.uhn.fhir.jpa.empi.svc;\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Nzk1Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525377952", "bodyText": "Fix S/R", "author": "nvg-smile", "createdAt": "2020-11-17T18:08:58Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java", "diffHunk": "@@ -22,96 +22,89 @@\n \n import ca.uhn.fhir.empi.api.EmpiConstants;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n+import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n import ca.uhn.fhir.rest.api.server.IBundleProvider;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n import ca.uhn.fhir.rest.param.TokenParam;\n import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n+import org.jetbrains.annotations.NotNull;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n-import javax.annotation.PostConstruct;\n import java.util.List;\n import java.util.Optional;\n-import java.util.stream.Collectors;\n \n @Service\n public class EmpiResourceDaoSvc {\n+\n \tprivate static final int MAX_MATCHING_PERSONS = 1000;\n+\n \t@Autowired\n \tDaoRegistry myDaoRegistry;\n \t@Autowired\n \tIEmpiSettings myEmpiConfig;\n \n-\tprivate IFhirResourceDao<IBaseResource> myPatientDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPersonDao;\n-\tprivate IFhirResourceDao<IBaseResource> myPractitionerDao;\n-\n-\t@PostConstruct\n-\tpublic void postConstruct() {\n-\t\tmyPatientDao = myDaoRegistry.getResourceDao(\"Patient\");\n-\t\tmyPersonDao = myDaoRegistry.getResourceDao(\"Person\");\n-\t\tmyPractitionerDao = myDaoRegistry.getResourceDao(\"Practitioner\");\n-\t}\n-\n-\tpublic IAnyResource readPatient(IIdType theId) {\n-\t\treturn (IAnyResource) myPatientDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPerson(IIdType theId) {\n-\t\treturn (IAnyResource) myPersonDao.read(theId);\n-\t}\n-\n-\tpublic IAnyResource readPractitioner(IIdType theId) {\n-\t\treturn (IAnyResource) myPractitionerDao.read(theId);\n-\t}\n-\n-\tpublic DaoMethodOutcome updatePerson(IAnyResource thePerson) {\n-\t\tif (thePerson.getIdElement().hasIdPart()) {\n-\t\t\treturn myPersonDao.update(thePerson);\n+\tpublic DaoMethodOutcome upsertSourceResource(IAnyResource theSourceResource, String theResourceType) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nsimilarity index 77%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\nindex 039b222c0e..90adb25613 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiResourceDaoSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/MdmResourceDaoSvc.java\n\n@@ -20,8 +20,8 @@ package ca.uhn.fhir.jpa.empi.svc;\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n import ca.uhn.fhir.jpa.api.model.DaoMethodOutcome;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MDUzMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525380531", "bodyText": "removeTargetLinks can be removed altogether?", "author": "nvg-smile", "createdAt": "2020-11-17T18:12:52Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/GoldenResourceMergerSvcImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiLinkSvc;\n+import ca.uhn.fhir.empi.api.IGoldenResourceMergerSvc;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.MdmTransactionContext;\n+import ca.uhn.fhir.empi.util.PersonHelper;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class GoldenResourceMergerSvcImpl implements IGoldenResourceMergerSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tPersonHelper myPersonHelper;\n+\t@Autowired\n+\tEmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tIEmpiLinkSvc myEmpiLinkSvc;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tEmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\n+\t@Override\n+\t@Transactional\n+\tpublic IAnyResource mergeGoldenResources(IAnyResource theFromGoldenResource, IAnyResource theToGoldenResource, MdmTransactionContext theMdmTransactionContext) {\n+\t\tLong fromGoldenResourcePid = myIdHelperService.getPidOrThrowException(theFromGoldenResource);\n+\t\tLong toGoldenResourcePid = myIdHelperService.getPidOrThrowException(theToGoldenResource);\n+\t\tString resourceType = theMdmTransactionContext.getResourceType();\n+\n+\t\t//Merge attributes, to be determined when survivorship is solved.\n+\t\tmyPersonHelper.mergeFields(theFromGoldenResource, theToGoldenResource);\n+\n+\t\t//Merge the links from the FROM to the TO resource. Clean up dangling links.\n+\t\tmergeGoldenResourceLinks(theFromGoldenResource, theToGoldenResource, toGoldenResourcePid, theMdmTransactionContext);\n+\n+\t\t//Create the new REDIRECT link\n+\t\taddMergeLink(toGoldenResourcePid, fromGoldenResourcePid, resourceType);\n+\n+\t\t//Strip the golden resource tag from the now-deprecated resource.\n+\t\tmyEmpiResourceDaoSvc.removeGoldenResourceTag(theFromGoldenResource, resourceType);\n+\n+\t\t//Add the REDIRECT tag to that same deprecated resource.\n+\t\tmyPersonHelper.deactivateResource(theFromGoldenResource);\n+\n+\t\t//Save the deprecated resource.\n+\t\tmyEmpiResourceDaoSvc.upsertSourceResource(theFromGoldenResource, resourceType);\n+\n+\t\tlog(theMdmTransactionContext, \"Merged \" + theFromGoldenResource.getIdElement().toVersionless() + \" into \" + theToGoldenResource.getIdElement().toVersionless());\n+\t\treturn theToGoldenResource;\n+\t}\n+\n+\t/**\n+\t * Removes non-manual links from source to target\n+\t *\n+\t * @param theFrom                   Target of the link\n+\t * @param theTo                     Source resource of the link\n+\t * @param theMdmTransactionContext Context to keep track of the deletions\n+\t */\n+\tprivate void removeTargetLinks(IAnyResource theFrom, IAnyResource theTo, MdmTransactionContext theMdmTransactionContext) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/GoldenResourceMergerSvcImpl.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/GoldenResourceMergerSvcImpl.java\nsimilarity index 68%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/GoldenResourceMergerSvcImpl.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/GoldenResourceMergerSvcImpl.java\nindex 240323a0a6..26afd39fc9 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/GoldenResourceMergerSvcImpl.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/GoldenResourceMergerSvcImpl.java\n\n@@ -1,4 +1,4 @@\n-package ca.uhn.fhir.jpa.empi.svc;\n+package ca.uhn.fhir.jpa.mdm.svc;\n \n /*-\n  * #%L\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MDkzMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525380931", "bodyText": "address S/R", "author": "nvg-smile", "createdAt": "2020-11-17T18:13:35Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java", "diffHunk": "@@ -35,11 +35,11 @@\n \n \tCandidateList findCandidates(IAnyResource theTarget) {\n \t\tCandidateList candidateList = new CandidateList(getStrategy());\n-\t\tcandidateList.addAll(findMatchPersonCandidates(theTarget));\n+\t\tcandidateList.addAll(findMatchSourceResourceCandidates(theTarget));", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\nsimilarity index 79%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\nindex c1e687d0f8..fcb45a9f02 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/BaseCandidateFinder.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/BaseCandidateFinder.java\n\n@@ -31,15 +31,15 @@ public abstract class BaseCandidateFinder {\n \t@Autowired\n \tIdHelperService myIdHelperService;\n \t@Autowired\n-\tEmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\tMdmLinkDaoSvc myMdmLinkDaoSvc;\n \n \tCandidateList findCandidates(IAnyResource theTarget) {\n \t\tCandidateList candidateList = new CandidateList(getStrategy());\n-\t\tcandidateList.addAll(findMatchSourceResourceCandidates(theTarget));\n+\t\tcandidateList.addAll(findMatchGoldenResourceCandidates(theTarget));\n \t\treturn candidateList;\n \t}\n \n-\tprotected abstract List<MatchedSourceResourceCandidate> findMatchSourceResourceCandidates(IAnyResource theTarget);\n+\tprotected abstract List<MatchedGoldenResourceCandidate> findMatchGoldenResourceCandidates(IAnyResource theTarget);\n \n \tprotected abstract CandidateStrategyEnum getStrategy();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MTEwMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525381102", "bodyText": "Rename to MdmGoldenResourceFindingSvc", "author": "nvg-smile", "createdAt": "2020-11-17T18:13:53Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/EmpiSourceResourceFindingSvc.java", "diffHunk": "@@ -30,7 +30,7 @@\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiPersonFindingSvc {\n+public class EmpiSourceResourceFindingSvc {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/EmpiSourceResourceFindingSvc.java b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/MdmGoldenResourceFindingSvc.java\nsimilarity index 63%\nrename from hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/EmpiSourceResourceFindingSvc.java\nrename to hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/MdmGoldenResourceFindingSvc.java\nindex 5090df8871..6907a3cfb8 100644\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/EmpiSourceResourceFindingSvc.java\n+++ b/hapi-fhir-jpaserver-mdm/src/main/java/ca/uhn/fhir/jpa/mdm/svc/candidate/MdmGoldenResourceFindingSvc.java\n\n@@ -30,11 +30,12 @@ import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n @Service\n-public class EmpiSourceResourceFindingSvc {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class MdmGoldenResourceFindingSvc {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \t@Autowired\n-\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\tprivate MdmResourceDaoSvc myMdmResourceDaoSvc;\n \n \t@Autowired\n \tprivate FindCandidateByEidSvc myFindCandidateByEidSvc;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MTg0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525381848", "bodyText": "Rename to MatchedGoldenResourceCandidate", "author": "nvg-smile", "createdAt": "2020-11-17T18:15:01Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java", "diffHunk": "@@ -24,22 +24,23 @@\n import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n \n-public class MatchedPersonCandidate {\n-\tprivate final ResourcePersistentId myCandidatePersonPid;\n+public class MatchedSourceResourceCandidate {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java\ndeleted file mode 100644\nindex f318890f40..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java\n+++ /dev/null\n\n@@ -1,53 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc.candidate;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n-\n-public class MatchedSourceResourceCandidate {\n-\n-\tprivate final ResourcePersistentId myCandidateSourceResourcePid;\n-\tprivate final EmpiMatchOutcome myEmpiMatchOutcome;\n-\n-\tpublic MatchedSourceResourceCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n-\t\tmyCandidateSourceResourcePid = theCandidate;\n-\t\tmyEmpiMatchOutcome = theEmpiMatchOutcome;\n-\t}\n-\n-\tpublic MatchedSourceResourceCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {\n-\t\tmyCandidateSourceResourcePid = thePersonPid;\n-\t\tmyEmpiMatchOutcome = new EmpiMatchOutcome(theEmpiLink.getVector(), theEmpiLink.getScore()).setMatchResultEnum(theEmpiLink.getMatchResult());\n-\t}\n-\n-\tpublic ResourcePersistentId getCandidatePersonPid() {\n-\t\treturn myCandidateSourceResourcePid;\n-\t}\n-\n-\tpublic EmpiMatchOutcome getMatchResult() {\n-\t\treturn myEmpiMatchOutcome;\n-\t}\n-\n-\tpublic boolean isMatch() {\n-\t\treturn myEmpiMatchOutcome.isMatch();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MjE0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525382148", "bodyText": "Fix person / empi", "author": "nvg-smile", "createdAt": "2020-11-17T18:15:26Z", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java", "diffHunk": "@@ -24,22 +24,23 @@\n import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n \n-public class MatchedPersonCandidate {\n-\tprivate final ResourcePersistentId myCandidatePersonPid;\n+public class MatchedSourceResourceCandidate {\n+\n+\tprivate final ResourcePersistentId myCandidateSourceResourcePid;\n \tprivate final EmpiMatchOutcome myEmpiMatchOutcome;\n \n-\tpublic MatchedPersonCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n-\t\tmyCandidatePersonPid = theCandidate;\n+\tpublic MatchedSourceResourceCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n+\t\tmyCandidateSourceResourcePid = theCandidate;\n \t\tmyEmpiMatchOutcome = theEmpiMatchOutcome;\n \t}\n \n-\tpublic MatchedPersonCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {\n-\t\tmyCandidatePersonPid = thePersonPid;\n+\tpublic MatchedSourceResourceCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java b/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java\ndeleted file mode 100644\nindex f318890f40..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/candidate/MatchedSourceResourceCandidate.java\n+++ /dev/null\n\n@@ -1,53 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.svc.candidate;\n-\n-/*-\n- * #%L\n- * HAPI FHIR JPA Server - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.empi.api.EmpiMatchOutcome;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n-\n-public class MatchedSourceResourceCandidate {\n-\n-\tprivate final ResourcePersistentId myCandidateSourceResourcePid;\n-\tprivate final EmpiMatchOutcome myEmpiMatchOutcome;\n-\n-\tpublic MatchedSourceResourceCandidate(ResourcePersistentId theCandidate, EmpiMatchOutcome theEmpiMatchOutcome) {\n-\t\tmyCandidateSourceResourcePid = theCandidate;\n-\t\tmyEmpiMatchOutcome = theEmpiMatchOutcome;\n-\t}\n-\n-\tpublic MatchedSourceResourceCandidate(ResourcePersistentId thePersonPid, EmpiLink theEmpiLink) {\n-\t\tmyCandidateSourceResourcePid = thePersonPid;\n-\t\tmyEmpiMatchOutcome = new EmpiMatchOutcome(theEmpiLink.getVector(), theEmpiLink.getScore()).setMatchResultEnum(theEmpiLink.getMatchResult());\n-\t}\n-\n-\tpublic ResourcePersistentId getCandidatePersonPid() {\n-\t\treturn myCandidateSourceResourcePid;\n-\t}\n-\n-\tpublic EmpiMatchOutcome getMatchResult() {\n-\t\treturn myEmpiMatchOutcome;\n-\t}\n-\n-\tpublic boolean isMatch() {\n-\t\treturn myEmpiMatchOutcome.isMatch();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MjcwNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525382707", "bodyText": "fix S/R", "author": "nvg-smile", "createdAt": "2020-11-17T18:16:13Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java", "diffHunk": "@@ -269,71 +316,91 @@ protected void assertLinkCount(long theExpectedCount) {\n \t\tassertEquals(theExpectedCount, myEmpiLinkDao.count());\n \t}\n \n-\tprotected Person getPersonFromTarget(IAnyResource theBaseResource) {\n+\tprotected IAnyResource getGoldenResourceFromTargetResource(IAnyResource theBaseResource) {\n+\t\tString resourceType = theBaseResource.getIdElement().getResourceType();\n+\t\tIFhirResourceDao relevantDao = myDaoRegistry.getResourceDao(resourceType);\n+\n \t\tOptional<EmpiLink> matchedLinkForTargetPid = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n \t\tif (matchedLinkForTargetPid.isPresent()) {\n-\t\t\tLong personPid = matchedLinkForTargetPid.get().getPersonPid();\n-\t\t\treturn (Person) myPersonDao.readByPid(new ResourcePersistentId(personPid));\n+\t\t\tLong sourceResourcePid = matchedLinkForTargetPid.get().getSourceResourcePid();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\nsimilarity index 71%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\nindex 948708481b..f1f1c5e284 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/BaseEmpiR4Test.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/BaseMdmR4Test.java\n\n@@ -313,40 +307,40 @@ abstract public class BaseEmpiR4Test extends BaseJpaR4Test {\n \t}\n \n \tprotected void assertLinkCount(long theExpectedCount) {\n-\t\tassertEquals(theExpectedCount, myEmpiLinkDao.count());\n+\t\tassertEquals(theExpectedCount, myMdmLinkDao.count());\n \t}\n \n \tprotected IAnyResource getGoldenResourceFromTargetResource(IAnyResource theBaseResource) {\n \t\tString resourceType = theBaseResource.getIdElement().getResourceType();\n \t\tIFhirResourceDao relevantDao = myDaoRegistry.getResourceDao(resourceType);\n \n-\t\tOptional<EmpiLink> matchedLinkForTargetPid = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n+\t\tOptional<MdmLink> matchedLinkForTargetPid = myMdmLinkDaoSvc.getMatchedLinkForTargetPid(myIdHelperService.getPidOrNull(theBaseResource));\n \t\tif (matchedLinkForTargetPid.isPresent()) {\n-\t\t\tLong sourceResourcePid = matchedLinkForTargetPid.get().getSourceResourcePid();\n-\t\t\treturn (IAnyResource) relevantDao.readByPid(new ResourcePersistentId(sourceResourcePid));\n+\t\t\tLong goldenResourcePid = matchedLinkForTargetPid.get().getGoldenResourcePid();\n+\t\t\treturn (IAnyResource) relevantDao.readByPid(new ResourcePersistentId(goldenResourcePid));\n \t\t} else {\n \t\t\treturn null;\n \t\t}\n \t}\n \n-\tprotected <T extends IBaseResource> T getTargetResourceFromEmpiLink(EmpiLink theEmpiLink, String theResourceType) {\n+\tprotected <T extends IBaseResource> T getTargetResourceFromMdmLink(MdmLink theMdmLink, String theResourceType) {\n \t\tIFhirResourceDao resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n-\t\treturn (T) resourceDao.readByPid(new ResourcePersistentId(theEmpiLink.getSourceResourcePid()));\n+\t\treturn (T) resourceDao.readByPid(new ResourcePersistentId(theMdmLink.getGoldenResourcePid()));\n \t}\n \n \tprotected Patient addExternalEID(Patient thePatient, String theEID) {\n-\t\tthePatient.addIdentifier().setSystem(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()).setValue(theEID);\n+\t\tthePatient.addIdentifier().setSystem(myMdmSettings.getMdmRules().getEnterpriseEIDSystem()).setValue(theEID);\n \t\treturn thePatient;\n \t}\n \n \tprotected Patient clearExternalEIDs(Patient thePatient) {\n-\t\tthePatient.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem()));\n+\t\tthePatient.getIdentifier().removeIf(theIdentifier -> theIdentifier.getSystem().equalsIgnoreCase(myMdmSettings.getMdmRules().getEnterpriseEIDSystem()));\n \t\treturn thePatient;\n \t}\n \n \tprotected Patient createPatientAndUpdateLinks(Patient thePatient) {\n \t\tthePatient = createPatient(thePatient);\n-\t\tmyEmpiMatchLinkSvc.updateEmpiLinksForEmpiTarget(thePatient, createContextForCreate(\"Patient\"));\n+\t\tmyMdmMatchLinkSvc.updateMdmLinksForMdmTarget(thePatient, createContextForCreate(\"Patient\"));\n \t\treturn thePatient;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NjIzMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386232", "bodyText": "Rename S/R -> Golden?", "author": "nvg-smile", "createdAt": "2020-11-17T18:21:28Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BaseSourceResourceMatcher.java", "diffHunk": "@@ -16,40 +18,41 @@\n import java.util.List;\n import java.util.stream.Collectors;\n \n-public abstract class BasePersonMatcher extends TypeSafeMatcher<IAnyResource> {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(BasePersonMatcher.class);\n+public abstract class BaseSourceResourceMatcher extends TypeSafeMatcher<IAnyResource> {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BaseSourceResourceMatcher.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BaseSourceResourceMatcher.java\ndeleted file mode 100644\nindex 3ef1037068..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BaseSourceResourceMatcher.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.matcher;\n-\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import org.hamcrest.TypeSafeMatcher;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public abstract class BaseSourceResourceMatcher extends TypeSafeMatcher<IAnyResource> {\n-\tprivate static final Logger ourLog = LoggerFactory.getLogger(BaseSourceResourceMatcher.class);\n-\n-\tprotected IdHelperService myIdHelperService;\n-\tprotected EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n-\tprotected Collection<IAnyResource> myBaseResources;\n-\tprotected String myTargetType;\n-\n-\tprotected BaseSourceResourceMatcher(IdHelperService theIdHelperService, EmpiLinkDaoSvc theEmpiLinkDaoSvc, IAnyResource... theBaseResource) {\n-\t\tmyIdHelperService = theIdHelperService;\n-\t\tmyEmpiLinkDaoSvc = theEmpiLinkDaoSvc;\n-\t\tmyBaseResources = Arrays.stream(theBaseResource).collect(Collectors.toList());\n-\t}\n-\n-\t@Nullable\n-\tprotected Long getMatchedResourcePidFromResource(IAnyResource theResource) {\n-\t\tLong retval;\n-\n-\t\tboolean isGoldenRecord = EmpiUtil.isEmpiManaged(theResource);\n-\t\tif (isGoldenRecord) {\n-\t\t\treturn myIdHelperService.getPidOrNull(theResource);\n-\t\t}\n-\t\tEmpiLink matchLink = getMatchedEmpiLink(theResource);\n-\n-\t\tif (matchLink == null) {\n-\t\t\treturn null;\n-\t\t} else {\n-\t\t\tretval = matchLink.getSourceResourcePid();\n-\t\t\tmyTargetType = matchLink.getEmpiTargetType();\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\tprotected List<Long> getPossibleMatchedSourceResourcePidsFromTarget(IAnyResource theBaseResource) {\n-\t\treturn getEmpiLinksForTarget(theBaseResource, EmpiMatchResultEnum.POSSIBLE_MATCH).stream().map(EmpiLink::getSourceResourcePid).collect(Collectors.toList());\n-\t}\n-\n-\tprotected EmpiLink getMatchedEmpiLink(IAnyResource thePatientOrPractitionerResource) {\n-\t\tList<EmpiLink> empiLinks = getEmpiLinksForTarget(thePatientOrPractitionerResource, EmpiMatchResultEnum.MATCH);\n-\t\tif (empiLinks.size() == 0) {\n-\t\t\treturn null;\n-\t\t} else if (empiLinks.size() == 1) {\n-\t\t\treturn empiLinks.get(0);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"Its illegal to have more than 1 match for a given target! we found \" + empiLinks.size() + \" for resource with id: \" + thePatientOrPractitionerResource.getIdElement().toUnqualifiedVersionless());\n-\t\t}\n-\t}\n-\n-\tprotected List<EmpiLink> getEmpiLinksForTarget(IAnyResource theTargetResource, EmpiMatchResultEnum theMatchResult) {\n-\t\tLong pidOrNull = myIdHelperService.getPidOrNull(theTargetResource);\n-\t\tList<EmpiLink> matchLinkForTarget = myEmpiLinkDaoSvc.getEmpiLinksByTargetPidAndMatchResult(pidOrNull, theMatchResult);\n-\t\tif (!matchLinkForTarget.isEmpty()) {\n-\t\t\treturn matchLinkForTarget;\n-\t\t} else {\n-\t\t\treturn new ArrayList<>();\n-\t\t}\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NjQ5MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386491", "bodyText": "S/R to Golden?", "author": "nvg-smile", "createdAt": "2020-11-17T18:21:52Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java", "diffHunk": "@@ -14,7 +14,7 @@\n  * is linked to a set of patients/practitioners via a person.\n  *\n  */\n-public class IsLinkedTo extends BasePersonMatcher {\n+public class IsLinkedTo extends BaseSourceResourceMatcher {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\nsimilarity index 70%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\nindex 6d6097a5d8..3f6d441356 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsLinkedTo.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/matcher/IsLinkedTo.java\n\n@@ -14,13 +14,13 @@ import java.util.stream.Collectors;\n  * is linked to a set of patients/practitioners via a person.\n  *\n  */\n-public class IsLinkedTo extends BaseSourceResourceMatcher {\n+public class IsLinkedTo extends BaseGoldenResourceMatcher {\n \n \tprivate List<Long> baseResourcePersonPids;\n \tprivate Long incomingResourcePersonPid;\n \n-\tprotected IsLinkedTo(IdHelperService theIdHelperService, EmpiLinkDaoSvc theEmpiLinkDaoSvc, IAnyResource... theBaseResource) {\n-\t\tsuper(theIdHelperService, theEmpiLinkDaoSvc, theBaseResource);\n+\tprotected IsLinkedTo(IdHelperService theIdHelperService, MdmLinkDaoSvc theMdmLinkDaoSvc, IAnyResource... theBaseResource) {\n+\t\tsuper(theIdHelperService, theMdmLinkDaoSvc, theBaseResource);\n \t}\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4Njc0Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525386743", "bodyText": "S/R to Golden?", "author": "nvg-smile", "createdAt": "2020-11-17T18:22:14Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsSameSourceResourceAs.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package ca.uhn.fhir.jpa.empi.matcher;\n+\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class IsSameSourceResourceAs extends BaseSourceResourceMatcher {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsSameSourceResourceAs.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsSameSourceResourceAs.java\ndeleted file mode 100644\nindex 8c21ef2da8..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/IsSameSourceResourceAs.java\n+++ /dev/null\n\n@@ -1,46 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.matcher;\n-\n-import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n-import ca.uhn.fhir.jpa.empi.dao.EmpiLinkDaoSvc;\n-import org.hamcrest.Description;\n-import org.hamcrest.Matcher;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class IsSameSourceResourceAs extends BaseSourceResourceMatcher {\n-\n-\tprivate List<Long> sourceResourcePidsToMatch;\n-\tprivate Long incomingSourceResourcePid;\n-\n-\tpublic IsSameSourceResourceAs(IdHelperService theIdHelperService, EmpiLinkDaoSvc theEmpiLinkDaoSvc, IAnyResource... theBaseResource) {\n-\t\tsuper(theIdHelperService, theEmpiLinkDaoSvc, theBaseResource);\n-\t}\n-\n-\t@Override\n-\tprotected boolean matchesSafely(IAnyResource theIncomingResource) {\n-\t\tincomingSourceResourcePid = getMatchedResourcePidFromResource(theIncomingResource);\n-\t\tsourceResourcePidsToMatch = myBaseResources.stream().map(this::getMatchedResourcePidFromResource).collect(Collectors.toList());\n-\t\tboolean allToCheckAreSame = sourceResourcePidsToMatch.stream().allMatch(pid -> pid.equals(sourceResourcePidsToMatch.get(0)));\n-\t\tif (!allToCheckAreSame) {\n-\t\t\tthrow new IllegalStateException(\"You wanted to do a source resource comparison, but the pool of source resources you submitted for checking don't match! We won't even check the incoming source resource against them.\");\n-\t\t}\n-\t\treturn sourceResourcePidsToMatch.contains(incomingSourceResourcePid);\n-\t}\n-\n-\t@Override\n-\tpublic void describeTo(Description theDescription) {\n-\t\ttheDescription.appendText(String.format(\" %s linked to source resource %s/%s\", myTargetType, myTargetType, sourceResourcePidsToMatch));\n-\t}\n-\n-\t@Override\n-\tprotected void describeMismatchSafely(IAnyResource item, Description mismatchDescription) {\n-\t\tsuper.describeMismatchSafely(item, mismatchDescription);\n-\t\tmismatchDescription.appendText(String.format(\" was actually linked to %s/%s\", myTargetType, incomingSourceResourcePid));\n-\t}\n-\n-\tpublic static Matcher<IAnyResource> sameSourceResourceAs(IdHelperService theIdHelperService, EmpiLinkDaoSvc theEmpiLinkDaoSvc, IAnyResource... theBaseResource) {\n-\t\treturn new IsSameSourceResourceAs(theIdHelperService, theEmpiLinkDaoSvc, theBaseResource);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzE1OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387159", "bodyText": "S/R to Golden?", "author": "nvg-smile", "createdAt": "2020-11-17T18:22:53Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java", "diffHunk": "@@ -29,16 +32,16 @@\n public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n \tprotected Practitioner myPractitioner;\n \tprotected StringType myPractitionerId;\n-\tprotected Person myPractitionerPerson;\n-\tprotected StringType myPractitionerPersonId;\n+\tprotected IAnyResource myPractitionerSourceResource;", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nsimilarity index 75%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nindex e3e279928d..fe435a14ba 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\n\n@@ -29,25 +29,25 @@ import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.junit.jupiter.api.Assertions.fail;\n \n-public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n+public class MdmProviderClearLinkR4Test extends BaseLinkR4Test {\n \tprotected Practitioner myPractitioner;\n \tprotected StringType myPractitionerId;\n-\tprotected IAnyResource myPractitionerSourceResource;\n-\tprotected StringType myPractitionerSourceResourceId;\n+\tprotected IAnyResource myPractitionerGoldenResource;\n+\tprotected StringType myPractitionerGoldenResourceId;\n \n \t@BeforeEach\n \tpublic void before() {\n \t\tsuper.before();\n \t\tmyPractitioner = createPractitionerAndUpdateLinks(new Practitioner());\n \t\tmyPractitionerId = new StringType(myPractitioner.getIdElement().getValue());\n-\t\tmyPractitionerSourceResource = getGoldenResourceFromTargetResource(myPractitioner);\n-\t\tmyPractitionerSourceResourceId = new StringType(myPractitionerSourceResource.getIdElement().getValue());\n+\t\tmyPractitionerGoldenResource = getGoldenResourceFromTargetResource(myPractitioner);\n+\t\tmyPractitionerGoldenResourceId = new StringType(myPractitionerGoldenResource.getIdElement().getValue());\n \t}\n \n \t@Test\n \tpublic void testClearAllLinks() {\n \t\tassertLinkCount(2);\n-\t\tmyEmpiProviderR4.clearEmpiLinks(null, myRequestDetails);\n+\t\tmyMdmProviderR4.clearMdmLinks(null, myRequestDetails);\n \t\tassertNoLinksExist();\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzQ5Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387497", "bodyText": "can be removed", "author": "nvg-smile", "createdAt": "2020-11-17T18:23:27Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java", "diffHunk": "@@ -124,29 +135,31 @@ public void testPersonsWithCircularReferenceCanBeCleared() {\n \n \t\t//SUT\n \t\tParameters parameters = myEmpiProviderR4.clearEmpiLinks(null, myRequestDetails);\n+\n+\t\tprintLinks();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nsimilarity index 75%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\nindex e3e279928d..fe435a14ba 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderClearLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderClearLinkR4Test.java\n\n@@ -134,12 +134,12 @@ public class EmpiProviderClearLinkR4Test extends BaseLinkR4Test {\n \t\tlinkPersons(personFromTarget2, personFromTarget);\n \n \t\t//SUT\n-\t\tParameters parameters = myEmpiProviderR4.clearEmpiLinks(null, myRequestDetails);\n+\t\tParameters parameters = myMdmProviderR4.clearMdmLinks(null, myRequestDetails);\n \n \t\tprintLinks();\n \n \t\tassertNoPatientLinksExist();\n-\t\tIBundleProvider search = myPatientDao.search(buildSourceResourceParameterMap());\n+\t\tIBundleProvider search = myPatientDao.search(buildGoldenResourceParameterMap());\n \t\tassertThat(search.size(), is(equalTo(0)));\n \n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4NzgxMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525387813", "bodyText": "clean up comments", "author": "nvg-smile", "createdAt": "2020-11-17T18:23:59Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java", "diffHunk": "@@ -3,132 +3,164 @@\n import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n+import ca.uhn.fhir.empi.util.EmpiUtil;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n-import org.hl7.fhir.r4.model.Person;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Identifier;\n+import org.hl7.fhir.r4.model.Patient;\n import org.hl7.fhir.r4.model.StringType;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n import java.util.List;\n+import java.util.Optional;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.endsWith;\n-import static org.hamcrest.Matchers.hasSize;\n-import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\n \n public class EmpiProviderMergePersonsR4Test extends BaseProviderR4Test {\n \n-\tprivate Person myFromPerson;\n-\tprivate StringType myFromPersonId;\n-\tprivate Person myToPerson;\n-\tprivate StringType myToPersonId;\n+\tprivate Patient myFromSourcePatient;\n+\tprivate StringType myFromSourcePatientId;\n+\tprivate Patient myToSourcePatient;\n+\tprivate StringType myToSourcePatientId;\n \n \t@Override\n \t@BeforeEach\n \tpublic void before() {\n \t\tsuper.before();\n \t\tsuper.loadEmpiSearchParameters();\n \n-\t\tmyFromPerson = createPerson();\n-\t\tmyFromPersonId = new StringType(myFromPerson.getIdElement().getValue());\n-\t\tmyToPerson = createPerson();\n-\t\tmyToPersonId = new StringType(myToPerson.getIdElement().getValue());\n+\t\tmyFromSourcePatient = createGoldenPatient();\n+\t\tmyFromSourcePatientId = new StringType(myFromSourcePatient.getIdElement().getValue());\n+\t\tmyToSourcePatient = createGoldenPatient();\n+\t\tmyToSourcePatientId = new StringType(myToSourcePatient.getIdElement().getValue());\n \t}\n \n \t@Test\n \tpublic void testMerge() {\n-\t\tPerson mergedPerson = myEmpiProviderR4.mergePersons(myFromPersonId, myToPersonId, myRequestDetails);\n-\t\tassertEquals(myToPerson.getIdElement(), mergedPerson.getIdElement());\n-\t\tassertThat(mergedPerson, is(samePersonAs(myToPerson)));\n-\t\tassertEquals(2, getAllPersons().size());\n-\t\tassertEquals(1, getAllActivePersons().size());\n-\n-\t\tPerson fromPerson = myPersonDao.read(myFromPerson.getIdElement().toUnqualifiedVersionless());\n-\t\tassertThat(fromPerson.getActive(), is(false));\n-\t\tList<Person.PersonLinkComponent> links = fromPerson.getLink();\n+\t\tPatient mergedSourcePatient = (Patient) myEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId,\n+\t\t\tmyToSourcePatientId, myRequestDetails);\n+\n+\t\tassertTrue(EmpiUtil.isGoldenRecord(myFromSourcePatient));\n+\t\tassertEquals(myToSourcePatient.getIdElement(), mergedSourcePatient.getIdElement());\n+\t\tassertThat(mergedSourcePatient, is(sameSourceResourceAs(myToSourcePatient)));\n+\t\tassertEquals(1, getAllRedirectedGoldenPatients().size());\n+\t\tassertEquals(1, getAllGoldenPatients().size());\n+\n+\t\tPatient fromSourcePatient = myPatientDao.read(myFromSourcePatient.getIdElement().toUnqualifiedVersionless());\n+\t\tassertThat(fromSourcePatient.getActive(), is(false));\n+\t\tassertTrue(EmpiUtil.isGoldenRecordRedirected(fromSourcePatient));\n+\n+\t\t//TODO GGG eventually this will need to check a redirect... this is a hack which doesnt work\n+\t\t// Optional<Identifier> redirect = fromSourcePatient.getIdentifier().stream().filter(theIdentifier -> theIdentifier.getSystem().equals(\"REDIRECT\")).findFirst();", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java b/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java\ndeleted file mode 100644\nindex bb9b92217c..0000000000\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderMergePersonsR4Test.java\n+++ /dev/null\n\n@@ -1,169 +0,0 @@\n-package ca.uhn.fhir.jpa.empi.provider;\n-\n-import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n-import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n-import ca.uhn.fhir.empi.util.AssuranceLevelUtil;\n-import ca.uhn.fhir.empi.util.EmpiUtil;\n-import ca.uhn.fhir.jpa.entity.EmpiLink;\n-import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n-import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n-import org.hl7.fhir.r4.model.StringType;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.List;\n-import java.util.Optional;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.*;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-public class EmpiProviderMergePersonsR4Test extends BaseProviderR4Test {\n-\n-\tprivate Patient myFromSourcePatient;\n-\tprivate StringType myFromSourcePatientId;\n-\tprivate Patient myToSourcePatient;\n-\tprivate StringType myToSourcePatientId;\n-\n-\t@Override\n-\t@BeforeEach\n-\tpublic void before() {\n-\t\tsuper.before();\n-\t\tsuper.loadEmpiSearchParameters();\n-\n-\t\tmyFromSourcePatient = createGoldenPatient();\n-\t\tmyFromSourcePatientId = new StringType(myFromSourcePatient.getIdElement().getValue());\n-\t\tmyToSourcePatient = createGoldenPatient();\n-\t\tmyToSourcePatientId = new StringType(myToSourcePatient.getIdElement().getValue());\n-\t}\n-\n-\t@Test\n-\tpublic void testMerge() {\n-\t\tPatient mergedSourcePatient = (Patient) myEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId,\n-\t\t\tmyToSourcePatientId, myRequestDetails);\n-\n-\t\tassertTrue(EmpiUtil.isGoldenRecord(myFromSourcePatient));\n-\t\tassertEquals(myToSourcePatient.getIdElement(), mergedSourcePatient.getIdElement());\n-\t\tassertThat(mergedSourcePatient, is(sameSourceResourceAs(myToSourcePatient)));\n-\t\tassertEquals(1, getAllRedirectedGoldenPatients().size());\n-\t\tassertEquals(1, getAllGoldenPatients().size());\n-\n-\t\tPatient fromSourcePatient = myPatientDao.read(myFromSourcePatient.getIdElement().toUnqualifiedVersionless());\n-\t\tassertThat(fromSourcePatient.getActive(), is(false));\n-\t\tassertTrue(EmpiUtil.isGoldenRecordRedirected(fromSourcePatient));\n-\n-\t\t//TODO GGG eventually this will need to check a redirect... this is a hack which doesnt work\n-\t\t// Optional<Identifier> redirect = fromSourcePatient.getIdentifier().stream().filter(theIdentifier -> theIdentifier.getSystem().equals(\"REDIRECT\")).findFirst();\n-\t\t// assertThat(redirect.get().getValue(), is(equalTo(myToSourcePatient.getIdElement().toUnqualified().getValue())));\n-\n-\t\tList<EmpiLink> links = myEmpiLinkDaoSvc.findEmpiLinksByTarget(myFromSourcePatient);\n-\t\tassertThat(links, hasSize(1));\n-\n-\t\tEmpiLink link = links.get(0);\n-\t\tassertEquals(link.getTargetPid(), myFromSourcePatient.getIdElement().toUnqualifiedVersionless().getIdPartAsLong());\n-\t\tassertEquals(link.getSourceResourcePid(), myToSourcePatient.getIdElement().toUnqualifiedVersionless().getIdPartAsLong());\n-\t\tassertEquals(link.getMatchResult(), EmpiMatchResultEnum.REDIRECT);\n-\t\tassertEquals(link.getLinkSource(), EmpiLinkSourceEnum.MANUAL);\n-\t\t// assertThat(links.get(0).getAssurance(), is (AssuranceLevelUtil.getAssuranceLevel(EmpiMatchResultEnum.REDIRECT, EmpiLinkSourceEnum.MANUAL).toR4()));\n-\t\t//List<Person.PersonLinkComponent> links = fromSourcePatient.getLink();\n-\t\t//assertThat(links, hasSize(1));\n-\t\t//assertThat(links.get(0).getTarget().getReference(), is (myToSourcePatient.getIdElement().toUnqualifiedVersionless().getValue()));\n-\t\t//assertThat(links.get(0).getAssurance(), is (AssuranceLevelUtil.getAssuranceLevel(EmpiMatchResultEnum.REDIRECT, EmpiLinkSourceEnum.MANUAL).toR4()));\n-\t}\n-\n-\t@Test\n-\tpublic void testUnmanagedMerge() {\n-\t\tStringType fromPersonId = new StringType(createPatient().getIdElement().getValue());\n-\t\tStringType toPersonId = new StringType(createPatient().getIdElement().getValue());\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(fromPersonId, toPersonId, myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (InvalidRequestException e) {\n-\t\t\tassertEquals(\"Only MDM managed resources can be merged. MDM managed resources must have the HAPI-MDM tag.\", e.getMessage());\n-\t\t}\n-\t}\n-\n-//\tINVALID ANYMORE - we support merging patients to patients now\n-//\t@Test\n-//\tpublic void testMergePatients() {\n-//\t\ttry {\n-//\t\t\tStringType patientId = new StringType(createPatient().getIdElement().getValue());\n-//\t\t\tStringType otherPatientId = new StringType(createPatient().getIdElement().getValue());\n-//\t\t\tmyEmpiProviderR4.mergeGoldenResources(patientId, otherPatientId, myRequestDetails);\n-//\t\t\tfail();\n-//\t\t} catch (InvalidRequestException e) {\n-//\t\t\tassertThat(e.getMessage(), endsWith(\"must have form Person/<id> where <id> is the id of the person\"));\n-//\t\t}\n-//\n-//\t}\n-\n-\t@Test\n-\tpublic void testNullParams() {\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(null, null, myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (InvalidRequestException e) {\n-\t\t\tassertEquals(\"fromGoldenResourceId cannot be null\", e.getMessage());\n-\t\t}\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(null, myToSourcePatientId, myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (InvalidRequestException e) {\n-\t\t\tassertEquals(\"fromGoldenResourceId cannot be null\", e.getMessage());\n-\t\t}\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId, null, myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (InvalidRequestException e) {\n-\t\t\tassertEquals(\"toGoldenResourceId cannot be null\", e.getMessage());\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void testBadParams() {\n-\t\tprint(myFromSourcePatient);\n-\t\tprint(myToSourcePatient);\n-\n-//\t\tTODO NG - THESE ARE NOW INVALID\n-//\t\ttry {\n-//\t\t\tmyEmpiProviderR4.mergeGoldenResources(new StringType(\"Patient/1\"), new StringType(\"Patient/2\"), myRequestDetails);\n-//\t\t\tfail();\n-//\t\t} catch (InvalidRequestException e) {\n-//\t\t\tassertThat(e.getMessage(), endsWith(\" must have form Person/<id> where <id> is the id of the person\"));\n-//\t\t}\n-//\n-//\t\ttry {\n-//\t\t\tmyEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId, new StringType(\"Patient/2\"), myRequestDetails);\n-//\t\t\tfail();\n-//\t\t} catch (InvalidRequestException e) {\n-//\t\t\tassertThat(e.getMessage(), endsWith(\" must have form Person/<id> where <id> is the id of the person\"));\n-//\t\t}\n-\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(new StringType(\"Person/1\"), new StringType(\"Person/1\"), myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (InvalidRequestException e) {\n-\t\t\tassertEquals(\"fromPersonId must be different from toPersonId\", e.getMessage());\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(new StringType(\"Person/abc\"), myToSourcePatientId, myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (ResourceNotFoundException e) {\n-\t\t\tassertEquals(\"Resource Person/abc is not known\", e.getMessage());\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tmyEmpiProviderR4.mergeGoldenResources(myFromSourcePatientId, new StringType(\"Person/abc\"), myRequestDetails);\n-\t\t\tfail();\n-\t\t} catch (ResourceNotFoundException e) {\n-\t\t\tassertEquals(\"Resource Person/abc is not known\", e.getMessage());\n-\t\t}\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4ODU2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525388565", "bodyText": "rename S/R to Golden", "author": "nvg-smile", "createdAt": "2020-11-17T18:25:07Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java", "diffHunk": "@@ -49,91 +50,114 @@ public void testUpdateLinkMatch() {\n \n \t@Test\n \tpublic void testUpdateLinkTwiceFailsDueToWrongVersion() {\n-\t\tmyEmpiProviderR4.updateLink(myPersonId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\n+\t\tmateriallyChangeGoldenPatient();\n+\n \t\ttry {\n-\t\t\tmyEmpiProviderR4.updateLink(myPersonId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\nsimilarity index 57%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\nindex 51181bd3b3..f826a1deeb 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/provider/EmpiProviderUpdateLinkR4Test.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/provider/MdmProviderUpdateLinkR4Test.java\n\n@@ -26,36 +26,36 @@ public class EmpiProviderUpdateLinkR4Test extends BaseLinkR4Test {\n \t@Test\n \tpublic void testUpdateLinkNoMatch() {\n \t\tassertLinkCount(1);\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n \t\tassertLinkCount(2);\n \n-\t\tList<EmpiLink> links = getPatientLinks();\n-\t\tassertEquals(EmpiLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.NO_MATCH, links.get(0).getMatchResult());\n-\t\tassertEquals(EmpiLinkSourceEnum.AUTO, links.get(1).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.MATCH, links.get(1).getMatchResult());\n-\t\tassertNotEquals(links.get(0).getSourceResourcePid(), links.get(1).getSourceResourcePid());\n+\t\tList<MdmLink> links = getPatientLinks();\n+\t\tassertEquals(MdmLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.NO_MATCH, links.get(0).getMatchResult());\n+\t\tassertEquals(MdmLinkSourceEnum.AUTO, links.get(1).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.MATCH, links.get(1).getMatchResult());\n+\t\tassertNotEquals(links.get(0).getGoldenResourcePid(), links.get(1).getGoldenResourcePid());\n \t}\n \n \t@Test\n \tpublic void testUpdateLinkMatch() {\n \t\tassertLinkCount(1);\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n \t\tassertLinkCount(1);\n \n-\t\tList<EmpiLink> links = getPatientLinks();\n-\t\tassertEquals(EmpiLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n-\t\tassertEquals(EmpiMatchResultEnum.MATCH, links.get(0).getMatchResult());\n+\t\tList<MdmLink> links = getPatientLinks();\n+\t\tassertEquals(MdmLinkSourceEnum.MANUAL, links.get(0).getLinkSource());\n+\t\tassertEquals(MdmMatchResultEnum.MATCH, links.get(0).getMatchResult());\n \t}\n \n \t@Test\n \tpublic void testUpdateLinkTwiceFailsDueToWrongVersion() {\n-\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n+\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, MATCH_RESULT, myRequestDetails);\n \n \t\tmateriallyChangeGoldenPatient();\n \n \t\ttry {\n-\t\t\tmyEmpiProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n+\t\t\tmyMdmProviderR4.updateLink(mySourcePatientId, myPatientId, NO_MATCH_RESULT, myRequestDetails);\n \t\t\tfail();\n \t\t} catch (ResourceVersionConflictException e) {\n \t\t\tassertThat(e.getMessage(), matchesPattern(\"Requested resource Patient/\\\\d+/_history/1 is not the latest version.  Latest version is Patient/\\\\d+/_history/2\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5MDUyMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525390523", "bodyText": "clean up comments", "author": "nvg-smile", "createdAt": "2020-11-17T18:27:53Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java", "diffHunk": "@@ -47,76 +53,78 @@ public void compareEmptyPatients() {\n \t@Test\n \tpublic void testCreateRemoveLink() {\n \t\tassertLinkCount(0);\n-\t\tPerson person = createPerson();\n-\t\tIdType personId = person.getIdElement().toUnqualifiedVersionless();\n-\t\tassertEquals(0, person.getLink().size());\n+\t\tPatient goldenPatient = createGoldenPatient();\n+\t\tIdType sourcePatientId = goldenPatient.getIdElement().toUnqualifiedVersionless();\n+\t\t// TODO NG should be ok to remove - assertEquals(0, goldenPatient.getLink().size());", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nsimilarity index 53%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\nindex c57faa9d0f..7d71b1b4a4 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiLinkSvcTest.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmLinkSvcTest.java\n\n@@ -46,8 +42,8 @@ public class EmpiLinkSvcTest extends BaseEmpiR4Test {\n \tpublic void compareEmptyPatients() {\n \t\tPatient patient = new Patient();\n \t\tpatient.setId(\"Patient/1\");\n-\t\tEmpiMatchResultEnum result = myEmpiResourceMatcherSvc.getMatchResult(patient, patient).getMatchResultEnum();\n-\t\tassertEquals(EmpiMatchResultEnum.NO_MATCH, result);\n+\t\tMdmMatchResultEnum result = myMdmResourceMatcherSvc.getMatchResult(patient, patient).getMatchResultEnum();\n+\t\tassertEquals(MdmMatchResultEnum.NO_MATCH, result);\n \t}\n \n \t@Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5MjE2Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525392162", "bodyText": "S/R to Golden", "author": "nvg-smile", "createdAt": "2020-11-17T18:30:32Z", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java", "diffHunk": "@@ -87,54 +110,54 @@ public void testAddPatientLinksToExistingPersonIfMatch() {\n \t\tPatient patient2 = createPatientAndUpdateLinks(buildJanePatient());\n \t\tassertLinkCount(2);\n \n-\t\tassertThat(patient1, is(samePersonAs(patient2)));\n+\t\tassertThat(patient1, is(sameSourceResourceAs(patient2)));", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmMatchLinkSvcTest.java\nsimilarity index 76%\nrename from hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\nrename to hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmMatchLinkSvcTest.java\nindex c43bc7faef..42d331645a 100644\n--- a/hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/svc/EmpiMatchLinkSvcTest.java\n+++ b/hapi-fhir-jpaserver-mdm/src/test/java/ca/uhn/fhir/jpa/mdm/svc/MdmMatchLinkSvcTest.java\n\n@@ -110,7 +104,7 @@ public class EmpiMatchLinkSvcTest extends BaseEmpiR4Test {\n \t\tPatient patient2 = createPatientAndUpdateLinks(buildJanePatient());\n \t\tassertLinkCount(2);\n \n-\t\tassertThat(patient1, is(sameSourceResourceAs(patient2)));\n+\t\tassertThat(patient1, is(sameGoldenResourceAs(patient2)));\n \t\tassertLinksMatchResult(MATCH, MATCH);\n \t\tassertLinksCreatedNewResource(true, false);\n \t\tassertLinksMatchedByEid(false, false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyMjY1Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525422656", "bodyText": "Do we need to adjust those to use MDM terminology?", "author": "nvg-smile", "createdAt": "2020-11-17T19:16:23Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java", "diffHunk": "@@ -25,13 +25,20 @@\n \t * TAG system for Person resources which are managed by HAPI EMPI.\n \t */\n \n-\tpublic static final String SYSTEM_EMPI_MANAGED = \"https://hapifhir.org/NamingSystem/managing-empi-system\";\n-\tpublic static final String CODE_HAPI_EMPI_MANAGED = \"HAPI-EMPI\";\n+\tpublic static final String SYSTEM_MDM_MANAGED = \"https://hapifhir.org/NamingSystem/managing-mdm-system\";\n+\tpublic static final String CODE_HAPI_MDM_MANAGED = \"HAPI-MDM\";\n \tpublic static final String DISPLAY_HAPI_EMPI_MANAGED = \"This Person can only be modified by Smile CDR's EMPI system.\";\n \tpublic static final String CODE_NO_EMPI_MANAGED = \"NO-EMPI\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\nsimilarity index 81%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\nindex 05d9dbcf93..eb87ff629d 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiConstants.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/MdmConstants.java\n\n@@ -20,16 +20,16 @@ package ca.uhn.fhir.empi.api;\n  * #L%\n  */\n \n-public class EmpiConstants {\n+public class MdmConstants {\n \t/**\n-\t * TAG system for Person resources which are managed by HAPI EMPI.\n+\t * TAG system for Person resources which are managed by HAPI MDM.\n \t */\n \n \tpublic static final String SYSTEM_MDM_MANAGED = \"https://hapifhir.org/NamingSystem/managing-mdm-system\";\n \tpublic static final String CODE_HAPI_MDM_MANAGED = \"HAPI-MDM\";\n-\tpublic static final String DISPLAY_HAPI_EMPI_MANAGED = \"This Person can only be modified by Smile CDR's EMPI system.\";\n-\tpublic static final String CODE_NO_EMPI_MANAGED = \"NO-EMPI\";\n-\tpublic static final String HAPI_ENTERPRISE_IDENTIFIER_SYSTEM = \"http://hapifhir.io/fhir/NamingSystem/empi-person-enterprise-id\";\n+\tpublic static final String DISPLAY_HAPI_MDM_MANAGED = \"This Person can only be modified by Smile CDR's MDM system.\";\n+\tpublic static final String CODE_NO_MDM_MANAGED = \"NO-MDM\";\n+\tpublic static final String HAPI_ENTERPRISE_IDENTIFIER_SYSTEM = \"http://hapifhir.io/fhir/NamingSystem/mdm-golden-resource-enterprise-id\";\n \tpublic static final String ALL_RESOURCE_SEARCH_PARAM_TYPE = \"*\";\n \n \tpublic static final String FIHR_STRUCTURE_DEF_MATCH_GRADE_URL_NAMESPACE = \"http://hl7.org/fhir/StructureDefinition/match-grade\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyMzM3MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525423370", "bodyText": "Reaming to MDM?", "author": "nvg-smile", "createdAt": "2020-11-17T19:17:34Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java", "diffHunk": "@@ -22,6 +22,8 @@\n \n import ca.uhn.fhir.empi.rules.json.EmpiRulesJson;\n \n+import java.util.stream.Collectors;\n+\n public interface IEmpiSettings {\n \tString EMPI_CHANNEL_NAME = \"empi\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\nsimilarity index 68%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\nindex 9a742809c1..2258c7af8c 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/IEmpiSettings.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/api/IMdmSettings.java\n\n@@ -20,20 +20,22 @@ package ca.uhn.fhir.empi.api;\n  * #L%\n  */\n \n-import ca.uhn.fhir.empi.rules.json.EmpiRulesJson;\n+import ca.uhn.fhir.mdm.rules.json.MdmRulesJson;\n \n import java.util.stream.Collectors;\n \n-public interface IEmpiSettings {\n-\tString EMPI_CHANNEL_NAME = \"empi\";\n-\t// Parallel processing of EMPI can result in missed matches.  Best to single-thread.\n-\tint EMPI_DEFAULT_CONCURRENT_CONSUMERS = 1;\n+public interface IMdmSettings {\n+\n+\tString MDM_CHANNEL_NAME = \"mdm\";\n+\n+\t// Parallel processing of MDM can result in missed matches.  Best to single-thread.\n+\tint MDM_DEFAULT_CONCURRENT_CONSUMERS = 1;\n \n \tboolean isEnabled();\n \n \tint getConcurrentConsumers();\n \n-\tEmpiRulesJson getEmpiRules();\n+\tMdmRulesJson getMdmRules();\n \n \tboolean isPreventEidUpdates();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNDIwMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525424202", "bodyText": "Move to MessageHelper and change to use proper terminology", "author": "nvg-smile", "createdAt": "2020-11-17T19:19:10Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java", "diffHunk": "@@ -43,43 +43,48 @@ public BaseEmpiProvider(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n-\tprotected void validateMergeParameters(IPrimitiveType<String> theFromPersonId, IPrimitiveType<String> theToPersonId) {\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPersonId);\n-\t\tvalidateNotNull(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPersonId);\n-\t\tif (theFromPersonId.getValue().equals(theToPersonId.getValue())) {\n+\tprotected void validateMergeParameters(IPrimitiveType<String> theFromGoldenResourceId, IPrimitiveType<String> theToGoldenResourceId) {\n+\t\t// TODO NG - Add validation to check that types are the same?\n+\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResourceId);\n+\t\tvalidateNotNull(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToGoldenResourceId);\n+\t\tif (theFromGoldenResourceId.getValue().equals(theToGoldenResourceId.getValue())) {\n \t\t\tthrow new InvalidRequestException(\"fromPersonId must be different from toPersonId\");", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/BaseMdmProvider.java\nsimilarity index 82%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/BaseMdmProvider.java\nindex 9fd42ac5c1..9d0d71d8e0 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/BaseEmpiProvider.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/BaseMdmProvider.java\n\n@@ -35,11 +35,11 @@ import org.hl7.fhir.instance.model.api.IPrimitiveType;\n \n import java.util.stream.Stream;\n \n-public abstract class BaseEmpiProvider {\n+public abstract class BaseMdmProvider {\n \n \tprotected final FhirContext myFhirContext;\n \n-\tpublic BaseEmpiProvider(FhirContext theFhirContext) {\n+\tpublic BaseMdmProvider(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNTIwOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525425209", "bodyText": "rename to validateIsMdmManaged", "author": "nvg-smile", "createdAt": "2020-11-17T19:20:41Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java", "diffHunk": "@@ -73,20 +84,24 @@ protected IAnyResource loadResource(IIdType theResourceId) {\n \t}\n \n \tpublic void validateMergeResources(IAnyResource theFromPerson, IAnyResource theToPerson) {\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, theFromPerson);\n-\t\tvalidateIsEmpiManaged(ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, theToPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPerson);\n+\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPerson);\n \t}\n \n \tpublic String toJson(IAnyResource theAnyResource) {\n \t\treturn myFhirContext.newJsonParser().encodeResourceToString(theAnyResource);\n \t}\n \n-\tprivate void validateIsEmpiManaged(String theName, IAnyResource thePerson) {\n-\t\tif (!\"Person\".equals(myFhirContext.getResourceType(thePerson))) {\n-\t\t\tthrow new InvalidRequestException(\"Only Person resources can be merged.  The \" + theName + \" points to a \" + myFhirContext.getResourceType(thePerson));\n+\tpublic void validateIsEmpiManaged(String theName, IAnyResource theResource) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\nsimilarity index 73%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\nindex 358dcfdddc..110cb8708e 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiControllerHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmControllerHelper.java\n\n@@ -84,23 +78,23 @@ public class EmpiControllerHelper {\n \t}\n \n \tpublic void validateMergeResources(IAnyResource theFromPerson, IAnyResource theToPerson) {\n-\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPerson);\n-\t\tvalidateIsEmpiManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPerson);\n+\t\tvalidateIsMdmManaged(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromPerson);\n+\t\tvalidateIsMdmManaged(ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, theToPerson);\n \t}\n \n \tpublic String toJson(IAnyResource theAnyResource) {\n \t\treturn myFhirContext.newJsonParser().encodeResourceToString(theAnyResource);\n \t}\n \n-\tpublic void validateIsEmpiManaged(String theName, IAnyResource theResource) {\n+\tpublic void validateIsMdmManaged(String theName, IAnyResource theResource) {\n \t\tString resourceType = myFhirContext.getResourceType(theResource);\n-\t\tif (!myEmpiSettings.isSupportedMdmType(resourceType)) {\n+\t\tif (!myMdmSettings.isSupportedMdmType(resourceType)) {\n \t\t\tthrow new InvalidRequestException(\n \t\t\t\tmyMessageHelper.getMessageForUnsupportedResource(theName, resourceType)\n \t\t\t);\n \t\t}\n \n-\t\tif (!EmpiUtil.isEmpiManaged(theResource)) {\n+\t\tif (!MdmUtil.isMdmManaged(theResource)) {\n \t\t\tthrow new InvalidRequestException(myMessageHelper.getMessageForUnmanagedResource());\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjEwMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525426100", "bodyText": "rename Empi to MDM", "author": "nvg-smile", "createdAt": "2020-11-17T19:22:13Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -79,107 +79,100 @@ public EmpiProviderDstu3(FhirContext theFhirContext, IEmpiControllerSvc theEmpiC\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.MDM_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n-\t\tmatches.sort(Comparator.comparing((MatchedTarget m) -> m.getMatchResult().getNormalizedScore()).reversed());\n-\n-\t\tBundle retVal = new Bundle();\n-\t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n-\t\tretVal.setId(UUID.randomUUID().toString());\n-\t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n-\n-\t\tfor (MatchedTarget next : matches) {\n-\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n-\t\t\tif (!shouldKeepThisEntry) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n-\t\t\tentry.setResource((Resource) next.getTarget());\n-\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\t\treturn getMatchesAndPossibleMatchesForResource(thePatient, \"Patient\");\n+\t}\n \n-\t\t\tretVal.addEntry(entry);\n+\t@Operation(name = ProviderConstants.MDM_MATCH)\n+\tpublic Bundle serverMatch(@OperationParam(name = ProviderConstants.MDM_MATCH_RESOURCE, min = 1, max = 1) IAnyResource theResource,\n+\t\t\t\t\t\t\t\t\t  @OperationParam(name = ProviderConstants.MDM_RESOURCE_TYPE, min = 1, max = 1) StringType theResourceType\n+\t) {\n+\t\tif (theResource == null) {\n+\t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n+\t\treturn getMatchesAndPossibleMatchesForResource(theResource, theResourceType.getValueNotNull());\n \n-\t\treturn retVal;\n \t}\n \n \tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget theMatchedTarget) {\n \t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n \t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n \t\tsearchComponent.setScore(theMatchedTarget.getMatchResult().getNormalizedScore());\n \n-\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n-\t\tif (theMatchedTarget.isMatch()) {\n-\t\t\tmatchGrade = MatchGrade.CERTAIN;\n-\t\t} else if (theMatchedTarget.isPossibleMatch()) {\n-\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n-\t\t}\n+\t\tMatchGrade matchGrade = getMatchGrade(theMatchedTarget);\n \n \t\tsearchComponent.addExtension(EmpiConstants.FIHR_STRUCTURE_DEF_MATCH_GRADE_URL_NAMESPACE, new CodeType(matchGrade.toCode()));\n \t\treturn searchComponent;\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_MERGE_PERSONS, type = Person.class)\n-\tpublic Person mergePerson(@OperationParam(name=ProviderConstants.EMPI_MERGE_PERSONS_FROM_PERSON_ID, min = 1, max = 1) StringType theFromPersonId,\n-\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_MERGE_PERSONS_TO_PERSON_ID, min = 1, max = 1) StringType theToPersonId,\n-\t\t\t\t\t\t\t\t\t  RequestDetails theRequestDetails) {\n-\t\tvalidateMergeParameters(theFromPersonId, theToPersonId);\n+\t@Operation(name = ProviderConstants.MDM_MERGE_GOLDEN_RESOURCES)\n+\tpublic IBaseResource mergeGoldenResource(@OperationParam(name=ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theFromGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theToGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  RequestDetails theRequestDetails) {\n+\t\tvalidateMergeParameters(theFromGoldenResourceId, theToGoldenResourceId);\n \n-\t\treturn (Person) myEmpiControllerSvc.mergePersons(theFromPersonId.getValue(), theToPersonId.getValue(), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.MERGE_PERSONS));\n+\t\tString resourceType = getResourceType(ProviderConstants.MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID, theFromGoldenResourceId);\n+\n+\t\treturn myEmpiControllerSvc.mergeGoldenResources(theFromGoldenResourceId.getValue(), theToGoldenResourceId.getValue(),\n+\t\t\tcreateMdmContext(theRequestDetails, MdmTransactionContext.OperationType.MERGE_PERSONS, resourceType));\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_UPDATE_LINK, type = Person.class)\n-\tpublic Person updateLink(@OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_PERSON_ID, min = 1, max = 1) StringType thePersonId,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_TARGET_ID, min = 1, max = 1) StringType theTargetId,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_UPDATE_LINK_MATCH_RESULT, min = 1, max = 1) StringType theMatchResult,\n+\t@Operation(name = ProviderConstants.MDM_UPDATE_LINK)\n+\tpublic IBaseResource updateLink(@OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, min = 1, max = 1) StringType theGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_RESOURCE_ID, min = 1, max = 1) StringType theTargetId,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_UPDATE_LINK_MATCH_RESULT, min = 1, max = 1) StringType theMatchResult,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ServletRequestDetails theRequestDetails) {\n \n-\t\tvalidateUpdateLinkParameters(thePersonId, theTargetId, theMatchResult);\n+\t\tvalidateUpdateLinkParameters(theGoldenResourceId, theTargetId, theMatchResult);\n \n-\t\treturn (Person) myEmpiControllerSvc.updateLink(thePersonId.getValue(), theTargetId.getValue(), theMatchResult.getValue(), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.UPDATE_LINK));\n+\t\treturn myEmpiControllerSvc.updateLink(theGoldenResourceId.getValue(), theTargetId.getValue(), theMatchResult.getValue(),\n+\t\t\tcreateMdmContext(theRequestDetails, MdmTransactionContext.OperationType.UPDATE_LINK,\n+\t\t\t\tgetResourceType(ProviderConstants.MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID, theGoldenResourceId)));\n \t}\n \n-\t@Operation(name = ProviderConstants.EMPI_QUERY_LINKS)\n-\tpublic Parameters queryLinks(@OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_PERSON_ID, min = 0, max = 1) StringType thePersonId,\n-\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_TARGET_ID, min = 0, max = 1) StringType theTargetId,\n+\t@Operation(name = ProviderConstants.MDM_QUERY_LINKS)\n+\tpublic Parameters queryLinks(@OperationParam(name=ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, min = 0, max = 1) StringType theGoldenResourceId,\n+\t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.MDM_QUERY_LINKS_RESOURCE_ID, min = 0, max = 1) StringType theTargetResourceId,\n \t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_MATCH_RESULT, min = 0, max = 1) StringType theMatchResult,\n \t\t\t\t\t\t\t\t\t\t  @OperationParam(name=ProviderConstants.EMPI_QUERY_LINKS_MATCH_RESULT, min = 0, max = 1) StringType theLinkSource,\n \t\t\t\t\t\t\t\t\t\t  ServletRequestDetails theRequestDetails) {\n \n-\t\tStream<EmpiLinkJson> empiLinkJson = myEmpiControllerSvc.queryLinks(extractStringOrNull(thePersonId), extractStringOrNull(theTargetId), extractStringOrNull(theMatchResult), extractStringOrNull(theLinkSource), createEmpiContext(theRequestDetails, EmpiTransactionContext.OperationType.QUERY_LINKS));\n+\t\tStream<EmpiLinkJson> empiLinkJson = myEmpiControllerSvc.queryLinks(extractStringOrNull(theGoldenResourceId), extractStringOrNull(theTargetResourceId),\n+\t\t\textractStringOrNull(theMatchResult), extractStringOrNull(theLinkSource), createMdmContext(theRequestDetails,\n+\t\t\t\tMdmTransactionContext.OperationType.QUERY_LINKS, getResourceType(ProviderConstants.MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID, theGoldenResourceId)));\n \t\treturn (Parameters) parametersFromEmpiLinks(empiLinkJson, true);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\nsimilarity index 73%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\nindex 8c91751707..81609bbdae 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderDstu3.java\n\n@@ -70,12 +70,12 @@ public class EmpiProviderDstu3 extends BaseEmpiProvider {\n \t * Note that this is not a spring bean. Any necessary injections should\n \t * happen in the constructor\n \t */\n-\tpublic EmpiProviderDstu3(FhirContext theFhirContext, IEmpiControllerSvc theEmpiControllerSvc, IEmpiMatchFinderSvc theEmpiMatchFinderSvc, IEmpiExpungeSvc theEmpiResetSvc, IEmpiSubmitSvc theEmpiBatchSvc) {\n+\tpublic MdmProviderDstu3(FhirContext theFhirContext, IMdmControllerSvc theMdmControllerSvc, IMdmMatchFinderSvc theMdmMatchFinderSvc, IMdmExpungeSvc theMdmExpungeSvc, IMdmSubmitSvc theMdmSubmitSvc) {\n \t\tsuper(theFhirContext);\n-\t\tmyEmpiControllerSvc = theEmpiControllerSvc;\n-\t\tmyEmpiMatchFinderSvc = theEmpiMatchFinderSvc;\n-\t\tmyEmpiResetSvc = theEmpiResetSvc;\n-\t\tmyEmpiBatchSvc = theEmpiBatchSvc;\n+\t\tmyMdmControllerSvc = theMdmControllerSvc;\n+\t\tmyMdmMatchFinderSvc = theMdmMatchFinderSvc;\n+\t\tmyMdmExpungeSvc = theMdmExpungeSvc;\n+\t\tmyMdmSubmitSvc = theMdmSubmitSvc;\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyNjk5OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525426999", "bodyText": "MdmProviderR4?", "author": "nvg-smile", "createdAt": "2020-11-17T19:23:45Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -63,30 +62,54 @@\n public class EmpiProviderR4 extends BaseEmpiProvider {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\nsimilarity index 80%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\nindex ab25e0435b..60366ffae2 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/provider/MdmProviderR4.java\n\n@@ -59,11 +59,11 @@ import java.util.List;\n import java.util.UUID;\n import java.util.stream.Stream;\n \n-public class EmpiProviderR4 extends BaseEmpiProvider {\n-\tprivate final IEmpiControllerSvc myEmpiControllerSvc;\n-\tprivate final IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n-\tprivate final IEmpiExpungeSvc myMdmExpungeSvc;\n-\tprivate final IEmpiSubmitSvc myMdmSubmitSvc;\n+public class MdmProviderR4 extends BaseMdmProvider {\n+\tprivate final IMdmControllerSvc myMdmControllerSvc;\n+\tprivate final IMdmMatchFinderSvc myMdmMatchFinderSvc;\n+\tprivate final IMdmExpungeSvc myMdmExpungeSvc;\n+\tprivate final IMdmSubmitSvc myMdmSubmitSvc;\n \n \t/**\n \t * Constructor\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODk4NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525428985", "bodyText": "Empi -> MDM", "author": "nvg-smile", "createdAt": "2020-11-17T19:26:54Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java", "diffHunk": "@@ -55,7 +56,70 @@ public static boolean isEmpiAccessible(IBaseResource theBaseResource) {\n \t * @return a boolean indicating whether or not EMPI manages this Person.\n \t */\n \tpublic static boolean isEmpiManaged(IBaseResource theBaseResource) {\n-\t\treturn theBaseResource.getMeta().getTag(EmpiConstants.SYSTEM_EMPI_MANAGED, EmpiConstants.CODE_HAPI_EMPI_MANAGED) != null;\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED);\n+\t}\n+\n+\tpublic static boolean isGoldenRecord(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD);\n+\t}\n+\n+\tpublic static boolean isGoldenRecordRedirected(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD_REDIRECTED);\n+\t}\n+\n+\tprivate static boolean resourceHasTag(IBaseResource theTheBaseResource, String theSystem, String theCode) {\n+\t\treturn theTheBaseResource.getMeta().getTag(theSystem, theCode) != null;\n+\t}\n+\n+\tprivate static Optional<? extends IBaseCoding> getTagWithSystem(IBaseResource theResource, String theSystem) {\n+\t\treturn theResource.getMeta().getTag().stream().filter(tag -> tag.getSystem().equalsIgnoreCase(theSystem)).findFirst();\n+\t}\n+\n+\tpublic static void removeTagWithSystem(IBaseResource theResource, String theSystem) {\n+\t\ttheResource.getMeta().getTag().removeIf(tag -> tag.getSystem().equalsIgnoreCase(theSystem));\n+\t}\n+\n+\n+\t/**\n+\t * Sets the EMPI-managed tag, indicating the EMPI system has ownership of this\n+\t * Resource. No changes are made if resource is already maanged by EMPI.\n+\t *\n+\t * @param theBaseResource resource to set the tag for\n+\t * @return\n+\t * \t\tReturns resource with the tag set.\n+\t */\n+\tpublic static IBaseResource setEmpiManaged(IBaseResource theBaseResource) {\n+\t\treturn setTagOnResource(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED, EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\nsimilarity index 56%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\nindex 8128d69d12..a8c6a0c061 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/EmpiUtil.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/MdmUtil.java\n\n@@ -21,56 +21,63 @@ package ca.uhn.fhir.empi.util;\n  */\n \n import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n+import ca.uhn.fhir.mdm.api.MdmConstants;\n import org.hl7.fhir.instance.model.api.IBaseCoding;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n \n import javax.annotation.Nonnull;\n import java.util.Optional;\n \n-public final class EmpiUtil {\n-\tprivate EmpiUtil() {}\n+public final class MdmUtil {\n \n-\n-\tpublic static boolean isEmpiResourceType(FhirContext theFhirContext, IBaseResource theResource) {\n-\t\tString resourceType = theFhirContext.getResourceType(theResource);\n-\t\treturn (\"Patient\".equals(resourceType) ||\n-\t\t\t\"Practitioner\".equals(resourceType)) ||\n-\t\t\t\"Person\".equals(resourceType);\n+\tprivate MdmUtil() {\n \t}\n \n \t/**\n-\t * If the resource is tagged as not managed by empi, return false. Otherwise true.\n-\t * @param theBaseResource The Patient/Practitioner that is potentially managed by EMPI.\n-\t * @return A boolean indicating whether EMPI should manage this resource.\n+\t * If the resource is tagged as not managed by MDM, return false. Otherwise true.\n+\t *\n+\t * @param theBaseResource The FHIR resource that is potentially managed by MDM.\n+\t * @return A boolean indicating whether MDM can manage this resource.\n \t */\n-\tpublic static boolean isEmpiAccessible(IBaseResource theBaseResource) {\n-\t\treturn theBaseResource.getMeta().getTag(EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_NO_EMPI_MANAGED) == null;\n+\tpublic static boolean isMdmAllowed(IBaseResource theBaseResource) {\n+\t\treturn theBaseResource.getMeta().getTag(MdmConstants.SYSTEM_MDM_MANAGED, MdmConstants.CODE_NO_MDM_MANAGED) == null;\n \t}\n \n \t/**\n-\t * Checks for the presence of the EMPI-managed tag, indicating the EMPI system has ownership\n+\t * Checks for the presence of the MDM-managed tag, indicating the MDM system has ownership\n \t * of this Person's links.\n \t *\n \t * @param theBaseResource the resource to check.\n-\t * @return a boolean indicating whether or not EMPI manages this Person.\n+\t * @return a boolean indicating whether or not MDM manages this FHIR resource.\n \t */\n-\tpublic static boolean isEmpiManaged(IBaseResource theBaseResource) {\n-\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_MDM_MANAGED, EmpiConstants.CODE_HAPI_MDM_MANAGED);\n+\tpublic static boolean isMdmManaged(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTag(theBaseResource, MdmConstants.SYSTEM_MDM_MANAGED, MdmConstants.CODE_HAPI_MDM_MANAGED);\n \t}\n \n \tpublic static boolean isGoldenRecord(IBaseResource theBaseResource) {\n-\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD);\n+\t\treturn resourceHasTag(theBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS, MdmConstants.CODE_GOLDEN_RECORD);\n+\t}\n+\n+\tpublic static boolean hasGoldenRecordSystemTag(IBaseResource theIBaseResource) {\n+\t\treturn resourceHasTagWithSystem(theIBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS);\n+\t}\n+\n+\tpublic static boolean containsTagWithSystem(IBaseResource theBaseResource) {\n+\t\treturn resourceHasTagWithSystem(theBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS);\n \t}\n \n \tpublic static boolean isGoldenRecordRedirected(IBaseResource theBaseResource) {\n-\t\treturn resourceHasTag(theBaseResource, EmpiConstants.SYSTEM_GOLDEN_RECORD_STATUS, EmpiConstants.CODE_GOLDEN_RECORD_REDIRECTED);\n+\t\treturn resourceHasTag(theBaseResource, MdmConstants.SYSTEM_GOLDEN_RECORD_STATUS, MdmConstants.CODE_GOLDEN_RECORD_REDIRECTED);\n \t}\n \n \tprivate static boolean resourceHasTag(IBaseResource theTheBaseResource, String theSystem, String theCode) {\n \t\treturn theTheBaseResource.getMeta().getTag(theSystem, theCode) != null;\n \t}\n \n+\tprivate static boolean resourceHasTagWithSystem(IBaseResource theTheBaseResource, String theSystem) {\n+\t\treturn theTheBaseResource.getMeta().getTag().stream().anyMatch(tag -> tag.getSystem().equalsIgnoreCase(theSystem));\n+\t}\n+\n \tprivate static Optional<? extends IBaseCoding> getTagWithSystem(IBaseResource theResource, String theSystem) {\n \t\treturn theResource.getMeta().getTag().stream().filter(tag -> tag.getSystem().equalsIgnoreCase(theSystem)).findFirst();\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyOTg2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525429869", "bodyText": "rename S/R to Golden", "author": "nvg-smile", "createdAt": "2020-11-17T19:28:19Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 79%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..f0f9ca6146 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -62,22 +61,22 @@ import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \n-\tprivate IEmpiLinkQuerySvc queyr;\n \n \tprivate final FhirContext myFhirContext;\n \n \t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDE0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525430148", "bodyText": "S/R to Golden", "author": "nvg-smile", "createdAt": "2020-11-17T19:28:46Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n \n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n+\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n \n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n+\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n \n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n+\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n \n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n+\t\tEmpiUtil.setGoldenResource(newSourceResource);\n \n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n+\t\treturn (T) newSourceResource;\n \t}\n \n-\n \t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n \t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 79%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..f0f9ca6146 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -62,22 +61,22 @@ import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \n-\tprivate IEmpiLinkQuerySvc queyr;\n \n \tprivate final FhirContext myFhirContext;\n \n \t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMDQ2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525430469", "bodyText": "s/r to golden", "author": "nvg-smile", "createdAt": "2020-11-17T19:29:17Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -73,374 +82,261 @@ public PersonHelper(FhirContext theFhirContext) {\n \t}\n \n \t/**\n-\t * Given a Person, extract all {@link IIdType}s for the linked targets.\n-\t *\n-\t * @param thePerson the Person to extract link IDs from.\n-\t * @return a Stream of {@link IIdType}.\n-\t */\n-\tpublic Stream<IIdType> getLinkIds(IBaseResource thePerson) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = (Person) thePerson;\n-\t\t\t\treturn personR4.getLink().stream()\n-\t\t\t\t\t.map(Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personStu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\treturn personStu3.getLink().stream()\n-\t\t\t\t\t.map(org.hl7.fhir.dstu3.model.Person.PersonLinkComponent::getTarget)\n-\t\t\t\t\t.map(IBaseReference::getReferenceElement)\n-\t\t\t\t\t.map(IIdType::toUnqualifiedVersionless);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether or not the given {@link IBaseResource} person contains a link to a particular {@link IIdType}\n+\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n+\t * a randomly generated UUID EID will be created.\n \t *\n-\t * @param thePerson     The person to check\n-\t * @param theResourceId The ID to check.\n-\t * @return A boolean indicating whether or not there was a contained link.\n+\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n+\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n \t */\n-\tpublic boolean containsLinkTo(IBaseResource thePerson, IIdType theResourceId) {\n-\t\tStream<IIdType> links = getLinkIds(thePerson);\n-\t\treturn links.anyMatch(link -> link.getValue().equals(theResourceId.getValue()));\n-\t}\n+\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n+\t\tvalidateContextSupported();\n \n-\t/**\n-\t * Create or update a link from source {@link IBaseResource} to the target {@link IIdType}, with the given {@link CanonicalIdentityAssuranceLevel}.\n-\t * @param thePerson The person who's link needs to be updated.\n-\t * @param theResourceId The target of the link\n-\t * @param canonicalAssuranceLevel The level of certainty of this link.\n-\t * @param theEmpiTransactionContext\n-\t */\n-\tpublic void addOrUpdateLink(IBaseResource thePerson, IIdType theResourceId, @Nonnull CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\thandleLinkUpdateR4(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\thandleLinkUpdateDSTU3(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n+\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n \n-\tprivate void handleLinkUpdateDSTU3(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theTransactionLogMessages) {\n-\t\tif (theCanonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n \n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new org.hl7.fhir.dstu3.model.Reference(theResourceId)).setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, theCanonicalAssuranceLevel, theTransactionLogMessages, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(theCanonicalAssuranceLevel.toDstu3());\n-\t\t\t\t});\n-\t\t}\n-\t}\n+\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n \n-\tprivate void logLinkAddMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel theCanonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Creating new link from \" + (StringUtils.isBlank(thePerson.getIdElement().toUnqualifiedVersionless().getValue()) ? \"new Person\" : thePerson.getIdElement().toUnqualifiedVersionless()) + \" -> \" + theResourceId.toUnqualifiedVersionless() + \" with IdentityAssuranceLevel: \" + theCanonicalAssuranceLevel.name());\n-\t}\n+\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n \n-\tprivate void logLinkUpdateMessage(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext, String theOriginalAssuranceLevel) {\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Updating link from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless() + \". Changing IdentityAssuranceLevel: \" + theOriginalAssuranceLevel + \" -> \" + canonicalAssuranceLevel.name());\n-\t}\n+\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n \n-\tprivate void handleLinkUpdateR4(IBaseResource thePerson, IIdType theResourceId, CanonicalIdentityAssuranceLevel canonicalAssuranceLevel, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (canonicalAssuranceLevel == null) {\n-\t\t\tourLog.warn(\"Refusing to update or add a link without an Assurance Level.\");\n-\t\t\treturn;\n-\t\t}\n+\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n+\t\tEmpiUtil.setGoldenResource(newSourceResource);\n \n-\t\tPerson person = (Person) thePerson;\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n-\t\t\tperson.addLink().setTarget(new Reference(theResourceId)).setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\tlogLinkAddMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext);\n-\t\t} else {\n-\t\t\tperson.getLink().stream()\n-\t\t\t\t.filter(link -> link.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()))\n-\t\t\t\t.findFirst()\n-\t\t\t\t.ifPresent(link -> {\n-\t\t\t\t\tlogLinkUpdateMessage(thePerson, theResourceId, canonicalAssuranceLevel, theEmpiTransactionContext, link.getAssurance().toCode());\n-\t\t\t\t\tlink.setAssurance(canonicalAssuranceLevel.toR4());\n-\t\t\t\t});\n-\t\t}\n+\t\treturn (T) newSourceResource;\n \t}\n \n-\n \t/**\n-\t * Removes a link from the given {@link IBaseResource} to the target {@link IIdType}.\n-\t * @param thePerson The person to remove the link from.\n-\t * @param theResourceId The target ID to remove.\n-\t * @param theEmpiTransactionContext\n+\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n \t */\n-\tpublic void removeLink(IBaseResource thePerson, IIdType theResourceId, EmpiTransactionContext theEmpiTransactionContext) {\n-\t\tif (!containsLinkTo(thePerson, theResourceId)) {\n+\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n+\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n+\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n+\n+\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n+\t\tif (!eidsToApply.isEmpty()) {\n \t\t\treturn;\n \t\t}\n-\t\ttheEmpiTransactionContext.addTransactionLogMessage(\"Removing PersonLinkComponent from \" + thePerson.getIdElement().toUnqualifiedVersionless() + \" -> \" + theResourceId.toUnqualifiedVersionless());\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson person = (Person) thePerson;\n-\t\t\t\tList<Person.PersonLinkComponent> links = person.getLink();\n-\t\t\t\tlinks.removeIf(component -> component.hasTarget() && component.getTarget().getReference().equals(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\t\t\tpersonDstu3.getLink().removeIf(component -> component.hasTarget() && component.getTarget().getReference().equalsIgnoreCase(theResourceId.getValue()));\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n+\n+\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n+\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n+\n+\t\t// set identifier on the target resource\n+\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n+\t}\n+\n+\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n+\t\t// get a ref to the actual ID Field\n+\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n+\t\t// hapi has 2 metamodels: for children and types\n+\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n \t}\n \n \t/**\n-\t * Create a Person from a given patient. This will carry over the Patient's EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param theSourceResource The Patient that will be used as the starting point for the person.\n-\t * @return the Person that is created.\n+\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n \t */\n-\tpublic IAnyResource createPersonFromEmpiTarget(IAnyResource theSourceResource) {\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theSourceResource);\n-\t\tif (eidsToApply.isEmpty()) {\n-\t\t\teidsToApply.add(myEIDHelper.createHapiEid());\n-\t\t}\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tPerson personR4 = new Person();\n+\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n+\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n \n-\t\t\t\tpersonR4.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personR4.addIdentifier(eid.toR4()));\n-\t\t\t\tpersonR4.getMeta().addTag((Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personR4, true);\n-\t\t\t\treturn personR4;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Person personDstu3 = new org.hl7.fhir.dstu3.model.Person();\n-\t\t\t\tpersonDstu3.setActive(true);\n-\t\t\t\teidsToApply.forEach(eid -> personDstu3.addIdentifier(eid.toDSTU3()));\n-\t\t\t\tpersonDstu3.getMeta().addTag((org.hl7.fhir.dstu3.model.Coding) buildEmpiManagedTag());\n-\t\t\t\tcopyEmpiTargetDataIntoPerson(theSourceResource, personDstu3, true);\n-\t\t\t\treturn personDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n+\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n \t}\n \n \t/**\n-\t * This will copy over all attributes that are copiable from Patient/Practitioner to Person.\n-\t *\n-\t * @param theBaseResource The incoming {@link Patient} or {@link Practitioner} who's data we want to copy into Person.\n-\t * @param thePerson       The incoming {@link Person} who needs to have their data updated.\n-\t * @param theAllowOverwriting If enabled, will overwrite existing values on the person. Otherwise, will set them only if they are currently empty/null.\n+\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n+\t * contract.\n \t *\n+\t * @param theFrom Resource to clone the specified filed from\n+\t * @param theTo Resource to clone the specified filed to\n+\t * @param field Field name to be copied\n \t */\n-\tprivate void copyEmpiTargetDataIntoPerson(IBaseResource theBaseResource, IBaseResource thePerson, Boolean theAllowOverwriting) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tcopyR4TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tcopyDSTU3TargetInformation(theBaseResource, thePerson, theAllowOverwriting);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n+\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n+\t\tFhirTerser terser = myFhirContext.newTerser();\n+\n+\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n+\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n+\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n+\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n+\n+\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n+\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n+\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n+\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n+\n+\t\t\ttheToFieldValues.add(newFieldValue);\n \t\t}\n \t}\n \n-\tprivate void copyR4TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\tPerson person = (Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\tPatient patient = (Patient) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\tPractitioner practitioner = (Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n-\t\t}\n+\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n+\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n+\t\treturn theItems.stream().filter(i -> {\n+\t\t\treturn predicate.test(i, theItem);\n+\t\t}).findFirst().isPresent();\n \t}\n \n-\tprivate void copyDSTU3TargetInformation(IBaseResource theBaseResource, IBaseResource thePerson, boolean theAllowOverwriting) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePerson;\n-\t\tswitch (myFhirContext.getResourceType(theBaseResource)) {\n-\t\t\tcase \"Patient\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Patient patient = (org.hl7.fhir.dstu3.model.Patient) theBaseResource;\n+\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n+\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n+\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n+\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n \n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(patient.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(patient.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(patient.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null ) {\n-\t\t\t\t\tperson.setBirthDate(patient.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null ) {\n-\t\t\t\t\tperson.setGender(patient.getGender());\n+\t\tfor (IBase base : sourceResourceIdentifiers) {\n+\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n+\t\t\tif (system.isPresent()) {\n+\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n+\t\t\t\tString baseSystem = system.get().getValueAsString();\n+\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n+\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n+\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n+\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n \t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(patient.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase \"Practitioner\":\n-\t\t\t\torg.hl7.fhir.dstu3.model.Practitioner practitioner = (org.hl7.fhir.dstu3.model.Practitioner) theBaseResource;\n-\t\t\t\tif (theAllowOverwriting || person.getName().isEmpty()) {\n-\t\t\t\t\tperson.setName(practitioner.getName());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getAddress().isEmpty()) {\n-\t\t\t\t\tperson.setAddress(practitioner.getAddress());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getTelecom().isEmpty()) {\n-\t\t\t\t\tperson.setTelecom(practitioner.getTelecom());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getBirthDate() == null) {\n-\t\t\t\t\tperson.setBirthDate(practitioner.getBirthDate());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getGender() == null) {\n-\t\t\t\t\tperson.setGender(practitioner.getGender());\n-\t\t\t\t}\n-\t\t\t\tif (theAllowOverwriting || person.getPhoto().isEmpty()) {\n-\t\t\t\t\tperson.setPhoto(practitioner.getPhotoFirstRep());\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"EMPI targets are limited to Practitioner/Patient. This is a : \" + myFhirContext.getResourceType(theBaseResource));\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(\"System is missing, skipping\");\n+\t\t\t}\n \t\t}\n \t}\n \n-\tprivate IBaseCoding buildEmpiManagedTag() {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tCoding empiManagedCoding = new Coding();\n-\t\t\t\tempiManagedCoding.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCoding.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCoding;\n-\t\t\tcase DSTU3:\n-\t\t\t\torg.hl7.fhir.dstu3.model.Coding empiManagedCodingDstu3 = new org.hl7.fhir.dstu3.model.Coding();\n-\t\t\t\tempiManagedCodingDstu3.setSystem(EmpiConstants.SYSTEM_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setCode(EmpiConstants.CODE_HAPI_EMPI_MANAGED);\n-\t\t\t\tempiManagedCodingDstu3.setDisplay(EmpiConstants.DISPLAY_HAPI_EMPI_MANAGED);\n-\t\t\t\treturn empiManagedCodingDstu3;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\n+\tprivate void validateContextSupported() {\n+\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n+\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n+\t\t\treturn;\n \t\t}\n+\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n \t}\n \n \t/**\n \t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n \t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t *\n+\t * <p>\n \t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n \t *\n-\t * @param thePerson     The person to update the external EID on.\n-\t * @param theEmpiTarget The target we will retrieve the external EID from.\n+\t * @param theSourceResource The person to update the external EID on.\n+\t * @param theTargetResource The target we will retrieve the external EID from.\n \t * @return the modified {@link IBaseResource} representing the person.\n \t */\n-\tpublic IAnyResource updatePersonExternalEidFromEmpiTarget(IAnyResource thePerson, IAnyResource theEmpiTarget, EmpiTransactionContext theEmpiTransactionContext) {\n+\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 79%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..f0f9ca6146 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -62,22 +61,22 @@ import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+public class GoldenResourceHelper {\n+\n+\tprivate static final Logger ourLog = Logs.getMdmTroubleshootingLog();\n \n \tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n \n \t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n+\tprivate IMdmSettings myMdmSettings;\n \t@Autowired\n \tprivate EIDHelper myEIDHelper;\n \n-\tprivate IEmpiLinkQuerySvc queyr;\n \n \tprivate final FhirContext myFhirContext;\n \n \t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n+\tpublic GoldenResourceHelper(FhirContext theFhirContext) {\n \t\tmyFhirContext = theFhirContext;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMTU2Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525431567", "bodyText": "Rename to ResourceHelper or GoldenResourceHelper?", "author": "nvg-smile", "createdAt": "2020-11-17T19:31:05Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -20,51 +20,60 @@\n  * #L%\n  */\n \n+import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n+import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.api.EmpiConstants;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n import ca.uhn.fhir.empi.api.IEmpiSettings;\n import ca.uhn.fhir.empi.log.Logs;\n import ca.uhn.fhir.empi.model.CanonicalEID;\n import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n-import org.apache.commons.lang3.StringUtils;\n+import ca.uhn.fhir.empi.model.MdmTransactionContext;\n+import ca.uhn.fhir.fhirpath.IFhirPath;\n+import ca.uhn.fhir.util.FhirTerser;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBase;\n import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseCoding;\n-import org.hl7.fhir.instance.model.api.IBaseReference;\n import org.hl7.fhir.instance.model.api.IBaseResource;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.Coding;\n+import org.hl7.fhir.r4.model.BooleanType;\n import org.hl7.fhir.r4.model.ContactPoint;\n import org.hl7.fhir.r4.model.HumanName;\n import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Patient;\n import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Practitioner;\n import org.hl7.fhir.r4.model.Reference;\n import org.slf4j.Logger;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n-import javax.annotation.Nonnull;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.function.BiPredicate;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+\n+import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n+import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n \n @Service\n public class PersonHelper {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 79%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..f0f9ca6146 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -25,12 +25,11 @@ import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.context.FhirVersionEnum;\n import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n+import ca.uhn.fhir.mdm.api.IMdmSettings;\n+import ca.uhn.fhir.mdm.log.Logs;\n+import ca.uhn.fhir.mdm.model.CanonicalEID;\n+import ca.uhn.fhir.mdm.model.CanonicalIdentityAssuranceLevel;\n+import ca.uhn.fhir.mdm.model.MdmTransactionContext;\n import ca.uhn.fhir.fhirpath.IFhirPath;\n import ca.uhn.fhir.util.FhirTerser;\n import org.hl7.fhir.instance.model.api.IAnyResource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0MzI0Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525443243", "bodyText": "rename person to golden resource", "author": "nvg-smile", "createdAt": "2020-11-17T19:42:11Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -458,26 +355,20 @@ private void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, or\n \t\t}\n \t}\n \n-\tprivate void addIdentifierIfAbsent(Person thePerson, Identifier theIdentifier) {\n-\t\tOptional<Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n+\tpublic void mergeFields(IBaseResource theFromPerson, IBaseResource theToPerson) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffee7a894ff0a1f4d48cfbb17ed8a31e6c60a84f", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\ndeleted file mode 100644\nindex 46f2a8c4b7..0000000000\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ /dev/null\n\n@@ -1,513 +0,0 @@\n-package ca.uhn.fhir.empi.util;\n-\n-/*-\n- * #%L\n- * HAPI FHIR - Enterprise Master Patient Index\n- * %%\n- * Copyright (C) 2014 - 2020 University Health Network\n- * %%\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * #L%\n- */\n-\n-import ca.uhn.fhir.context.BaseRuntimeChildDefinition;\n-import ca.uhn.fhir.context.BaseRuntimeElementCompositeDefinition;\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.context.FhirVersionEnum;\n-import ca.uhn.fhir.context.RuntimeResourceDefinition;\n-import ca.uhn.fhir.empi.api.IEmpiLinkQuerySvc;\n-import ca.uhn.fhir.empi.api.IEmpiSettings;\n-import ca.uhn.fhir.empi.log.Logs;\n-import ca.uhn.fhir.empi.model.CanonicalEID;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.model.MdmTransactionContext;\n-import ca.uhn.fhir.fhirpath.IFhirPath;\n-import ca.uhn.fhir.util.FhirTerser;\n-import org.hl7.fhir.instance.model.api.IAnyResource;\n-import org.hl7.fhir.instance.model.api.IBase;\n-import org.hl7.fhir.instance.model.api.IBaseBackboneElement;\n-import org.hl7.fhir.instance.model.api.IBaseResource;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.instance.model.api.IPrimitiveType;\n-import org.hl7.fhir.r4.model.Address;\n-import org.hl7.fhir.r4.model.BooleanType;\n-import org.hl7.fhir.r4.model.ContactPoint;\n-import org.hl7.fhir.r4.model.HumanName;\n-import org.hl7.fhir.r4.model.Identifier;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.slf4j.Logger;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Service;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.context.FhirVersionEnum.DSTU3;\n-import static ca.uhn.fhir.context.FhirVersionEnum.R4;\n-\n-@Service\n-public class PersonHelper {\n-\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n-\n-\tprivate static final String FIELD_NAME_IDENTIFIER = \"identifier\";\n-\n-\t@Autowired\n-\tprivate IEmpiSettings myEmpiConfig;\n-\t@Autowired\n-\tprivate EIDHelper myEIDHelper;\n-\n-\tprivate IEmpiLinkQuerySvc queyr;\n-\n-\tprivate final FhirContext myFhirContext;\n-\n-\t@Autowired\n-\tpublic PersonHelper(FhirContext theFhirContext) {\n-\t\tmyFhirContext = theFhirContext;\n-\t}\n-\n-\t/**\n-\t * Creates a copy of the specified resource. This method will carry over resource EID if it exists. If it does not exist,\n-\t * a randomly generated UUID EID will be created.\n-\t *\n-\t * @param <T>                 Supported MDM resource type (e.g. Patient, Practitioner)\n-\t * @param theIncomingResource The resource that will be used as the starting point for the MDM linking.\n-\t */\n-\tpublic <T extends IAnyResource> T createGoldenResourceFromMdmTarget(T theIncomingResource) {\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theIncomingResource);\n-\t\tIBaseResource newSourceResource = resourceDefinition.newInstance();\n-\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\n-\t\tcloneAllExternalEidsIntoNewSourceResource(sourceResourceIdentifier, theIncomingResource, newSourceResource);\n-\n-\t\taddHapiEidIfNoExternalEidIsPresent(newSourceResource, sourceResourceIdentifier, theIncomingResource);\n-\n-\t\t//setGoldenResource(newSourceResource, resourceDefinition, true);\n-\n-\t\tEmpiUtil.setEmpiManaged(newSourceResource);\n-\t\tEmpiUtil.setGoldenResource(newSourceResource);\n-\n-\t\treturn (T) newSourceResource;\n-\t}\n-\n-\t/**\n-\t * If there are no external EIDs on the incoming resource, create a new HAPI EID on the new SourceResource.\n-\t */\n-\t//TODO GGG ask james if there is any way we can convert this canonical EID into a generic STU-agnostic IBase.\n-\tprivate <T extends IAnyResource> void addHapiEidIfNoExternalEidIsPresent(\n-\t\tIBaseResource theNewSourceResource, BaseRuntimeChildDefinition theSourceResourceIdentifier, IAnyResource theTargetResource) {\n-\n-\t\tList<CanonicalEID> eidsToApply = myEIDHelper.getExternalEid(theNewSourceResource);\n-\t\tif (!eidsToApply.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tCanonicalEID hapiEid = myEIDHelper.createHapiEid();\n-\t\ttheSourceResourceIdentifier.getMutator().addValue(theNewSourceResource, toId(hapiEid));\n-\n-\t\t// set identifier on the target resource\n-\t\tcloneEidIntoResource(theTargetResource, hapiEid);\n-\t}\n-\n-\tprivate void cloneEidIntoResource(IBaseResource theResourceToCloneInto, CanonicalEID theEid) {\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theResourceToCloneInto);\n-\t\t// hapi has 2 metamodels: for children and types\n-\t\tBaseRuntimeChildDefinition resourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tcloneEidIntoResource(resourceIdentifier, toId(theEid), theResourceToCloneInto);\n-\t}\n-\n-\t/**\n-\t * Given an Child Definition of `identifier`, a R4/DSTU3 EID Identifier, and a new resource, clone the EID into that resources' identifier list.\n-\t */\n-\tprivate void cloneEidIntoResource(BaseRuntimeChildDefinition theIdentifierDefinition, IBase theEid, IBase theResourceToCloneEidInto) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>) theIdentifierDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tIBase resourceNewIdentifier = childIdentifier.newInstance();\n-\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\t\tterser.cloneInto(theEid, resourceNewIdentifier, true);\n-\t\ttheIdentifierDefinition.getMutator().addValue(theResourceToCloneEidInto, resourceNewIdentifier);\n-\t}\n-\n-\t/**\n-\t * Clones specified composite field (collection). Composite field values must confirm to the collections\n-\t * contract.\n-\t *\n-\t * @param theFrom Resource to clone the specified filed from\n-\t * @param theTo Resource to clone the specified filed to\n-\t * @param field Field name to be copied\n-\t */\n-\tprivate void cloneCompositeField(IBaseResource theFrom, IBaseResource theTo, String field) {\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tRuntimeResourceDefinition definition = myFhirContext.getResourceDefinition(theFrom);\n-\t\tBaseRuntimeChildDefinition childDefinition = definition.getChildByName(field);\n-\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> theFromFieldValues = childDefinition.getAccessor().getValues(theFrom);\n-\t\tList<IBase> theToFieldValues = childDefinition.getAccessor().getValues(theTo);\n-\n-\t\tfor (IBase theFromFieldValue: theFromFieldValues) {\n-\t\t\tif (contains(theFromFieldValue, theToFieldValues)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> compositeDefinition = (BaseRuntimeElementCompositeDefinition<?>) childDefinition.getChildByName(field);\n-\t\t\tIBase newFieldValue = compositeDefinition.newInstance();\n-\t\t\tterser.cloneInto(theFromFieldValue, newFieldValue, true);\n-\n-\t\t\ttheToFieldValues.add(newFieldValue);\n-\t\t}\n-\t}\n-\n-\tprivate boolean contains(IBase theItem, List<IBase> theItems) {\n-\t\tPrimitiveTypeComparingPredicate predicate = new PrimitiveTypeComparingPredicate();\n-\t\treturn theItems.stream().filter(i -> {\n-\t\t\treturn predicate.test(i, theItem);\n-\t\t}).findFirst().isPresent();\n-\t}\n-\n-\tprivate void cloneAllExternalEidsIntoNewSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource, IBase theNewSourceResource) {\n-\t\t// FHIR choice types - fields within fhir where we have a choice of ids\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n-\n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tcloneEidIntoResource(theSourceResourceIdentifier, base, theNewSourceResource);\n-\t\t\t\t} else if (ourLog.isDebugEnabled()) {\n-\t\t\t\t\tourLog.debug(String.format(\"System %s differs from system in the EMPI rules %s\", baseSystem, empiSystem));\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tourLog.debug(\"System is missing, skipping\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void validateContextSupported() {\n-\t\tFhirVersionEnum fhirVersion = myFhirContext.getVersion().getVersion();\n-\t\tif (fhirVersion == R4 || fhirVersion == DSTU3) {\n-\t\t\treturn;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * Update a Person's EID based on the incoming target resource. If the incoming resource has an external EID, it is applied\n-\t * to the Person, unless that person already has an external EID which does not match, in which case throw {@link IllegalArgumentException}\n-\t * <p>\n-\t * If running in multiple EID mode, then incoming EIDs are simply added to the Person without checking for matches.\n-\t *\n-\t * @param theSourceResource The person to update the external EID on.\n-\t * @param theTargetResource The target we will retrieve the external EID from.\n-\t * @return the modified {@link IBaseResource} representing the person.\n-\t */\n-\tpublic IAnyResource updateSourceResourceExternalEidFromTargetResource(IAnyResource theSourceResource, IAnyResource\n-\t\ttheTargetResource, MdmTransactionContext theMdmTransactionContext) {\n-\t\t//This handles overwriting an automatically assigned EID if a patient that links is coming in with an official EID.\n-\t\tList<CanonicalEID> incomingTargetEid = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tList<CanonicalEID> personOfficialEid = myEIDHelper.getExternalEid(theSourceResource);\n-\n-\t\tif (!incomingTargetEid.isEmpty()) {\n-\t\t\tif (personOfficialEid.isEmpty() || !myEmpiConfig.isPreventMultipleEids()) {\n-\t\t\t\tlog(theMdmTransactionContext, \"Incoming resource:\" + theTargetResource.getIdElement().toUnqualifiedVersionless() + \" + with EID \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" is applying this EIDs to its related Source Resource, as this Source Resource does not yet have an external EID\");\n-\t\t\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, incomingTargetEid);\n-\t\t\t} else if (!personOfficialEid.isEmpty() && myEIDHelper.eidMatchExists(personOfficialEid, incomingTargetEid)) {\n-\t\t\t\tlog(theMdmTransactionContext, \"incoming resource:\" + theTargetResource.getIdElement().toVersionless() + \" with EIDs \" + incomingTargetEid.stream().map(CanonicalEID::toString).collect(Collectors.joining(\",\")) + \" does not need to overwrite person, as this EID is already present\");\n-\t\t\t} else {\n-\t\t\t\tthrow new IllegalArgumentException(\"This would create a duplicate person!\");\n-\t\t\t}\n-\t\t}\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tpublic IBaseResource overwriteExternalEids(IBaseResource theSourceResource, List<CanonicalEID> theNewEid) {\n-\t\tclearExternalEids(theSourceResource);\n-\t\taddCanonicalEidsToSourceResourceIfAbsent(theSourceResource, theNewEid);\n-\t\treturn theSourceResource;\n-\t}\n-\n-\tprivate void clearExternalEidsFromTheSourceResource(BaseRuntimeChildDefinition theSourceResourceIdentifier, IBase theSourceResource) {\n-\t\tIFhirPath fhirPath = myFhirContext.newFhirPath();\n-\t\tList<IBase> sourceResourceIdentifiers = theSourceResourceIdentifier.getAccessor().getValues(theSourceResource);\n-\t\tList<IBase> clonedIdentifiers = new ArrayList<>();\n-\t\tFhirTerser terser = myFhirContext.newTerser();\n-\n-\t\tfor (IBase base : sourceResourceIdentifiers) {\n-\t\t\tOptional<IPrimitiveType> system = fhirPath.evaluateFirst(base, \"system\", IPrimitiveType.class);\n-\t\t\tif (system.isPresent()) {\n-\t\t\t\tString empiSystem = myEmpiConfig.getEmpiRules().getEnterpriseEIDSystem();\n-\t\t\t\tString baseSystem = system.get().getValueAsString();\n-\t\t\t\tif (Objects.equals(baseSystem, empiSystem)) {\n-\t\t\t\t\tif (ourLog.isDebugEnabled()) {\n-\t\t\t\t\t\tourLog.debug(String.format(\"Found EID confirming to EMPI rules %s. It should not be copied, skipping\", baseSystem));\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tBaseRuntimeElementCompositeDefinition<?> childIdentifier = (BaseRuntimeElementCompositeDefinition<?>)\n-\t\t\t\t\ttheSourceResourceIdentifier.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\t\tIBase sourceResourceNewIdentifier = childIdentifier.newInstance();\n-\t\t\tterser.cloneInto(base, sourceResourceNewIdentifier, true);\n-\n-\t\t\tclonedIdentifiers.add(sourceResourceNewIdentifier);\n-\t\t}\n-\n-\t\tsourceResourceIdentifiers.clear();\n-\t\tsourceResourceIdentifiers.addAll(clonedIdentifiers);\n-\t}\n-\n-\tprivate void clearExternalEids(IBaseResource theSourceResource) {\n-\t\t// validate the system - if it's set to EID system - then clear it - type and STU version\n-\t\tvalidateContextSupported();\n-\n-\t\t// get a ref to the actual ID Field\n-\t\tRuntimeResourceDefinition resourceDefinition = myFhirContext.getResourceDefinition(theSourceResource);\n-\t\tBaseRuntimeChildDefinition sourceResourceIdentifier = resourceDefinition.getChildByName(FIELD_NAME_IDENTIFIER);\n-\t\tclearExternalEidsFromTheSourceResource(sourceResourceIdentifier, theSourceResource);\n-\t}\n-\n-\t/**\n-\t * Given a list of incoming External EIDs, and a Source Resource, apply all the EIDs to this resource, which did not already exist on it.\n-\t */\n-\tprivate void addCanonicalEidsToSourceResourceIfAbsent(IBaseResource theSourceResource, List<CanonicalEID> theIncomingTargetExternalEids) {\n-\t\tList<CanonicalEID> sourceResourceExternalEids = myEIDHelper.getExternalEid(theSourceResource);\n-\n-\t\tfor (CanonicalEID incomingExternalEid : theIncomingTargetExternalEids) {\n-\t\t\tif (sourceResourceExternalEids.contains(incomingExternalEid)) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tcloneEidIntoResource(theSourceResource, incomingExternalEid);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <T extends IBase> T toId(CanonicalEID eid) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) eid.toR4();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) eid.toDSTU3();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\n-\tprivate <T extends IBase> T toBooleanType(boolean theFlag) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn (T) new BooleanType(theFlag);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn (T) new org.hl7.fhir.dstu3.model.BooleanType(theFlag);\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\tprivate <T extends IBase> boolean fromBooleanType(T theFlag) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn ((BooleanType)theFlag).booleanValue();\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn ((org.hl7.fhir.dstu3.model.BooleanType)theFlag).booleanValue();\n-\t\t}\n-\t\tthrow new IllegalStateException(\"Unsupported FHIR version \" + myFhirContext.getVersion().getVersion());\n-\t}\n-\n-\t/**\n-\t * To avoid adding duplicate\n-\t *\n-\t * @param thePerson\n-\t * @param theIdentifier\n-\t */\n-\tprivate void addIdentifierIfAbsent(org.hl7.fhir.dstu3.model.Person thePerson, org.hl7.fhir.dstu3.model.Identifier\n-\t\ttheIdentifier) {\n-\t\tOptional<org.hl7.fhir.dstu3.model.Identifier> first = thePerson.getIdentifier().stream().filter(identifier -> identifier.getSystem().equals(theIdentifier.getSystem())).filter(identifier -> identifier.getValue().equals(theIdentifier.getValue())).findFirst();\n-\t\tif (first.isPresent()) {\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthePerson.addIdentifier(theIdentifier);\n-\t\t}\n-\t}\n-\n-\tpublic void mergeFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\t//\tTODO NG - Revisit when merge rules are defined\n-\t\tcloneCompositeField(theFromPerson, theToPerson, FIELD_NAME_IDENTIFIER);\n-\n-//\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-//\t\t\tcase R4:\n-//\t\t\t\tmergeR4PersonFields(theFromPerson, theToPerson);\n-//\t\t\t\tbreak;\n-//\t\t\tcase DSTU3:\n-//\t\t\t\tmergeDstu3PersonFields(theFromPerson, theToPerson);\n-//\t\t\t\tbreak;\n-//\t\t\tdefault:\n-//\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-//\t\t}\n-\t}\n-\n-\tprivate void mergeR4PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\tPerson fromPerson = (Person) theFromPerson;\n-\t\tPerson toPerson = (Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, HumanName.class, Person::getName, HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Identifier.class, Person::getIdentifier, Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, Address.class, Person::getAddress, Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, ContactPoint.class, Person::getTelecom, ContactPoint::equalsDeep);\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\tprivate <P, T> void mergeElementList(P fromPerson, P\n-\t\ttoPerson, Class<T> theBase, Function<P, List<T>> theGetList, BiPredicate<T, T> theEquals) {\n-\t\tList<T> fromList = theGetList.apply(fromPerson);\n-\t\tList<T> toList = theGetList.apply(toPerson);\n-\t\tList<T> itemsToAdd = new ArrayList<>();\n-\n-\t\tfor (T fromItem : fromList) {\n-\t\t\tif (toList.stream().noneMatch(t -> theEquals.test(fromItem, t))) {\n-\t\t\t\titemsToAdd.add(fromItem);\n-\t\t\t}\n-\t\t}\n-\t\ttoList.addAll(itemsToAdd);\n-\t}\n-\n-\tprivate void mergeDstu3PersonFields(IBaseResource theFromPerson, IBaseResource theToPerson) {\n-\t\torg.hl7.fhir.dstu3.model.Person fromPerson = (org.hl7.fhir.dstu3.model.Person) theFromPerson;\n-\t\torg.hl7.fhir.dstu3.model.Person toPerson = (org.hl7.fhir.dstu3.model.Person) theToPerson;\n-\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.HumanName.class, org.hl7.fhir.dstu3.model.Person::getName, org.hl7.fhir.dstu3.model.HumanName::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Identifier.class, org.hl7.fhir.dstu3.model.Person::getIdentifier, org.hl7.fhir.dstu3.model.Identifier::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.Address.class, org.hl7.fhir.dstu3.model.Person::getAddress, org.hl7.fhir.dstu3.model.Address::equalsDeep);\n-\t\tmergeElementList(fromPerson, toPerson, org.hl7.fhir.dstu3.model.ContactPoint.class, org.hl7.fhir.dstu3.model.Person::getTelecom, org.hl7.fhir.dstu3.model.ContactPoint::equalsDeep);\n-\n-\t\tif (!toPerson.hasBirthDate()) {\n-\t\t\ttoPerson.setBirthDate(fromPerson.getBirthDate());\n-\t\t}\n-\t\tif (!toPerson.hasGender()) {\n-\t\t\ttoPerson.setGender(fromPerson.getGender());\n-\t\t}\n-\t\tif (!toPerson.hasPhoto()) {\n-\t\t\ttoPerson.setPhoto(fromPerson.getPhoto());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * An incoming resource is a potential duplicate if it matches a Patient that has a Person with an official EID, but\n-\t * the incoming resource also has an EID that does not match.\n-\t *\n-\t * @param theExistingPerson\n-\t * @param theComparingPerson\n-\t * @return\n-\t */\n-\tpublic boolean isPotentialDuplicate(IAnyResource theExistingPerson, IAnyResource theComparingPerson) {\n-\t\tList<CanonicalEID> externalEidsPerson = myEIDHelper.getExternalEid(theExistingPerson);\n-\t\tList<CanonicalEID> externalEidsResource = myEIDHelper.getExternalEid(theComparingPerson);\n-\t\treturn !externalEidsPerson.isEmpty() && !externalEidsResource.isEmpty() && !myEIDHelper.eidMatchExists(externalEidsResource, externalEidsPerson);\n-\t}\n-\n-\tpublic IBaseBackboneElement newPersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel theAssuranceLevel) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\treturn newR4PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tcase DSTU3:\n-\t\t\t\treturn newDstu3PersonLink(theTargetId, theAssuranceLevel);\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate IBaseBackboneElement newR4PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel\n-\t\ttheAssuranceLevel) {\n-\t\tPerson.PersonLinkComponent retval = new Person.PersonLinkComponent();\n-\t\tretval.setTarget(new Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toR4());\n-\t\treturn retval;\n-\t}\n-\n-\tprivate IBaseBackboneElement newDstu3PersonLink(IIdType theTargetId, CanonicalIdentityAssuranceLevel\n-\t\ttheAssuranceLevel) {\n-\t\torg.hl7.fhir.dstu3.model.Person.PersonLinkComponent retval = new org.hl7.fhir.dstu3.model.Person.PersonLinkComponent();\n-\t\tretval.setTarget(new org.hl7.fhir.dstu3.model.Reference(theTargetId));\n-\t\tretval.setAssurance(theAssuranceLevel.toDstu3());\n-\t\treturn retval;\n-\t}\n-\n-\tpublic void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement> theNewLinks) {\n-\t\tswitch (myFhirContext.getVersion().getVersion()) {\n-\t\t\tcase R4:\n-\t\t\t\tsetLinksR4(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tcase DSTU3:\n-\t\t\t\tsetLinksDstu3(thePersonResource, theNewLinks);\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Version not supported: \" + myFhirContext.getVersion().getVersion());\n-\t\t}\n-\t}\n-\n-\tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\torg.hl7.fhir.dstu3.model.Person person = (org.hl7.fhir.dstu3.model.Person) thePersonResource;\n-\t\tList<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent> links = (List<org.hl7.fhir.dstu3.model.Person.PersonLinkComponent>) (List<?>) theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void setLinksR4(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {\n-\t\tPerson person = (Person) thePersonResource;\n-\t\tList<Person.PersonLinkComponent> links = (List<Person.PersonLinkComponent>) (List<?>) theLinks;\n-\t\tperson.setLink(links);\n-\t}\n-\n-\tprivate void log(MdmTransactionContext theMdmTransactionContext, String theMessage) {\n-\t\ttheMdmTransactionContext.addTransactionLogMessage(theMessage);\n-\t\tourLog.debug(theMessage);\n-\t}\n-\n-\tpublic void handleExternalEidAddition(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext\n-\t\t\t  theMdmTransactionContext) {\n-\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n-\t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateSourceResourceExternalEidFromTargetResource(theSourceResource, theTargetResource, theMdmTransactionContext);\n-\t\t}\n-\t}\n-\n-\tpublic void deactivateResource(IAnyResource theResource) {\n-\t\tEmpiUtil.setGoldenResourceRedirected(theResource);\n-\t}\n-\n-\tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n-\t\treturn EmpiUtil.isGoldenRecordRedirected(theGoldenResource);\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0Mzc3OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525443778", "bodyText": "This can be removed?", "author": "nvg-smile", "createdAt": "2020-11-17T19:42:36Z", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java", "diffHunk": "@@ -585,75 +479,35 @@ public void setLinks(IAnyResource thePersonResource, List<IBaseBackboneElement>\n \t}\n \n \tprivate void setLinksDstu3(IAnyResource thePersonResource, List<IBaseBackboneElement> theLinks) {", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nsimilarity index 79%\nrename from hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\nrename to hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\nindex 46f2a8c4b7..f0f9ca6146 100644\n--- a/hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/util/PersonHelper.java\n+++ b/hapi-fhir-server-mdm/src/main/java/ca/uhn/fhir/mdm/util/GoldenResourceHelper.java\n\n@@ -495,19 +490,19 @@ public class PersonHelper {\n \t\tourLog.debug(theMessage);\n \t}\n \n-\tpublic void handleExternalEidAddition(IAnyResource theSourceResource, IAnyResource theTargetResource, MdmTransactionContext\n+\tpublic void handleExternalEidAddition(IAnyResource theGoldenResource, IAnyResource theTargetResource, MdmTransactionContext\n \t\t\t  theMdmTransactionContext) {\n \t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theTargetResource);\n \t\tif (!eidFromResource.isEmpty()) {\n-\t\t\tupdateSourceResourceExternalEidFromTargetResource(theSourceResource, theTargetResource, theMdmTransactionContext);\n+\t\t\tupdateGoldenResourceExternalEidFromTargetResource(theGoldenResource, theTargetResource, theMdmTransactionContext);\n \t\t}\n \t}\n \n \tpublic void deactivateResource(IAnyResource theResource) {\n-\t\tEmpiUtil.setGoldenResourceRedirected(theResource);\n+\t\tMdmUtil.setGoldenResourceRedirected(theResource);\n \t}\n \n \tpublic boolean isDeactivated(IBaseResource theGoldenResource) {\n-\t\treturn EmpiUtil.isGoldenRecordRedirected(theGoldenResource);\n+\t\treturn MdmUtil.isGoldenRecordRedirected(theGoldenResource);\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ0OTg4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525449883", "bodyText": "This test can be removed - linking is done via EmpiLink class", "author": "nvg-smile", "createdAt": "2020-11-17T19:47:25Z", "path": "hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java", "diffHunk": "@@ -33,52 +35,55 @@ public void testGetLinks() {\n \t\tperson.addLink().setTarget(new Reference(PATIENT_1));\n \t\tperson.addLink().setTarget(new Reference(PATIENT_2));\n \n-\t\t{\n-\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-\t\t\tassertEquals(2, links.size());\n-\t\t\tassertEquals(PATIENT_1, links.get(0).getValue());\n-\t\t\tassertEquals(PATIENT_2, links.get(1).getValue());\n-\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_1)));\n-\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_2)));\n-\t\t\tassertFalse(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_BAD)));\n-\t\t}\n-\n-\t\t{\n-\t\t\tMY_PERSON_HELPER.removeLink(person, new IdDt(PATIENT_1), createDummyContext());\n-\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-\t\t\tassertEquals(1, links.size());\n-\t\t\tassertEquals(PATIENT_2, links.get(0).getValue());\n+\t\t// TODO NG - check if we need similar functionality in JPA DAO", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java\ndeleted file mode 100644\nindex 98ef7a6f26..0000000000\n--- a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperDSTU3Test.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-package ca.uhn.fhir.empi.svc;\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.model.primitive.IdDt;\n-import org.hl7.fhir.dstu3.model.Person;\n-import org.hl7.fhir.dstu3.model.Reference;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.empi.util.TestUtils.createDummyContext;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.core.Is.is;\n-import static org.hamcrest.core.IsEqual.equalTo;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class PersonHelperDSTU3Test {\n-\n-\tpublic static final FhirContext ourFhirContext = FhirContext.forDstu3();\n-\tpublic static final String PATIENT_1 = \"Patient/1\";\n-\tpublic static final String PATIENT_2 = \"Patient/2\";\n-\tpublic static final String PATIENT_BAD = \"Patient/BAD\";\n-\tpublic static final PersonHelper MY_PERSON_HELPER = new PersonHelper(ourFhirContext);\n-\n-\t@Test\n-\tpublic void testGetLinks() {\n-\t\tPerson person = new Person();\n-\t\tperson.addLink().setTarget(new Reference(PATIENT_1));\n-\t\tperson.addLink().setTarget(new Reference(PATIENT_2));\n-\n-\t\t// TODO NG - check if we need similar functionality in JPA DAO\n-\t\tif (true) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<IIdType> links = new ArrayList<>();\n-//\t\tlinks = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-\t\tassertEquals(2, links.size());\n-\t\tassertEquals(PATIENT_1, links.get(0).getValue());\n-\t\tassertEquals(PATIENT_2, links.get(1).getValue());\n-//\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_1)));\n-//\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_2)));\n-//\t\t\tassertFalse(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_BAD)));\n-\t}\n-\n-\t{\n-//\t\t\tMY_PERSON_HELPER.removeLink(person, new IdDt(PATIENT_1), createDummyContext());\n-//\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-//\t\tassertEquals(1, links.size());\n-//\t\tassertEquals(PATIENT_2, links.get(0).getValue());\n-\t}\n-\n-\n-//\t@Test\n-//\tpublic void testAddOrUpdateLinks() {\n-//\t\tPerson person = new Person();\n-//\n-//\t\t//Links with no assurance level are rejected\n-//\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), null, createDummyContext());\n-//\t\t\tassertThat(person.getLink().size(), is(equalTo(0)));\n-//\t\t}\n-//\t\t//Original link addition\n-//\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), CanonicalIdentityAssuranceLevel.LEVEL3, createDummyContext());\n-//\t\t\tassertThat(person.getLink().size(), is(equalTo(1)));\n-//\t\t}\n-//\n-//\t\t//Link update\n-//\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), CanonicalIdentityAssuranceLevel.LEVEL4, createDummyContext());\n-//\t\t\tassertThat(person.getLink().size(), is(equalTo(1)));\n-//\t\t}\n-//\n-//\t\t//New link\n-//\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_2), CanonicalIdentityAssuranceLevel.LEVEL4, createDummyContext());\n-//\t\t\tassertThat(person.getLink().size(), is(equalTo(2)));\n-//\t\t}\n-//\t}\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MDI0NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525450245", "bodyText": "Obsolete test", "author": "nvg-smile", "createdAt": "2020-11-17T19:47:44Z", "path": "hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java", "diffHunk": "@@ -30,52 +30,61 @@\n \n \t@Test\n \tpublic void testGetLinks() {\n+\t\t// TODO NG - Revisit this code checking if we need to keep it - if yes - push to the JPA level, delete otherwise", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java b/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java\ndeleted file mode 100644\nindex 1dff85a5fd..0000000000\n--- a/hapi-fhir-server-empi/src/test/java/ca/uhn/fhir/empi/svc/PersonHelperR4Test.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-package ca.uhn.fhir.empi.svc;\n-\n-import ca.uhn.fhir.context.FhirContext;\n-import ca.uhn.fhir.empi.model.CanonicalIdentityAssuranceLevel;\n-import ca.uhn.fhir.empi.util.PersonHelper;\n-import ca.uhn.fhir.model.primitive.IdDt;\n-import org.hl7.fhir.instance.model.api.IIdType;\n-import org.hl7.fhir.r4.model.Person;\n-import org.hl7.fhir.r4.model.Reference;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import static ca.uhn.fhir.empi.util.TestUtils.createDummyContext;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.core.Is.is;\n-import static org.hamcrest.core.IsEqual.equalTo;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class PersonHelperR4Test {\n-\tpublic static final FhirContext ourFhirContext = FhirContext.forR4();\n-\tpublic static final String PATIENT_1 = \"Patient/1\";\n-\tpublic static final String PATIENT_2 = \"Patient/2\";\n-\tpublic static final String PATIENT_BAD = \"Patient/BAD\";\n-\n-\tpublic static final PersonHelper MY_PERSON_HELPER = new PersonHelper(ourFhirContext);\n-\n-\t@Test\n-\tpublic void testGetLinks() {\n-\t\t// TODO NG - Revisit this code checking if we need to keep it - if yes - push to the JPA level, delete otherwise\n-\t\tPerson person = new Person();\n-\t\tperson.addLink().setTarget(new Reference(PATIENT_1));\n-\t\tperson.addLink().setTarget(new Reference(PATIENT_2));\n-\n-\t\tif (true) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t{\n-//\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-//\t\t\tassertEquals(2, links.size());\n-//\t\t\tassertEquals(PATIENT_1, links.get(0).getValue());\n-//\t\t\tassertEquals(PATIENT_2, links.get(1).getValue());\n-//\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_1)));\n-//\t\t\tassertTrue(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_2)));\n-//\t\t\tassertFalse(MY_PERSON_HELPER.containsLinkTo(person, new IdDt(PATIENT_BAD)));\n-\t\t}\n-\n-\t\t{\n-//\t\t\tMY_PERSON_HELPER.removeLink(person, new IdDt(PATIENT_1), createDummyContext());\n-//\t\t\tList<IIdType> links = MY_PERSON_HELPER.getLinkIds(person).collect(Collectors.toList());\n-//\t\t\tassertEquals(1, links.size());\n-//\t\t\tassertEquals(PATIENT_2, links.get(0).getValue());\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void testAddOrUpdateLinks() {\n-\t\tPerson person = new Person();\n-\t\tif (true) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t//Link addition without assurance level should NOOP\n-\t\t// TODO NG - Revisit this code checking if we need to keep it - if yes - push to the JPA level, delete otherwise\n-\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), null, null);\n-\t\t\tassertThat(person.getLink().size(), is(equalTo(0)));\n-\t\t}\n-\t\t//Original link addition\n-\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), CanonicalIdentityAssuranceLevel.LEVEL3, createDummyContext());\n-\t\t\tassertThat(person.getLink().size(), is(equalTo(1)));\n-\t\t}\n-\n-\t\t//Link update\n-\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_1), CanonicalIdentityAssuranceLevel.LEVEL4, createDummyContext());\n-\t\t\tassertThat(person.getLink().size(), is(equalTo(1)));\n-\t\t}\n-\n-\t\t//New link\n-\t\t{\n-//\t\t\tMY_PERSON_HELPER.addOrUpdateLink(person, new IdDt(PATIENT_2), CanonicalIdentityAssuranceLevel.LEVEL4, createDummyContext());\n-\t\t\tassertThat(person.getLink().size(), is(equalTo(2)));\n-\t\t}\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MTIyNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2177#discussion_r525451226", "bodyText": "Rename to MDM", "author": "nvg-smile", "createdAt": "2020-11-17T19:48:38Z", "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java", "diffHunk": "@@ -62,30 +62,35 @@\n \t * EMPI Operations\n \t */\n \tpublic static final String EMPI_MATCH = \"$match\";\n-\tpublic static final String EMPI_MATCH_RESOURCE = \"resource\";\n+\t//TODO GGG MDM: implement a server-level MDM match to complement the FHIR-spec $match for /Patient\n+\tpublic static final String MDM_MATCH = \"$mdm-match\";\n+\tpublic static final String MDM_MATCH_RESOURCE = \"resource\";\n+\tpublic static final String MDM_RESOURCE_TYPE = \"resourceType\";\n \n-\tpublic static final String EMPI_MERGE_PERSONS = \"$empi-merge-persons\";\n-\tpublic static final String EMPI_MERGE_PERSONS_FROM_PERSON_ID = \"fromPersonId\";\n-\tpublic static final String EMPI_MERGE_PERSONS_TO_PERSON_ID = \"toPersonId\";\n+\t//TODO GGG MDM: rename all these vars\n+\tpublic static final String MDM_MERGE_GOLDEN_RESOURCES = \"$mdm-merge-golden-resources\";\n+\tpublic static final String MDM_MERGE_GR_FROM_GOLDEN_RESOURCE_ID = \"fromGoldenResourceId\";\n+\tpublic static final String MDM_MERGE_GR_TO_GOLDEN_RESOURCE_ID = \"toGoldenResourceId\";\n \n-\tpublic static final String EMPI_UPDATE_LINK = \"$empi-update-link\";\n-\tpublic static final String EMPI_UPDATE_LINK_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_UPDATE_LINK_TARGET_ID = \"targetId\";\n-\tpublic static final String EMPI_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_UPDATE_LINK = \"$mdm-update-link\";\n+\tpublic static final String MDM_UPDATE_LINK_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_RESOURCE_ID = \"resourceId\";\n+\tpublic static final String MDM_UPDATE_LINK_MATCH_RESULT = \"matchResult\";\n \n-\tpublic static final String EMPI_QUERY_LINKS = \"$empi-query-links\";\n-\tpublic static final String EMPI_QUERY_LINKS_PERSON_ID = \"personId\";\n-\tpublic static final String EMPI_QUERY_LINKS_TARGET_ID = \"targetId\";\n+\tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n+\tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n+\tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n \tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";", "originalCommit": "805d5b1d6c1c800295cbe99af777b53f6290dd71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c64ca813739ffa111458f1684a5f783e3149ede4", "chunk": "diff --git a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\nindex 05a52cea31..3de765c250 100644\n--- a/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n+++ b/hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/provider/ProviderConstants.java\n\n@@ -80,11 +80,11 @@ public class ProviderConstants {\n \tpublic static final String MDM_QUERY_LINKS = \"$mdm-query-links\";\n \tpublic static final String MDM_QUERY_LINKS_GOLDEN_RESOURCE_ID = \"goldenResourceId\";\n \tpublic static final String MDM_QUERY_LINKS_RESOURCE_ID = \"resourceId\";\n-\tpublic static final String EMPI_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n-\tpublic static final String EMPI_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n+\tpublic static final String MDM_QUERY_LINKS_MATCH_RESULT = \"matchResult\";\n+\tpublic static final String MDM_QUERY_LINKS_LINK_SOURCE = \"linkSource\";\n \n-\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$empi-duplicate-golden-resources\";\n-\tpublic static final String MDM_NOT_DUPLICATE = \"$empi-not-duplicate\";\n+\tpublic static final String MDM_DUPLICATE_GOLDEN_RESOURCES = \"$mdm-duplicate-golden-resources\";\n+\tpublic static final String MDM_NOT_DUPLICATE = \"$mdm-not-duplicate\";\n \n \tpublic static final String MDM_CLEAR = \"$mdm-clear\";\n \tpublic static final String MDM_CLEAR_TARGET_TYPE = \"targetType\";\n"}}, {"oid": "f470c343c56603f4a4ea803f4833267c51c75da8", "url": "https://github.com/hapifhir/hapi-fhir/commit/f470c343c56603f4a4ea803f4833267c51c75da8", "message": "Docs - first pass", "committedDate": "2020-11-17T22:22:06Z", "type": "commit"}, {"oid": "6d50687d4c8f11ecd8db3330a8401b47c633cc49", "url": "https://github.com/hapifhir/hapi-fhir/commit/6d50687d4c8f11ecd8db3330a8401b47c633cc49", "message": "Renamed EMPI to MDM in the docs", "committedDate": "2020-11-18T18:49:17Z", "type": "commit"}, {"oid": "1f21220e398e128256dc46aa8ece471daf7f7797", "url": "https://github.com/hapifhir/hapi-fhir/commit/1f21220e398e128256dc46aa8ece471daf7f7797", "message": "Updated MDM create use cases", "committedDate": "2020-11-18T20:57:05Z", "type": "commit"}, {"oid": "75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "url": "https://github.com/hapifhir/hapi-fhir/commit/75c0c25d7b08de83b03e5660d63f07d7053d7bb7", "message": "remove references to EMPI", "committedDate": "2020-11-19T00:50:00Z", "type": "commit"}, {"oid": "d97d4b63a0800a479fd152729b2269f84c1721ef", "url": "https://github.com/hapifhir/hapi-fhir/commit/d97d4b63a0800a479fd152729b2269f84c1721ef", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T00:53:21Z", "type": "commit"}, {"oid": "3209faf2fb2090b3590431dba77c27db8a1a4baa", "url": "https://github.com/hapifhir/hapi-fhir/commit/3209faf2fb2090b3590431dba77c27db8a1a4baa", "message": "Rename package and module", "committedDate": "2020-11-19T02:55:29Z", "type": "commit"}, {"oid": "b44ae49dd288af7bb42484bbdb3b99c6a88825ed", "url": "https://github.com/hapifhir/hapi-fhir/commit/b44ae49dd288af7bb42484bbdb3b99c6a88825ed", "message": "Removed hardcoded references to the supported MDM types", "committedDate": "2020-11-19T18:37:45Z", "type": "commit"}, {"oid": "f11f8a38ac3b54d2efa843fe0616a1a77d4b3bd4", "url": "https://github.com/hapifhir/hapi-fhir/commit/f11f8a38ac3b54d2efa843fe0616a1a77d4b3bd4", "message": "Add licenses", "committedDate": "2020-11-19T19:23:47Z", "type": "commit"}, {"oid": "3ad0fa8fda380fa004476a34cb2775f0e2bd5768", "url": "https://github.com/hapifhir/hapi-fhir/commit/3ad0fa8fda380fa004476a34cb2775f0e2bd5768", "message": "Merge branch 'gg_20201105-remove-person-references' of github.com:jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:23:50Z", "type": "commit"}, {"oid": "b62ebe7bd5c9026e117cbef1ab454c1345d9e2d1", "url": "https://github.com/hapifhir/hapi-fhir/commit/b62ebe7bd5c9026e117cbef1ab454c1345d9e2d1", "message": "Merge remote-tracking branch 'origin/master' into 2161-refactor-empi", "committedDate": "2020-11-19T19:24:26Z", "type": "commit"}, {"oid": "953b662827439bd8de93a718687e034226066ffa", "url": "https://github.com/hapifhir/hapi-fhir/commit/953b662827439bd8de93a718687e034226066ffa", "message": "Merge branch '2161-refactor-empi' into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:24:51Z", "type": "commit"}, {"oid": "4378df7dcb00762269628f995f065204dd7d5e03", "url": "https://github.com/hapifhir/hapi-fhir/commit/4378df7dcb00762269628f995f065204dd7d5e03", "message": "Removed more EMPI refs from the docs", "committedDate": "2020-11-19T19:56:18Z", "type": "commit"}, {"oid": "4bbe4a3ef733f036fa7136628f193d4bebe7dab5", "url": "https://github.com/hapifhir/hapi-fhir/commit/4bbe4a3ef733f036fa7136628f193d4bebe7dab5", "message": "Merge branch 'gg_20201105-remove-person-references' of https://github.com/jamesagnew/hapi-fhir into gg_20201105-remove-person-references", "committedDate": "2020-11-19T19:56:31Z", "type": "commit"}, {"oid": "5f97428d38b0aec2a5bc5927e5907726f9d4f93e", "url": "https://github.com/hapifhir/hapi-fhir/commit/5f97428d38b0aec2a5bc5927e5907726f9d4f93e", "message": "Added schema migration steps for MDM", "committedDate": "2020-11-24T20:50:56Z", "type": "commit"}, {"oid": "03643a7b3cf394c9627a7ec8046db514f1794997", "url": "https://github.com/hapifhir/hapi-fhir/commit/03643a7b3cf394c9627a7ec8046db514f1794997", "message": "Fix for bean scope inconsistenices", "committedDate": "2020-11-25T22:37:37Z", "type": "commit"}, {"oid": "8a7dc4e80b9c22532519fff921daeeba99e69949", "url": "https://github.com/hapifhir/hapi-fhir/commit/8a7dc4e80b9c22532519fff921daeeba99e69949", "message": "EMPI to MDM", "committedDate": "2020-11-27T20:12:21Z", "type": "commit"}, {"oid": "36ce84335a175ab2106d380ad6c154e2720f7dbf", "url": "https://github.com/hapifhir/hapi-fhir/commit/36ce84335a175ab2106d380ad6c154e2720f7dbf", "message": "Renamed sourceResource to goldenResource", "committedDate": "2020-11-27T21:53:21Z", "type": "commit"}, {"oid": "dc2a9e55c550f1764d6538f90797acd2eb0d99b5", "url": "https://github.com/hapifhir/hapi-fhir/commit/dc2a9e55c550f1764d6538f90797acd2eb0d99b5", "message": "Renamed sourceResource to goldenResource", "committedDate": "2020-11-27T21:53:47Z", "type": "commit"}, {"oid": "2a3b72db17a3a2ad3a03df89be42272a62c5e971", "url": "https://github.com/hapifhir/hapi-fhir/commit/2a3b72db17a3a2ad3a03df89be42272a62c5e971", "message": "Merge remote-tracking branch 'origin/master' into gg_20201105-remove-person-references", "committedDate": "2020-11-27T21:54:04Z", "type": "commit"}]}