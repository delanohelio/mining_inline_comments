{"pr_number": 2262, "pr_title": "Fix order by clause in search query for MySQL, MSSQL and MariaDB", "pr_createdAt": "2020-12-24T20:18:37Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/2262", "timeline": [{"oid": "63e0c90023a81594db7ec9f24918c9d9a8c0cd05", "url": "https://github.com/hapifhir/hapi-fhir/commit/63e0c90023a81594db7ec9f24918c9d9a8c0cd05", "message": "Change order by clause in search query to support MySQL, MSSQL and MariaDB.", "committedDate": "2020-12-24T18:54:37Z", "type": "commit"}, {"oid": "eb59da3f0353c86388feab04fe94909f08023557", "url": "https://github.com/hapifhir/hapi-fhir/commit/eb59da3f0353c86388feab04fe94909f08023557", "message": "Added changelog.", "committedDate": "2020-12-24T20:23:50Z", "type": "commit"}, {"oid": "8a2dfe86fd66df04d79186275f1ef0884d52f21b", "url": "https://github.com/hapifhir/hapi-fhir/commit/8a2dfe86fd66df04d79186275f1ef0884d52f21b", "message": "Merge remote-tracking branch 'origin/master' into 2260-fix-sorting-for-mysql", "committedDate": "2021-01-04T14:00:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5MTkyNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551391927", "bodyText": "It's probably better to avoid the version specific dialects..\nI think you can get away with just checking whether the dialect is instanceof MySQLDialect (which covers all versions of MySQL as well as MariaDB) or SQLServerDialect (which covers all versions of SQL Server).", "author": "jamesagnew", "createdAt": "2021-01-04T15:39:18Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -115,6 +119,16 @@ private SearchQueryBuilder(FhirContext theFhirContext, ModelConfig theModelConfi\n \t\tmySqlBuilderFactory = theSqlBuilderFactory;\n \t\tmyCountQuery = theCountQuery;\n \t\tmyDialect = theDialect;\n+\t\tif (myDialect instanceof org.hibernate.dialect.MySQL57Dialect){", "originalCommit": "8a2dfe86fd66df04d79186275f1ef0884d52f21b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0MDEyNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551640125", "bodyText": "Good point. Implemented suggested changes.", "author": "IanMMarshall", "createdAt": "2021-01-05T00:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5MTkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "bac47dbbf6b31a9d32db0f5371a7a5a294c77d78", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\nindex c49da7706c..a7214933e2 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\n\n@@ -119,13 +118,10 @@ public class SearchQueryBuilder {\n \t\tmySqlBuilderFactory = theSqlBuilderFactory;\n \t\tmyCountQuery = theCountQuery;\n \t\tmyDialect = theDialect;\n-\t\tif (myDialect instanceof org.hibernate.dialect.MySQL57Dialect){\n+\t\tif (myDialect instanceof org.hibernate.dialect.MySQLDialect){\n \t\t\tdialectIsMySql = true;\n \t\t}\n-\t\tif (myDialect instanceof org.hibernate.dialect.MariaDB53Dialect){\n-\t\t\tdialectIsMariaDb = true;\n-\t\t}\n-\t\tif (myDialect instanceof org.hibernate.dialect.SQLServer2012Dialect){\n+\t\tif (myDialect instanceof org.hibernate.dialect.SQLServerDialect){\n \t\t\tdialectIsMsSql = true;\n \t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5NzMxMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551397313", "bodyText": "I'm worried about the performance implications of adding this coalesce here when operating over large datasets... I think my recommendation would be to just add the sort without any null ordering on DBs that don't support it.\nFYI it looks like hibernate has an interesting alternate approach for accomplishing the same thing: https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/dialect/MySQLDialect.java#L467 -- But I suspect the most performance sensitive thing is to just not use null ordering.", "author": "jamesagnew", "createdAt": "2021-01-04T15:48:01Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -550,12 +564,87 @@ public boolean haveAtLeastOnePredicate() {\n \t\treturn myHaveAtLeastOnePredicate;\n \t}\n \n-\tpublic void addSort(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\tpublic void addSortString(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortString(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortNumeric(DbColumn theColumnValueNormalized, boolean theAscending) {\n \t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n-\t\taddSort(theColumnValueNormalized, theAscending, nullOrder);\n+\t\taddSortNumeric(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortDate(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortDate(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortString(DbColumn theTheColumnValueNormalized, boolean theTheAscending, OrderObject.NullOrder theNullOrder) {\n+\t\tif ((dialectIsMariaDb || dialectIsMySql || dialectIsMsSql)) {\n+\t\t\t// MariaDB, MySQL and MSSQL do not support \"NULLS FIRST\" and \"NULLS LAST\" syntax.\n+\t\t\t// Null values are always treated as less than non-null values.\n+\t\t\t// As such special handling is required here.\n+\t\t\tString direction = theTheAscending ? \" ASC\" : \" DESC\";\n+\t\t\tString sortColumnName = theTheColumnValueNormalized.getTable().getAlias() + \".\" + theTheColumnValueNormalized.getName();\n+\t\t\tif ((theTheAscending && theNullOrder == OrderObject.NullOrder.LAST)", "originalCommit": "8a2dfe86fd66df04d79186275f1ef0884d52f21b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0MTc0Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551641743", "bodyText": "Once again, good point. I took a look at the link you provided above and coded and tested a similar approach (i.e. embedding a case statement into the order by clause) and confirmed that this could also work. However per your concerns about performance, I have opted to comment out the special order by clause for now (keeping the tested code in place in case for future reference if needed).\nThe modified code will sort without any null ordering for MariaDB, MSSQL and MySQL.", "author": "IanMMarshall", "createdAt": "2021-01-05T00:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5NzMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "bac47dbbf6b31a9d32db0f5371a7a5a294c77d78", "chunk": "diff --git a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\nindex c49da7706c..a7214933e2 100644\n--- a/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\n+++ b/hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java\n\n@@ -580,29 +576,31 @@ public class SearchQueryBuilder {\n \t}\n \n \tpublic void addSortString(DbColumn theTheColumnValueNormalized, boolean theTheAscending, OrderObject.NullOrder theNullOrder) {\n-\t\tif ((dialectIsMariaDb || dialectIsMySql || dialectIsMsSql)) {\n+\t\tif ((dialectIsMySql || dialectIsMsSql)) {\n \t\t\t// MariaDB, MySQL and MSSQL do not support \"NULLS FIRST\" and \"NULLS LAST\" syntax.\n-\t\t\t// Null values are always treated as less than non-null values.\n-\t\t\t// As such special handling is required here.\n \t\t\tString direction = theTheAscending ? \" ASC\" : \" DESC\";\n \t\t\tString sortColumnName = theTheColumnValueNormalized.getTable().getAlias() + \".\" + theTheColumnValueNormalized.getName();\n+\t\t\tfinal StringBuilder sortColumnNameBuilder = new StringBuilder();\n+\t\t\t// The following block has been commented out for performance.\n+\t\t\t// Uncomment if NullOrder is needed for MariaDB, MySQL or MSSQL\n+\t\t\t/*\n+\t\t\t// Null values are always treated as less than non-null values.\n \t\t\tif ((theTheAscending && theNullOrder == OrderObject.NullOrder.LAST)\n \t\t\t\t|| (!theTheAscending && theNullOrder == OrderObject.NullOrder.FIRST)) {\n-\t\t\t\t// Coalescing the value with a String consisting of 200 'z' characters will ensure that the rows appear\n-\t\t\t\t// in the correct order with nulls being treated as the highest String values.\n-\t\t\t\tchar[] chars = new char[200];\n-\t\t\t\tArrays.fill(chars, 'z');\n-\t\t\t\tString lastString = new String(chars);\n-\t\t\t\tsortColumnName = \"COALESCE(\" + sortColumnName + \", '\" + lastString + \"')\";\n+\t\t\t\t// In this case, precede the \"order by\" column with a case statement that returns\n+\t\t\t\t// 1 for null and 0 non-null so that nulls will be sorted as greater than non-nulls.\n+\t\t\t\tsortColumnNameBuilder.append( \"CASE WHEN \" ).append( sortColumnName ).append( \" IS NULL THEN 1 ELSE 0 END\" ).append(direction).append(\", \");\n \t\t\t}\n-\t\t\tmySelect.addCustomOrderings(sortColumnName + direction);\n+\t\t   */\n+\t\t\tsortColumnNameBuilder.append(sortColumnName).append(direction);\n+\t\t\tmySelect.addCustomOrderings(sortColumnNameBuilder.toString());\n \t\t} else {\n \t\t\taddSort(theTheColumnValueNormalized, theTheAscending, theNullOrder);\n \t\t}\n \t}\n \n \tpublic void addSortNumeric(DbColumn theTheColumnValueNormalized, boolean theTheAscending, OrderObject.NullOrder theNullOrder) {\n-\t\tif ((dialectIsMariaDb || dialectIsMySql || dialectIsMsSql)) {\n+\t\tif ((dialectIsMySql || dialectIsMsSql)) {\n \t\t\t// MariaDB, MySQL and MSSQL do not support \"NULLS FIRST\" and \"NULLS LAST\" syntax.\n \t\t\t// Null values are always treated as less than non-null values.\n \t\t\t// As such special handling is required here.\n"}}, {"oid": "bac47dbbf6b31a9d32db0f5371a7a5a294c77d78", "url": "https://github.com/hapifhir/hapi-fhir/commit/bac47dbbf6b31a9d32db0f5371a7a5a294c77d78", "message": "Changes per code review plus test fixes.", "committedDate": "2021-01-05T00:06:39Z", "type": "commit"}, {"oid": "1f0ea21cdedf3ee17d995016e8c43633ee9d71c6", "url": "https://github.com/hapifhir/hapi-fhir/commit/1f0ea21cdedf3ee17d995016e8c43633ee9d71c6", "message": "Changes per code review plus test fixes.", "committedDate": "2021-01-05T00:09:04Z", "type": "commit"}]}