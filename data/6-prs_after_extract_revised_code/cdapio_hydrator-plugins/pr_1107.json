{"pr_number": 1107, "pr_title": "CDAP-16895 use new aggregator api", "pr_createdAt": "2020-06-07T10:45:37Z", "pr_url": "https://github.com/cdapio/hydrator-plugins/pull/1107", "timeline": [{"oid": "59c990c12caa7cfa72a9b3e641b8d5a3ffafe239", "url": "https://github.com/cdapio/hydrator-plugins/commit/59c990c12caa7cfa72a9b3e641b8d5a3ffafe239", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-07T10:46:03Z", "type": "forcePushed"}, {"oid": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "url": "https://github.com/cdapio/hydrator-plugins/commit/f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-07T10:50:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNTA1OQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436905059", "bodyText": "if the input schema is null, moving this check down will cause the validation to be skipped.", "author": "albertshau", "createdAt": "2020-06-08T18:22:06Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/DedupAggregator.java", "diffHunk": "@@ -87,6 +84,13 @@ public void configurePipeline(PipelineConfigurer pipelineConfigurer) {\n     Schema outputSchema = getOutputSchema(inputSchema);\n     FailureCollector collector = stageConfigurer.getFailureCollector();\n     validateSchema(outputSchema, uniqueFields, functionInfo, collector);\n+\n+    if (functionInfo != null) {", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDYyMw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437080623", "bodyText": "If input schema is null, then this check cannot be performed, since the function will require a field schema to start with, passing a null to it just doesn't make sense.", "author": "yaojiefeng", "createdAt": "2020-06-09T01:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNTA1OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwODIyNQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436908225", "bodyText": "I'm confused about what is being put in this Table. Whatever object this is needs to be Serializable right? Does this work properly?", "author": "albertshau", "createdAt": "2020-06-08T18:27:52Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java", "diffHunk": "@@ -174,26 +179,50 @@ public void groupBy(StructuredRecord record, Emitter<StructuredRecord> emitter)\n   }\n \n   @Override\n-  public void aggregate(StructuredRecord groupKey, Iterator<StructuredRecord> iterator,\n-                        Emitter<StructuredRecord> emitter) throws Exception {\n-    if (!iterator.hasNext()) {\n-      return;\n+  public Table<String, String, Object> initializeAggregateValue(StructuredRecord record) {\n+    Table<String, String, Object> table = HashBasedTable.create();\n+    table.put(SCHEMA, \"\", record.getSchema());", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjk2Nw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436916967", "bodyText": "after reading some more, it seems like a proper object here would be better, would make it more clear what is happening instead of using special keys.", "author": "albertshau", "createdAt": "2020-06-08T18:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwODIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java\nindex ca2e77a3..59b8e5b0 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/GroupByAggregator.java\n\n@@ -179,50 +175,35 @@ public class GroupByAggregator extends RecordReducibleAggregator<Table<String, S\n   }\n \n   @Override\n-  public Table<String, String, Object> initializeAggregateValue(StructuredRecord record) {\n-    Table<String, String, Object> table = HashBasedTable.create();\n-    table.put(SCHEMA, \"\", record.getSchema());\n-    // this is needed since if the schema is macro enabled, we cannot have the input schema in initialize\n-    if (aggregateFunctions == null) {\n-      initAggregates(record.getSchema());\n-    }\n-    updateAggregates(table, record);\n-    return table;\n+  public AggregateResult initializeAggregateValue(StructuredRecord record) {\n+    Map<String, AggregateFunction> functions = initAggregates(record.getSchema());\n+    updateAggregates(functions, record);\n+    return new AggregateResult(record.getSchema(), functions);\n   }\n \n   @Override\n-  public Table<String, String, Object> mergeValues(Table<String, String, Object> agg, StructuredRecord record) {\n-    // this is needed since if the schema is macro enabled, we cannot have the input schema in initialize\n-    if (aggregateFunctions == null) {\n-      initAggregates(record.getSchema());\n-    }\n-    updateAggregates(agg, record);\n+  public AggregateResult mergeValues(AggregateResult agg, StructuredRecord record) {\n+    updateAggregates(agg.getFunctions(), record);\n     return agg;\n   }\n \n   @Override\n-  public Table<String, String, Object> mergePartitions(Table<String, String, Object> agg1,\n-                                                       Table<String, String, Object> agg2) {\n-    // this is needed since if the schema is macro enabled, we cannot have the input schema in initialize\n-    if (aggregateFunctions == null) {\n-      initAggregates((Schema) agg1.get(SCHEMA, \"\"));\n-    }\n-    mergeAggregates(agg1, agg2);\n+  public AggregateResult mergePartitions(AggregateResult agg1, AggregateResult agg2) {\n+    mergeAggregates(agg1.getFunctions(), agg2.getFunctions());\n     return agg1;\n   }\n \n   @Override\n-  public void finalize(StructuredRecord groupKey, Table<String, String, Object> aggValue,\n+  public void finalize(StructuredRecord groupKey, AggregateResult aggValue,\n                        Emitter<StructuredRecord> emitter) {\n-    Schema schema = (Schema) aggValue.get(SCHEMA, \"\");\n-    initAggregates(schema);\n+    initAggregates(aggValue.getInputSchema());\n     StructuredRecord.Builder builder = StructuredRecord.builder(outputSchema);\n     for (String groupByField : groupByFields) {\n       builder.set(groupByField, groupKey.get(groupByField));\n     }\n \n-    for (Map.Entry<String, AggregateFunction> aggregateFunction : aggregateFunctions.entrySet()) {\n-      builder.set(aggregateFunction.getKey(), aggregateFunction.getValue().getAggregate(aggValue));\n+    for (Map.Entry<String, AggregateFunction> aggregateFunction : aggValue.getFunctions().entrySet()) {\n+      builder.set(aggregateFunction.getKey(), aggregateFunction.getValue().getAggregate());\n     }\n     emitter.emit(builder.build());\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwOTI5OQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436909299", "bodyText": "I'm confused about what is in this Table.", "author": "albertshau", "createdAt": "2020-06-08T18:29:58Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java", "diffHunk": "@@ -16,27 +16,46 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * Performs an aggregation. For each group that needs an aggregate to be calculated, the {@link #beginFunction()}\n- * method is called first. After that, one or more calls to {@link #operateOn(StructuredRecord)} are made, one call for\n- * each value in the group. Finally, {@link #getAggregate()} is called to retrieve the aggregate.\n- *\n- * todo: convert this to a plugin\n+ * Performs an aggregation.\n  *\n  * @param <T> type of aggregate value\n  */\n-public interface AggregateFunction<T> extends RecordFunctionLifecycle {\n+public interface AggregateFunction<T> {\n+\n+  /**\n+   * Merge the given record to the aggregated collection. This function is guaranteed to get called at least once\n+   * before {@link #mergeAggregates(Table, Table)} is called.\n+   *\n+   * @param agg the aggregated collection, the merged result should be added to it\n+   * @param record the record to merge\n+   */\n+  void mergeValue(Table<String, String, Object> agg, StructuredRecord record);", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNzM5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436927390", "bodyText": "After reading some more it seems like it's used to carry intermediate data? Using Table as the intermediate data makes things harder to understand and maintain because it's not clear what is in the Table.\nIt seems like it would be better for each individual function to be able to decide what reduced data it needs to keep track of, using an actual object instead of a Table or a Map with special keys.", "author": "albertshau", "createdAt": "2020-06-08T19:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwOTI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java\nindex b1fd2e57..92a4f4ec 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/AggregateFunction.java\n\n@@ -16,46 +16,48 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n-import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n+import java.io.Serializable;\n import javax.annotation.Nullable;\n \n /**\n  * Performs an aggregation.\n  *\n  * @param <T> type of aggregate value\n+ * @param <V> type of aggregate function\n  */\n-public interface AggregateFunction<T> {\n+public interface AggregateFunction<T, V extends AggregateFunction> extends Serializable {\n \n   /**\n-   * Merge the given record to the aggregated collection. This function is guaranteed to get called at least once\n-   * before {@link #mergeAggregates(Table, Table)} is called.\n+   * Initialize the function. This function is guaranteed to be called before any other method is called.\n+   */\n+  void initialize();\n+\n+  /**\n+   * Merge the given record to the aggregated collection. This function is guaranteed to get called once\n    *\n-   * @param agg the aggregated collection, the merged result should be added to it\n    * @param record the record to merge\n    */\n-  void mergeValue(Table<String, String, Object> agg, StructuredRecord record);\n+  void mergeValue(StructuredRecord record);\n \n   /**\n    * Merge the given two aggregates into one aggregate, the result is stored in first aggregate.\n    *\n-   * @param agg1 the first aggregation, the merged result will be in it\n-   * @param agg2 the second aggregation\n+   * @param otherAgg other aggregation function to merge\n    */\n-  void mergeAggregates(Table<String, String, Object> agg1, Table<String, String, Object> agg2);\n+  void mergeAggregates(V otherAgg);\n \n   /**\n    * Get the aggregated result from the given aggregated records. This method is guaranteed to be called\n-   * after all the {@link #mergeValue(Table, StructuredRecord)} and {@link #mergeAggregates(Table, Table)} calls\n+   * after all the {@link #mergeValue(StructuredRecord)} and {@link #mergeAggregates(AggregateFunction)} calls\n    * are done.\n    *\n-   * @param agg the aggregation to get result\n    * @return the aggregate value\n    */\n   @Nullable\n-  T getAggregate(Table<String, String, Object> agg);\n+  T getAggregate();\n \n   /**\n    * @return the schema of the aggregate value returned by this function.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkyNjMxMA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436926310", "bodyText": "ok so it looks like Table is used to prevent conflicts between fields in the group key and intermediate data?\nIt seems like it would be better to have a separate class that contains the group key as a field along with any additional fields that are required.", "author": "albertshau", "createdAt": "2020-06-08T19:00:48Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java", "diffHunk": "@@ -38,32 +43,45 @@ public Avg(String fieldName, Schema fieldSchema) {\n         \"Cannot compute avg on field %s because its type %s is not numeric\", fieldName, fieldType));\n     }\n \n+    // the avg is null only if the field value is always null\n     outputSchema = isNullable ? Schema.nullableOf(Schema.of(Schema.Type.DOUBLE)) : Schema.of(Schema.Type.DOUBLE);\n   }\n \n   @Override\n-  public void beginFunction() {\n-    avg = 0d;\n-    count = 0d;\n+  public void mergeValue(Table<String, String, Object> agg, StructuredRecord record) {\n+    Object val = record.get(fieldName);\n+    if (val == null) {\n+      return;\n+    }\n+    computeAvg(agg, 1L, (Number) val);\n   }\n \n   @Override\n-  public void operateOn(StructuredRecord record) {\n-    Object val = record.get(fieldName);\n+  public void mergeAggregates(Table<String, String, Object> agg1, Table<String, String, Object> agg2) {\n+    Object val = agg2.get(fieldName, AGG_KEY);\n     if (val == null) {\n       return;\n     }\n-    count++;\n-    avg = avg + (((Number) val).doubleValue() - avg) / count;\n+    Long agg2Count = (Long) agg2.get(fieldName, AGG_COUNT_KEY);\n+    computeAvg(agg1, agg2Count, (Number) val);\n   }\n \n-  @Override\n-  public Double getAggregate() {\n-    if (count == 0) {\n-      // only happens if the field value was always null\n-      return null;\n+  private void computeAvg(Table<String, String, Object> table, long deltaCount, Number oldAvg) {\n+    if (!table.contains(fieldName, AGG_KEY)) {", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java\nindex 615dabf1..424c7a42 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Avg.java\n\n@@ -48,44 +43,44 @@ public class Avg implements AggregateFunction<Double> {\n   }\n \n   @Override\n-  public void mergeValue(Table<String, String, Object> agg, StructuredRecord record) {\n-    Object val = record.get(fieldName);\n-    if (val == null) {\n-      return;\n-    }\n-    computeAvg(agg, 1L, (Number) val);\n+  public void initialize() {\n+    this.avg = 0d;\n+    this.count = 0L;\n   }\n \n   @Override\n-  public void mergeAggregates(Table<String, String, Object> agg1, Table<String, String, Object> agg2) {\n-    Object val = agg2.get(fieldName, AGG_KEY);\n+  public void mergeValue(StructuredRecord record) {\n+    Object val = record.get(fieldName);\n     if (val == null) {\n       return;\n     }\n-    Long agg2Count = (Long) agg2.get(fieldName, AGG_COUNT_KEY);\n-    computeAvg(agg1, agg2Count, (Number) val);\n+    computeAvg(1L, (Number) val);\n   }\n \n-  private void computeAvg(Table<String, String, Object> table, long deltaCount, Number oldAvg) {\n-    if (!table.contains(fieldName, AGG_KEY)) {\n-      table.put(fieldName, AGG_KEY, 0d);\n-      table.put(fieldName, AGG_COUNT_KEY, 0L);\n-    }\n-\n-    long count = (Long) table.get(fieldName, AGG_COUNT_KEY) + deltaCount;\n-    double avg = (Double) table.get(fieldName, AGG_KEY);\n-    avg = avg + (oldAvg.doubleValue() - avg) * deltaCount / count;\n-    table.put(fieldName, AGG_KEY, avg);\n-    table.put(fieldName, AGG_COUNT_KEY, count);\n+  @Override\n+  public void mergeAggregates(Avg otherAgg) {\n+    computeAvg(otherAgg.count, otherAgg.avg);\n   }\n \n   @Override\n-  public Double getAggregate(Table<String, String, Object> agg) {\n-    return (Double) agg.get(fieldName, AGG_KEY);\n+  public Double getAggregate() {\n+    // this only happens when every value is null\n+    if (count == 0) {\n+      return null;\n+    }\n+    return avg;\n   }\n \n   @Override\n   public Schema getOutputSchema() {\n     return outputSchema;\n   }\n+\n+  private void computeAvg(long deltaCount, Number oldAvg) {\n+    if (deltaCount == 0L) {\n+      return;\n+    }\n+    count += deltaCount;\n+    avg = avg + (oldAvg.doubleValue() - avg) * deltaCount / count;\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNjg4NA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436936884", "bodyText": "typo", "author": "albertshau", "createdAt": "2020-06-08T19:11:51Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java", "diffHunk": "@@ -16,51 +16,50 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Calculates the Standard Deviation\n  */\n public class Stddev implements AggregateFunction<Double> {\n-  private final String fieldName;\n-  private final Schema outputSchema;\n-  private RunningStats stats;\n+  private final AggregateFunction<Double> variance;\n \n   public Stddev(String fieldName, Schema fieldSchema) {\n-    this.fieldName = fieldName;\n-    boolean isNullable = fieldSchema.isNullable();\n-    Schema.Type fieldType = isNullable ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n+    Schema.Type fieldType = fieldSchema.isNullable() ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n     if (!AggregationUtils.isNumericType(fieldType)) {\n       throw new IllegalArgumentException(String.format(\n-        \"Cannot compute standard deviation on field %s because its type %s is not numeric\", fieldName, fieldType));\n+        \"Cannot compute standard devisation on field %s because its type %s is not numeric\", fieldName, fieldType));", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java\nindex 6066c888..3707a0b4 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Stddev.java\n\n@@ -16,7 +16,6 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n-import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436944226", "bodyText": "I thought the difference between population and sample variance is just the denominator, where one divides by n, and the other by n+1? If you're keeping track of the squared mean and count, it seems like it should be straightforward division?", "author": "albertshau", "createdAt": "2020-06-08T19:18:33Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java", "diffHunk": "@@ -16,17 +16,28 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * Calculates Variance\n+ * Calculates Sample Variance\n+ * TODO: CDAP-16911 figure out a way to compute population variance", "originalCommit": "f03c0eb709c1361a85312b6ff12be0fb8cfadeb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk5MzkyMA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r436993920", "bodyText": "Variance doesn't work in this way. The squared mean only makes sense for its own group since the mean and count are accumulated across the data.\nIf you consider following code:\n    count++;\n    double delta = value.doubleValue() - mean;\n    mean += delta / count;  // here the count only makes sense for individual group\n    double delta2 = value.doubleValue() - mean;\n    squareMean += delta * delta2;\n\nFor entire group, we cannot simply add up square mean as the new square mean because the actual square mean should be computed using the actual mean and count across the entire data.", "author": "yaojiefeng", "createdAt": "2020-06-08T20:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0NjMzMQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437046331", "bodyText": "Isn't the population variance just the sample variance * (N-1)/N, where N is the count?", "author": "albertshau", "createdAt": "2020-06-08T22:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1NTQ5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437055490", "bodyText": "Ah, you are right, I thought it is complicated than this, will fix.", "author": "yaojiefeng", "createdAt": "2020-06-08T23:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NDIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java\nindex 35c383af..152cb10b 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Variance.java\n\n@@ -16,7 +16,6 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n-import com.google.common.collect.Table;\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n import io.cdap.plugin.batch.aggregator.AggregationUtils;\n"}}, {"oid": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "url": "https://github.com/cdapio/hydrator-plugins/commit/6e44efc1e5dd1615a0a78138c20a75dff840d542", "message": "get rid of table", "committedDate": "2020-06-09T17:28:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODI1Mw==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437638253", "bodyText": "I think these were originally done so that we don't do an extra comparison on type for every record. I don't think it actually matters much from a performance perspective, don't imagine this was a bottleneck in any way. Are we just changing it for readability?", "author": "albertshau", "createdAt": "2020-06-09T18:35:55Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/Min.java", "diffHunk": "@@ -16,80 +16,54 @@\n \n package io.cdap.plugin.batch.aggregator.function;\n \n+import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import javax.annotation.Nullable;\n-\n /**\n  * Calculates minimum values of a field in a group.\n  */\n-public class Min extends NumberFunction {\n-  private Integer minInt;\n-  private Long minLong;\n-  private Float minFloat;\n-  private Double minDouble;\n+public class Min extends NumberFunction<Min> {\n \n-  public Min(String fieldName, @Nullable Schema fieldSchema) {\n+  public Min(String fieldName, Schema fieldSchema) {\n     super(fieldName, fieldSchema);\n   }\n \n   @Override\n-  protected void startInt() {\n-    minInt = null;\n-  }\n-\n-  @Override\n-  protected void startLong() {\n-    minLong = null;\n+  public void mergeValue(StructuredRecord record) {\n+    combine(record.get(fieldName));\n   }\n \n   @Override\n-  protected void startFloat() {\n-    minFloat = null;\n+  public void mergeAggregates(Min otherAgg) {\n+    combine(otherAgg.getAggregate());\n   }\n \n-  @Override\n-  protected void startDouble() {\n-    minDouble = null;\n-  }\n-\n-  @Override\n-  protected void updateInt(int val) {", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0MjQ3NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437642475", "bodyText": "Yes, the original class is really hard to understand and it creates delegates to make sure the correct function is called. Since this is just a simple comparison, I want to remove it for better readability.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODI1Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODg5NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437638895", "bodyText": "there used to be null handling before, how come it is being removed? Was that actually never supported?", "author": "albertshau", "createdAt": "2020-06-09T18:37:11Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java", "diffHunk": "@@ -19,172 +19,57 @@\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n /**\n  * Base class for number based selection functions.\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n- * if {@link #operateOn(StructuredRecord)} is called, only {@link #operateOnInt(int, StructuredRecord)} will be called.\n+ * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n+ * only {@link #combineInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n-  private final SelectionFunction delegate;\n   private final String fieldName;\n+  private final Schema.Type fieldType;\n \n-  public NumberSelection(final String fieldName, @Nullable Schema fieldSchema) {\n+  public NumberSelection(String fieldName, Schema fieldSchema) {\n     this.fieldName = fieldName;\n-    // if schema is not known before we start getting records, just use doubles.", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0Mzc2NQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437643765", "bodyText": "By default it uses double to handle null, but a null schema scenario actually doesn't exist. If a field does not exist, the validation should fail. If a field does exist, then it has to have a field schema. Previously this was mainly used to validate and unit test that a null schema can fetch the result, so I removed this.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzODg5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\nindex 26e192d2..f1c3376d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\n\n@@ -24,7 +24,7 @@ import io.cdap.cdap.api.data.schema.Schema;\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n  * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n- * only {@link #combineInt(int, int)} will be called.\n+ * only {@link #compareInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n   private final String fieldName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzOTQ1MQ==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437639451", "bodyText": "these methods should be called 'compare' instead of 'combine', and they should all return an int.", "author": "albertshau", "createdAt": "2020-06-09T18:38:12Z", "path": "core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java", "diffHunk": "@@ -19,172 +19,57 @@\n import io.cdap.cdap.api.data.format.StructuredRecord;\n import io.cdap.cdap.api.data.schema.Schema;\n \n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n /**\n  * Base class for number based selection functions.\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n- * if {@link #operateOn(StructuredRecord)} is called, only {@link #operateOnInt(int, StructuredRecord)} will be called.\n+ * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n+ * only {@link #combineInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n-  private final SelectionFunction delegate;\n   private final String fieldName;\n+  private final Schema.Type fieldType;\n \n-  public NumberSelection(final String fieldName, @Nullable Schema fieldSchema) {\n+  public NumberSelection(String fieldName, Schema fieldSchema) {\n     this.fieldName = fieldName;\n-    // if schema is not known before we start getting records, just use doubles.\n-    if (fieldSchema == null) {\n-      delegate = new SelectionFunction() {\n-        @Override\n-        public List<StructuredRecord> getSelectedRecords() {\n-          return getRecords();\n-        }\n+    this.fieldType = fieldSchema.isNullable() ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n+  }\n \n-        @Override\n-        public void beginFunction() {\n-          startDouble();\n-        }\n+  protected abstract int combineInt(int val1, int val2);\n \n-        @Override\n-        public void operateOn(StructuredRecord record) {\n-          Number number = record.get(fieldName);\n-          if (number != null) {\n-            operateOnDouble(number.doubleValue(), record);\n-          }\n-        }\n-      };\n-      return;\n-    }\n+  protected abstract long combineLong(long val1, long val2);\n \n-    final boolean isNullable = fieldSchema.isNullable();\n-    Schema.Type fieldType = isNullable ? fieldSchema.getNonNullable().getType() : fieldSchema.getType();\n-    switch (fieldType) {\n-      case INT:\n-        delegate = new SelectionFunction() {\n-          @Override\n-          public List<StructuredRecord> getSelectedRecords() {\n-            return getRecords();\n-          }\n+  protected abstract float combineFloat(float val1, float val2);", "originalCommit": "6e44efc1e5dd1615a0a78138c20a75dff840d542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0NTg5MA==", "url": "https://github.com/cdapio/hydrator-plugins/pull/1107#discussion_r437645890", "bodyText": "good catch, the implementation is based on compare, I forgot to change this.", "author": "yaojiefeng", "createdAt": "2020-06-09T18:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYzOTQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "chunk": "diff --git a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\nindex 26e192d2..f1c3376d 100644\n--- a/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\n+++ b/core-plugins/src/main/java/io/cdap/plugin/batch/aggregator/function/NumberSelection.java\n\n@@ -24,7 +24,7 @@ import io.cdap.cdap.api.data.schema.Schema;\n  * Allows subclasses to implement typed methods instead of implementing their own casting logic.\n  * Guarantees that only methods for one type will be called for each aggregate. For example,\n  * if {@link #select(StructuredRecord, StructuredRecord)} is called,\n- * only {@link #combineInt(int, int)} will be called.\n+ * only {@link #compareInt(int, int)} will be called.\n  */\n public abstract class NumberSelection implements SelectionFunction {\n   private final String fieldName;\n"}}, {"oid": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "url": "https://github.com/cdapio/hydrator-plugins/commit/bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-09T18:56:00Z", "type": "commit"}, {"oid": "bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "url": "https://github.com/cdapio/hydrator-plugins/commit/bc9ba6d6edad7efd7822f3dd55e68b962b44ced4", "message": "CDAP-16895 use new aggregator api", "committedDate": "2020-06-09T18:56:00Z", "type": "forcePushed"}]}