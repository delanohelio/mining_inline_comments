{"pr_number": 13858, "pr_title": "Encryption: fix asyncness - remove blocking calls ", "pr_createdAt": "2020-08-07T05:04:06Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/13858", "timeline": [{"oid": "5052c7d4188e8ce026b31fec8bf38474248a1312", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5052c7d4188e8ce026b31fec8bf38474248a1312", "message": "more tests", "committedDate": "2020-08-03T20:40:33Z", "type": "commit"}, {"oid": "e7898ba2129a20d56de3dbc4cc5e0eaf39cdd913", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7898ba2129a20d56de3dbc4cc5e0eaf39cdd913", "message": "removed blocking calls where possible", "committedDate": "2020-08-05T21:53:08Z", "type": "commit"}, {"oid": "fa4b2dafafbc8bc99dcae50eb8de5c889372eb68", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fa4b2dafafbc8bc99dcae50eb8de5c889372eb68", "message": "minor cleanup", "committedDate": "2020-08-05T22:23:35Z", "type": "commit"}, {"oid": "57a9039f8aefc06a8beb7124e4f479f8541f1206", "url": "https://github.com/Azure/azure-sdk-for-java/commit/57a9039f8aefc06a8beb7124e4f479f8541f1206", "message": "minor cleanup", "committedDate": "2020-08-05T22:45:22Z", "type": "commit"}, {"oid": "b3d64815a362f546cb00b57e5787a340027d77b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3d64815a362f546cb00b57e5787a340027d77b3", "message": "cleanup", "committedDate": "2020-08-05T22:54:13Z", "type": "commit"}, {"oid": "65db9390cdcd05f771cebb5ec1e27500311598c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/65db9390cdcd05f771cebb5ec1e27500311598c6", "message": "encryption/decryption on the correct scheduler", "committedDate": "2020-08-07T04:58:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyMjk5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466822998", "bodyText": "return type should be updated now here and other places.", "author": "kushagraThapar", "createdAt": "2020-08-07T05:06:36Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DataEncryptionKeyProvider.java", "diffHunk": "@@ -15,10 +17,8 @@\n      * @param encryptionAlgorithm Encryption algorithm that the retrieved key will be used with.\n      * @return Data encryption key bytes.", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxMjA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r467712043", "bodyText": "thanks for catching. I will fix javadoc in the next commit.", "author": "moderakh", "createdAt": "2020-08-10T06:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyMjk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DataEncryptionKeyProvider.java b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DataEncryptionKeyProvider.java\nindex 3b40919ebaf..8e0e9e80530 100644\n--- a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DataEncryptionKeyProvider.java\n+++ b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/DataEncryptionKeyProvider.java\n\n@@ -15,7 +15,7 @@ public interface DataEncryptionKeyProvider {\n      * Retrieves the data encryption key for the given id.\n      * @param id Identifier of the data encryption key.\n      * @param encryptionAlgorithm Encryption algorithm that the retrieved key will be used with.\n-     * @return Data encryption key bytes.\n+     * @return a Mono of Data encryption key bytes.\n      */\n     Mono<DataEncryptionKey> getDataEncryptionKey(\n         String id,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyMzc2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466823768", "bodyText": "By capturing the Schedulers.elastic() in an instance variable, you are using the same Scheduler with every async API. Just a heads up on not sure how this will behave.\nAlso, Schedulers.boundedElastic() is the preferred way now for wrapping I/O calls. Please see that too.", "author": "kushagraThapar", "createdAt": "2020-08-07T05:09:50Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -33,13 +33,16 @@\n \n // TODO: for now basic functionality is in. some APIs and some logic branch is not complete yet.\n public class EncryptionCosmosAsyncContainer {\n+    private final Scheduler encryptionScheduler;\n     private final Encryptor encryptor;\n     private final CosmosResponseFactory responseFactory = new CosmosResponseFactoryCore();\n     private final CosmosAsyncContainer container;\n \n     EncryptionCosmosAsyncContainer(String id, CosmosAsyncDatabase database, Encryptor encryptor) {\n         this.container = BridgeInternal.createCosmosAsyncContainer(id, database);\n         this.encryptor = encryptor;\n+        // TODO: moderakh once EncryptionKeyWrapProvider apis are made async this should change to Schedulers.parallel()\n+        this.encryptionScheduler = Schedulers.elastic();", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxNTIyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r467715229", "bodyText": "using the variable is fine. The elastic scheduler provided by the reactor lib is a singleton instance.\nsure, I will switch to Schedulers.boundedElastic() for now (next commit). in the long run this will be replaced by Schedulers.parallel() after I fix the remaining blocking io call. (one potential blocking call is remaining).", "author": "moderakh", "createdAt": "2020-08-10T06:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyMzc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java\nindex c6ca38db10f..0b28da99c6a 100644\n--- a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java\n\n@@ -42,7 +42,7 @@ public class EncryptionCosmosAsyncContainer {\n         this.container = BridgeInternal.createCosmosAsyncContainer(id, database);\n         this.encryptor = encryptor;\n         // TODO: moderakh once EncryptionKeyWrapProvider apis are made async this should change to Schedulers.parallel()\n-        this.encryptionScheduler = Schedulers.elastic();\n+        this.encryptionScheduler = Schedulers.boundedElastic();\n     }\n \n     private Mono<CosmosItemResponse<byte[]>> createItemStream(byte[] payload,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNDA5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466824090", "bodyText": "SubsribeOn will also change the actual call - which in this case could be all the way back to azure-cosmos. Any reason why you are not using PublishOn here ?", "author": "kushagraThapar", "createdAt": "2020-08-07T05:11:04Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -242,22 +259,22 @@\n             Preconditions.checkArgument(partitionKey != null, \"partitionKey cannot be null for operations using \"\n                 + \"EncryptionContainer.\");\n \n-            byte[] payload = cosmosSerializerToStream(item);\n-            Mono<CosmosItemResponse<byte[]>> result = this.replaceItemStream(payload,\n-                itemId,\n-                partitionKey,\n-                encryptionItemRequestOptions);\n+            return Mono.defer(() -> {\n+                byte[] payload = cosmosSerializerToStream(item);\n+                Mono<CosmosItemResponse<byte[]>> result = this.replaceItemStream(payload,\n+                    itemId,\n+                    partitionKey,\n+                    encryptionItemRequestOptions);\n \n-            return result.map(rsp -> (CosmosItemResponse<T>) this.responseFactory.createItemResponse(rsp,\n-                item.getClass()));\n+                return result.map(rsp -> (CosmosItemResponse<T>) this.responseFactory.createItemResponse(rsp,\n+                    item.getClass()));\n+            }).subscribeOn(encryptionScheduler);", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxMzIyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r467713220", "bodyText": "decryption will happen when Flux/Mono emits results (after reading data from service) and so we need publishOn for decryption to ensure it runs on the desired scheduler.\nencryption will happen prior to sending data to service and we have a defer operator which in conjunction of subscribeOn will ensure the actual encryption call to happen on the desired scheduler.", "author": "moderakh", "createdAt": "2020-08-10T06:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNDA5MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNDI1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466824258", "bodyText": "return type update :)", "author": "kushagraThapar", "createdAt": "2020-08-07T05:11:49Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/Encryptor.java", "diffHunk": "@@ -17,7 +19,7 @@\n      * @param encryptionAlgorithm Identifier for the encryption algorithm.\n      * @return Cipher text.", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxMzMyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r467713321", "bodyText": "thanks for pointing that out. will fix.", "author": "moderakh", "createdAt": "2020-08-10T06:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNDI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/Encryptor.java b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/Encryptor.java\nindex cdc6a2d98fd..eea3e21d4e1 100644\n--- a/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/Encryptor.java\n+++ b/sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/Encryptor.java\n\n@@ -17,7 +17,7 @@ public interface Encryptor {\n      * @param plainText           Plain text.\n      * @param dataEncryptionKeyId Identifier of the data encryption key.\n      * @param encryptionAlgorithm Identifier for the encryption algorithm.\n-     * @return Cipher text.\n+     * @return Mono of Cipher text byte array.\n      */\n     Mono<byte[]> encryptAsync(\n         byte[] plainText,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNTEzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466825135", "bodyText": "Instead of using blocking calls, since now we are going asynchronous, please try using StepVerifier from reactor-test.\nIts actually built in for testing async APIs. We have used it in azure-spring-data-cosmos-test and also in azure-cosmos.\nPlease take a look at VeryLargeDocumentQueryTest.java and any reactive test in azure-spring-data-cosmos-test - ReactiveCosmosTemplateIT, ReactiveCourseRepositoryIT, etc.", "author": "kushagraThapar", "createdAt": "2020-08-07T05:15:25Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/implementation/encryption/EncryptionTests.java", "diffHunk": "@@ -522,6 +590,58 @@ public void createItemEncrypt_readItemDecrypt() throws Exception {\n         assertThat(readWithoutDecryption.sensitive).isNull();\n     }\n \n+    // async write, upsert, read\n+    @Test(groups = { \"encryption\" }, timeOut = TIMEOUT)\n+    public void asyncCreateItemEncrypt_readItemDecrypt() throws Exception {\n+        EncryptionItemRequestOptions requestOptions = new EncryptionItemRequestOptions();\n+        EncryptionOptions encryptionOptions = new EncryptionOptions();\n+        encryptionOptions.setPathsToEncrypt(ImmutableList.of(\"/Sensitive\"));\n+\n+        encryptionOptions.setDataEncryptionKeyId(dekId);\n+        encryptionOptions.setEncryptionAlgorithm(CosmosEncryptionAlgorithm.AEAES_256_CBC_HMAC_SHA_256_RANDOMIZED);\n+        requestOptions.setEncryptionOptions(encryptionOptions);\n+\n+        TestDoc properties = getItem(UUID.randomUUID().toString());", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA3OTM1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r468079353", "bodyText": "good suggestion. Moved to StepVerifier for test validation.", "author": "moderakh", "createdAt": "2020-08-10T17:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNTEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/implementation/encryption/EncryptionTests.java b/sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/implementation/encryption/EncryptionTests.java\nindex b663b74710e..2fd5db0149d 100644\n--- a/sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/implementation/encryption/EncryptionTests.java\n+++ b/sdk/cosmos/azure-cosmos-encryption/src/test/java/com/azure/cosmos/implementation/encryption/EncryptionTests.java\n\n@@ -608,6 +608,8 @@ public class EncryptionTests extends TestSuiteBase {\n             requestOptions)\n                      .flatMap(\n                          createResponse -> {\n+                             logger.info(\"1 on thread [{}]\",\n+                                 Thread.currentThread().getName());\n                              return encryptionContainer.upsertItem(\n                                  properties,\n                                  new PartitionKey(properties.pk),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNTgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r466825816", "bodyText": "Regarding these two changes (this and below) with using Flux.merge - did you do any performance testing?\nCan you please share the results ?\nWe should make sure this doesn't break any existing cosmos APIs. Please run the full CI for this PR.", "author": "kushagraThapar", "createdAt": "2020-08-07T05:18:05Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -460,39 +460,43 @@ public String getId() {\n         });\n     }\n \n-    private <T> Flux<FeedResponse<T>> applyTransformer(Flux<FeedResponse<Document>> queryDocuments, Function<Document, Document> transformer, Scheduler scheduler, Class<T> classType) {\n+    private <T> Flux<FeedResponse<T>> applyTransformer(Flux<FeedResponse<Document>> queryDocuments, Function<Document, Mono<Document>> transformer, Scheduler scheduler, Class<T> classType) {\n         if (transformer == null) {\n-            return queryDocuments.map(response -> prepareFeedResponse(response, classType));\n+            return queryDocuments.flatMap(response -> prepareFeedResponse(response, classType));\n         } else {\n-            return queryDocuments.publishOn(scheduler).subscribeOn(scheduler).map(response -> prepareFeedResponse(response, classType, transformer));\n+            return queryDocuments.publishOn(scheduler).subscribeOn(scheduler).flatMap(response -> prepareFeedResponse(response, classType, transformer));\n         }\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    private <T> Mono<FeedResponse<T>> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n         return prepareFeedResponse(response, classType, null);\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType, Function<Document, Document> transformer) {\n+    private <T> Mono<FeedResponse<T>> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType, Function<Document, Mono<Document>> transformer) {\n         QueryInfo queryInfo = ModelBridgeInternal.getQueryInfoFromFeedResponse(response);\n         if (queryInfo != null && queryInfo.hasSelectValue()) {\n-            List<T> transformedResults = response.getResults()\n+            List<Mono<T>> transformedResultsAsync = response.getResults()\n                                              .stream()\n                                               .map(d -> d.has(Constants.Properties.VALUE) ?\n-                                                 transform(d.get(Constants.Properties.VALUE), classType) :\n+                                                 Mono.just(transform(d.get(Constants.Properties.VALUE), classType)) :\n                                                  ModelBridgeInternal.toObjectFromJsonSerializable(d, classType, transformer))\n                                              .collect(Collectors.toList());\n \n-            return BridgeInternal.createFeedResponseWithQueryMetrics(transformedResults,\n-                                                                     response.getResponseHeaders(),\n-                                                                     ModelBridgeInternal.queryMetrics(response));\n-\n+            return Flux.merge(transformedResultsAsync).collectList().map(", "originalCommit": "65db9390cdcd05f771cebb5ec1e27500311598c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMjQzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13858#discussion_r468312433", "bodyText": "all the enrcyption code for query factored out.\nThis has 0 impact on perf now.", "author": "moderakh", "createdAt": "2020-08-11T03:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNTgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "cd7f2b42a5e8a3cfcdd775b7caf97bc85f5a0669", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex 3e3e67eb846..ce402016f7c 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -445,58 +447,62 @@ public class CosmosAsyncContainer {\n     }\n \n     <T> CosmosPagedFlux<T> queryItemsInternal(\n-        SqlQuerySpec sqlQuerySpec, CosmosQueryRequestOptions cosmosQueryRequestOptions, Class<T> classType, Function<Document, Mono<Document>> transformer, Scheduler scheduler) {\n-        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+        SqlQuerySpec sqlQuerySpec, CosmosQueryRequestOptions cosmosQueryRequestOptions, Class<T> classType, Function<Document, Document> transformer, Scheduler scheduler) {\n+        return UtilBridgeInternal.createCosmosPagedFlux(queryItemsInternalFunc(sqlQuerySpec, cosmosQueryRequestOptions, classType, transformer, scheduler));\n+    }\n+\n+    <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryItemsInternalFunc(\n+        SqlQuerySpec sqlQuerySpec, CosmosQueryRequestOptions cosmosQueryRequestOptions, Class<T> classType, Function<Document, Document> transformer,\n+        Scheduler scheduler) {\n+        Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction = (pagedFluxOptions -> {\n             String spanName = this.queryItemsSpanName;\n             pagedFluxOptions.setTracerInformation(this.getDatabase().getClient().getTracerProvider(), spanName,\n                 this.getDatabase().getClient().getServiceEndpoint(), database.getId());\n             setContinuationTokenAndMaxItemCount(pagedFluxOptions, cosmosQueryRequestOptions);\n \n             return applyTransformer(\n-             getDatabase().getDocClientWrapper()\n-                .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions), transformer, scheduler,\n+                getDatabase().getDocClientWrapper()\n+                             .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions), transformer, scheduler,\n                 classType);\n \n         });\n+\n+        return pagedFluxOptionsFluxFunction;\n     }\n \n-    private <T> Flux<FeedResponse<T>> applyTransformer(Flux<FeedResponse<Document>> queryDocuments, Function<Document, Mono<Document>> transformer, Scheduler scheduler, Class<T> classType) {\n+    private <T> Flux<FeedResponse<T>> applyTransformer(Flux<FeedResponse<Document>> queryDocuments, Function<Document, Document> transformer, Scheduler scheduler, Class<T> classType) {\n         if (transformer == null) {\n-            return queryDocuments.flatMap(response -> prepareFeedResponse(response, classType));\n+            return queryDocuments.map(response -> prepareFeedResponse(response, classType));\n         } else {\n-            return queryDocuments.publishOn(scheduler).subscribeOn(scheduler).flatMap(response -> prepareFeedResponse(response, classType, transformer));\n+            return queryDocuments.publishOn(scheduler).subscribeOn(scheduler).map(response -> prepareFeedResponse(response, classType, transformer));\n         }\n     }\n \n-    private <T> Mono<FeedResponse<T>> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n         return prepareFeedResponse(response, classType, null);\n     }\n \n-    private <T> Mono<FeedResponse<T>> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType, Function<Document, Mono<Document>> transformer) {\n+    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType, Function<Document, Document> transformer) {\n         QueryInfo queryInfo = ModelBridgeInternal.getQueryInfoFromFeedResponse(response);\n         if (queryInfo != null && queryInfo.hasSelectValue()) {\n-            List<Mono<T>> transformedResultsAsync = response.getResults()\n-                                             .stream()\n-                                              .map(d -> d.has(Constants.Properties.VALUE) ?\n-                                                 Mono.just(transform(d.get(Constants.Properties.VALUE), classType)) :\n-                                                 ModelBridgeInternal.toObjectFromJsonSerializable(d, classType, transformer))\n-                                             .collect(Collectors.toList());\n-\n-            return Flux.merge(transformedResultsAsync).collectList().map(\n-                transformedResults ->\n-                    BridgeInternal.createFeedResponseWithQueryMetrics(transformedResults,\n-                        response.getResponseHeaders(),\n-                        ModelBridgeInternal.queryMetrics(response))\n-            );\n-        }\n+            List<T> transformedResults = response.getResults()\n+                                                 .stream()\n+                                                 .map(d -> d.has(Constants.Properties.VALUE) ?\n+                                                     transform(d.get(Constants.Properties.VALUE), classType) :\n+                                                     ModelBridgeInternal.toObjectFromJsonSerializable(d, classType, transformer))\n+                                                 .collect(Collectors.toList());\n+\n+            return BridgeInternal.createFeedResponseWithQueryMetrics(transformedResults,\n+                response.getResponseHeaders(),\n+                ModelBridgeInternal.queryMetrics(response));\n \n-        return Flux.merge(response.getResults().stream().map(\n-            document -> ModelBridgeInternal.toObjectFromJsonSerializable(document, classType, transformer)).collect(Collectors.toList())).collectList().map(\n-            results ->\n-                BridgeInternal.createFeedResponseWithQueryMetrics(\n-                    results, response.getResponseHeaders(),\n-                    ModelBridgeInternal.queryMetrics(response))\n-        );\n+        }\n+        return BridgeInternal.createFeedResponseWithQueryMetrics(\n+            (response.getResults().stream().map(document -> ModelBridgeInternal.toObjectFromJsonSerializable(document,\n+                classType,\n+                transformer))\n+                     .collect(Collectors.toList())), response.getResponseHeaders(),\n+            ModelBridgeInternal.queryMetrics(response));\n     }\n \n     private <T> T transform(Object object, Class<T> classType) {\n"}}, {"oid": "180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/180d808b7bc0f1b9b7c8b7a8dc928e2f8324f66c", "message": "address code review comments", "committedDate": "2020-08-10T07:01:24Z", "type": "commit"}, {"oid": "b74c571136c6003858abf1ffaa7f646db8d71f6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b74c571136c6003858abf1ffaa7f646db8d71f6a", "message": "addressed review comments, fixed code style", "committedDate": "2020-08-10T17:55:47Z", "type": "commit"}, {"oid": "cd7f2b42a5e8a3cfcdd775b7caf97bc85f5a0669", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cd7f2b42a5e8a3cfcdd775b7caf97bc85f5a0669", "message": "factored out decryption code from container.queryITem", "committedDate": "2020-08-11T03:57:45Z", "type": "commit"}, {"oid": "15196399011a5a2eb566edae46ded5a99b5b2b23", "url": "https://github.com/Azure/azure-sdk-for-java/commit/15196399011a5a2eb566edae46ded5a99b5b2b23", "message": "cleanup", "committedDate": "2020-08-11T05:03:25Z", "type": "commit"}, {"oid": "fb3117600d9190b99da2c445cf47a2cca75e4b10", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb3117600d9190b99da2c445cf47a2cca75e4b10", "message": "cleanup", "committedDate": "2020-08-11T05:15:50Z", "type": "commit"}, {"oid": "bcd714d2835c40cba37cd473d7e7ac9d38724758", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bcd714d2835c40cba37cd473d7e7ac9d38724758", "message": "cleanup", "committedDate": "2020-08-11T05:22:14Z", "type": "commit"}]}