{"pr_number": 10734, "pr_title": "SyncClient: Bug fix - Multiple Receive on same client", "pr_createdAt": "2020-05-05T21:42:42Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10734", "timeline": [{"oid": "76726384ed21f77f7e9e73f263b0791d4b7e57d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/76726384ed21f77f7e9e73f263b0791d4b7e57d0", "message": "SyncClient: Bug fix - Multiple Receive on same client", "committedDate": "2020-05-05T21:41:35Z", "type": "commit"}, {"oid": "160171f58d90c08e15be073ef5132a8d4acfa9f7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/160171f58d90c08e15be073ef5132a8d4acfa9f7", "message": "Fixing spot bugs", "committedDate": "2020-05-05T21:57:03Z", "type": "commit"}, {"oid": "54a03f3bafa0769d3ca5c46c86987a5264fe5795", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54a03f3bafa0769d3ca5c46c86987a5264fe5795", "message": "improving the integration test", "committedDate": "2020-05-05T22:20:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzA4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467089", "bodyText": "This isn't thread safe, in the time that you check for null, someone else could have set it. Or if it is null, and then you create it, it could possibly overwrite an existing EmitterProcessor that was set in this time.", "author": "conniey", "createdAt": "2020-05-05T23:29:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {", "originalCommit": "54a03f3bafa0769d3ca5c46c86987a5264fe5795", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjUzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420486539", "bodyText": "This should insure against it messageProcessor.compareAndSet(null, newProcessor)", "author": "hemanttanwar", "createdAt": "2020-05-06T00:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a6d58eba4ef..4b52a83e9d9 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -629,12 +630,12 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n             messageProcessor.get().dispose();\n         }\n \n         Disposable activeSubscription = messageProcessorSubscription.get();\n-        if (activeSubscription != null) {\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n             activeSubscription.dispose();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzI3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467274", "bodyText": "Will it throw if you call dispose twice?", "author": "conniey", "createdAt": "2020-05-05T23:29:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {", "originalCommit": "54a03f3bafa0769d3ca5c46c86987a5264fe5795", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a6d58eba4ef..4b52a83e9d9 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -629,12 +630,12 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n             messageProcessor.get().dispose();\n         }\n \n         Disposable activeSubscription = messageProcessorSubscription.get();\n-        if (activeSubscription != null) {\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n             activeSubscription.dispose();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzM1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467352", "bodyText": "These are for side effects.", "author": "conniey", "createdAt": "2020-05-05T23:29:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +628,56 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            EmitterProcessor<ServiceBusReceivedMessageContext> processor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+\n+            if (!messageProcessor.compareAndSet(null, processor)) {\n+                processor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started ContinuesMessageSubscriber message subscriber for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)\n+            .doOnNext(messageContext -> {", "originalCommit": "54a03f3bafa0769d3ca5c46c86987a5264fe5795", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzcyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420467722", "bodyText": "doOnNext, doOnError, doOnComplete are for side effects like logging or monitoring. It shouldn't be used as part of the main chain of operations.", "author": "conniey", "createdAt": "2020-05-05T23:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NzM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a6d58eba4ef..4b52a83e9d9 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -629,12 +630,12 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n             messageProcessor.get().dispose();\n         }\n \n         Disposable activeSubscription = messageProcessorSubscription.get();\n-        if (activeSubscription != null) {\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n             activeSubscription.dispose();\n         }\n     }\n"}}, {"oid": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/58a53d31c75349677e3fb8bc2322d2e1502f624b", "message": "Review comments", "committedDate": "2020-05-06T00:34:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDcwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420490705", "bodyText": "commented code should be removed.", "author": "srnagar", "createdAt": "2020-05-06T00:51:34Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -503,7 +509,8 @@ public ServiceBusReceivedMessage peekAt(long sequenceNumber, String sessionId) {\n \n         final Flux<ServiceBusReceivedMessageContext> messages = Flux.create(emitter -> queueWork(maxMessages,\n             maxWaitTime, emitter));\n-\n+        //queueWork(maxMessages, maxWaitTime, null);\n+        //return null;", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 4b52a83e9d9..474596f0ab1 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -509,8 +509,6 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n         final Flux<ServiceBusReceivedMessageContext> messages = Flux.create(emitter -> queueWork(maxMessages,\n             maxWaitTime, emitter));\n-        //queueWork(maxMessages, maxWaitTime, null);\n-        //return null;\n         return new IterableStream<>(messages);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MTEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420491131", "bodyText": "Between isDisposed() check and dispose() the processor might have changed state. This is not an atomic operation, if that's what you were trying to achieve using the AtomicReference.", "author": "srnagar", "createdAt": "2020-05-06T00:53:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff89717fde24a5bde0e2a52628f2382763e7e02f", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 4b52a83e9d9..3e1fa90e6d3 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -657,7 +657,8 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n             EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n                 .subscribeWith(EmitterProcessor.create(false));\n-            // if some other thread have come in between, we will not reset new processor\n+\n+            // if some other thread have come in between, we will dispose new processor\n             if (!messageProcessor.compareAndSet(null, newProcessor)) {\n                 newProcessor.dispose();\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MTE5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420491194", "bodyText": "Same here, this is not an atomic operation.", "author": "srnagar", "createdAt": "2020-05-06T00:53:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff89717fde24a5bde0e2a52628f2382763e7e02f", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 4b52a83e9d9..3e1fa90e6d3 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -657,7 +657,8 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n             EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n                 .subscribeWith(EmitterProcessor.create(false));\n-            // if some other thread have come in between, we will not reset new processor\n+\n+            // if some other thread have come in between, we will dispose new processor\n             if (!messageProcessor.compareAndSet(null, newProcessor)) {\n                 newProcessor.dispose();\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MjA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420492080", "bodyText": "Missing javadoc. Do we need this class in public API surface? This should be in implementation package.", "author": "srnagar", "createdAt": "2020-05-06T00:57:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.azure.messaging.servicebus;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java\ndeleted file mode 100644\nindex 08ac4ea1e5f..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,37 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import org.reactivestreams.Subscription;\n-import reactor.core.publisher.BaseSubscriber;\n-\n-public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private Subscription subscription;\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        this.subscription = subscription;\n-        subscription.request(1);\n-    }\n-\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        System.out.println(Thread.currentThread().getName() + \" : \" + value);\n-        // Request for one more event\n-        subscription.request(1);\n-    }\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        System.out.println(\"Complete\");\n-    }\n-\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        throwable.printStackTrace();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        System.out.println(\"Cancelled\");\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MjU3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420492572", "bodyText": "Why do we need this class? This seems to be just printing some debug info to the console.", "author": "srnagar", "createdAt": "2020-05-06T00:59:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.azure.messaging.servicebus;\n+\n+import org.reactivestreams.Subscription;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private Subscription subscription;\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        this.subscription = subscription;\n+        subscription.request(1);\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n+        System.out.println(Thread.currentThread().getName() + \" : \" + value);\n+        // Request for one more event\n+        subscription.request(1);\n+    }\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        System.out.println(\"Complete\");\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        throwable.printStackTrace();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        System.out.println(\"Cancelled\");\n+    }", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMTYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420521619", "bodyText": "I should not have checked in, I was trying something else. So  removing it.", "author": "hemanttanwar", "createdAt": "2020-05-06T03:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MjU3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java\ndeleted file mode 100644\nindex 08ac4ea1e5f..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SyncMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,37 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import org.reactivestreams.Subscription;\n-import reactor.core.publisher.BaseSubscriber;\n-\n-public class SyncMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private Subscription subscription;\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        this.subscription = subscription;\n-        subscription.request(1);\n-    }\n-\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        System.out.println(Thread.currentThread().getName() + \" : \" + value);\n-        // Request for one more event\n-        subscription.request(1);\n-    }\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        System.out.println(\"Complete\");\n-    }\n-\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        throwable.printStackTrace();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        System.out.println(\"Cancelled\");\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5Njg0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420496847", "bodyText": "timeout() is not the right operator here. The maxWaitTime param specifies the maximum time to wait before receiving all messages upto maximumMessageCount. timeout() operator will reset the timer after each message is received. Also, if there is a timeout, it will throw an exception which is not what should happen. Instead, it should return all messages until the timeout occurred.", "author": "srnagar", "createdAt": "2020-05-06T01:16:37Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +629,63 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            logger.info(\"[{}]: Creating EmitterProcessor message processor for entity.\", asyncClient.getEntityPath());\n+\n+            EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+            // if some other thread have come in between, we will not reset new processor\n+            if (!messageProcessor.compareAndSet(null, newProcessor)) {\n+                newProcessor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+            logger.info(\"[{}]: Subscribing EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)", "originalCommit": "58a53d31c75349677e3fb8bc2322d2e1502f624b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff89717fde24a5bde0e2a52628f2382763e7e02f", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 4b52a83e9d9..3e1fa90e6d3 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -657,7 +657,8 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n             EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n                 .subscribeWith(EmitterProcessor.create(false));\n-            // if some other thread have come in between, we will not reset new processor\n+\n+            // if some other thread have come in between, we will dispose new processor\n             if (!messageProcessor.compareAndSet(null, newProcessor)) {\n                 newProcessor.dispose();\n             }\n"}}, {"oid": "ff89717fde24a5bde0e2a52628f2382763e7e02f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ff89717fde24a5bde0e2a52628f2382763e7e02f", "message": "Review comments", "committedDate": "2020-05-06T02:08:58Z", "type": "commit"}, {"oid": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "url": "https://github.com/Azure/azure-sdk-for-java/commit/52bb661dd924dc8f2aae5a141ab28698e8248eba", "message": "review comments", "committedDate": "2020-05-06T03:08:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMzM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r420523379", "bodyText": "What if the existing subscription is still waiting for work? You're going to cancel it?", "author": "conniey", "createdAt": "2020-05-06T03:14:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -622,20 +627,61 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n+            messageProcessor.get().dispose();\n+        }\n+\n+        Disposable activeSubscription = messageProcessorSubscription.get();\n+        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n+            activeSubscription.dispose();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n+     * message processor has not been created, will initialise it.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n+            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n+            return;\n+        }\n+\n+        if (messageProcessor.get() == null) {\n+            logger.info(\"[{}]: Creating EmitterProcessor message processor for entity.\", asyncClient.getEntityPath());\n+\n+            EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false));\n+\n+            // if some other thread have come in between, we will dispose new processor\n+            if (!messageProcessor.compareAndSet(null, newProcessor)) {\n+                newProcessor.dispose();\n+            }\n+\n+            logger.info(\"[{}]: Started EmitterProcessor message processor for entity.\",\n+                asyncClient.getEntityPath());\n+        }\n+\n+        Disposable newSubscription = messageProcessor.get()\n+            .take(maximumMessageCount)\n+            .timeout(maxWaitTime)\n+            .map(message -> {\n+                emitter.next(message);\n+                return message;\n+            })\n+            .subscribe(message -> {},\n+                error -> {\n+                    logger.error(\"Error occurred while receiving messages.\", error);\n+                    emitter.error(error);\n+                },\n+                () -> emitter.complete());\n+\n+        Disposable oldSubscription = messageProcessorSubscription.getAndSet(newSubscription);\n+        if (oldSubscription != null && !oldSubscription.isDisposed()) {", "originalCommit": "52bb661dd924dc8f2aae5a141ab28698e8248eba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "57fae633d7098624559fe8317fa68a167456e33a", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 474596f0ab1..5b8315b5900 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -628,60 +628,20 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null && !messageProcessor.get().isDisposed()) {\n-            messageProcessor.get().dispose();\n-        }\n-\n-        Disposable activeSubscription = messageProcessorSubscription.get();\n-        if (activeSubscription != null && !activeSubscription.isDisposed()) {\n-            activeSubscription.dispose();\n-        }\n+        messageProcessor.onComplete();\n     }\n \n     /**\n-     * Given an {@code emitter}, creates a {@link EmitterProcessor} to receive messages from Service Bus. If the\n-     * message processor has not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n \n-        if (messageProcessor.get() != null && messageProcessor.get().isDisposed()) {\n-            logger.error(\"[{}]: Can not receive messaged because client is closed.\", asyncClient.getEntityPath());\n-            return;\n-        }\n-\n-        if (messageProcessor.get() == null) {\n-            logger.info(\"[{}]: Creating EmitterProcessor message processor for entity.\", asyncClient.getEntityPath());\n-\n-            EmitterProcessor<ServiceBusReceivedMessageContext> newProcessor = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                .subscribeWith(EmitterProcessor.create(false));\n-\n-            // if some other thread have come in between, we will dispose new processor\n-            if (!messageProcessor.compareAndSet(null, newProcessor)) {\n-                newProcessor.dispose();\n-            }\n+        final long id = idGenerator.getAndIncrement();\n+        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter);\n+        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n \n-            logger.info(\"[{}]: Started EmitterProcessor message processor for entity.\",\n-                asyncClient.getEntityPath());\n-        }\n-\n-        Disposable newSubscription = messageProcessor.get()\n-            .take(maximumMessageCount)\n-            .timeout(maxWaitTime)\n-            .map(message -> {\n-                emitter.next(message);\n-                return message;\n-            })\n-            .subscribe(message -> {},\n-                error -> {\n-                    logger.error(\"Error occurred while receiving messages.\", error);\n-                    emitter.error(error);\n-                },\n-                () -> emitter.complete());\n-\n-        Disposable oldSubscription = messageProcessorSubscription.getAndSet(newSubscription);\n-        if (oldSubscription != null && !oldSubscription.isDisposed()) {\n-            oldSubscription.dispose();\n-        }\n+        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n+        messageProcessor.subscribe(syncSubscriber);\n     }\n }\n"}}, {"oid": "57fae633d7098624559fe8317fa68a167456e33a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/57fae633d7098624559fe8317fa68a167456e33a", "message": "review comments", "committedDate": "2020-05-06T10:47:59Z", "type": "commit"}, {"oid": "e13c33eeabba3736f78ec3e9a9f86c9c6f02ace7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e13c33eeabba3736f78ec3e9a9f86c9c6f02ace7", "message": "fixing test", "committedDate": "2020-05-06T17:36:54Z", "type": "commit"}, {"oid": "03012020658feedb94426c0aac665d26cc229d86", "url": "https://github.com/Azure/azure-sdk-for-java/commit/03012020658feedb94426c0aac665d26cc229d86", "message": "Removing unwanted logging in test", "committedDate": "2020-05-06T17:42:01Z", "type": "commit"}, {"oid": "e8a5345245f535569a0156294ef7e8cd0b3c411d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e8a5345245f535569a0156294ef7e8cd0b3c411d", "message": "moving creation of Emitter processor out of constructor", "committedDate": "2020-05-06T20:09:06Z", "type": "commit"}, {"oid": "baacc2e0078fff24323b63f0d5835fe003c79714", "url": "https://github.com/Azure/azure-sdk-for-java/commit/baacc2e0078fff24323b63f0d5835fe003c79714", "message": "merge master into branch", "committedDate": "2020-05-06T20:16:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421066623", "bodyText": "synchronized : This is because if multiple client are calling receive, we need to ensure that short lived sync subscriber is thread safe.", "author": "hemanttanwar", "createdAt": "2020-05-06T20:18:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +609,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor != null) {\n+            messageProcessor.onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {", "originalCommit": "baacc2e0078fff24323b63f0d5835fe003c79714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNjE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421106154", "bodyText": "You don't need an atomic variable then.", "author": "conniey", "createdAt": "2020-05-06T21:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMjEzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421112139", "bodyText": "You can also synchronize on a lock object rather than on an entire class to scope down how large this critical path is.", "author": "conniey", "createdAt": "2020-05-06T21:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzMzM4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421133382", "bodyText": "yes: atomic is not needed  but our Checks during build time complains about it or I had to supress the warning .", "author": "hemanttanwar", "createdAt": "2020-05-06T22:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NjYyMw=="}], "type": "inlineReview", "revised_code": {"commit": "99418e736e4bbba82faf76cb6850aa258784f6f2", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 55d12b43742..a318b91b2ac 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -610,8 +612,8 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor != null) {\n-            messageProcessor.onComplete();\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().onComplete();\n         }\n     }\n \n"}}, {"oid": "38cd751349bde6f92765c3051aa2e6756e78b6a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/38cd751349bde6f92765c3051aa2e6756e78b6a4", "message": "fix test", "committedDate": "2020-05-06T20:20:57Z", "type": "commit"}, {"oid": "99418e736e4bbba82faf76cb6850aa258784f6f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99418e736e4bbba82faf76cb6850aa258784f6f2", "message": "fix check style error", "committedDate": "2020-05-06T20:47:45Z", "type": "commit"}, {"oid": "072ea0c480d1718c7b2efdbf30c9ea12d65263c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/072ea0c480d1718c7b2efdbf30c9ea12d65263c6", "message": "Merge branch 'master' into servicebus-track2-sync-receive-multiple-times-10519", "committedDate": "2020-05-06T21:49:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzU4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421107587", "bodyText": "The operation should be cancel(), not onComplete(). onComplete and methods like that should be done through a sink.\nvar processor = messageProcessor.getAndSet(null);\nif (processor != null) {\n   processor.cancel()\n}", "author": "conniey", "createdAt": "2020-05-06T21:37:16Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {", "originalCommit": "99418e736e4bbba82faf76cb6850aa258784f6f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEzNDI1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421134256", "bodyText": "discussed on teams and decided to not change it.", "author": "hemanttanwar", "createdAt": "2020-05-06T22:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a318b91b2ac..7554d480643 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -612,27 +613,33 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n-            messageProcessor.get().onComplete();\n+        EmitterProcessor<ServiceBusReceivedMessageContext> processor = messageProcessor.getAndSet(null);\n+        if (processor != null) {\n+            processor.onComplete();\n         }\n     }\n \n     /**\n      * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-\n-        if (messageProcessor.get() ==  null) {\n-            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                .subscribeWith(EmitterProcessor.create(false)));\n+        synchronized (lock) {\n+            final long id = idGenerator.getAndIncrement();\n+            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n+\n+            final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n+                emitter);\n+            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n+            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n+\n+            if (emitterProcessor == null) {\n+                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n+                messageProcessor.set(emitterProcessor);\n+            }\n+\n+            emitterProcessor.subscribe(syncSubscriber);\n         }\n-\n-        messageProcessor.get().subscribe(syncSubscriber);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMjgxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421112810", "bodyText": "This overload fetches 256. I was hoping you'd use the overload that specifies the buffer size, so you don't accidentally consume more messages than the user wants to process. EmitterProcessor.create(prefetch, false);", "author": "conniey", "createdAt": "2020-05-06T21:49:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         final long id = idGenerator.getAndIncrement();\n         final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n             emitter);\n         final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-\n         logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+\n+        if (messageProcessor.get() ==  null) {\n+            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false)));", "originalCommit": "99418e736e4bbba82faf76cb6850aa258784f6f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a318b91b2ac..7554d480643 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -612,27 +613,33 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n-            messageProcessor.get().onComplete();\n+        EmitterProcessor<ServiceBusReceivedMessageContext> processor = messageProcessor.getAndSet(null);\n+        if (processor != null) {\n+            processor.onComplete();\n         }\n     }\n \n     /**\n      * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-\n-        if (messageProcessor.get() ==  null) {\n-            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                .subscribeWith(EmitterProcessor.create(false)));\n+        synchronized (lock) {\n+            final long id = idGenerator.getAndIncrement();\n+            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n+\n+            final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n+                emitter);\n+            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n+            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n+\n+            if (emitterProcessor == null) {\n+                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n+                messageProcessor.set(emitterProcessor);\n+            }\n+\n+            emitterProcessor.subscribe(syncSubscriber);\n         }\n-\n-        messageProcessor.get().subscribe(syncSubscriber);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMzE4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10734#discussion_r421113184", "bodyText": "The general trick is to store the value from your AtomicReference operation in a local variable so you don't keep accessing it. You had already fetched its value in line 631.", "author": "conniey", "createdAt": "2020-05-06T21:49:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -606,20 +611,28 @@ public void setSessionState(String sessionId, byte[] sessionState) {\n     @Override\n     public void close() {\n         asyncClient.close();\n+\n+        if (messageProcessor.get() != null) {\n+            messageProcessor.get().onComplete();\n+        }\n     }\n \n     /**\n-     * Given an {@code emitter}, queues that work in {@link SynchronousMessageSubscriber}. If the synchronous job has\n-     * not been created, will initialise it.\n+     * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         final long id = idGenerator.getAndIncrement();\n         final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n             emitter);\n         final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-\n         logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-        asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(syncSubscriber);\n+\n+        if (messageProcessor.get() ==  null) {\n+            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                .subscribeWith(EmitterProcessor.create(false)));\n+        }\n+\n+        messageProcessor.get().subscribe(syncSubscriber);", "originalCommit": "99418e736e4bbba82faf76cb6850aa258784f6f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex a318b91b2ac..7554d480643 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -612,27 +613,33 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     public void close() {\n         asyncClient.close();\n \n-        if (messageProcessor.get() != null) {\n-            messageProcessor.get().onComplete();\n+        EmitterProcessor<ServiceBusReceivedMessageContext> processor = messageProcessor.getAndSet(null);\n+        if (processor != null) {\n+            processor.onComplete();\n         }\n     }\n \n     /**\n      * Given an {@code emitter}, creates a {@link SynchronousMessageSubscriber} to receive messages from Service Bus.\n      */\n-    private synchronized void queueWork(int maximumMessageCount, Duration maxWaitTime,\n+    private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        final long id = idGenerator.getAndIncrement();\n-        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-            emitter);\n-        final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-        logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n-\n-        if (messageProcessor.get() ==  null) {\n-            messageProcessor.set(this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                .subscribeWith(EmitterProcessor.create(false)));\n+        synchronized (lock) {\n+            final long id = idGenerator.getAndIncrement();\n+            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n+\n+            final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n+                emitter);\n+            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n+            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n+\n+            if (emitterProcessor == null) {\n+                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n+                messageProcessor.set(emitterProcessor);\n+            }\n+\n+            emitterProcessor.subscribe(syncSubscriber);\n         }\n-\n-        messageProcessor.get().subscribe(syncSubscriber);\n     }\n }\n"}}, {"oid": "3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3eb41e2f32eb31a33a31ee63a58eb645bc2eeac0", "message": "Review comments", "committedDate": "2020-05-06T22:43:25Z", "type": "commit"}, {"oid": "66e580f24a3b22f808a5b77469b30e9952a3eb09", "url": "https://github.com/Azure/azure-sdk-for-java/commit/66e580f24a3b22f808a5b77469b30e9952a3eb09", "message": "review comments", "committedDate": "2020-05-06T23:10:01Z", "type": "commit"}, {"oid": "0796a28db883855b36820a1648cbb1a365c0a30d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0796a28db883855b36820a1648cbb1a365c0a30d", "message": "Merge branch 'master' into servicebus-track2-sync-receive-multiple-times-10519", "committedDate": "2020-05-07T21:42:35Z", "type": "commit"}, {"oid": "6e73d01c9113492b4eb36411a83147650e82128e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e73d01c9113492b4eb36411a83147650e82128e", "message": "merge master", "committedDate": "2020-05-07T21:43:50Z", "type": "commit"}]}