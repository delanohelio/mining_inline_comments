{"pr_number": 13448, "pr_title": "Adding write and query workload for ctl run", "pr_createdAt": "2020-07-23T14:49:32Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/13448", "timeline": [{"oid": "5323920a7673b104f348145eba87f8f0353e4641", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5323920a7673b104f348145eba87f8f0353e4641", "message": "adding ctl workload", "committedDate": "2020-07-22T21:51:04Z", "type": "commit"}, {"oid": "bf5d3b041f884957c8efe4a6ddc8f67a14ac3076", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf5d3b041f884957c8efe4a6ddc8f67a14ac3076", "message": "formatting and refoctoring changes", "committedDate": "2020-07-23T14:58:29Z", "type": "commit"}, {"oid": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "url": "https://github.com/Azure/azure-sdk-for-java/commit/313aa63d6ccc3a256314ff5e32c77d50963e3cff", "message": "build error", "committedDate": "2020-07-23T15:00:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MzE3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459673177", "bodyText": "shouldn't this be CTLWorkload?", "author": "moderakh", "createdAt": "2020-07-23T19:18:24Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -155,7 +162,8 @@ public Duration convert(String value) {\n         QueryTopOrderby,\n         Mixed,\n         ReadMyWrites,\n-        ReadThroughputWithMultipleClients;\n+        ReadThroughputWithMultipleClients,\n+        CtlWorkload;", "originalCommit": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMjA1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460122050", "bodyText": "yes CTL is short name Itself , but CtlWorkload is more consistent with other workload camelcase", "author": "simplynaveen20", "createdAt": "2020-07-24T15:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MzE3Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NDI0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459674247", "bodyText": "does this need to be public? can we change it to private or package level?", "author": "moderakh", "createdAt": "2020-07-23T19:20:20Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java", "diffHunk": "@@ -47,7 +46,7 @@\n \n abstract class AsyncBenchmark<T> {\n     private final MetricRegistry metricsRegistry = new MetricRegistry();\n-    private final ScheduledReporter reporter;\n+    public ScheduledReporter reporter;", "originalCommit": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMjE0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460122145", "bodyText": "reverted", "author": "simplynaveen20", "createdAt": "2020-07-24T15:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NDI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java\nindex 499698c6528..cd35411b6e1 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncBenchmark.java\n\n@@ -46,7 +46,7 @@ import java.util.concurrent.atomic.AtomicLong;\n \n abstract class AsyncBenchmark<T> {\n     private final MetricRegistry metricsRegistry = new MetricRegistry();\n-    public ScheduledReporter reporter;\n+    private ScheduledReporter reporter;\n \n     private Meter successMeter;\n     private Meter failureMeter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459675203", "bodyText": "this class is getting instantiated in a for loop in your benchmark, meaning the logger initialization will be called per for loop iteration.\nlogger should be static to avoid initialization cost per loop iteration.", "author": "moderakh", "createdAt": "2020-07-23T19:22:01Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final Logger logger;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private  AtomicLong count;\n+    Timer.Context context;\n+\n+    public BenchmarkRequestSubscriber(Meter successMeter, Meter failureMeter, Semaphore concurrencyControlSemaphore,  AtomicLong count) {\n+        this.successMeter = successMeter;\n+        this.failureMeter = failureMeter;\n+        this.concurrencyControlSemaphore = concurrencyControlSemaphore;\n+        this.count = count;\n+        logger = LoggerFactory.getLogger(this.getClass());", "originalCommit": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMjIxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460122210", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-24T15:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\nindex 362514b5dcf..e4cdfdf74b8 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n\n@@ -14,19 +14,18 @@ import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicLong;\n \n public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n-    final Logger logger;\n+    final static Logger logger = LoggerFactory.getLogger(BenchmarkRequestSubscriber.class);\n     private Meter successMeter;\n     private Meter failureMeter;\n     private Semaphore concurrencyControlSemaphore;\n-    private  AtomicLong count;\n-    Timer.Context context;\n+    private AtomicLong count;\n+    public Timer.Context context;\n \n     public BenchmarkRequestSubscriber(Meter successMeter, Meter failureMeter, Semaphore concurrencyControlSemaphore,  AtomicLong count) {\n         this.successMeter = successMeter;\n         this.failureMeter = failureMeter;\n         this.concurrencyControlSemaphore = concurrencyControlSemaphore;\n         this.count = count;\n-        logger = LoggerFactory.getLogger(this.getClass());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTQzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459675439", "bodyText": "nit: additional space.", "author": "moderakh", "createdAt": "2020-07-23T19:22:28Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final Logger logger;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private  AtomicLong count;", "originalCommit": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMjI0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460122243", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-24T15:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NTQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\nindex 362514b5dcf..e4cdfdf74b8 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n\n@@ -14,19 +14,18 @@ import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicLong;\n \n public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n-    final Logger logger;\n+    final static Logger logger = LoggerFactory.getLogger(BenchmarkRequestSubscriber.class);\n     private Meter successMeter;\n     private Meter failureMeter;\n     private Semaphore concurrencyControlSemaphore;\n-    private  AtomicLong count;\n-    Timer.Context context;\n+    private AtomicLong count;\n+    public Timer.Context context;\n \n     public BenchmarkRequestSubscriber(Meter successMeter, Meter failureMeter, Semaphore concurrencyControlSemaphore,  AtomicLong count) {\n         this.successMeter = successMeter;\n         this.failureMeter = failureMeter;\n         this.concurrencyControlSemaphore = concurrencyControlSemaphore;\n         this.count = count;\n-        logger = LoggerFactory.getLogger(this.getClass());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r459685339", "bodyText": "This is used only in CTL so BenchmarkRequestSubscriber -> CTLBenchmarkRequestSubscriber\nor perhaps create a sub package for CTL and put CTL related code in that package?\ncom.azure.cosmos.benchmark.ctl ? thought Naveen?", "author": "moderakh", "createdAt": "2020-07-23T19:41:44Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {", "originalCommit": "313aa63d6ccc3a256314ff5e32c77d50963e3cff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyNDI1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460124257", "bodyText": "Moved AsyncCtlWorkload to com.azure.cosmos.benchmark.ctl. BenchmarkRequestSubscriber  is not just ctl related  and can be reused in other places. Could have done the refactoring(it is non minimal) , but it would have increased the scope of this PR.  Will move all these common classes to common packages in future work.", "author": "simplynaveen20", "createdAt": "2020-07-24T15:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NTMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\nindex 362514b5dcf..e4cdfdf74b8 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java\n\n@@ -14,19 +14,18 @@ import java.util.concurrent.Semaphore;\n import java.util.concurrent.atomic.AtomicLong;\n \n public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n-    final Logger logger;\n+    final static Logger logger = LoggerFactory.getLogger(BenchmarkRequestSubscriber.class);\n     private Meter successMeter;\n     private Meter failureMeter;\n     private Semaphore concurrencyControlSemaphore;\n-    private  AtomicLong count;\n-    Timer.Context context;\n+    private AtomicLong count;\n+    public Timer.Context context;\n \n     public BenchmarkRequestSubscriber(Meter successMeter, Meter failureMeter, Semaphore concurrencyControlSemaphore,  AtomicLong count) {\n         this.successMeter = successMeter;\n         this.failureMeter = failureMeter;\n         this.concurrencyControlSemaphore = concurrencyControlSemaphore;\n         this.count = count;\n-        logger = LoggerFactory.getLogger(this.getClass());\n     }\n \n     @Override\n"}}, {"oid": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/19bb729f2076c370d9c2bce92387532e6c2c16dc", "message": "refactoring code", "committedDate": "2020-07-24T15:20:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMzgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460133804", "bodyText": "public?", "author": "moderakh", "createdAt": "2020-07-24T15:42:26Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/BenchmarkRequestSubscriber.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Timer;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class BenchmarkRequestSubscriber<T> extends BaseSubscriber<T> {\n+    final static Logger logger = LoggerFactory.getLogger(BenchmarkRequestSubscriber.class);\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Semaphore concurrencyControlSemaphore;\n+    private AtomicLong count;\n+    public Timer.Context context;", "originalCommit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3NDQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460174418", "bodyText": "now AsyncCtlWorkload moved to different package we need to access this, we could have use setter , but this is more simple  given its usecase.", "author": "simplynaveen20", "createdAt": "2020-07-24T16:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMzgwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNTUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460135521", "bodyText": "as a code style, we should try to either\n\nhave all args on the same line\nor if there are many, have one arg per line.\n\nPlease try to follow that here and in other new code.", "author": "moderakh", "createdAt": "2020-07-24T15:45:17Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);\n+        } else {\n+            int index = random.nextInt(1000);\n+            RequestOptions options = new RequestOptions();\n+            String partitionKeyValue = docsToRead.get(container.getId()).get(index).getId();\n+            options.setPartitionKey(new PartitionKey(partitionKeyValue));\n+            obs = container.readItem(docsToRead.get(container.getId()).get(index).getId(),\n+                new PartitionKey(partitionKeyValue),\n+                PojoizedJson.class)\n+                .flux();\n+        }\n+\n+        concurrencyControlSemaphore.acquire();\n+\n+        obs.subscribeOn(Schedulers.parallel()).subscribe(documentSubscriber);\n+    }\n+\n+    public void run() throws Exception {\n+        readSuccessMeter = metricsRegistry.meter(\"#Read Successful Operations\");\n+        readFailureMeter = metricsRegistry.meter(\"#Read Unsuccessful Operations\");\n+        writeSuccessMeter = metricsRegistry.meter(\"#Write Successful Operations\");\n+        writeFailureMeter = metricsRegistry.meter(\"#Write Unsuccessful Operations\");\n+        querySuccessMeter = metricsRegistry.meter(\"#Query Successful Operations\");\n+        queryFailureMeter = metricsRegistry.meter(\"#Query Unsuccessful Operations\");\n+        readLatency = metricsRegistry.timer(\"Read Latency\");\n+        writeLatency = metricsRegistry.timer(\"Write Latency\");\n+        queryLatency = metricsRegistry.timer(\"Query Latency\");\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        int writeRange = readPct + writePct;\n+        for (i = 0; BenchmarkHelper.shouldContinue(startTime, i, configuration); i++) {\n+            int index = (int) i % 100;\n+            if (index < readPct) {\n+                BenchmarkRequestSubscriber<Object> readSubscriber = new BenchmarkRequestSubscriber<>(readSuccessMeter,\n+                    readFailureMeter, concurrencyControlSemaphore, count);", "originalCommit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MzU5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460173599", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-07-24T16:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNTUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6d406884e8a50e8e8946546db08d514252fd223", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\nindex fef0e0d0812..c3ec9709f5b 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n\n@@ -43,7 +43,6 @@ import reactor.core.publisher.Flux;\n import reactor.core.scheduler.Schedulers;\n \n import java.net.InetSocketAddress;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNjQ2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460136468", "bodyText": "if the input config is not valid, shouldn't we log error and terminate?\notherwise invalid config may go unnoticed.\nI don't see you throwing any exception on invalid config.", "author": "moderakh", "createdAt": "2020-07-24T15:46:59Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);\n+        } else {\n+            int index = random.nextInt(1000);\n+            RequestOptions options = new RequestOptions();\n+            String partitionKeyValue = docsToRead.get(container.getId()).get(index).getId();\n+            options.setPartitionKey(new PartitionKey(partitionKeyValue));\n+            obs = container.readItem(docsToRead.get(container.getId()).get(index).getId(),\n+                new PartitionKey(partitionKeyValue),\n+                PojoizedJson.class)\n+                .flux();\n+        }\n+\n+        concurrencyControlSemaphore.acquire();\n+\n+        obs.subscribeOn(Schedulers.parallel()).subscribe(documentSubscriber);\n+    }\n+\n+    public void run() throws Exception {\n+        readSuccessMeter = metricsRegistry.meter(\"#Read Successful Operations\");\n+        readFailureMeter = metricsRegistry.meter(\"#Read Unsuccessful Operations\");\n+        writeSuccessMeter = metricsRegistry.meter(\"#Write Successful Operations\");\n+        writeFailureMeter = metricsRegistry.meter(\"#Write Unsuccessful Operations\");\n+        querySuccessMeter = metricsRegistry.meter(\"#Query Successful Operations\");\n+        queryFailureMeter = metricsRegistry.meter(\"#Query Unsuccessful Operations\");\n+        readLatency = metricsRegistry.timer(\"Read Latency\");\n+        writeLatency = metricsRegistry.timer(\"Write Latency\");\n+        queryLatency = metricsRegistry.timer(\"Query Latency\");\n+\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        long startTime = System.currentTimeMillis();\n+\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        int writeRange = readPct + writePct;\n+        for (i = 0; BenchmarkHelper.shouldContinue(startTime, i, configuration); i++) {\n+            int index = (int) i % 100;\n+            if (index < readPct) {\n+                BenchmarkRequestSubscriber<Object> readSubscriber = new BenchmarkRequestSubscriber<>(readSuccessMeter,\n+                    readFailureMeter, concurrencyControlSemaphore, count);\n+                readSubscriber.context = readLatency.time();\n+                performWorkload(readSubscriber, OperationType.Read, i);\n+            } else if (index < writeRange) {\n+                BenchmarkRequestSubscriber<Object> writeSubscriber = new BenchmarkRequestSubscriber<>(writeSuccessMeter,\n+                    writeFailureMeter, concurrencyControlSemaphore, count);\n+                writeSubscriber.context = writeLatency.time();\n+                performWorkload(writeSubscriber, OperationType.Create, i);\n+\n+            } else {\n+                BenchmarkRequestSubscriber<Object> querySubscriber = new BenchmarkRequestSubscriber<>(querySuccessMeter,\n+                    queryFailureMeter, concurrencyControlSemaphore, count);\n+                querySubscriber.context = queryLatency.time();\n+                performWorkload(querySubscriber, OperationType.Query, i);\n+            }\n+        }\n+\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    private void parsedReadWriteQueryPct(String readWriteQueryPct) {\n+        String[] readWriteQueryPctList = readWriteQueryPct.split(\",\");\n+        if (readWriteQueryPctList.length == 3) {\n+            try {\n+                if (Integer.valueOf(readWriteQueryPctList[0]) + Integer.valueOf(readWriteQueryPctList[1]) + Integer.valueOf(readWriteQueryPctList[2]) == 100) {\n+                    readPct = Integer.valueOf(readWriteQueryPctList[0]);\n+                    writePct = Integer.valueOf(readWriteQueryPctList[1]);\n+                    queryPct = Integer.valueOf(readWriteQueryPctList[2]);\n+                } else {\n+                    logger.warn(PERCENT_PARSING_ERROR, readPct,\n+                        writePct, queryPct);\n+                }\n+            } catch (NumberFormatException ex) {\n+                logger.warn(PERCENT_PARSING_ERROR, readPct,\n+                    writePct, queryPct);\n+            }\n+        } else {\n+            logger.warn(PERCENT_PARSING_ERROR, readPct, writePct,\n+                queryPct);\n+        }", "originalCommit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MjExOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460172118", "bodyText": "Yes i was printing warning and using default, but throwing exception would be more clear. Done", "author": "simplynaveen20", "createdAt": "2020-07-24T16:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNjQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "b6d406884e8a50e8e8946546db08d514252fd223", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\nindex fef0e0d0812..c3ec9709f5b 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n\n@@ -43,7 +43,6 @@ import reactor.core.publisher.Flux;\n import reactor.core.scheduler.Schedulers;\n \n import java.net.InetSocketAddress;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzODQxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460138413", "bodyText": "so on query, we just run an orderby by query and we expect it to not fail, but we don't validate the result.\nam I right?", "author": "moderakh", "createdAt": "2020-07-24T15:50:17Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark.ctl;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.DirectConnectionConfig;\n+import com.azure.cosmos.GatewayConnectionConfig;\n+import com.azure.cosmos.benchmark.BenchmarkHelper;\n+import com.azure.cosmos.benchmark.BenchmarkRequestSubscriber;\n+import com.azure.cosmos.benchmark.Configuration;\n+import com.azure.cosmos.benchmark.PojoizedJson;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.ThroughputProperties;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.CsvReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import com.codahale.metrics.jvm.CachedThreadStatesGaugeSet;\n+import com.codahale.metrics.jvm.GarbageCollectorMetricSet;\n+import com.codahale.metrics.jvm.MemoryUsageGaugeSet;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsyncCtlWorkload {\n+    private final String PERCENT_PARSING_ERROR = \"Unable to parse user provided readWriteQueryPct, using default {} {} {}\";\n+    private final String prefixUuidForCreate;\n+    private final String dataFieldValue;\n+    private final String partitionKey;\n+    private final MetricRegistry metricsRegistry = new MetricRegistry();\n+    private final Logger logger;\n+    private final CosmosAsyncClient cosmosClient;\n+    private final Configuration configuration;\n+    private final Map<String, List<PojoizedJson>> docsToRead = new HashMap<>();\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Random random;\n+\n+    private Timer readLatency;\n+    private Timer writeLatency;\n+    private Timer queryLatency;\n+    private ScheduledReporter reporter;\n+\n+    private Meter readSuccessMeter;\n+    private Meter readFailureMeter;\n+    private Meter writeSuccessMeter;\n+    private Meter writeFailureMeter;\n+    private Meter querySuccessMeter;\n+    private Meter queryFailureMeter;\n+\n+    private CosmosAsyncDatabase cosmosAsyncDatabase;\n+    private List<CosmosAsyncContainer> containers = new ArrayList<>();\n+    private List<String> containerToClearAfterTest = new ArrayList<>();\n+    private boolean databaseCreated;\n+    private int readPct = 90;\n+    private int writePct = 9;\n+    private int queryPct = 1;\n+\n+    public AsyncCtlWorkload(Configuration cfg) {\n+        CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder()\n+            .endpoint(cfg.getServiceEndpoint())\n+            .key(cfg.getMasterKey())\n+            .consistencyLevel(cfg.getConsistencyLevel())\n+            .contentResponseOnWriteEnabled(Boolean.parseBoolean(cfg.isContentResponseOnWriteEnabled()));\n+        if (cfg.getConnectionMode().equals(ConnectionMode.DIRECT)) {\n+            cosmosClientBuilder = cosmosClientBuilder.directMode(DirectConnectionConfig.getDefaultConfig());\n+        } else {\n+            GatewayConnectionConfig gatewayConnectionConfig = new GatewayConnectionConfig();\n+            gatewayConnectionConfig.setMaxConnectionPoolSize(cfg.getMaxConnectionPoolSize());\n+            cosmosClientBuilder = cosmosClientBuilder.gatewayMode(gatewayConnectionConfig);\n+        }\n+        cosmosClient = cosmosClientBuilder.buildAsyncClient();\n+        configuration = cfg;\n+        logger = LoggerFactory.getLogger(this.getClass());\n+\n+        createDatabaseAndContainers(configuration);\n+\n+        partitionKey = containers.get(0).read().block().getProperties().getPartitionKeyDefinition()\n+            .getPaths().iterator().next().split(\"/\")[1];\n+\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+\n+        logger.info(\"PRE-populating {} documents ....\", cfg.getNumberOfPreCreatedDocuments());\n+        dataFieldValue = RandomStringUtils.randomAlphabetic(configuration.getDocumentDataFieldSize());\n+        createPrePopulatedDocs(configuration.getNumberOfPreCreatedDocuments());\n+\n+        if (configuration.isEnableJvmStats()) {\n+            metricsRegistry.register(\"gc\", new GarbageCollectorMetricSet());\n+            metricsRegistry.register(\"threads\", new CachedThreadStatesGaugeSet(10, TimeUnit.SECONDS));\n+            metricsRegistry.register(\"memory\", new MemoryUsageGaugeSet());\n+        }\n+\n+        initializeReporter(cfg);\n+\n+        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+\n+        registry = configuration.getGraphiteMeterRegistry();\n+\n+        if (registry != null) {\n+            BridgeInternal.monitorTelemetry(registry);\n+        }\n+        prefixUuidForCreate = UUID.randomUUID().toString();\n+        random = new Random();\n+        parsedReadWriteQueryPct(configuration.getReadWriteQueryPct());\n+    }\n+\n+    public void shutdown() {\n+        if (this.databaseCreated) {\n+            cosmosAsyncDatabase.delete().block();\n+            logger.info(\"Deleted temporary database {} created for this test\", this.configuration.getDatabaseId());\n+        } else if (containerToClearAfterTest.size() > 0) {\n+            for (String id : containerToClearAfterTest) {\n+                cosmosAsyncDatabase.getContainer(id).delete().block();\n+                logger.info(\"Deleted temporary collection {} created for this test\", id);\n+            }\n+        }\n+        cosmosClient.close();\n+    }\n+\n+    private void performWorkload(BaseSubscriber<Object> documentSubscriber, OperationType type, long i) throws Exception {\n+        Flux<? extends Object> obs;\n+        CosmosAsyncContainer container = containers.get((int) i % containers.size());\n+        if (type.equals(OperationType.Create)) {\n+            PojoizedJson data = BenchmarkHelper.generateDocument(prefixUuidForCreate + i, dataFieldValue, partitionKey,\n+                configuration.getDocumentDataFieldCount());\n+            obs = container.createItem(data).flux();\n+        } else if (type.equals(OperationType.Query)) {\n+            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n+            String sqlQuery = \"Select top 100 * from c order by c._ts\";\n+            obs = container.queryItems(sqlQuery, options, PojoizedJson.class).byPage(10);", "originalCommit": "19bb729f2076c370d9c2bce92387532e6c2c16dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MzUzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13448#discussion_r460173533", "bodyText": "Yes we are not validating result , as it would put extra perf to our sdk query end to end result. We are only expecting it not to fail for a successful result.", "author": "simplynaveen20", "createdAt": "2020-07-24T16:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzODQxMw=="}], "type": "inlineReview", "revised_code": {"commit": "b6d406884e8a50e8e8946546db08d514252fd223", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\nindex fef0e0d0812..c3ec9709f5b 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/ctl/AsyncCtlWorkload.java\n\n@@ -43,7 +43,6 @@ import reactor.core.publisher.Flux;\n import reactor.core.scheduler.Schedulers;\n \n import java.net.InetSocketAddress;\n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n"}}, {"oid": "b6d406884e8a50e8e8946546db08d514252fd223", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b6d406884e8a50e8e8946546db08d514252fd223", "message": "resolving comments", "committedDate": "2020-07-24T16:46:36Z", "type": "commit"}, {"oid": "8c684816ad17c4021992bb7d815c102b0b802605", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8c684816ad17c4021992bb7d815c102b0b802605", "message": "resolving comments", "committedDate": "2020-07-24T16:50:17Z", "type": "commit"}]}