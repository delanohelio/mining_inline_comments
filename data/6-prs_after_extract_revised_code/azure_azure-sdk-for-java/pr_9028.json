{"pr_number": 9028, "pr_title": "Service Bus track 2 - schedule message and cancel schedule feature", "pr_createdAt": "2020-03-12T17:02:34Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9028", "timeline": [{"oid": "37daa62a07523eb099204e5efef08c915453a933", "url": "https://github.com/Azure/azure-sdk-for-java/commit/37daa62a07523eb099204e5efef08c915453a933", "message": "schedule and cancel schedule feature", "committedDate": "2020-03-12T16:58:56Z", "type": "commit"}, {"oid": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51d07edca12068ac9cafe1a80e58b11e0e831b3a", "message": "fixing some spotbugs and refactoring", "committedDate": "2020-03-12T19:03:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDMyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960321", "bodyText": ".map is sufficient since this is not an asynchronous operation. Also replace usage of System.out with logger", "author": "conniey", "createdAt": "2020-03-12T23:40:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -217,12 +217,17 @@ public String getEntityName() {\n      *\n      * @throws NullPointerException if {@code message} or {@code scheduledEnqueueTime} is {@code null}.\n      */\n-    public Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime) {\n+    public Mono<Long> scheduleMessage(ServiceBusMessage message, Instant scheduledEnqueueTime) {\n         Objects.requireNonNull(message, \"'message' cannot be null.\");\n         Objects.requireNonNull(scheduledEnqueueTime, \"'scheduledEnqueueTime' cannot be null.\");\n \n-        //TODO (hemanttanwar): Implement session id feature.\n-        return Mono.error(new IllegalStateException(\"Not implemented.\"));\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName))\n+            .flatMap(x -> x.schedule(message, scheduledEnqueueTime))\n+            .flatMap(scheduleSequenceNumber -> {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java\nindex f48b49e034a..b998c36b23b 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java\n\n@@ -222,12 +282,9 @@ public final class ServiceBusSenderAsyncClient implements Closeable {\n         Objects.requireNonNull(scheduledEnqueueTime, \"'scheduledEnqueueTime' cannot be null.\");\n \n         return connectionProcessor\n-            .flatMap(connection -> connection.getManagementNode(entityName))\n+            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(x -> x.schedule(message, scheduledEnqueueTime))\n-            .flatMap(scheduleSequenceNumber -> {\n-                System.out.println(getClass().getName() + \".schedule scheduleSequenceNumber = \" + scheduleSequenceNumber);\n-                return Mono.just(scheduleSequenceNumber);\n-            });\n+            .flatMap(scheduleSequenceNumber -> Mono.just(scheduleSequenceNumber));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDU0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960542", "bodyText": "Should these all go into ManagementConstants? There are two places where these strings live.", "author": "conniey", "createdAt": "2020-03-12T23:40:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -40,17 +52,38 @@\n     public static final String MANAGEMENT_RESULT_LAST_ENQUEUED_TIME_UTC = \"last_enqueued_time_utc\";\n     public static final String MANAGEMENT_RESULT_RUNTIME_INFO_RETRIEVAL_TIME_UTC = \"runtime_info_retrieval_time_utc\";\n     public static final String MANAGEMENT_RESULT_PARTITION_IS_EMPTY = \"is_partition_empty\";\n-\n     // Well-known keys for management plane service requests.\n     private static final String MANAGEMENT_ENTITY_TYPE_KEY = \"type\";\n     private static final String MANAGEMENT_OPERATION_KEY = \"operation\";\n     private static final String MANAGEMENT_SECURITY_TOKEN_KEY = \"security_token\";\n \n+    public static final String REQUEST_RESPONSE_MESSAGES = \"messages\";", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex c9967864f19..0d5316fd4ad 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -5,106 +5,111 @@ package com.azure.messaging.servicebus.implementation;\n \n import com.azure.core.amqp.exception.AmqpErrorContext;\n import com.azure.core.amqp.exception.AmqpException;\n-import com.azure.core.amqp.implementation.AmqpConstants;\n+import com.azure.core.amqp.exception.AmqpResponseCode;\n+import com.azure.core.amqp.exception.SessionErrorContext;\n+import com.azure.core.amqp.implementation.ExceptionUtil;\n import com.azure.core.amqp.implementation.MessageSerializer;\n import com.azure.core.amqp.implementation.RequestResponseChannel;\n import com.azure.core.amqp.implementation.RequestResponseUtils;\n import com.azure.core.amqp.implementation.TokenManager;\n+import com.azure.core.util.logging.ClientLogger;\n import com.azure.messaging.servicebus.ServiceBusMessage;\n import com.azure.messaging.servicebus.ServiceBusReceivedMessage;\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n import org.apache.qpid.proton.Proton;\n import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.UnsignedInteger;\n import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n import org.apache.qpid.proton.message.Message;\n-import reactor.core.Disposable;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n-import reactor.core.scheduler.Scheduler;\n \n import java.time.Duration;\n import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.UUID;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.ASSOCIATED_LINK_NAME_KEY;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.FROM_SEQUENCE_NUMBER;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.LOCK_TOKENS_KEY;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.MANAGEMENT_OPERATION_KEY;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.MESSAGE_COUNT_KEY;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.PEEK_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.RECEIVER_SETTLE_MODE;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.RECEIVE_BY_SEQUENCE_NUMBER_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.RENEW_LOCK_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.SEQUENCE_NUMBERS;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.SERVER_TIMEOUT;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.UPDATE_DISPOSITION_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.CANCEL_SCHEDULED_MESSAGE_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.SCHEDULE_MESSAGE_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.REQUEST_RESPONSE_MESSAGES;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.REQUEST_RESPONSE_MESSAGE;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.REQUEST_RESPONSE_MESSAGE_ID;\n \n /**\n- * Channel responsible for Service Bus related metadata, peek  and management plane operations.\n- * Management plane operations increasing quotas, etc.\n+ * Channel responsible for Service Bus related metadata, peek  and management plane operations. Management plane\n+ * operations increasing quotas, etc.\n  */\n-public class ManagementChannel implements  ServiceBusManagementNode {\n-    // Well-known keys from the management service responses and requests.\n-    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n-    public static final String MANAGEMENT_PARTITION_NAME_KEY = \"partition\";\n-    public static final String MANAGEMENT_RESULT_PARTITION_IDS = \"partition_ids\";\n-    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n-    public static final String MANAGEMENT_RESULT_BEGIN_SEQUENCE_NUMBER = \"begin_sequence_number\";\n-    public static final String MANAGEMENT_RESULT_LAST_ENQUEUED_SEQUENCE_NUMBER = \"last_enqueued_sequence_number\";\n-    public static final String MANAGEMENT_RESULT_LAST_ENQUEUED_OFFSET = \"last_enqueued_offset\";\n-    public static final String MANAGEMENT_RESULT_LAST_ENQUEUED_TIME_UTC = \"last_enqueued_time_utc\";\n-    public static final String MANAGEMENT_RESULT_RUNTIME_INFO_RETRIEVAL_TIME_UTC = \"runtime_info_retrieval_time_utc\";\n-    public static final String MANAGEMENT_RESULT_PARTITION_IS_EMPTY = \"is_partition_empty\";\n-    // Well-known keys for management plane service requests.\n-    private static final String MANAGEMENT_ENTITY_TYPE_KEY = \"type\";\n-    private static final String MANAGEMENT_OPERATION_KEY = \"operation\";\n-    private static final String MANAGEMENT_SECURITY_TOKEN_KEY = \"security_token\";\n-\n-    public static final String REQUEST_RESPONSE_MESSAGES = \"messages\";\n-    public static final String REQUEST_RESPONSE_MESSAGE = \"message\";\n-    public static final String REQUEST_RESPONSE_MESSAGE_ID = \"message-id\";\n-    public static final String REQUEST_RESPONSE_SEQUENCE_NUMBERS = \"sequence-numbers\";\n-    public static final String REQUEST_RESPONSE_OPERATION_NAME = \"operation\";\n-    public static final String REQUEST_RESPONSE_ASSOCIATED_LINK_NAME = \"associated-link-name\";\n-    public static final String REQUEST_RESPONSE_TIMEOUT = AmqpConstants.VENDOR + \":server-timeout\";\n-\n-\n-    // Well-known values for the service request.\n-    private static final String PEEK_OPERATION_VALUE = AmqpConstants.VENDOR + \":peek-message\";\n-    public static final String REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION = AmqpConstants.VENDOR + \":schedule-message\";\n-    public static final String REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION = AmqpConstants.VENDOR\n-        + \":cancel-scheduled-message\";\n-    private static final String MANAGEMENT_SERVICEBUS_ENTITY_TYPE = AmqpConstants.VENDOR + \":servicebus\";\n-    private static final String MANAGEMENT_SERVER_TIMEOUT = AmqpConstants.VENDOR + \":server-timeout\";\n-\n-\n-    private static final int REQUEST_RESPONSE_OK_STATUS_CODE = 200;\n-\n-\n-    private static Duration DEFAULT_REQUEST_RESPONSE_TIMEOUT = Duration.ofSeconds(60);\n-\n-    // TODO(Hemant) :This value should be read from Receive Link\n-    private static final int MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES = 512;\n-\n-\n-    private final Mono<RequestResponseChannel> channelMono;\n-    private final Scheduler scheduler;\n+public class ManagementChannel implements ServiceBusManagementNode {\n     private final MessageSerializer messageSerializer;\n+    private final TokenManager tokenManager;\n+    private final Duration operationTimeout;\n+    private final Mono<RequestResponseChannel> createRequestResponse;\n+    private final String fullyQualifiedNamespace;\n+    private final ClientLogger logger;\n+    private final String entityPath;\n+    private final AtomicLong lastPeekedSequenceNumber = new AtomicLong();\n+\n+    private volatile boolean isDisposed;\n+\n+    ManagementChannel(Mono<RequestResponseChannel> createRequestResponse, String fullyQualifiedNamespace,\n+        String entityPath, TokenManager tokenManager, MessageSerializer messageSerializer, Duration operationTimeout) {\n+        this.createRequestResponse = createRequestResponse;\n+        this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n+        this.logger = new ClientLogger(String.format(\"%s<%s>\", ManagementChannel.class, entityPath));\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.tokenManager = Objects.requireNonNull(tokenManager, \"'tokenManager' cannot be null.\");\n+        this.operationTimeout = operationTimeout;\n+    }\n \n-    /*This is to maintain cbs node and get authorization.*/\n-    private final TokenManager cbsBasedTokenManager;\n-\n-    // Maintain last peek sequence number\n-    private AtomicReference<Long>  lastPeekedSequenceNumber = new AtomicReference<>(0L);\n-    private AtomicReference<Boolean> cbsBasedTokenManagerCalled = new AtomicReference<>(false);\n-\n-\n+    @Override\n+    public Mono<Void> updateDisposition(UUID lockToken, DispositionStatus dispositionStatus, String deadLetterReason,\n+        String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        return isAuthorized(UPDATE_DISPOSITION_OPERATION).then(createRequestResponse.flatMap(channel -> {\n+            final Message message = createDispositionMessage(new UUID[] {lockToken}, dispositionStatus,\n+                null, null, null, channel.getReceiveLinkName());\n+            return channel.sendWithAck(message);\n+        }).flatMap(response -> {\n+            final int statusCode = RequestResponseUtils.getResponseStatusCode(response);\n+            final AmqpResponseCode responseCode = AmqpResponseCode.fromValue(statusCode);\n+            if (responseCode == AmqpResponseCode.OK) {\n+                return Mono.empty();\n+            } else {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"\", getErrorContext()));\n+            }\n+        }));\n+    }\n \n-    ManagementChannel(Mono<RequestResponseChannel> responseChannelMono,\n-                      MessageSerializer messageSerializer, Scheduler scheduler, TokenManager cbsBasedTokenManager\n-    ) {\n-        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n-        this.channelMono = Objects.requireNonNull(responseChannelMono, \"'responseChannelMono' cannot be null.\");\n-        this.scheduler = Objects.requireNonNull(scheduler, \"'scheduler' cannot be null.\");\n-        this.cbsBasedTokenManager = Objects.requireNonNull(cbsBasedTokenManager,\n-            \"'cbsBasedTokenManager' cannot be null.\");\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(UUID lockToken) {\n+        return renewMessageLock(new UUID[]{lockToken})\n+            .next();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDgwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960807", "bodyText": "Why .flatMapMany? You can use .map.", "author": "conniey", "createdAt": "2020-03-12T23:41:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex c9967864f19..0d5316fd4ad 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -131,182 +134,291 @@ public class ManagementChannel implements  ServiceBusManagementNode {\n      */\n     @Override\n     public Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber) {\n+        return peek(fromSequenceNumber, 1, null)\n+            .last();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages) {\n \n-        return peek(ServiceBusReceivedMessage.class, 1, fromSequenceNumber, null)\n-            .last()\n-            .publishOn(scheduler);\n+        return peek(this.lastPeekedSequenceNumber.get() + 1, maxMessages, null);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<ServiceBusReceivedMessage> peek() {\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages, long fromSequenceNumber) {\n \n-        return peek(this.lastPeekedSequenceNumber.get() + 1);\n+        return peek(fromSequenceNumber, maxMessages, null);\n     }\n \n-    private <T> Flux<T> peek(Class<T> responseType, int maxMessages, long fromSequenceNumber, UUID sessionId) {\n-        return\n-            Mono.defer(() -> {\n-                if (!cbsBasedTokenManagerCalled.get()) {\n-                    return cbsBasedTokenManager\n-                        .authorize()\n-                        .doOnNext(refreshCBSTokenTime -> {\n-                            cbsBasedTokenManagerCalled.set(true);\n-                        })\n-                        .then();\n-                } else {\n-                    return Mono.empty();\n-                }\n-            })\n-            .then(\n-                  channelMono.flatMap(requestResponseChannel -> {\n-\n-                      Map<String, Object> appProperties = new HashMap<>();\n-                      // set mandatory application properties for AMQP message.\n-                      appProperties.put(MANAGEMENT_OPERATION_KEY, PEEK_OPERATION_VALUE);\n-                      //TODO(hemanttanwar) fix timeour configuration\n-                      appProperties.put(MANAGEMENT_SERVER_TIMEOUT, \"30000\");\n-\n-                      final Message request = Proton.message();\n-                      final ApplicationProperties applicationProperties = new ApplicationProperties(appProperties);\n-                      request.setApplicationProperties(applicationProperties);\n-\n-                      // set mandatory properties on AMQP message body\n-                      HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_MESSAGE_COUNT, maxMessages);\n-\n-                      if (!Objects.isNull(sessionId)) {\n-                          requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n-                      }\n-\n-                      request.setBody(new AmqpValue(requestBodyMap));\n-\n-                      return requestResponseChannel.sendWithAck(request);\n-                  })\n-            ).flatMapMany(amqpMessage -> {\n-                @SuppressWarnings(\"unchecked\")\n-                List<T> messageListObj =  messageSerializer.deserialize(amqpMessage, List.class);\n-\n-                 // Assign the last sequence number so that we can peek from next time\n-                if (messageListObj.size() > 0) {\n-                    ServiceBusReceivedMessage receivedMessage = (ServiceBusReceivedMessage) messageListObj\n-                        .get(messageListObj.size() - 1);\n-                    if (receivedMessage.getSequenceNumber() > 0) {\n-                        this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n-                    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(ReceiveMode receiveMode, long sequenceNumber) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumber)\n+            .next();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode,\n+           long... sequenceNumbers) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumbers);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> peek() {\n+        return peek(lastPeekedSequenceNumber.get() + 1);\n+    }\n+\n+    private Flux<ServiceBusReceivedMessage> peek(long fromSequenceNumber, int maxMessages, UUID sessionId) {\n+        return isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(PEEK_OPERATION, channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            final HashMap<String, Object> requestBodyMap = new HashMap<>();\n+            requestBodyMap.put(FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n+            requestBodyMap.put(MESSAGE_COUNT_KEY, maxMessages);\n+\n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n                 }\n-                return Flux.fromIterable(messageListObj);\n-            });\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-\n-                }))\n-                .flatMapMany(responseMessage -> {\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        return Mono.empty();\n-                    }\n-                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n-                        + cancelScheduleNumbers,\n-                        new AmqpErrorContext(\"namespace name\")));\n-                })\n-            .then();\n+    private Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode, UUID sessionId,\n+            long... fromSequenceNumbers) {\n+        return isAuthorized(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            HashMap<String, Object> requestBodyMap = new HashMap<>();\n+\n+            requestBodyMap.put(SEQUENCE_NUMBERS, Arrays.stream(fromSequenceNumbers)\n+                .boxed().toArray(Long[]::new));\n+\n+            requestBodyMap.put(RECEIVER_SETTLE_MODE,\n+                UnsignedInteger.valueOf(receiveMode == ReceiveMode.RECEIVE_AND_DELETE ? 0 : 1));\n \n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n+                }\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private Mono<Void>  cbsAuthorizationOnce() {\n-        return Mono.defer(() -> {\n-            if (!cbsBasedTokenManagerCalled.get()) {\n-                return cbsBasedTokenManager\n-                    .authorize()\n-                    .doOnNext(refreshCBSTokenTime -> {\n-                        cbsBasedTokenManagerCalled.set(true);\n-                    })\n-                    .then();\n+    private Mono<Void> isAuthorized(String operation) {\n+        return tokenManager.getAuthorizationResults().next().flatMap(response -> {\n+            if (response != AmqpResponseCode.ACCEPTED) {\n+                return Mono.error(new AmqpException(false, String.format(\n+                    \"User does not have authorization to perform operation [%s] on entity [%s]\", operation, entityPath),\n+                    getErrorContext()));\n             } else {\n                 return Mono.empty();\n             }\n         });\n     }\n \n-    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n-                                 Class<T> responseType) {\n+    private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n+        String linkName) {\n \n-        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        logger.verbose(\"Update disposition of deliveries '{}' to '{}' on entity '{}', session '{}'\",\n+            Arrays.toString(lockTokens), dispositionStatus, entityPath, \"n/a\");\n+\n+        final Message message = createManagementMessage(UPDATE_DISPOSITION_OPERATION, linkName);\n+\n+        final Map<String, Object> requestBody = new HashMap<>();\n+        requestBody.put(LOCK_TOKENS_KEY, lockTokens);\n+        requestBody.put(ManagementConstants.DISPOSITION_STATUS_KEY, dispositionStatus.getValue());\n+\n+        if (deadLetterReason != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_REASON_KEY, deadLetterReason);\n+        }\n \n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    List<Message> messagesToSchedule = new ArrayList<>();\n-                    messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-                    Map<String, Object> requestBodyMap = new HashMap<>();\n-                    Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-                    for (Message message : messagesToSchedule) {\n-                        HashMap<String, Object> messageEntry = new HashMap<>();\n-                        Pair<byte[], Integer> encodedPair;\n-                        encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n-                            MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n-\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n-                            0, encodedPair.getSecondItem()));\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n-                        messageList.add(messageEntry);\n-                    }\n-                    requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-                })\n-            )\n-             .map(responseMessage -> {\n-\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-                    List<T> sequenceNumbers = null;\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        @SuppressWarnings(\"unchecked\")\n-                        Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n-                            .getBody()).getValue();\n-                        Object seqNumberListObj = responseBody.get(REQUEST_RESPONSE_SEQUENCE_NUMBERS);\n-\n-                        if (seqNumberListObj instanceof  long[]){\n-                            @SuppressWarnings(\"unchecked\")\n-                            List<T> seqNumbers  = (List<T>)Arrays.stream((long[])seqNumberListObj)\n-                                .boxed().collect(Collectors.toList());\n-                            sequenceNumbers = seqNumbers;\n-                        }\n-                    }\n-                    return sequenceNumbers;\n-                })\n-         .flatMapMany(Flux::fromIterable);\n+        if (deadLetterErrorDescription != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_DESCRIPTION_KEY, deadLetterErrorDescription);\n+        }\n+\n+        if (propertiesToModify != null && propertiesToModify.size() > 0) {\n+            requestBody.put(ManagementConstants.PROPERTIES_TO_MODIFY_KEY, propertiesToModify);\n+        }\n+\n+        message.setBody(new AmqpValue(requestBody));\n+\n+        return message;\n     }\n \n-    private Message createRequestMessageFromValueBody(String operation, Object valueBody, Duration timeout) {\n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n+                channel.getReceiveLinkName());\n \n-        Message requestMessage = Message.Factory.create();\n-        requestMessage.setBody(new AmqpValue(valueBody));\n-        HashMap<String, Object> applicationPropertiesMap = new HashMap<>();\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_OPERATION_NAME, operation);\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_TIMEOUT, timeout.toMillis());\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, renewLockList)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not renew the lock.\",\n+                    getErrorContext()));\n+            }\n \n-        requestMessage.setApplicationProperties(new ApplicationProperties(applicationPropertiesMap));\n-        return requestMessage;\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));\n+        }));\n+    }\n+\n+    /**\n+     * Creates an AMQP message with the required application properties.\n+     *\n+     * @param operation Management operation to perform (ie. peek, update-disposition, etc.)\n+     * @param linkName Name of receiver link associated with operation.\n+     *\n+     * @return An AMQP message with the required headers.\n+     */\n+    private Message createManagementMessage(String operation, String linkName) {\n+        final Duration serverTimeout = MessageUtils.adjustServerTimeout(operationTimeout);\n+        final Map<String, Object> applicationProperties = new HashMap<>();\n+        applicationProperties.put(MANAGEMENT_OPERATION_KEY, operation);\n+        applicationProperties.put(SERVER_TIMEOUT, serverTimeout.toMillis());\n+\n+        if (linkName != null && !linkName.isEmpty()) {\n+            applicationProperties.put(ASSOCIATED_LINK_NAME_KEY, linkName);\n+        }\n+\n+        final Message message = Proton.message();\n+        message.setApplicationProperties(new ApplicationProperties(applicationProperties));\n+\n+        return message;\n+    }\n+\n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+            Pair<byte[], Integer> encodedPair;\n+            encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n+                MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n+\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n+                0, encodedPair.getSecondItem()));\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n+    private AmqpErrorContext getErrorContext() {\n+        return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n+    }\n+\n+    private <T> Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                + cancelScheduleNumbers.toString(),\n+\n+                new AmqpErrorContext(fullyQualifiedNamespace)));\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not schedule message.\",\n+                    getErrorContext()));\n+            }\n+\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Long.class));\n+        }));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960901", "bodyText": "Is the responseType another class? Why the use of generics?", "author": "conniey", "createdAt": "2020-03-12T23:42:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        return Mono.empty();\n+                    }\n+                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                        + cancelScheduleNumbers,\n+                        new AmqpErrorContext(\"namespace name\")));\n+                })\n+            .then();\n+\n+    }\n+\n+    private Mono<Void>  cbsAuthorizationOnce() {\n+        return Mono.defer(() -> {\n+            if (!cbsBasedTokenManagerCalled.get()) {\n+                return cbsBasedTokenManager\n+                    .authorize()\n+                    .doOnNext(refreshCBSTokenTime -> {\n+                        cbsBasedTokenManagerCalled.set(true);\n+                    })\n+                    .then();\n+            } else {\n+                return Mono.empty();\n+            }\n+        });\n+    }\n+\n+    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n+                                 Class<T> responseType) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex c9967864f19..0d5316fd4ad 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -131,182 +134,291 @@ public class ManagementChannel implements  ServiceBusManagementNode {\n      */\n     @Override\n     public Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber) {\n+        return peek(fromSequenceNumber, 1, null)\n+            .last();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages) {\n \n-        return peek(ServiceBusReceivedMessage.class, 1, fromSequenceNumber, null)\n-            .last()\n-            .publishOn(scheduler);\n+        return peek(this.lastPeekedSequenceNumber.get() + 1, maxMessages, null);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<ServiceBusReceivedMessage> peek() {\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages, long fromSequenceNumber) {\n \n-        return peek(this.lastPeekedSequenceNumber.get() + 1);\n+        return peek(fromSequenceNumber, maxMessages, null);\n     }\n \n-    private <T> Flux<T> peek(Class<T> responseType, int maxMessages, long fromSequenceNumber, UUID sessionId) {\n-        return\n-            Mono.defer(() -> {\n-                if (!cbsBasedTokenManagerCalled.get()) {\n-                    return cbsBasedTokenManager\n-                        .authorize()\n-                        .doOnNext(refreshCBSTokenTime -> {\n-                            cbsBasedTokenManagerCalled.set(true);\n-                        })\n-                        .then();\n-                } else {\n-                    return Mono.empty();\n-                }\n-            })\n-            .then(\n-                  channelMono.flatMap(requestResponseChannel -> {\n-\n-                      Map<String, Object> appProperties = new HashMap<>();\n-                      // set mandatory application properties for AMQP message.\n-                      appProperties.put(MANAGEMENT_OPERATION_KEY, PEEK_OPERATION_VALUE);\n-                      //TODO(hemanttanwar) fix timeour configuration\n-                      appProperties.put(MANAGEMENT_SERVER_TIMEOUT, \"30000\");\n-\n-                      final Message request = Proton.message();\n-                      final ApplicationProperties applicationProperties = new ApplicationProperties(appProperties);\n-                      request.setApplicationProperties(applicationProperties);\n-\n-                      // set mandatory properties on AMQP message body\n-                      HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_MESSAGE_COUNT, maxMessages);\n-\n-                      if (!Objects.isNull(sessionId)) {\n-                          requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n-                      }\n-\n-                      request.setBody(new AmqpValue(requestBodyMap));\n-\n-                      return requestResponseChannel.sendWithAck(request);\n-                  })\n-            ).flatMapMany(amqpMessage -> {\n-                @SuppressWarnings(\"unchecked\")\n-                List<T> messageListObj =  messageSerializer.deserialize(amqpMessage, List.class);\n-\n-                 // Assign the last sequence number so that we can peek from next time\n-                if (messageListObj.size() > 0) {\n-                    ServiceBusReceivedMessage receivedMessage = (ServiceBusReceivedMessage) messageListObj\n-                        .get(messageListObj.size() - 1);\n-                    if (receivedMessage.getSequenceNumber() > 0) {\n-                        this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n-                    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(ReceiveMode receiveMode, long sequenceNumber) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumber)\n+            .next();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode,\n+           long... sequenceNumbers) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumbers);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> peek() {\n+        return peek(lastPeekedSequenceNumber.get() + 1);\n+    }\n+\n+    private Flux<ServiceBusReceivedMessage> peek(long fromSequenceNumber, int maxMessages, UUID sessionId) {\n+        return isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(PEEK_OPERATION, channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            final HashMap<String, Object> requestBodyMap = new HashMap<>();\n+            requestBodyMap.put(FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n+            requestBodyMap.put(MESSAGE_COUNT_KEY, maxMessages);\n+\n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n                 }\n-                return Flux.fromIterable(messageListObj);\n-            });\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-\n-                }))\n-                .flatMapMany(responseMessage -> {\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        return Mono.empty();\n-                    }\n-                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n-                        + cancelScheduleNumbers,\n-                        new AmqpErrorContext(\"namespace name\")));\n-                })\n-            .then();\n+    private Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode, UUID sessionId,\n+            long... fromSequenceNumbers) {\n+        return isAuthorized(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            HashMap<String, Object> requestBodyMap = new HashMap<>();\n+\n+            requestBodyMap.put(SEQUENCE_NUMBERS, Arrays.stream(fromSequenceNumbers)\n+                .boxed().toArray(Long[]::new));\n+\n+            requestBodyMap.put(RECEIVER_SETTLE_MODE,\n+                UnsignedInteger.valueOf(receiveMode == ReceiveMode.RECEIVE_AND_DELETE ? 0 : 1));\n \n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n+                }\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private Mono<Void>  cbsAuthorizationOnce() {\n-        return Mono.defer(() -> {\n-            if (!cbsBasedTokenManagerCalled.get()) {\n-                return cbsBasedTokenManager\n-                    .authorize()\n-                    .doOnNext(refreshCBSTokenTime -> {\n-                        cbsBasedTokenManagerCalled.set(true);\n-                    })\n-                    .then();\n+    private Mono<Void> isAuthorized(String operation) {\n+        return tokenManager.getAuthorizationResults().next().flatMap(response -> {\n+            if (response != AmqpResponseCode.ACCEPTED) {\n+                return Mono.error(new AmqpException(false, String.format(\n+                    \"User does not have authorization to perform operation [%s] on entity [%s]\", operation, entityPath),\n+                    getErrorContext()));\n             } else {\n                 return Mono.empty();\n             }\n         });\n     }\n \n-    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n-                                 Class<T> responseType) {\n+    private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n+        String linkName) {\n \n-        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        logger.verbose(\"Update disposition of deliveries '{}' to '{}' on entity '{}', session '{}'\",\n+            Arrays.toString(lockTokens), dispositionStatus, entityPath, \"n/a\");\n+\n+        final Message message = createManagementMessage(UPDATE_DISPOSITION_OPERATION, linkName);\n+\n+        final Map<String, Object> requestBody = new HashMap<>();\n+        requestBody.put(LOCK_TOKENS_KEY, lockTokens);\n+        requestBody.put(ManagementConstants.DISPOSITION_STATUS_KEY, dispositionStatus.getValue());\n+\n+        if (deadLetterReason != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_REASON_KEY, deadLetterReason);\n+        }\n \n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    List<Message> messagesToSchedule = new ArrayList<>();\n-                    messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-                    Map<String, Object> requestBodyMap = new HashMap<>();\n-                    Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-                    for (Message message : messagesToSchedule) {\n-                        HashMap<String, Object> messageEntry = new HashMap<>();\n-                        Pair<byte[], Integer> encodedPair;\n-                        encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n-                            MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n-\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n-                            0, encodedPair.getSecondItem()));\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n-                        messageList.add(messageEntry);\n-                    }\n-                    requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-                })\n-            )\n-             .map(responseMessage -> {\n-\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-                    List<T> sequenceNumbers = null;\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        @SuppressWarnings(\"unchecked\")\n-                        Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n-                            .getBody()).getValue();\n-                        Object seqNumberListObj = responseBody.get(REQUEST_RESPONSE_SEQUENCE_NUMBERS);\n-\n-                        if (seqNumberListObj instanceof  long[]){\n-                            @SuppressWarnings(\"unchecked\")\n-                            List<T> seqNumbers  = (List<T>)Arrays.stream((long[])seqNumberListObj)\n-                                .boxed().collect(Collectors.toList());\n-                            sequenceNumbers = seqNumbers;\n-                        }\n-                    }\n-                    return sequenceNumbers;\n-                })\n-         .flatMapMany(Flux::fromIterable);\n+        if (deadLetterErrorDescription != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_DESCRIPTION_KEY, deadLetterErrorDescription);\n+        }\n+\n+        if (propertiesToModify != null && propertiesToModify.size() > 0) {\n+            requestBody.put(ManagementConstants.PROPERTIES_TO_MODIFY_KEY, propertiesToModify);\n+        }\n+\n+        message.setBody(new AmqpValue(requestBody));\n+\n+        return message;\n     }\n \n-    private Message createRequestMessageFromValueBody(String operation, Object valueBody, Duration timeout) {\n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n+                channel.getReceiveLinkName());\n \n-        Message requestMessage = Message.Factory.create();\n-        requestMessage.setBody(new AmqpValue(valueBody));\n-        HashMap<String, Object> applicationPropertiesMap = new HashMap<>();\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_OPERATION_NAME, operation);\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_TIMEOUT, timeout.toMillis());\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, renewLockList)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not renew the lock.\",\n+                    getErrorContext()));\n+            }\n \n-        requestMessage.setApplicationProperties(new ApplicationProperties(applicationPropertiesMap));\n-        return requestMessage;\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));\n+        }));\n+    }\n+\n+    /**\n+     * Creates an AMQP message with the required application properties.\n+     *\n+     * @param operation Management operation to perform (ie. peek, update-disposition, etc.)\n+     * @param linkName Name of receiver link associated with operation.\n+     *\n+     * @return An AMQP message with the required headers.\n+     */\n+    private Message createManagementMessage(String operation, String linkName) {\n+        final Duration serverTimeout = MessageUtils.adjustServerTimeout(operationTimeout);\n+        final Map<String, Object> applicationProperties = new HashMap<>();\n+        applicationProperties.put(MANAGEMENT_OPERATION_KEY, operation);\n+        applicationProperties.put(SERVER_TIMEOUT, serverTimeout.toMillis());\n+\n+        if (linkName != null && !linkName.isEmpty()) {\n+            applicationProperties.put(ASSOCIATED_LINK_NAME_KEY, linkName);\n+        }\n+\n+        final Message message = Proton.message();\n+        message.setApplicationProperties(new ApplicationProperties(applicationProperties));\n+\n+        return message;\n+    }\n+\n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+            Pair<byte[], Integer> encodedPair;\n+            encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n+                MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n+\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n+                0, encodedPair.getSecondItem()));\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n+    private AmqpErrorContext getErrorContext() {\n+        return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n+    }\n+\n+    private <T> Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                + cancelScheduleNumbers.toString(),\n+\n+                new AmqpErrorContext(fullyQualifiedNamespace)));\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not schedule message.\",\n+                    getErrorContext()));\n+            }\n+\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Long.class));\n+        }));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTAyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961027", "bodyText": "I don't like the use of Object. I'd prefer it be a strongly typed Map or something similar.", "author": "conniey", "createdAt": "2020-03-12T23:42:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        return Mono.empty();\n+                    }\n+                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                        + cancelScheduleNumbers,\n+                        new AmqpErrorContext(\"namespace name\")));\n+                })\n+            .then();\n+\n+    }\n+\n+    private Mono<Void>  cbsAuthorizationOnce() {\n+        return Mono.defer(() -> {\n+            if (!cbsBasedTokenManagerCalled.get()) {\n+                return cbsBasedTokenManager\n+                    .authorize()\n+                    .doOnNext(refreshCBSTokenTime -> {\n+                        cbsBasedTokenManagerCalled.set(true);\n+                    })\n+                    .then();\n+            } else {\n+                return Mono.empty();\n+            }\n+        });\n+    }\n+\n+    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n+                                 Class<T> responseType) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    List<Message> messagesToSchedule = new ArrayList<>();\n+                    messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+                    Map<String, Object> requestBodyMap = new HashMap<>();\n+                    Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+                    for (Message message : messagesToSchedule) {\n+                        HashMap<String, Object> messageEntry = new HashMap<>();\n+                        Pair<byte[], Integer> encodedPair;\n+                        encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n+                            MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n+\n+                        messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n+                            0, encodedPair.getSecondItem()));\n+                        messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n+                        messageList.add(messageEntry);\n+                    }\n+                    requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+                })\n+            )\n+             .map(responseMessage -> {\n+\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+                    List<T> sequenceNumbers = null;\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n+                            .getBody()).getValue();\n+                        Object seqNumberListObj = responseBody.get(REQUEST_RESPONSE_SEQUENCE_NUMBERS);\n+\n+                        if (seqNumberListObj instanceof  long[]){\n+                            @SuppressWarnings(\"unchecked\")\n+                            List<T> seqNumbers  = (List<T>)Arrays.stream((long[])seqNumberListObj)\n+                                .boxed().collect(Collectors.toList());\n+                            sequenceNumbers = seqNumbers;\n+                        }\n+                    }\n+                    return sequenceNumbers;\n+                })\n+         .flatMapMany(Flux::fromIterable);\n+    }\n+\n+    private Message createRequestMessageFromValueBody(String operation, Object valueBody, Duration timeout) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex c9967864f19..0d5316fd4ad 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -131,182 +134,291 @@ public class ManagementChannel implements  ServiceBusManagementNode {\n      */\n     @Override\n     public Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber) {\n+        return peek(fromSequenceNumber, 1, null)\n+            .last();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages) {\n \n-        return peek(ServiceBusReceivedMessage.class, 1, fromSequenceNumber, null)\n-            .last()\n-            .publishOn(scheduler);\n+        return peek(this.lastPeekedSequenceNumber.get() + 1, maxMessages, null);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<ServiceBusReceivedMessage> peek() {\n+    public Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages, long fromSequenceNumber) {\n \n-        return peek(this.lastPeekedSequenceNumber.get() + 1);\n+        return peek(fromSequenceNumber, maxMessages, null);\n     }\n \n-    private <T> Flux<T> peek(Class<T> responseType, int maxMessages, long fromSequenceNumber, UUID sessionId) {\n-        return\n-            Mono.defer(() -> {\n-                if (!cbsBasedTokenManagerCalled.get()) {\n-                    return cbsBasedTokenManager\n-                        .authorize()\n-                        .doOnNext(refreshCBSTokenTime -> {\n-                            cbsBasedTokenManagerCalled.set(true);\n-                        })\n-                        .then();\n-                } else {\n-                    return Mono.empty();\n-                }\n-            })\n-            .then(\n-                  channelMono.flatMap(requestResponseChannel -> {\n-\n-                      Map<String, Object> appProperties = new HashMap<>();\n-                      // set mandatory application properties for AMQP message.\n-                      appProperties.put(MANAGEMENT_OPERATION_KEY, PEEK_OPERATION_VALUE);\n-                      //TODO(hemanttanwar) fix timeour configuration\n-                      appProperties.put(MANAGEMENT_SERVER_TIMEOUT, \"30000\");\n-\n-                      final Message request = Proton.message();\n-                      final ApplicationProperties applicationProperties = new ApplicationProperties(appProperties);\n-                      request.setApplicationProperties(applicationProperties);\n-\n-                      // set mandatory properties on AMQP message body\n-                      HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n-                      requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_MESSAGE_COUNT, maxMessages);\n-\n-                      if (!Objects.isNull(sessionId)) {\n-                          requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n-                      }\n-\n-                      request.setBody(new AmqpValue(requestBodyMap));\n-\n-                      return requestResponseChannel.sendWithAck(request);\n-                  })\n-            ).flatMapMany(amqpMessage -> {\n-                @SuppressWarnings(\"unchecked\")\n-                List<T> messageListObj =  messageSerializer.deserialize(amqpMessage, List.class);\n-\n-                 // Assign the last sequence number so that we can peek from next time\n-                if (messageListObj.size() > 0) {\n-                    ServiceBusReceivedMessage receivedMessage = (ServiceBusReceivedMessage) messageListObj\n-                        .get(messageListObj.size() - 1);\n-                    if (receivedMessage.getSequenceNumber() > 0) {\n-                        this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n-                    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(ReceiveMode receiveMode, long sequenceNumber) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumber)\n+            .next();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode,\n+           long... sequenceNumbers) {\n+        return receiveDeferredMessageBatch(receiveMode, null, sequenceNumbers);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<ServiceBusReceivedMessage> peek() {\n+        return peek(lastPeekedSequenceNumber.get() + 1);\n+    }\n+\n+    private Flux<ServiceBusReceivedMessage> peek(long fromSequenceNumber, int maxMessages, UUID sessionId) {\n+        return isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(PEEK_OPERATION, channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            final HashMap<String, Object> requestBodyMap = new HashMap<>();\n+            requestBodyMap.put(FROM_SEQUENCE_NUMBER, fromSequenceNumber);\n+            requestBodyMap.put(MESSAGE_COUNT_KEY, maxMessages);\n+\n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n                 }\n-                return Flux.fromIterable(messageListObj);\n-            });\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n-                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-\n-                }))\n-                .flatMapMany(responseMessage -> {\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        return Mono.empty();\n-                    }\n-                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n-                        + cancelScheduleNumbers,\n-                        new AmqpErrorContext(\"namespace name\")));\n-                })\n-            .then();\n+    private Flux<ServiceBusReceivedMessage> receiveDeferredMessageBatch(ReceiveMode receiveMode, UUID sessionId,\n+            long... fromSequenceNumbers) {\n+        return isAuthorized(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+            final Message message = createManagementMessage(RECEIVE_BY_SEQUENCE_NUMBER_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            // set mandatory properties on AMQP message body\n+            HashMap<String, Object> requestBodyMap = new HashMap<>();\n+\n+            requestBodyMap.put(SEQUENCE_NUMBERS, Arrays.stream(fromSequenceNumbers)\n+                .boxed().toArray(Long[]::new));\n+\n+            requestBodyMap.put(RECEIVER_SETTLE_MODE,\n+                UnsignedInteger.valueOf(receiveMode == ReceiveMode.RECEIVE_AND_DELETE ? 0 : 1));\n \n+            if (!Objects.isNull(sessionId)) {\n+                requestBodyMap.put(ManagementConstants.REQUEST_RESPONSE_SESSION_ID, sessionId);\n+            }\n+\n+            message.setBody(new AmqpValue(requestBodyMap));\n+\n+            return channel.sendWithAck(message);\n+        }).flatMapMany(amqpMessage -> {\n+            final List<ServiceBusReceivedMessage> messageList =\n+                messageSerializer.deserializeList(amqpMessage, ServiceBusReceivedMessage.class);\n+\n+            // Assign the last sequence number so that we can peek from next time\n+            if (messageList.size() > 0) {\n+                final ServiceBusReceivedMessage receivedMessage = messageList.get(messageList.size() - 1);\n+\n+                logger.info(\"Setting last peeked sequence number: {}\", receivedMessage.getSequenceNumber());\n+\n+                if (receivedMessage.getSequenceNumber() > 0) {\n+                    this.lastPeekedSequenceNumber.set(receivedMessage.getSequenceNumber());\n+                }\n+            }\n+\n+            return Flux.fromIterable(messageList);\n+        }));\n     }\n \n-    private Mono<Void>  cbsAuthorizationOnce() {\n-        return Mono.defer(() -> {\n-            if (!cbsBasedTokenManagerCalled.get()) {\n-                return cbsBasedTokenManager\n-                    .authorize()\n-                    .doOnNext(refreshCBSTokenTime -> {\n-                        cbsBasedTokenManagerCalled.set(true);\n-                    })\n-                    .then();\n+    private Mono<Void> isAuthorized(String operation) {\n+        return tokenManager.getAuthorizationResults().next().flatMap(response -> {\n+            if (response != AmqpResponseCode.ACCEPTED) {\n+                return Mono.error(new AmqpException(false, String.format(\n+                    \"User does not have authorization to perform operation [%s] on entity [%s]\", operation, entityPath),\n+                    getErrorContext()));\n             } else {\n                 return Mono.empty();\n             }\n         });\n     }\n \n-    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n-                                 Class<T> responseType) {\n+    private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n+        String linkName) {\n \n-        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        logger.verbose(\"Update disposition of deliveries '{}' to '{}' on entity '{}', session '{}'\",\n+            Arrays.toString(lockTokens), dispositionStatus, entityPath, \"n/a\");\n+\n+        final Message message = createManagementMessage(UPDATE_DISPOSITION_OPERATION, linkName);\n+\n+        final Map<String, Object> requestBody = new HashMap<>();\n+        requestBody.put(LOCK_TOKENS_KEY, lockTokens);\n+        requestBody.put(ManagementConstants.DISPOSITION_STATUS_KEY, dispositionStatus.getValue());\n+\n+        if (deadLetterReason != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_REASON_KEY, deadLetterReason);\n+        }\n \n-        return cbsAuthorizationOnce()\n-            .then(\n-                channelMono.flatMap(requestResponseChannel -> {\n-                    List<Message> messagesToSchedule = new ArrayList<>();\n-                    messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-                    Map<String, Object> requestBodyMap = new HashMap<>();\n-                    Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-                    for (Message message : messagesToSchedule) {\n-                        HashMap<String, Object> messageEntry = new HashMap<>();\n-                        Pair<byte[], Integer> encodedPair;\n-                        encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n-                            MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n-\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n-                            0, encodedPair.getSecondItem()));\n-                        messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n-                        messageList.add(messageEntry);\n-                    }\n-                    requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n-\n-                    Message requestMessage = createRequestMessageFromValueBody(\n-                        REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION, requestBodyMap,\n-                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n-                    return requestResponseChannel.sendWithAck(requestMessage);\n-                })\n-            )\n-             .map(responseMessage -> {\n-\n-                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n-                    List<T> sequenceNumbers = null;\n-                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n-                        @SuppressWarnings(\"unchecked\")\n-                        Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n-                            .getBody()).getValue();\n-                        Object seqNumberListObj = responseBody.get(REQUEST_RESPONSE_SEQUENCE_NUMBERS);\n-\n-                        if (seqNumberListObj instanceof  long[]){\n-                            @SuppressWarnings(\"unchecked\")\n-                            List<T> seqNumbers  = (List<T>)Arrays.stream((long[])seqNumberListObj)\n-                                .boxed().collect(Collectors.toList());\n-                            sequenceNumbers = seqNumbers;\n-                        }\n-                    }\n-                    return sequenceNumbers;\n-                })\n-         .flatMapMany(Flux::fromIterable);\n+        if (deadLetterErrorDescription != null) {\n+            requestBody.put(ManagementConstants.DEADLETTER_DESCRIPTION_KEY, deadLetterErrorDescription);\n+        }\n+\n+        if (propertiesToModify != null && propertiesToModify.size() > 0) {\n+            requestBody.put(ManagementConstants.PROPERTIES_TO_MODIFY_KEY, propertiesToModify);\n+        }\n+\n+        message.setBody(new AmqpValue(requestBody));\n+\n+        return message;\n     }\n \n-    private Message createRequestMessageFromValueBody(String operation, Object valueBody, Duration timeout) {\n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n+                channel.getReceiveLinkName());\n \n-        Message requestMessage = Message.Factory.create();\n-        requestMessage.setBody(new AmqpValue(valueBody));\n-        HashMap<String, Object> applicationPropertiesMap = new HashMap<>();\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_OPERATION_NAME, operation);\n-        applicationPropertiesMap.put(REQUEST_RESPONSE_TIMEOUT, timeout.toMillis());\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, renewLockList)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not renew the lock.\",\n+                    getErrorContext()));\n+            }\n \n-        requestMessage.setApplicationProperties(new ApplicationProperties(applicationPropertiesMap));\n-        return requestMessage;\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));\n+        }));\n+    }\n+\n+    /**\n+     * Creates an AMQP message with the required application properties.\n+     *\n+     * @param operation Management operation to perform (ie. peek, update-disposition, etc.)\n+     * @param linkName Name of receiver link associated with operation.\n+     *\n+     * @return An AMQP message with the required headers.\n+     */\n+    private Message createManagementMessage(String operation, String linkName) {\n+        final Duration serverTimeout = MessageUtils.adjustServerTimeout(operationTimeout);\n+        final Map<String, Object> applicationProperties = new HashMap<>();\n+        applicationProperties.put(MANAGEMENT_OPERATION_KEY, operation);\n+        applicationProperties.put(SERVER_TIMEOUT, serverTimeout.toMillis());\n+\n+        if (linkName != null && !linkName.isEmpty()) {\n+            applicationProperties.put(ASSOCIATED_LINK_NAME_KEY, linkName);\n+        }\n+\n+        final Message message = Proton.message();\n+        message.setApplicationProperties(new ApplicationProperties(applicationProperties));\n+\n+        return message;\n+    }\n+\n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+            Pair<byte[], Integer> encodedPair;\n+            encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n+                MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n+\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n+                0, encodedPair.getSecondItem()));\n+            messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n+    private AmqpErrorContext getErrorContext() {\n+        return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n+    }\n+\n+    private <T> Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                + cancelScheduleNumbers.toString(),\n+\n+                new AmqpErrorContext(fullyQualifiedNamespace)));\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not schedule message.\",\n+                    getErrorContext()));\n+            }\n+\n+            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Long.class));\n+        }));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961156", "bodyText": "iirc, this logic exists elsewhere.", "author": "conniey", "createdAt": "2020-03-12T23:43:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -71,4 +98,195 @@ public static UUID convertDotNetBytesToUUID(byte[] dotNetBytes) {\n         long leastSignificantBits = buffer.getLong();\n         return new UUID(mostSignificantBits, leastSignificantBits);\n     }\n+\n+\n+\n+    private static int getPayloadSize(Message msg) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391962357", "bodyText": "check the serializer class.", "author": "conniey", "createdAt": "2020-03-12T23:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java\nindex 31eacb0844f..9e490852b50 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java\n\n@@ -90,17 +114,12 @@ final class MessageUtils {\n                     indexInReorderedBytes = i;\n             }\n \n-            reOrderedBytes[indexInReorderedBytes] = dotNetBytes[i];\n+            reorderedBytes[indexInReorderedBytes] = javaBytes[i];\n         }\n \n-        ByteBuffer buffer = ByteBuffer.wrap(reOrderedBytes);\n-        long mostSignificantBits = buffer.getLong();\n-        long leastSignificantBits = buffer.getLong();\n-        return new UUID(mostSignificantBits, leastSignificantBits);\n+        return reorderedBytes;\n     }\n \n-\n-\n     private static int getPayloadSize(Message msg) {\n         if (msg == null || msg.getBody() == null) {\n             return 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961197", "bodyText": "Why a pair?", "author": "conniey", "createdAt": "2020-03-12T23:43:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Pair.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+/**", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTYzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961633", "bodyText": "In your usage of it, it feels like you can infer the size from the length of the bytes.", "author": "conniey", "createdAt": "2020-03-12T23:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f702b08e3c07df60f4835ad5cfee61f11ad6a6f9", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Pair.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Pair.java\ndeleted file mode 100644\nindex c856780558f..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Pair.java\n+++ /dev/null\n\n@@ -1,66 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.messaging.servicebus.implementation;\n-\n-/**\n- *\n- * @param <T>\n- * @param <V>\n- */\n-public class Pair<T, V> {\n-    private T t;\n-    private V v;\n-\n-    Pair(T t, V v) {\n-        this.t = t;\n-        this.v = v;\n-    }\n-\n-    public T getFirstItem() {\n-        return t;\n-    }\n-\n-    public V getSecondItem() {\n-        return v;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        final int prime = 31;\n-        int result = 1;\n-        result = prime * result + ((t == null) ? 0 : t.hashCode());\n-        result = prime * result + ((v == null) ? 0 : v.hashCode());\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Pair<Object, Object> other = (Pair<Object, Object>) obj;\n-        if (t == null) {\n-            if (other.t != null) {\n-                return false;\n-            }\n-        } else if (!t.equals(other.t)) {\n-            return false;\n-        }\n-        if (v == null) {\n-            if (other.v != null) {\n-                return false;\n-            }\n-        } else if (!v.equals(other.v)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjE4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391962184", "bodyText": "Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.", "author": "conniey", "createdAt": "2020-03-12T23:47:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -185,4 +194,31 @@ void sendSingleMessage() {\n         final Message message = singleMessageCaptor.getValue();\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n+\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned =10;\n+\n+        when(managementNode.schedule(any(ServiceBusMessage.class), any(Instant.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(mock(ServiceBusMessage.class), mock(Instant.class)))", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\nindex af66421265e..fdff07240e0 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n\n@@ -198,7 +303,7 @@ public class ServiceBusSenderAsyncClientTest {\n     @Test\n     void scheduleMessage() {\n         // Arrange\n-        long sequenceNumberReturned =10;\n+        long sequenceNumberReturned = 10;\n \n         when(managementNode.schedule(any(ServiceBusMessage.class), any(Instant.class)))\n             .thenReturn(just(sequenceNumberReturned));\n"}}, {"oid": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "url": "https://github.com/Azure/azure-sdk-for-java/commit/45ae563d18b949418c4c2e8349ff66e67c2d4998", "message": " schedule and cancelschedule message", "committedDate": "2020-03-30T00:06:36Z", "type": "commit"}, {"oid": "00d2a0c7af4b0fac2cdd31a54f85be04c17e9527", "url": "https://github.com/Azure/azure-sdk-for-java/commit/00d2a0c7af4b0fac2cdd31a54f85be04c17e9527", "message": "ongoing changes", "committedDate": "2020-03-30T16:54:38Z", "type": "commit"}, {"oid": "f702b08e3c07df60f4835ad5cfee61f11ad6a6f9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f702b08e3c07df60f4835ad5cfee61f11ad6a6f9", "message": "more chanegs", "committedDate": "2020-03-30T19:35:49Z", "type": "commit"}, {"oid": "d5a3f6a66fc52839ed286fbf96e669f25f28ebcd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d5a3f6a66fc52839ed286fbf96e669f25f28ebcd", "message": " checkstyle changes", "committedDate": "2020-03-31T03:48:52Z", "type": "commit"}, {"oid": "a0060414b3a3e284aa44ee63403089ba8a4cc7d6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0060414b3a3e284aa44ee63403089ba8a4cc7d6", "message": "Fixed test", "committedDate": "2020-03-31T04:59:57Z", "type": "commit"}, {"oid": "84d8ab500f8773ba97e6c193d3a932befd1c9213", "url": "https://github.com/Azure/azure-sdk-for-java/commit/84d8ab500f8773ba97e6c193d3a932befd1c9213", "message": "Rolling back builder", "committedDate": "2020-03-31T17:41:08Z", "type": "commit"}, {"oid": "f5fa721037261b55de710a52910bc357e886fa58", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5fa721037261b55de710a52910bc357e886fa58", "message": "merge master", "committedDate": "2020-03-31T18:28:07Z", "type": "commit"}, {"oid": "6c4ffb32918d1945487a6498d8a1f39781e1a970", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6c4ffb32918d1945487a6498d8a1f39781e1a970", "message": "Fixing test", "committedDate": "2020-03-31T18:45:37Z", "type": "commit"}, {"oid": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "message": "java doc and renaming constants", "committedDate": "2020-03-31T19:49:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401177512", "bodyText": "nit: unnecessary empty line.", "author": "conniey", "createdAt": "2020-03-31T19:58:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,34 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\nindex aae6b51c7d6..aa31b31ec40 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n\n@@ -201,7 +201,6 @@ class ServiceBusMessageSerializer implements MessageSerializer {\n     }\n \n     private List<Long> deserializeListOfLong(Message amqpMessage) {\n-\n         if (amqpMessage.getBody() instanceof AmqpValue) {\n             AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n             if (amqpValue.getValue() instanceof  Map) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzY2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401177669", "bodyText": "nit: unnecessary new line", "author": "conniey", "createdAt": "2020-03-31T19:58:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,34 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+\n+        if (amqpMessage.getBody() instanceof AmqpValue) {\n+            AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n+            if (amqpValue.getValue() instanceof  Map) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) amqpValue.getValue();\n+                Object expirationListObj = responseBody.get(SEQUENCE_NUMBERS);\n+\n+                if (expirationListObj instanceof long[]) {\n+                    return Arrays.stream((long[]) expirationListObj)\n+                        .boxed()\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\nindex aae6b51c7d6..aa31b31ec40 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n\n@@ -201,7 +201,6 @@ class ServiceBusMessageSerializer implements MessageSerializer {\n     }\n \n     private List<Long> deserializeListOfLong(Message amqpMessage) {\n-\n         if (amqpMessage.getBody() instanceof AmqpValue) {\n             AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n             if (amqpValue.getValue() instanceof  Map) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODA4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401178081", "bodyText": "cancelScheduledMessage", "author": "conniey", "createdAt": "2020-03-31T19:59:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -101,6 +116,23 @@\n             .next();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelSchedule(long sequenceNumber) {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -120,16 +118,8 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * {@inheritDoc}\n      */\n     @Override\n-    public Mono<Void> cancelSchedule(long sequenceNumber) {\n-        return cancelSchedule(new Long[]{sequenceNumber});\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime) {\n-        return scheduleMessage(message, scheduledEnqueueTime)\n+    public Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n+        return scheduleMessage(message, scheduledEnqueueTime, maxSendLinkSize)\n             .next();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODc4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401178789", "bodyText": "This doesn't need to be a method, it is only used in one place. Roll it up into the calling method.", "author": "conniey", "createdAt": "2020-03-31T20:01:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -352,41 +342,40 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n-    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n-        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n-        Map<String, Object> requestBodyMap = new HashMap<>();\n-        List<Message> messagesToSchedule = new ArrayList<>();\n-        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-        for (Message message : messagesToSchedule) {\n-            final int payloadSize = messageSerializer.getSize(message);\n-            final int allocationSize =\n-                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = message.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage =\n-                    String.format(Locale.US,\n-                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n-                        maxMessageSize / 1024);\n-                throw logger.logExceptionAsWarning(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n-            }\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n \n-            HashMap<String, Object> messageEntry = new HashMap<>();\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n \n-            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n-            messageEntry.put(MESSAGE_ID, message.getMessageId());\n-            messageList.add(messageEntry);\n-        }\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n         requestBodyMap.put(MESSAGES, messageList);\n-\n         return requestBodyMap;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTM3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401179370", "bodyText": "You may need to reformat your code. There are double spaces where there shouldn't be.", "author": "conniey", "createdAt": "2020-03-31T20:02:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence \"\n+                + Arrays.toString(cancelScheduleNumbers), getErrorContext()));\n+\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -352,41 +342,40 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n-    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n-        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n-        Map<String, Object> requestBodyMap = new HashMap<>();\n-        List<Message> messagesToSchedule = new ArrayList<>();\n-        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-        for (Message message : messagesToSchedule) {\n-            final int payloadSize = messageSerializer.getSize(message);\n-            final int allocationSize =\n-                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = message.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage =\n-                    String.format(Locale.US,\n-                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n-                        maxMessageSize / 1024);\n-                throw logger.logExceptionAsWarning(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n-            }\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n \n-            HashMap<String, Object> messageEntry = new HashMap<>();\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n \n-            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n-            messageEntry.put(MESSAGE_ID, message.getMessageId());\n-            messageList.add(messageEntry);\n-        }\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n         requestBodyMap.put(MESSAGES, messageList);\n-\n         return requestBodyMap;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401180255", "bodyText": "Use monoError(logger, exception). It also logs the message. In addition to places you also return a mono error.", "author": "conniey", "createdAt": "2020-03-31T20:03:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence \"\n+                + Arrays.toString(cancelScheduleNumbers), getErrorContext()));\n+\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION, channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap;\n+            requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not schedule message.\",", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -352,41 +342,40 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n-    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n-        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n-        Map<String, Object> requestBodyMap = new HashMap<>();\n-        List<Message> messagesToSchedule = new ArrayList<>();\n-        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-        for (Message message : messagesToSchedule) {\n-            final int payloadSize = messageSerializer.getSize(message);\n-            final int allocationSize =\n-                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = message.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage =\n-                    String.format(Locale.US,\n-                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n-                        maxMessageSize / 1024);\n-                throw logger.logExceptionAsWarning(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n-            }\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n \n-            HashMap<String, Object> messageEntry = new HashMap<>();\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n \n-            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n-            messageEntry.put(MESSAGE_ID, message.getMessageId());\n-            messageList.add(messageEntry);\n-        }\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n         requestBodyMap.put(MESSAGES, messageList);\n-\n         return requestBodyMap;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401180940", "bodyText": "I should have noticed it before, put the private renewMessageLock method into the public one. It is only used in one place. It saves another stack call.", "author": "conniey", "createdAt": "2020-03-31T20:05:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNzc0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401307741", "bodyText": "I was thinking of when we have to renew multiple lock Token in one go and need to expose that API,  this would be helpful.\nBut for now I have changed this like you said.", "author": "hemanttanwar", "createdAt": "2020-04-01T01:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -352,41 +342,40 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n-    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n-        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n-        Map<String, Object> requestBodyMap = new HashMap<>();\n-        List<Message> messagesToSchedule = new ArrayList<>();\n-        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-        for (Message message : messagesToSchedule) {\n-            final int payloadSize = messageSerializer.getSize(message);\n-            final int allocationSize =\n-                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = message.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage =\n-                    String.format(Locale.US,\n-                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n-                        maxMessageSize / 1024);\n-                throw logger.logExceptionAsWarning(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n-            }\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n \n-            HashMap<String, Object> messageEntry = new HashMap<>();\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n \n-            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n-            messageEntry.put(MESSAGE_ID, message.getMessageId());\n-            messageList.add(messageEntry);\n-        }\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n         requestBodyMap.put(MESSAGES, messageList);\n-\n         return requestBodyMap;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401184391", "bodyText": "Why are you creating a list and iterating through it for a single message?\nYou aren't taking into account the size of the send link. It is not always \"MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES\".\nThis doesn't need to be a method. It is only used in a single place.\nDocument that the logic is from ReactorSender, so if we bug fix one place, it can also be done in another.", "author": "conniey", "createdAt": "2020-03-31T20:11:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MTg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401261890", "bodyText": "A separate method will keep scheduleMessage succinct and readable. I can merge them together if you still want.", "author": "hemanttanwar", "createdAt": "2020-03-31T22:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 38b8e30fb42..f3978d1d9bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -352,41 +342,40 @@ public class ManagementChannel implements ServiceBusManagementNode {\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n-    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n-        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n-        Map<String, Object> requestBodyMap = new HashMap<>();\n-        List<Message> messagesToSchedule = new ArrayList<>();\n-        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n-        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n-        for (Message message : messagesToSchedule) {\n-            final int payloadSize = messageSerializer.getSize(message);\n-            final int allocationSize =\n-                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n-            final byte[] bytes = new byte[allocationSize];\n-\n-            int encodedSize;\n-            try {\n-                encodedSize = message.encode(bytes, 0, allocationSize);\n-            } catch (BufferOverflowException exception) {\n-                final String errorMessage =\n-                    String.format(Locale.US,\n-                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n-                        maxMessageSize / 1024);\n-                throw logger.logExceptionAsWarning(new AmqpException(false,\n-                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n-            }\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n \n-            HashMap<String, Object> messageEntry = new HashMap<>();\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n \n-            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n-            messageEntry.put(MESSAGE_ID, message.getMessageId());\n-            messageList.add(messageEntry);\n-        }\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n         requestBodyMap.put(MESSAGES, messageList);\n-\n         return requestBodyMap;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401184877", "bodyText": "This should be from the send link, not receive link.", "author": "conniey", "createdAt": "2020-03-31T20:11:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java", "diffHunk": "@@ -34,4 +37,12 @@\n     static final String ASSOCIATED_LINK_NAME_KEY = \"associated-link-name\";\n     static final String SEQUENCE_NUMBERS = \"sequence-numbers\";\n     static final String RECEIVER_SETTLE_MODE = \"receiver-settle-mode\";\n+    static final String MESSAGES = \"messages\";\n+    static final String MESSAGE = \"message\";\n+    static final String MESSAGE_ID = \"message-id\";\n+\n+\n+    // TODO(Hemant) :This value should be read from Receive Link (Currently using track 1 default value)\n+    static final int MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES = 1024 * 1024;", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NTUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401185515", "bodyText": "This is different than the one in azure-core-amqp's ClientConstants.", "author": "conniey", "createdAt": "2020-03-31T20:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDg3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java\nindex b049054fc29..fb5914ac290 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java\n\n@@ -41,8 +41,5 @@ class ManagementConstants {\n     static final String MESSAGE = \"message\";\n     static final String MESSAGE_ID = \"message-id\";\n \n-\n-    // TODO(Hemant) :This value should be read from Receive Link (Currently using track 1 default value)\n-    static final int MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES = 1024 * 1024;\n     static final int MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES = 512;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NjE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401186140", "bodyText": "<<queue-name>> for constency.", "author": "conniey", "createdAt": "2020-03-31T20:14:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name\")", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\nindex 58e1485f1e4..e5e219f9831 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n\n@@ -64,7 +64,7 @@ public class MessageSendAsyncSample {\n         ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n             .connectionString(connectionString)\n             .sender()\n-            .queueName(\"<queue-name\")\n+            .queueName(\"<<queue-name>>\")\n             .buildAsyncClient();\n \n         // Create an message to send.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NzYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401187609", "bodyText": "The variable creations like Instant.now.plus.. and Duration.ofSeconds(enqeueDe...) are a part of your \"Arrange\" section. The Act part is usually, \"I set up all my things, now let me invoke it.\"", "author": "conniey", "createdAt": "2020-03-31T20:16:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,47 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 2;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 07cdc5a3c3e..207a24c86bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -119,11 +119,13 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         final String messageId = UUID.randomUUID().toString();\n         final String contents = \"Some-contents\";\n         final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n-        int enqueDelayInSec = 2;\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n         // Assert & Act\n-        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))\n-            .delaySubscription(Duration.ofSeconds(enqueDelayInSec + 1))\n-            .thenMany(receiver.receive().take(1)))\n+        StepVerifier.create(receiver.receive().take(1))\n             .assertNext(receivedMessage -> {\n                 Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n                 Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4ODAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401188035", "bodyText": "Scheduling a message isn't part of the scenario. Do that as part of your // Arrange.", "author": "conniey", "createdAt": "2020-03-31T20:17:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,47 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 2;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))\n+            .delaySubscription(Duration.ofSeconds(enqueDelayInSec + 1))\n+            .thenMany(receiver.receive().take(1)))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 3;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 07cdc5a3c3e..207a24c86bb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -119,11 +119,13 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         final String messageId = UUID.randomUUID().toString();\n         final String contents = \"Some-contents\";\n         final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n-        int enqueDelayInSec = 2;\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n         // Assert & Act\n-        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))\n-            .delaySubscription(Duration.ofSeconds(enqueDelayInSec + 1))\n-            .thenMany(receiver.receive().take(1)))\n+        StepVerifier.create(receiver.receive().take(1))\n             .assertNext(receivedMessage -> {\n                 Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n                 Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n"}}, {"oid": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ecbd6092f758b8b11790f9f355df8349ef75b97", "message": "Review comments", "committedDate": "2020-04-01T01:28:07Z", "type": "commit"}, {"oid": "1c2bd1ab5979ae1c47eba67c480fb735f35e5b76", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c2bd1ab5979ae1c47eba67c480fb735f35e5b76", "message": "Review comments", "committedDate": "2020-04-01T01:35:57Z", "type": "commit"}, {"oid": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47b5ea234acabd851dabb9fd32657b00e1b42a3a", "message": "Review comments", "committedDate": "2020-04-01T01:48:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxNzk0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401317946", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (amqpValue.getValue() instanceof  Map) {\n          \n          \n            \n                        if (amqpValue.getValue() instanceof Map) {", "author": "conniey", "createdAt": "2020-04-01T02:17:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,32 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+        if (amqpMessage.getBody() instanceof AmqpValue) {\n+            AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n+            if (amqpValue.getValue() instanceof  Map) {", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\nindex aa31b31ec40..c56a3a0ed46 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java\n\n@@ -203,7 +203,7 @@ class ServiceBusMessageSerializer implements MessageSerializer {\n     private List<Long> deserializeListOfLong(Message amqpMessage) {\n         if (amqpMessage.getBody() instanceof AmqpValue) {\n             AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n-            if (amqpValue.getValue() instanceof  Map) {\n+            if (amqpValue.getValue() instanceof Map) {\n                 @SuppressWarnings(\"unchecked\")\n                 Map<String, Object> responseBody = (Map<String, Object>) amqpValue.getValue();\n                 Object expirationListObj = responseBody.get(SEQUENCE_NUMBERS);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxODkzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401318938", "bodyText": "Don't think this needs to be its own function. It's only used once. Same with your helper method to create a message. Functions are pieces of code that can be reused.", "author": "conniey", "createdAt": "2020-04-01T02:20:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +334,98 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex d017f558c3c..5838ebcc1df 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -403,8 +394,11 @@ public class ManagementChannel implements ServiceBusManagementNode {\n         })).then();\n     }\n \n-    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n-                       int maxSendLinkSize) {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Long> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n         messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n         return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTQwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime,  int maxSendLinkSize);\n          \n          \n            \n                Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime, int maxSendLinkSize);", "author": "conniey", "createdAt": "2020-04-01T02:22:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementNode.java", "diffHunk": "@@ -39,6 +40,28 @@\n      */\n     Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber);\n \n+    /**\n+     * Sends a scheduled message to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time. This is an asynchronous method\n+     * returning a CompletableFuture which completes when the message is sent to the entity. The CompletableFuture,\n+     * on completion, returns the sequence number of the scheduled message which can be used to cancel the scheduling\n+     * of the message.\n+     *\n+     * @param message The message to be sent to the entity.\n+     * @param scheduledEnqueueTime The {@link Instant} at which the message should be enqueued in the entity.\n+     * @return The sequence number representing the pending send, which returns the sequence number of\n+      * the scheduled message. This sequence number can be used to cancel the scheduling of the message.\n+     */\n+    Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime,  int maxSendLinkSize);", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319499", "bodyText": "nit: empty line. Same with the one below. there's an extra empty line.", "author": "conniey", "createdAt": "2020-04-01T02:23:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);\n+            });\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\nindex e5e219f9831..17e18102fd3 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n\n@@ -3,22 +3,21 @@\n \n package com.azure.messaging.servicebus;\n \n-import org.junit.jupiter.api.Test;\n-\n import java.time.Duration;\n-import java.time.Instant;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n \n /**\n- * Sending message async.\n+ * Sample demonstrates how to send a {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n  */\n public class MessageSendAsyncSample {\n+\n     /**\n      * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n      */\n-    @Test\n-    public void sendMessage() {\n+    public static void main(String[] args) {\n         // The connection string value can be obtained by:\n         // 1. Going to your Service Bus namespace in Azure Portal.\n         // 2. Go to \"Shared access policies\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTczNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319737", "bodyText": "Tests should be in the test folder.", "author": "conniey", "createdAt": "2020-04-01T02:23:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);\n+            });\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Main method to invoke this demo on how to cancle a scheduled  message to an Azure Service Bus.\n+     */\n+    @Test", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\nindex e5e219f9831..17e18102fd3 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java\n\n@@ -3,22 +3,21 @@\n \n package com.azure.messaging.servicebus;\n \n-import org.junit.jupiter.api.Test;\n-\n import java.time.Duration;\n-import java.time.Instant;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n \n /**\n- * Sending message async.\n+ * Sample demonstrates how to send a {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n  */\n public class MessageSendAsyncSample {\n+\n     /**\n      * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n      */\n-    @Test\n-    public void sendMessage() {\n+    public static void main(String[] args) {\n         // The connection string value can be obtained by:\n         // 1. Going to your Service Bus namespace in Azure Portal.\n         // 2. Go to \"Shared access policies\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTg4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319883", "bodyText": "Why delaySubscription vs Mono.delay(duration).then(cancelSubscription)?", "author": "conniey", "createdAt": "2020-04-01T02:24:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,53 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);\n+        Duration delayDuration = Duration.ofSeconds(3);\n+        Long sequenceNumber = sender.scheduleMessage(message, scheduledEnqueueTime).block();\n+\n+        sender.cancelScheduledMessage(sequenceNumber.longValue())\n+            .delaySubscription(delayDuration)", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 207a24c86bb..0a6932d3680 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -119,7 +119,8 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         final String messageId = UUID.randomUUID().toString();\n         final String contents = \"Some-contents\";\n         final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n-        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+\n         sender.scheduleMessage(message, scheduledEnqueueTime)\n             .delaySubscription(Duration.ofSeconds(3))\n             .block();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTk1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319953", "bodyText": "consistency: use final for the rest of them", "author": "conniey", "createdAt": "2020-04-01T02:24:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,53 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 207a24c86bb..0a6932d3680 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -119,7 +119,8 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         final String messageId = UUID.randomUUID().toString();\n         final String contents = \"Some-contents\";\n         final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n-        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+\n         sender.scheduleMessage(message, scheduledEnqueueTime)\n             .delaySubscription(Duration.ofSeconds(3))\n             .block();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320104", "bodyText": "by default the mock runnable does nothing.", "author": "conniey", "createdAt": "2020-04-01T02:25:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -113,8 +123,15 @@ void setup() {\n         connectionProcessor = Mono.fromCallable(() -> connection).repeat(10).subscribeWith(\n             new ServiceBusConnectionProcessor(connectionOptions.getFullyQualifiedNamespace(),\n                 connectionOptions.getRetry()));\n-        sender = new ServiceBusSenderAsyncClient(ENTITY_NAME, connectionProcessor, retryOptions,\n-            tracerProvider, messageSerializer, onClientClose);\n+\n+        sender = new ServiceBusSenderAsyncClient(ENTITY_NAME, MessagingEntityType.QUEUE, connectionProcessor,\n+            retryOptions, tracerProvider, messageSerializer, onClientClose);\n+\n+        when(connection.getManagementNode(anyString(), any(MessagingEntityType.class)))\n+            .thenReturn(just(managementNode));\n+\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(ServiceBusSenderAsyncClient.MAX_MESSAGE_LENGTH_BYTES));\n+        doNothing().when(onClientClose).run();", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNzQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401337401", "bodyText": "It was throwing NPE in test when it was invoked by client.", "author": "hemanttanwar", "createdAt": "2020-04-01T03:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDEwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDIwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320209", "bodyText": "Should you verify that the management node operation was called?", "author": "conniey", "createdAt": "2020-04-01T02:25:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -290,6 +307,33 @@ void sendSingleMessage() {\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n \n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+\n+        when(managementNode.schedule(eq(message), any(Instant.class), any(Integer.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(message, mock(Instant.class)))\n+            .expectNext(sequenceNumberReturned)\n+            .verifyComplete();\n+    }\n+\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+\n+        when(managementNode.cancelScheduledMessage(eq(sequenceNumberReturned)))\n+            .thenReturn(Mono.empty());\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.cancelScheduledMessage(sequenceNumberReturned))\n+            .verifyComplete();\n+    }", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\nindex 4fb6a47ff9f..5725de3cbfb 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n\n@@ -311,6 +311,9 @@ public class ServiceBusSenderAsyncClientTest {\n     void scheduleMessage() {\n         // Arrange\n         long sequenceNumberReturned = 10;\n+        when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n+            .thenReturn(Mono.just(sendLink));\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n \n         when(managementNode.schedule(eq(message), any(Instant.class), any(Integer.class)))\n             .thenReturn(just(sequenceNumberReturned));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320282", "bodyText": "Did you mean to change code in this library?", "author": "conniey", "createdAt": "2020-04-01T02:26:03Z", "path": "sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java", "diffHunk": "@@ -94,7 +93,7 @@ private static void testBasicReceiveAndDeleteWithBinaryData(IMessageSender sende\n         receivedMessage = receiver.receive(SHORT_WAIT_TIME);\n         Assert.assertNull(\"Message received again\", receivedMessage);\n     }\n-    \n+", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "chunk": "diff --git a/sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java b/sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java\nindex e6fe1a0a977..2908d3c121f 100644\n--- a/sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java\n+++ b/sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java\n\n@@ -93,7 +94,7 @@ public class TestCommons {\n         receivedMessage = receiver.receive(SHORT_WAIT_TIME);\n         Assert.assertNull(\"Message received again\", receivedMessage);\n     }\n-\n+    \n     private static void testBasicReceiveAndCompleteWithBinaryData(IMessageSender sender, String sessionId, IMessageReceiver receiver, int messageSize) throws InterruptedException, ServiceBusException, ExecutionException {\n         String messageId = UUID.randomUUID().toString();\n         byte[] binaryData = new byte[messageSize];\n"}}, {"oid": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "message": "review comment", "committedDate": "2020-04-01T05:05:48Z", "type": "commit"}, {"oid": "4604222d206dfdff1da92e147d551fc7d264de11", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4604222d206dfdff1da92e147d551fc7d264de11", "message": "review comment", "committedDate": "2020-04-01T05:10:11Z", "type": "commit"}, {"oid": "d169489a504dc592de4321be520c789d149ed249", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d169489a504dc592de4321be520c789d149ed249", "message": "review comment", "committedDate": "2020-04-01T05:12:43Z", "type": "commit"}, {"oid": "b3438321825719351486bfd02c540a8c271e0a20", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3438321825719351486bfd02c540a8c271e0a20", "message": " rollback track 1 test change", "committedDate": "2020-04-01T05:21:53Z", "type": "commit"}, {"oid": "f3cde12beef84973db44eb1e88c60d263bc41208", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3cde12beef84973db44eb1e88c60d263bc41208", "message": " rollback track 1 test change", "committedDate": "2020-04-01T05:25:06Z", "type": "commit"}, {"oid": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "message": "revert back", "committedDate": "2020-04-01T05:28:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401720318", "bodyText": "You already have access to the list here, why not return the first item in the list as a mono rather than wrapping it in a flux from iterable and only choosing one item from it?", "author": "conniey", "createdAt": "2020-04-01T15:49:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -289,7 +297,8 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n             }\n \n             return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 5838ebcc1df..fd8830fc43f 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -292,13 +292,14 @@ public class ManagementChannel implements ServiceBusManagementNode {\n         }).flatMapMany(responseMessage -> {\n             int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n             if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+\n                 return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not renew the lock.\",\n                     getErrorContext()));\n             }\n-\n-            return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));\n-        }))\n-            .next();\n+            return Mono.just(messageSerializer.deserializeList(responseMessage, Instant.class).get(0));\n+            //return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));\n+        }));\n+            //.next();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401720678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /***\n          \n          \n            \n                /**", "author": "conniey", "createdAt": "2020-04-01T15:49:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 5838ebcc1df..fd8830fc43f 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -325,11 +326,12 @@ public class ManagementChannel implements ServiceBusManagementNode {\n         return message;\n     }\n \n-    /***\n+    /**\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n      * @param maxMessageSize The maximum size allowed on send link.\n+     *\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401722607", "bodyText": "When .thenMany versus .then? You aren't returning a stream of items, just a Mono.", "author": "conniey", "createdAt": "2020-04-01T15:52:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 5838ebcc1df..fd8830fc43f 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -325,11 +326,12 @@ public class ManagementChannel implements ServiceBusManagementNode {\n         return message;\n     }\n \n-    /***\n+    /**\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n      * @param maxMessageSize The maximum size allowed on send link.\n+     *\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjkzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401722934", "bodyText": "Why .thenMany? Same comment as above.", "author": "conniey", "createdAt": "2020-04-01T15:53:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Long> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMzYwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401723605", "bodyText": "You only take the first item from the list.. I'd just return it as a mono instead of wrapping it in a flux.", "author": "conniey", "createdAt": "2020-04-01T15:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 5838ebcc1df..fd8830fc43f 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -325,11 +326,12 @@ public class ManagementChannel implements ServiceBusManagementNode {\n         return message;\n     }\n \n-    /***\n+    /**\n      * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n      *\n      * @param messageToSchedule The message which needs to be scheduled.\n      * @param maxMessageSize The maximum size allowed on send link.\n+     *\n      * @return Map of key and value in Amqp format.\n      * @throws AmqpException When payload exceeded maximum message allowed size.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNDc0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401724740", "bodyText": "These printed messages should be cleaned up in both samples.", "author": "conniey", "createdAt": "2020-04-01T15:55:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\nindex 643fd3cbc40..c4c249cb7c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n\n@@ -14,7 +14,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n public class MessageScheduleAsyncSample {\n \n     /**\n-     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     * Main method to invoke this demo on how to schedule a message to an Azure Service Bus queue or topic.\n      *\n      * @param args Unused arguments to the program.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725062", "bodyText": "Update the documentation to describe that schedule operation?", "author": "conniey", "createdAt": "2020-04-01T15:55:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\nindex 643fd3cbc40..c4c249cb7c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n\n@@ -14,7 +14,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n public class MessageScheduleAsyncSample {\n \n     /**\n-     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     * Main method to invoke this demo on how to schedule a message to an Azure Service Bus queue or topic.\n      *\n      * @param args Unused arguments to the program.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTM0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725342", "bodyText": "Why not .plusSeconds(60) or plusMinute(1)?", "author": "conniey", "createdAt": "2020-04-01T15:56:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MzQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401743451", "bodyText": "I did not see plusMinute() API .", "author": "hemanttanwar", "createdAt": "2020-04-01T16:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\nindex 643fd3cbc40..c4c249cb7c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java\n\n@@ -14,7 +14,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;\n public class MessageScheduleAsyncSample {\n \n     /**\n-     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     * Main method to invoke this demo on how to schedule a message to an Azure Service Bus queue or topic.\n      *\n      * @param args Unused arguments to the program.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725613", "bodyText": "I thought you added this sample in another PR.", "author": "conniey", "createdAt": "2020-04-01T15:56:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to send {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageSendAsyncSample {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401744680", "bodyText": "Another PR I just had an update to it .", "author": "hemanttanwar", "createdAt": "2020-04-01T16:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDc2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401800761", "bodyText": "This sample exists almost exactly: https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/SendMessageAsyncSample.java", "author": "conniey", "createdAt": "2020-04-01T17:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNjQ3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401726473", "bodyText": "use client logger.", "author": "conniey", "createdAt": "2020-04-01T15:57:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,57 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);\n+        final Duration delayDuration = Duration.ofSeconds(3);\n+\n+        final Long sequenceNumber = sender.scheduleMessage(message, scheduledEnqueueTime).block();\n+        System.out.println(\"Scheduled the message, sequence number: \" + sequenceNumber);", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 0a6932d3680..1e3eaf0dcbc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -148,12 +149,12 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         final Duration delayDuration = Duration.ofSeconds(3);\n \n         final Long sequenceNumber = sender.scheduleMessage(message, scheduledEnqueueTime).block();\n-        System.out.println(\"Scheduled the message, sequence number: \" + sequenceNumber);\n+        logger.verbose(\"Scheduled the message, sequence number {}.\", sequenceNumber);\n \n         Mono.delay(delayDuration)\n             .then(sender.cancelScheduledMessage(sequenceNumber.longValue()))\n             .block();\n-        System.out.println(\"Cancelled the scheduled message, sequence number: \" + sequenceNumber);\n+        logger.verbose(\"Cancelled the scheduled message, sequence number {}.\", sequenceNumber);\n \n         // Assert & Act\n         StepVerifier.create(receiver.receive().take(1))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNzU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401727575", "bodyText": "I could have been more clear, the verification of management node operation should be here as well.", "author": "conniey", "createdAt": "2020-04-01T15:59:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -290,6 +307,37 @@ void sendSingleMessage() {\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n \n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+        Instant instant = mock(Instant.class);\n+\n+        when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n+            .thenReturn(Mono.just(sendLink));\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(message, instant))\n+            .expectNext(sequenceNumberReturned)\n+            .verifyComplete();\n+    }", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\nindex 5542214dfb4..cc142cc7bde 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java\n\n@@ -323,6 +323,7 @@ public class ServiceBusSenderAsyncClientTest {\n         StepVerifier.create(sender.scheduleMessage(message, instant))\n             .expectNext(sequenceNumberReturned)\n             .verifyComplete();\n+        verify(managementNode).schedule(message, instant, MAX_MESSAGE_LENGTH_BYTES);\n     }\n \n     @Test\n"}}, {"oid": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab538c3640b0d6ddd6eb4785b313624e765f715d", "message": " continue  changes", "committedDate": "2020-04-01T16:43:14Z", "type": "commit"}, {"oid": "7dba46e6e09ee421149bf58130c1e4144cefc7a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7dba46e6e09ee421149bf58130c1e4144cefc7a4", "message": "changes in management channel", "committedDate": "2020-04-01T17:30:11Z", "type": "commit"}, {"oid": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99420905173fdbb7ec0afab54f7daa17c72c1eaf", "message": "changes in management channel", "committedDate": "2020-04-01T17:35:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5OTQ2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401799469", "bodyText": "Nothing is this code is async, you can use .map.", "author": "conniey", "createdAt": "2020-04-01T17:49:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -272,23 +277,33 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n-    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n-\n-        return  isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(UUID lockToken) {\n+        return  isAuthorized(PEEK_OPERATION).then(createRequestResponse.flatMap(channel -> {\n \n             Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n                 channel.getReceiveLinkName());\n \n-            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, renewLockList)));\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, new UUID[]{lockToken})));\n             return channel.sendWithAck(requestMessage);\n-        }).flatMapMany(responseMessage -> {\n+        }).flatMap(responseMessage -> {", "originalCommit": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "916fa7038bf66e8260ef7d9273717678a59e625c", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 42ac7f3b439..2f3b9fb2853 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -289,7 +289,7 @@ public class ManagementChannel implements ServiceBusManagementNode {\n \n             requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, new UUID[]{lockToken})));\n             return channel.sendWithAck(requestMessage);\n-        }).flatMap(responseMessage -> {\n+        }).map(responseMessage -> {\n             int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n             if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDA1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401800050", "bodyText": "Similar to my first comment above. This can be .map rather than .flatMap.", "author": "conniey", "createdAt": "2020-04-01T17:50:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +331,108 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /**\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     *\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).then(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Long> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).then(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION, channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule, maxSendLinkSize);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMap(responseMessage -> {", "originalCommit": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "916fa7038bf66e8260ef7d9273717678a59e625c", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\nindex 42ac7f3b439..2f3b9fb2853 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java\n\n@@ -414,7 +414,7 @@ public class ManagementChannel implements ServiceBusManagementNode {\n \n             requestMessage.setBody(new AmqpValue(requestBodyMap));\n             return channel.sendWithAck(requestMessage);\n-        }).flatMap(responseMessage -> {\n+        }).map(responseMessage -> {\n             int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n \n             if (statusCode != AmqpResponseCode.OK.getValue()) {\n"}}, {"oid": "916fa7038bf66e8260ef7d9273717678a59e625c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/916fa7038bf66e8260ef7d9273717678a59e625c", "message": "Continue the work", "committedDate": "2020-04-01T19:34:53Z", "type": "commit"}, {"oid": "f08a809ac505b14fa2ab845d68172db866c8c80c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f08a809ac505b14fa2ab845d68172db866c8c80c", "message": "change continue", "committedDate": "2020-04-01T21:08:56Z", "type": "commit"}, {"oid": "452eaee0162b5e169673304698035edf18a4d01a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/452eaee0162b5e169673304698035edf18a4d01a", "message": "review comments", "committedDate": "2020-04-02T05:08:04Z", "type": "commit"}]}