{"pr_number": 14162, "pr_title": "Bug: BasuAuthorizationProvider credential update/refresh", "pr_createdAt": "2020-08-17T01:17:38Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14162", "timeline": [{"oid": "98f73f36fd0cae76f148825c993a8f16e176429d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/98f73f36fd0cae76f148825c993a8f16e176429d", "message": "BasuAuthorizationProvider credential update/refresh bug fix", "committedDate": "2020-08-17T01:14:00Z", "type": "commit"}, {"oid": "80e7385faea38c023a4ab0048de9bd0e6e6b1ccb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80e7385faea38c023a4ab0048de9bd0e6e6b1ccb", "message": "Always fall back the cached instance part.", "committedDate": "2020-08-17T01:33:06Z", "type": "commit"}, {"oid": "50c2f1c66b50127eb853e81600386db60d3ebec7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/50c2f1c66b50127eb853e81600386db60d3ebec7", "message": "Merge branch 'master' into users/kirankk/credential_change_fix", "committedDate": "2020-08-17T18:49:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r471711009", "bodyText": "I am concerned about this synchronized code piece, since this will be called on every request. My concern is this will slow down things.\nDo we need synchronized block here even though credential is volatile now ?", "author": "kushagraThapar", "createdAt": "2020-08-17T18:54:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -203,25 +202,28 @@ private Mac getMacInstance() {\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-            byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-            SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-            try {\n-                Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                macInstance.init(signingKey);\n-                //  Update the master key hash code\n-                this.masterKeyHashCode = masterKeyLatestHashCode;\n-                return macInstance;\n-            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        } else {\n-            //  Master key hasn't changed, return the cloned mac instance\n-            try {\n-                return (Mac)this.macInstance.clone();\n-            } catch (CloneNotSupportedException e) {\n-                throw new IllegalStateException(e);\n+            synchronized (this.credential) {", "originalCommit": "50c2f1c66b50127eb853e81600386db60d3ebec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r471711683", "bodyText": "this is very valid point. I also think will have perf impact", "author": "moderakh", "createdAt": "2020-08-17T18:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxNjQyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472616428", "bodyText": "Only when the hashcode is different is when this code path hits.\nFew triggering points are\n\nnew client creation starting point\nkey-changed\n\nIf the assumption is that its a both credentials are valid for a good period of time, the refresh can be asynchronous.\nCan we make that assumption?", "author": "kirankumarkolli", "createdAt": "2020-08-19T02:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzMzUyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472633523", "bodyText": "Yes, that is correct assumption. We can proceed with this PR. looks good to me.", "author": "kushagraThapar", "createdAt": "2020-08-19T03:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4ODMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r472888314", "bodyText": "Refreshed the implementation to eventually move to the new key.\nOne thread will try to refresh where as others will move forward with current key.", "author": "kirankumarkolli", "createdAt": "2020-08-19T09:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxMTAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "30ec84de60d1c1e0ce3940fd94914be7c2ed68cb", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java\nindex 7ac6ab50999..3307e4aaf7c 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java\n\n@@ -198,32 +200,51 @@ public class BaseAuthorizationTokenProvider implements AuthorizationTokenProvide\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();\n+            if (lockAcquired) {\n+                try {\n+                    if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n+                        byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n+                        byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n+                        SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n+                        try {\n+                            Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n+                            macInstance.init(signingKey);\n+                            //  Update the master key hash code\n+                            this.masterKeyHashCode = masterKeyLatestHashCode;\n+                            this.macInstance = macInstance;\n+                        } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n+                            throw new IllegalStateException(e);\n+                        }\n                     }\n+                } finally {\n+                    this.macInstanceLock.unlock();\n                 }\n             }\n         }\n-\n-        try {\n-            return (Mac)this.macInstance.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new IllegalStateException(e);\n-        }\n     }\n }\n"}}, {"oid": "30ec84de60d1c1e0ce3940fd94914be7c2ed68cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30ec84de60d1c1e0ce3940fd94914be7c2ed68cb", "message": "Little more refractoring", "committedDate": "2020-08-19T09:18:15Z", "type": "commit"}, {"oid": "ca56f96945f53384c856c81d08519694754251c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca56f96945f53384c856c81d08519694754251c1", "message": "Merge branch 'master' into users/kirankk/credential_change_fix", "committedDate": "2020-08-19T09:19:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473099708", "bodyText": "what is the benefit of using ReentrantLock here?\nkey rotation doesn't happen often and this adds a bit to complexity.\nWhy aren't we simply using synchronized?", "author": "moderakh", "createdAt": "2020-08-19T15:04:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/BaseAuthorizationTokenProvider.java", "diffHunk": "@@ -198,32 +200,51 @@ public String getAuthorizationTokenUsingResourceTokens(Map<String, String> resou\n     }\n \n     private Mac getMacInstance() {\n+        reInitializeIfPossible();\n+\n+        try {\n+            return (Mac)this.macInstance.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /*\n+     * Ensures that this.macInstance is initialized\n+     * In-case of credential change, optimistically will try to refresh the macInstance\n+     *\n+     * Implementation is non-blocking, the one which acquire the lock will try to refresh\n+     * with new credentials\n+     *\n+     * NOTE: Calling it CTOR ensured that default is initialized.\n+     */\n+    private void reInitializeIfPossible() {\n         int masterKeyLatestHashCode = this.credential.getKey().hashCode();\n \n         //  Master key has changed, or this is the first time we are getting mac instance\n         if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-            synchronized (this.credential) {\n-                if (masterKeyLatestHashCode != this.masterKeyHashCode) {\n-                    byte[] masterKeyBytes = this.credential.getKey().getBytes(StandardCharsets.UTF_8);\n-                    byte[] masterKeyDecodedBytes = Utils.Base64Decoder.decode(masterKeyBytes);\n-                    SecretKey signingKey = new SecretKeySpec(masterKeyDecodedBytes, \"HMACSHA256\");\n-                    try {\n-                        Mac macInstance = Mac.getInstance(\"HMACSHA256\");\n-                        macInstance.init(signingKey);\n-                        //  Update the master key hash code\n-                        this.masterKeyHashCode = masterKeyLatestHashCode;\n-                        this.macInstance = macInstance;\n-                    } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n-                        throw new IllegalStateException(e);\n+            // Try to acquire the lock, the one who got lock will try to refresh the macInstance\n+            boolean lockAcquired = this.macInstanceLock.tryLock();", "originalCommit": "ca56f96945f53384c856c81d08519694754251c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MTg5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473171893", "bodyText": "reEntrant lock comes into picture only when there is change detected. Otherwise no impact, no?", "author": "kirankumarkolli", "createdAt": "2020-08-19T16:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MzQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473173451", "bodyText": "that's correct.\nmy question is: isn't synchronized(.) easier to use? what's the benefit of reEntrant lock here? I don't think you will get any benefit and its usage is slightly more complicated than using synchronized(.)\nis there any benefit in using reEntrant lock over synchrnozied()?", "author": "moderakh", "createdAt": "2020-08-19T16:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MDQ0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473190442", "bodyText": "synchronized is blocking, where as reEntry.TryLock is enabling non-blocking. So only one thread will go into re-initialization.", "author": "kirankumarkolli", "createdAt": "2020-08-19T17:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NTM1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14162#discussion_r473195354", "bodyText": "if the key is rotated, then shouldn't the threads attempting to get a new macInstance wait and block till a new macInstance generated?\nIs the old macInstance value returned to the threads which don't get the lock a valid macInstance in the key-rotation scenario?", "author": "moderakh", "createdAt": "2020-08-19T17:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5OTcwOA=="}], "type": "inlineReview", "revised_code": null}]}