{"pr_number": 16822, "pr_title": "Adding client telemetry", "pr_createdAt": "2020-10-26T20:33:04Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16822", "timeline": [{"oid": "0bef5c252d45d4aee650e42fa381913f1430e212", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0bef5c252d45d4aee650e42fa381913f1430e212", "message": "client telemetry changes", "committedDate": "2020-10-09T21:14:07Z", "type": "commit"}, {"oid": "078f8b14ad24d9a90feb6502da48fe2698425805", "url": "https://github.com/Azure/azure-sdk-for-java/commit/078f8b14ad24d9a90feb6502da48fe2698425805", "message": "build fix", "committedDate": "2020-10-09T21:30:02Z", "type": "commit"}, {"oid": "623cf696789255583db90e6665ab5c4d3b08c925", "url": "https://github.com/Azure/azure-sdk-for-java/commit/623cf696789255583db90e6665ab5c4d3b08c925", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:11:23Z", "type": "commit"}, {"oid": "e214000ec233da19a95da8405c68ab2931e04f24", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e214000ec233da19a95da8405c68ab2931e04f24", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:13:30Z", "type": "commit"}, {"oid": "68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:22:31Z", "type": "commit"}, {"oid": "6ac5a0f9983e0caa62e58602c9f0db722a69a917", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ac5a0f9983e0caa62e58602c9f0db722a69a917", "message": "merge with masrer", "committedDate": "2020-10-19T19:25:42Z", "type": "commit"}, {"oid": "96e650bc88e383ea45a5792dc73caf77955aff63", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96e650bc88e383ea45a5792dc73caf77955aff63", "message": "incremental check in", "committedDate": "2020-10-20T17:53:48Z", "type": "commit"}, {"oid": "561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "message": "Incremental work", "committedDate": "2020-10-26T19:04:15Z", "type": "commit"}, {"oid": "df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-10-26T19:09:18Z", "type": "commit"}, {"oid": "e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "message": "Incremental work", "committedDate": "2020-10-26T20:21:37Z", "type": "commit"}, {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f96b243b10963f2e18fd0bf0ec99550897a6bfae", "message": "incremental work", "committedDate": "2020-10-26T20:25:06Z", "type": "commit"}, {"oid": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a8c1f509176246306664dc0bbbf07c7240c2fa42", "message": "adding setAutoResize on cpu and memory", "committedDate": "2020-10-26T22:45:30Z", "type": "commit"}, {"oid": "f087a988ec3bc8836d432b1113365d84173a3096", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f087a988ec3bc8836d432b1113365d84173a3096", "message": "adding useragent in serialization", "committedDate": "2020-10-27T18:53:12Z", "type": "commit"}, {"oid": "60b2e6c0ee9888856e16ac427390e82e06c9cda6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/60b2e6c0ee9888856e16ac427390e82e06c9cda6", "message": "Adding test file", "committedDate": "2020-10-29T16:07:04Z", "type": "commit"}, {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6c8da63c311ebbada183cb99019bcf55bb06eea4", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-10-29T16:41:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514431823", "bodyText": "I got this hashing from our existing partition key class, I could have done without (hash * 397) , thoughts ?", "author": "simplynaveen20", "createdAt": "2020-10-29T17:17:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "originalCommit": "6c8da63c311ebbada183cb99019bcf55bb06eea4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMDM5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518300395", "bodyText": "The notion of 397 is - usually in hashCode() we take a prime number and then use that to generate hashCode.\nI will suggest to keep it.\nCan you also please check what IntelliJ generates when you generate the hashCode with it ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NDM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520754343", "bodyText": "Oh I see, intellij with hash 397 generated 1474114674 and without it 1390251919. As you rightly mentioned it will help in better distribution of hash. So we are good with this.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java\nindex 3b1ca864c57..2c570596769 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java\n\n@@ -14,7 +14,7 @@ public class ReportPayload {\n     private String regionsContacted;\n     private Boolean greaterThan1Kb;\n     private ConsistencyLevel consistency;\n-    private String databasesName;\n+    private String databaseName;\n     private String containerName;\n     private OperationType operation;\n     private ResourceType resource;\n"}}, {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3687c02c8e112d392357bd04d36bcd902aff6005", "message": "adding suprression for reportpayload equals method", "committedDate": "2020-10-29T17:44:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642419", "bodyText": "Please add java documentation to this.", "author": "kushagraThapar", "createdAt": "2020-10-30T00:32:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -579,6 +580,11 @@ public CosmosClientBuilder multipleWriteRegionsEnabled(boolean multipleWriteRegi\n         return this;\n     }\n \n+    public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjM2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952369", "bodyText": "Thanks for this, done", "author": "simplynaveen20", "createdAt": "2020-11-03T21:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "252850bb53ec1a08ece93613b302abeb547a161b", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java\nindex 88972a6ac3b..b97836e1cf0 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java\n\n@@ -580,6 +580,16 @@ public class CosmosClientBuilder {\n         return this;\n     }\n \n+    /**\n+     * Sets the flag to enable client telemetry which will periodically collect\n+     * database operations aggregation statistics, system information like cpu/memory\n+     * and send it to cosmos monitoring service, which will be helpful during debugging.\n+     *<p/>\n+     * DEFAULT value is false indicating this is opt in feature, by default no telemetry collection.\n+     *\n+     * @param clientTelemetryEnabled flag to enable client telemetry.\n+     * @return current CosmosClientBuilder\n+     */\n     public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {\n         this.clientTelemetryEnabled = clientTelemetryEnabled;\n         return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642704", "bodyText": "This is great, thank you!\nPlease mention this issue in the PR as this API solves the github issue ask: #13488", "author": "kushagraThapar", "createdAt": "2020-10-30T00:33:28Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "diffHunk": "@@ -281,6 +281,22 @@ CosmosException setDiagnostics(CosmosDiagnostics cosmosDiagnostics) {\n         return this;\n     }\n \n+    /**\n+     * Gets the request charge as request units (RU) consumed by the operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952293", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-03T21:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "071f928e47bb7945ed473a391320309b96032421", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java\nindex c4aa7475ceb..4f92e55bc8e 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java\n\n@@ -300,7 +300,7 @@ public class CosmosException extends AzureException {\n     @Override\n     public String toString() {\n         return getClass().getSimpleName() + \"{\" + \"userAgent=\" + USER_AGENT + \", error=\" + cosmosError + \", resourceAddress='\"\n-                   + resourceAddress  +  \"', requestUri='\" + (requestUri != null ? requestUri.getURIAsString() : null) +  \"', statusCode=\" + statusCode + \", message=\" + getMessage()\n+                   + resourceAddress  +  \", statusCode=\" + statusCode + \", message=\" + getMessage()\n                    + \", causeInfo=\" + causeInfo() + \", responseHeaders=\" + responseHeaders + \", requestHeaders=\"\n                    + filterSensitiveData(requestHeaders) + '}';\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642843", "bodyText": "It is every 600 seconds / 10 minutes ?", "author": "kushagraThapar", "createdAt": "2020-10-30T00:34:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mjc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952791", "bodyText": "yes it is 10 min , representation 10*60 is more readable and i followed the existing model", "author": "simplynaveen20", "createdAt": "2020-11-03T21:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284661", "bodyText": "Makes sense, thanks!", "author": "kushagraThapar", "createdAt": "2020-11-05T18:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643450", "bodyText": "nit: What if the val is not a boolean value - this will throw an exception and might stop the application. Instead we should try catch it and just log the error and move forward with default value.\nAlso, this is an issue with other API as well - getIntValue()", "author": "kushagraThapar", "createdAt": "2020-10-30T00:36:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mzk0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516953949", "bodyText": "If we pass any thing apart from true and false , it will return false. Below code from from Boolean class\n    public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; }\n public static boolean parseBoolean(String s) { return \"true\".equalsIgnoreCase(s); }", "author": "simplynaveen20", "createdAt": "2020-11-03T21:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284890", "bodyText": "I see, cool, thanks!", "author": "kushagraThapar", "createdAt": "2020-11-05T18:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643572", "bodyText": "Please include clientTelemetryEnabled in toString() API", "author": "kushagraThapar", "createdAt": "2020-10-30T00:36:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "diffHunk": "@@ -497,6 +500,14 @@ public ConnectionPolicy setMaxRequestsPerConnection(int maxRequestsPerConnection\n         return this;\n     }\n \n+    public boolean isClientTelemetryEnabled() {\n+        return clientTelemetryEnabled;\n+    }\n+\n+    public void setClientTelemetryEnabled(boolean clientTelemetryEnabled) {\n+        this.clientTelemetryEnabled = clientTelemetryEnabled;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConnectionPolicy{\" +", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDM4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954386", "bodyText": "Good catch , thanks", "author": "simplynaveen20", "createdAt": "2020-11-03T21:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643785", "bodyText": "Why are we changing the scope of this API ?", "author": "kushagraThapar", "createdAt": "2020-10-30T00:37:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -121,18 +129,28 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n     public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n                                                                                    Context context,\n                                                                                    String spanName,\n+                                                                                   String containerId,\n                                                                                    String databaseId,\n-                                                                                   String endpoint) {\n-        return traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint,\n+                                                                                   CosmosAsyncClient client,\n+                                                                                   ConsistencyLevel consistencyLevel,\n+                                                                                   OperationType operationType,\n+                                                                                   ResourceType resourceType) {\n+\n+        return publisherWithClientTelemetry(resultPublisher, context, spanName, containerId, databaseId,\n+            BridgeInternal.getServiceEndpoint(client),\n+            client,\n+            consistencyLevel,\n+            operationType,\n+            resourceType,\n             CosmosItemResponse::getStatusCode);\n     }\n \n-    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n-                                             Context context,\n-                                             String spanName,\n-                                             String databaseId,\n-                                             String endpoint,\n-                                             Function<T, Integer> statusCodeFunc) {\n+    private <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954804", "bodyText": "This must be left public my mistake , not getting called from outside", "author": "simplynaveen20", "createdAt": "2020-11-03T21:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "bae66233a06f0f68824ca52ee35c46be9a704e3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bae66233a06f0f68824ca52ee35c46be9a704e3c", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-03T20:01:51Z", "type": "commit"}, {"oid": "252850bb53ec1a08ece93613b302abeb547a161b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/252850bb53ec1a08ece93613b302abeb547a161b", "message": "performance turning and resolving comments", "committedDate": "2020-11-03T20:59:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518286200", "bodyText": "when checking for throwable instanceof CosmosException, shouldn't we try to unwrap the exception in case the exception is of type ReactiveException ?\nSame for other places where we are checking throwable in doOnError blocks.", "author": "kushagraThapar", "createdAt": "2020-11-05T18:53:42Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NTYyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520755624", "bodyText": "Idea here is to log the telemetry on every cosmos exception, irrespective of inner cause.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjEwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812102", "bodyText": "I see, sounds good.", "author": "kushagraThapar", "createdAt": "2020-11-10T19:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\nindex 3345191d0f1..0ca0d4f0198 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n\n@@ -232,9 +232,9 @@ public class TracerProvider {\n             ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n         } else {\n             if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n             }\n \n             latencyHistogram.setAutoResize(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518287619", "bodyText": "We also treat HttpConstants.StatusCodes.NOT_MODIFIED as success code in other places in the code. Shouldn't we include that here ?", "author": "kushagraThapar", "createdAt": "2020-11-05T18:56:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1Njk4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520756982", "bodyText": "TracerProvider file will log only point operation, and 304 is for feed operation. So it will be redundant check. In cosmos page flux we create our own status code base on success and failure , it is not needed there also.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\nindex 3345191d0f1..0ca0d4f0198 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n\n@@ -232,9 +232,9 @@ public class TracerProvider {\n             ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n         } else {\n             if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n             }\n \n             latencyHistogram.setAutoResize(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518289671", "bodyText": "nit : This could be a private class if not used outside, if used outside, may be Compute can be its own class outside.", "author": "kushagraThapar", "createdAt": "2020-11-05T18:59:43Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {\n+    private Compute compute;\n+    public String getLocation() {\n+        return compute != null ? compute.getLocation() : null;\n+    }\n+\n+    public Compute getCompute() {\n+        return compute;\n+    }\n+\n+    public void setCompute(Compute compute) {\n+        this.compute = compute;\n+    }\n+\n+    static class Compute{", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757448", "bodyText": "Done, if in future we will use Compute exclusively , we will change it back to package private", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\nindex 724a2ebff7f..7450440913a 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\n\n@@ -16,7 +16,7 @@ public class AzureVMMetadata {\n         this.compute = compute;\n     }\n \n-    static class Compute{\n+    private static class Compute{\n         private String location;\n \n         public String getLocation() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290364", "bodyText": "Can you please add units to the name of this constant ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:00:51Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757586", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290607", "bodyText": "Please add unit to the name of the constant.", "author": "kushagraThapar", "createdAt": "2020-11-05T19:01:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzY1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757658", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518293515", "bodyText": "I see, this is trace logging, while others are warning and info, is there a reason for this?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:06:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761659", "bodyText": "This is done intentionally, till the time we enable telemetry by default i don't want cx to get this log. Otherwise every customer will be getting this every 10 min , and might create a cri with question.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518295548", "bodyText": "Are we doing recursion inside flatMap ?\nThere could be a better way to do this instead of doing it though flatMap- please take a look at expand operation from project reactor.", "author": "kushagraThapar", "createdAt": "2020-11-05T19:09:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODc0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520758745", "bodyText": "This is in line with what we do in GlobalEndpointManager. Also expand is more applicable where we have values in stream and we want to do breath first or depth first recursion. In our case it is mono void.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjMxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812319", "bodyText": "Makes sense, thanks.", "author": "kushagraThapar", "createdAt": "2020-11-10T19:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518298911", "bodyText": "where is that validation happening ?\nMay be worth mentioning here ?\nAlso, how do we plan to validate the keys specially in the set API for percentiles ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:15:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1OTY0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520759646", "bodyText": "Removed the comment, it was the leftover from the initial contract discussion, it was more for BE service to validate the contract. Already passed this information to Vignesh", "author": "simplynaveen20", "createdAt": "2020-11-10T17:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\nindex fa4c6c3bd75..4f963c0d14a 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\n\n@@ -12,7 +12,7 @@ public class MetricInfo {\n     private long count;\n     private double min;\n     private double max;\n-    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required\n+    private Map<Double, Double> percentiles;\n \n     public MetricInfo(String metricsName, String unitName) {\n         this.metricsName = metricsName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518383157", "bodyText": "why can't we keep it double?", "author": "kushagraThapar", "createdAt": "2020-11-05T21:36:19Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "diffHunk": "@@ -9,44 +9,56 @@\n \n import java.lang.management.ManagementFactory;\n \n-public class CpuReader {\n-    private final static Logger logger = LoggerFactory.getLogger(CpuReader.class);\n+public class CpuMemoryReader {\n+    private final static Logger logger = LoggerFactory.getLogger(CpuMemoryReader.class);\n     private final com.sun.management.OperatingSystemMXBean operatingSystemMXBean;\n \n-    public CpuReader() {\n+    public CpuMemoryReader() {\n         java.lang.management.OperatingSystemMXBean mxBean = null;\n         try {\n             mxBean =\n                 ManagementFactory.getOperatingSystemMXBean();\n         } catch (Throwable t) {\n-            logger.error(\"failed to initialized CpuReader\", t);\n+            logger.error(\"failed to initialized CpuMemoryReader\", t);\n         }\n \n         this.operatingSystemMXBean = tryGetAs(mxBean,\n             com.sun.management.OperatingSystemMXBean.class);\n     }\n \n-    public double getSystemWideCpuUsage() {\n+    public float getSystemWideCpuUsage() {\n         try {\n             if (operatingSystemMXBean != null) {\n-                double val = operatingSystemMXBean.getSystemCpuLoad();\n+                float val = (float) operatingSystemMXBean.getSystemCpuLoad();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDI3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760271", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure cpu percentage.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518384544", "bodyText": "I wonder why we can't keep it double in the client telemetry as well ?", "author": "kushagraThapar", "createdAt": "2020-11-05T21:38:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -125,11 +139,103 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n                 pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable),\n                     TracerProvider.ERROR_CODE);\n             }\n+\n+            if (pagedFluxOptions.getCosmosAsyncClient() != null &&\n+                Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(pagedFluxOptions.getCosmosAsyncClient())) &&\n+                throwable instanceof CosmosException) {\n+                CosmosException cosmosException = (CosmosException) throwable;\n+                fillClientTelemetry(pagedFluxOptions.getCosmosAsyncClient(), 0, pagedFluxOptions.getContainerId(),\n+                    pagedFluxOptions.getDatabaseId(),\n+                    pagedFluxOptions.getOperationType(), pagedFluxOptions.getResourceType(),\n+                    BridgeInternal.getContextClient(pagedFluxOptions.getCosmosAsyncClient()).getConsistencyLevel(),\n+                    (float) cosmosException.getRequestCharge(), Duration.between(startTime.get(), Instant.now()));", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDU0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760549", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure request charge.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java\nindex 49962d9ba22..bd975d352a6 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java\n\n@@ -189,10 +189,10 @@ public final class CosmosPagedFlux<T> extends ContinuablePagedFlux<String, T, Fe\n             ClientTelemetry.recordValue(latencyHistogram, latency.toNanos() / 1000);\n         } else {\n             if (statusCode == HttpConstants.StatusCodes.OK) {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX,\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC,\n                     ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX,\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC,\n                     ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261595", "bodyText": "why aren't we capturing the exception stacktace?", "author": "moderakh", "createdAt": "2020-10-26T20:54:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzk5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763997", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex 0b5dafb4a40..62ead3f1599 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -183,6 +183,7 @@ public class ClientTelemetry {\n         //Filling cpu information\n         DoubleHistogram cpuHistogram = new DoubleHistogram(ClientTelemetry.CPU_MAX,\n             ClientTelemetry.CPU_PRECISION);\n+        cpuHistogram.setAutoResize(true);\n         for(double val : CpuMemoryMonitor.getClientTelemetryCpuLatestList()) {\n             recordValue(cpuHistogram, val);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261680", "bodyText": "ditto", "author": "moderakh", "createdAt": "2020-10-26T20:54:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzg4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763881", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex 0b5dafb4a40..62ead3f1599 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -183,6 +183,7 @@ public class ClientTelemetry {\n         //Filling cpu information\n         DoubleHistogram cpuHistogram = new DoubleHistogram(ClientTelemetry.CPU_MAX,\n             ClientTelemetry.CPU_PRECISION);\n+        cpuHistogram.setAutoResize(true);\n         for(double val : CpuMemoryMonitor.getClientTelemetryCpuLatestList()) {\n             recordValue(cpuHistogram, val);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512263648", "bodyText": "you are capturing the exception message twice.", "author": "moderakh", "createdAt": "2020-10-26T20:57:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();\n+            }).onErrorResume(ex -> {\n+                logger.error(\"sendClientTelemetry() - Unable to send client telemetry\" +\n+                    \". Exception: {}\", ex.toString(), ex);", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763742", "bodyText": "removed extra message", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex 0b5dafb4a40..62ead3f1599 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -183,6 +183,7 @@ public class ClientTelemetry {\n         //Filling cpu information\n         DoubleHistogram cpuHistogram = new DoubleHistogram(ClientTelemetry.CPU_MAX,\n             ClientTelemetry.CPU_PRECISION);\n+        cpuHistogram.setAutoResize(true);\n         for(double val : CpuMemoryMonitor.getClientTelemetryCpuLatestList()) {\n             recordValue(cpuHistogram, val);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518457521", "bodyText": "is this accessed from multiple threads?", "author": "moderakh", "createdAt": "2020-11-06T00:46:02Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MzU4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763582", "bodyText": "removed the object creation from here. This is getting created in a single thread every 10 min in client telemetry, so we don't need concurrency.", "author": "simplynaveen20", "createdAt": "2020-11-10T18:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\nindex fa4c6c3bd75..4f963c0d14a 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java\n\n@@ -12,7 +12,7 @@ public class MetricInfo {\n     private long count;\n     private double min;\n     private double max;\n-    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required\n+    private Map<Double, Double> percentiles;\n \n     public MetricInfo(String metricsName, String unitName) {\n         this.metricsName = metricsName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458103", "bodyText": "please use log instead of e.printSTackTrace", "author": "moderakh", "createdAt": "2020-11-06T00:47:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MjEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520762104", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458644", "bodyText": "ideally we should use daemon threads otherwise if executor is not shutdown correctly JVM will not terminate.\nTake a look at how rntbd sets up its daemon IO threads.", "author": "moderakh", "createdAt": "2020-11-06T00:49:42Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTk4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761988", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\nindex c9944865444..3e3c739656d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java\n\n@@ -28,11 +28,12 @@ import java.time.Duration;\n import java.time.Instant;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n \n public class ClientTelemetry {\n-    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int ONE_KB_TO_BYTES = 1024;\n+    public final static int REQUEST_LATENCY_MAX_MICRO_SEC = 300000000;\n     public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n     public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n     public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518459015", "bodyText": "constant?", "author": "moderakh", "createdAt": "2020-11-06T00:50:55Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_CHARGE_NAME, ClientTelemetry.REQUEST_CHARGE_UNIT);\n+        ConcurrentDoubleHistogram requestChargeHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadRequestCharge);\n+        if (requestChargeHistogram != null) {\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+        } else {\n+            requestChargeHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_CHARGE_MAX, ClientTelemetry.REQUEST_CHARGE_PRECISION);\n+            requestChargeHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadRequestCharge,\n+                requestChargeHistogram);\n+        }\n+    }\n+\n+    private ReportPayload createReportPayload(CosmosAsyncClient cosmosAsyncClient,\n+                                              CosmosDiagnostics cosmosDiagnostics,\n+                                              int statusCode,\n+                                              Integer objectSize,\n+                                              String containerId,\n+                                              String databaseId,\n+                                              OperationType operationType,\n+                                              ResourceType resourceType,\n+                                              ConsistencyLevel consistencyLevel,\n+                                              String metricsName,\n+                                              String unitName) {\n+        ReportPayload reportPayload = new ReportPayload(metricsName, unitName);\n+        reportPayload.setRegionsContacted(BridgeInternal.getRegionContacted(cosmosDiagnostics).toString());\n+        reportPayload.setConsistency(consistencyLevel == null ?\n+            BridgeInternal.getContextClient(cosmosAsyncClient).getConsistencyLevel() :\n+            consistencyLevel);\n+        if (objectSize != null) {\n+            reportPayload.setGreaterThan1Kb(objectSize > 1024);", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTkyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761920", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\nindex 3345191d0f1..0ca0d4f0198 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n\n@@ -232,9 +232,9 @@ public class TracerProvider {\n             ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n         } else {\n             if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n-                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n             }\n \n             latencyHistogram.setAutoResize(true);\n"}}, {"oid": "80b2d75f73f2058994b5e1b5608f5a6da9438340", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80b2d75f73f2058994b5e1b5608f5a6da9438340", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-10T17:32:49Z", "type": "commit"}, {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "message": "resolving comments and merge with latest", "committedDate": "2020-11-10T17:40:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520915653", "bodyText": "Should be getRegionsContacted?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:30:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -70,6 +73,26 @@ public static CosmosDiagnostics createCosmosDiagnostics(DiagnosticsClientContext\n         return new CosmosDiagnostics(diagnosticsClientContext);\n     }\n \n+    @Warning(value = INTERNAL_USE_ONLY_WARNING)\n+    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044365", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-13T16:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\nindex 84593c41cb7..21278b33e7c 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\n\n@@ -74,7 +74,7 @@ public final class BridgeInternal {\n     }\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {\n+    public static Set<URI> getRegionsContacted(CosmosDiagnostics cosmosDiagnostics) {\n         return cosmosDiagnostics.clientSideRequestStatistics().getRegionsContacted();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520923344", "bodyText": "300 instead - to stick with 5 minutes which we used everywhere else? We can adjust if needed - but why not start with the default that works reasonably well in other places?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:47:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044244", "bodyText": "Discussed offline, will go with 10 minutes , and eventually will move to 5 min when we have answer where will be the endpoint", "author": "simplynaveen20", "createdAt": "2020-11-13T16:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925708", "bodyText": "I think the right groups here are\n200 - 299 --> success\n400 - 499 --> client_failure\n\n= 500 --> service failure", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:53:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0Mzc2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043764", "bodyText": "Discussed offline, changed success scenario to cover status code between 200-299", "author": "simplynaveen20", "createdAt": "2020-11-13T15:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\nindex 0ca0d4f0198..56849735e7b 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n\n@@ -231,7 +231,7 @@ public class TracerProvider {\n         if (latencyHistogram != null) {\n             ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n         } else {\n-            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+            if (statusCode >= HttpConstants.StatusCodes.MINIMUM_SUCCESS_STATUSCODE && statusCode <= HttpConstants.StatusCodes.MAXIMUM_SUCCESS_STATUSCODE) {\n                 latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n                 latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925913", "bodyText": "NIT ',' at teh end of the line", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:53:51Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\nindex 0ca0d4f0198..56849735e7b 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java\n\n@@ -231,7 +231,7 @@ public class TracerProvider {\n         if (latencyHistogram != null) {\n             ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n         } else {\n-            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+            if (statusCode >= HttpConstants.StatusCodes.MINIMUM_SUCCESS_STATUSCODE && statusCode <= HttpConstants.StatusCodes.MAXIMUM_SUCCESS_STATUSCODE) {\n                 latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n             } else {\n                 latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520926635", "bodyText": "VM SKU woudl be very helpful as well?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:55:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0MzM0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043349", "bodyText": "Discussed offline , added hostEnvInfo in format \"Linux|18.04-LTS|Standard_F4s|AzurePublicCloud\"", "author": "simplynaveen20", "createdAt": "2020-11-13T15:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\nindex 7450440913a..338bd98c0ee 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java\n\n@@ -2,10 +2,29 @@\n // Licensed under the MIT License.\n package com.azure.cosmos.implementation.clientTelemetry;\n \n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+\n public class AzureVMMetadata {\n     private Compute compute;\n+\n     public String getLocation() {\n-        return compute != null ? compute.getLocation() : null;\n+        return compute != null ? compute.getLocation() : StringUtils.EMPTY;\n+    }\n+\n+    public String getSku() {\n+        return compute != null ? compute.getSku() : StringUtils.EMPTY;\n+    }\n+\n+    public String getAzEnvironment() {\n+        return compute != null ? compute.getAzEnvironment() : StringUtils.EMPTY;\n+    }\n+\n+    public String getOsType() {\n+        return compute != null ? compute.getOsType() : StringUtils.EMPTY;\n+    }\n+\n+    public String getVmSize() {\n+        return compute != null ? compute.getVmSize() : StringUtils.EMPTY;\n     }\n \n     public Compute getCompute() {\n"}}, {"oid": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/096a55afd9559b20be0169c9ee9c7c1858f2813a", "message": "resolving comments", "committedDate": "2020-11-13T15:54:49Z", "type": "commit"}, {"oid": "00cadd2d4b6535811e3d6f3447387831a84ebe11", "url": "https://github.com/Azure/azure-sdk-for-java/commit/00cadd2d4b6535811e3d6f3447387831a84ebe11", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-13T15:56:16Z", "type": "commit"}, {"oid": "b9fc1870497e155351c762b0bf9a7b56f14c71f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9fc1870497e155351c762b0bf9a7b56f14c71f2", "message": "fixing build error", "committedDate": "2020-11-13T16:06:34Z", "type": "commit"}, {"oid": "06cfe0d223b216ae53212eed965da9b5f0dbe268", "url": "https://github.com/Azure/azure-sdk-for-java/commit/06cfe0d223b216ae53212eed965da9b5f0dbe268", "message": "resolving build error", "committedDate": "2020-11-13T16:23:20Z", "type": "commit"}, {"oid": "17b829eca5ff981b6352625f526490923e03a7b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17b829eca5ff981b6352625f526490923e03a7b9", "message": "moving before and after from simple to emulator for telemetry", "committedDate": "2020-11-13T16:36:44Z", "type": "commit"}, {"oid": "071f928e47bb7945ed473a391320309b96032421", "url": "https://github.com/Azure/azure-sdk-for-java/commit/071f928e47bb7945ed473a391320309b96032421", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-19T21:43:17Z", "type": "commit"}, {"oid": "c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "message": "merge with master and changing database field name in report payload", "committedDate": "2020-11-19T21:45:17Z", "type": "commit"}]}