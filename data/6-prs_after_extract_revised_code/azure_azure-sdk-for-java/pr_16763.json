{"pr_number": 16763, "pr_title": "Bulk API in Java", "pr_createdAt": "2020-10-23T15:42:38Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16763", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTYwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513571600", "bodyText": "4.8.0 is out", "author": "moderakh", "createdAt": "2020-10-28T16:08:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkProcessingUtil}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjI0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412247", "bodyText": "Ack. Changed. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\nindex 952a75eb2c7..3637669724a 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n\n@@ -8,9 +8,9 @@ import com.azure.cosmos.util.Beta;\n \n /**\n  * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n- * creating bulk request using {@link BulkProcessingUtil}.\n+ * creating bulk request using {@link BulkOperations}.\n  */\n-@Beta(Beta.SinceVersion.V4_7_0)\n+@Beta(Beta.SinceVersion.V4_8_0)\n public final class BulkItemRequestOptions {\n     private ConsistencyLevel consistencyLevel;\n     private String sessionToken;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513573386", "bodyText": "I don't see the api for CosmosContianer (sync version). could you please add that too.", "author": "moderakh", "createdAt": "2020-10-28T16:10:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,71 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n+     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0OTU0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513649547", "bodyText": "Yeah I meant to ask you, should be take a list of operations there(without flux) and pass it to async one?", "author": "rakkuma", "createdAt": "2020-10-28T17:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjMyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412325", "bodyText": "Have added sync api which takes list of operation and return list of responses.", "author": "rakkuma", "createdAt": "2020-11-03T03:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex 9a06aac5ea0..d9ab658c360 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -590,25 +590,24 @@ public class CosmosAsyncContainer {\n      * Executes flux of operations in Bulk.\n      *\n      * @param <TContext> The context for the bulk processing.\n-     *\n      * @param operations Flux of operation which will be executed by this container.\n      *\n-     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n      * <p>\n-     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n-     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n      * </p>\n      * <p>\n-     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n-     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n      *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n      *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n      * </p>\n-     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n      * get the exception.\n      */\n-    @Beta(Beta.SinceVersion.V4_7_0)\n-    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(\n+    @Beta(Beta.SinceVersion.V4_8_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n         Flux<CosmosItemOperation> operations) {\n \n         return this.processBulkOperations(operations, new BulkProcessingOptions<>());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NjY3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513576677", "bodyText": "please eat the \"Assertions\" into static import similar to other tests. here and elsewhere.", "author": "moderakh", "createdAt": "2020-10-28T16:15:16Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.models.PartitionKey;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.api.Assertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class CosmosBulkTest extends BatchTestBase {\n+\n+    private CosmosAsyncClient bulkClient;\n+    private CosmosAsyncContainer bulkAsyncContainer;\n+\n+    @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n+    public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosBulkTest() {\n+        assertThat(this.bulkClient).isNull();\n+        this.bulkClient = getClientBuilder().buildAsyncClient();\n+        bulkAsyncContainer = getSharedMultiPartitionCosmosContainer(this.bulkClient);\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseAsync(this.bulkClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void createItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        Flux<CosmosItemOperation> cosmosItemOperationFlux = Flux.merge(\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                TestDoc testDoc = this.populateTestDoc(partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey));\n+            }),\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                EventDoc eventDoc = new EventDoc(UUID.randomUUID().toString(), 2, 4, \"type1\", partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(eventDoc, new PartitionKey(partitionKey));\n+            }));\n+\n+        BulkProcessingOptions<CosmosBulkTest> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<CosmosBulkTest>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(cosmosItemOperationFlux, bulkProcessingOptions);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        responseFlux\n+            .flatMap((CosmosBulkOperationRequestAndResponse<CosmosBulkTest> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest * 2);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void upsertItem_withbulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(1);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<Object>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(Flux.fromIterable(cosmosItemOperations));\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        responseFlux\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.CREATED.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                Assertions.assertThat(cosmosBulkOperationRequestAndResponse.getOperation()).isEqualTo(cosmosItemOperations.get(testDoc.getCost()));\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosBulkOperationRequestAndResponse.getOperation().getItem());\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void deleteItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> deleteCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkDeleteItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<TestDoc> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(1);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        bulkAsyncContainer\n+            .processBulkOperations(deleteCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<TestDoc> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.NO_CONTENT.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void readItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> readCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkReadItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>(Object.class);\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+        bulkAsyncContainer\n+            .processBulkOperations(readCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkItemResponse);\n+            }).blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void readItemMultipleTimes_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        List<CosmosItemOperation> cosmosItemOperations = new ArrayList<>();\n+\n+        for (int i = 0; i < totalRequest; i++) {\n+            String partitionKey = UUID.randomUUID().toString();\n+\n+            // use i as a identifier for re check.\n+            TestDoc testDoc = this.populateTestDoc(partitionKey, i, 20);\n+\n+            cosmosItemOperations.add(BulkProcessingUtil.getBulkUpsertItemOperation(testDoc, new PartitionKey(partitionKey)));\n+        }\n+\n+        createItemsAndVerify(cosmosItemOperations);\n+\n+        Flux<CosmosItemOperation> readCosmosItemOperationFlux =\n+            Flux.fromIterable(cosmosItemOperations).map((CosmosItemOperation cosmosItemOperation) -> {\n+                TestDoc testDoc = cosmosItemOperation.getItem();\n+                return BulkProcessingUtil.getBulkReadItemOperation(testDoc.getId(), cosmosItemOperation.getPartitionKeyValue());\n+            });\n+\n+        BulkProcessingOptions<Object> bulkProcessingOptions = new BulkProcessingOptions<>(Object.class);\n+        bulkProcessingOptions.setMaxMicroBatchSize(30);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        HashSet<TestDoc> distinctDocs = new HashSet<>();\n+        AtomicInteger processedDoc = new AtomicInteger(0);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<Object>> readResponseFlux = bulkAsyncContainer\n+            .processBulkOperations(readCosmosItemOperationFlux, bulkProcessingOptions)\n+            .flatMap((CosmosBulkOperationRequestAndResponse<Object> cosmosBulkOperationRequestAndResponse) -> {\n+\n+                processedDoc.incrementAndGet();\n+\n+                CosmosBulkItemResponse cosmosBulkItemResponse = cosmosBulkOperationRequestAndResponse.getResponse();\n+                Assertions.assertThat(cosmosBulkItemResponse.getStatusCode()).isEqualTo(HttpResponseStatus.OK.code());\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isGreaterThan(0);\n+                Assertions.assertThat(cosmosBulkItemResponse.getCosmosDiagnostics().toString()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getSessionToken()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getActivityId()).isNotNull();\n+                Assertions.assertThat(cosmosBulkItemResponse.getRequestCharge()).isNotNull();\n+\n+                // Using cost as list index like we assigned\n+                TestDoc testDoc = cosmosBulkItemResponse.getItem(TestDoc.class);\n+                distinctDocs.add(testDoc);\n+                Assertions.assertThat(testDoc).isEqualTo(cosmosItemOperations.get(testDoc.getCost()).getItem());\n+\n+                return Mono.just(cosmosBulkOperationRequestAndResponse);\n+            });\n+\n+        // Subscribe first time\n+        readResponseFlux\n+            .blockLast();\n+\n+        Assertions.assertThat(processedDoc.get()).isEqualTo(totalRequest);", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjM1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412356", "bodyText": "Ack. Done. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NjY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\nindex f73a265dbd4..aafc359d8e5 100644\n--- a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\n+++ b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\n\n@@ -5,27 +5,27 @@ package com.azure.cosmos;\n \n import com.azure.cosmos.models.PartitionKey;\n import io.netty.handler.codec.http.HttpResponseStatus;\n-import org.assertj.core.api.Assertions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Factory;\n import org.testng.annotations.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Random;\n import java.util.UUID;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-public class CosmosBulkTest extends BatchTestBase {\n+public class CosmosBulkTest  extends BatchTestBase {\n \n-    private CosmosAsyncClient bulkClient;\n-    private CosmosAsyncContainer bulkAsyncContainer;\n+    private final static Logger logger = LoggerFactory.getLogger(CosmosBulkAsyncTest.class);\n+\n+    private CosmosClient bulkClient;\n+    private CosmosContainer bulkContainer;\n \n     @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n     public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513622703", "bodyText": "@FabianMeiswinkel @kushagraThapar @kirankumarkolli thought on the naming?", "author": "moderakh", "createdAt": "2020-10-28T17:16:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingUtil.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class BulkProcessingUtil {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MTAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515891001", "bodyText": "My preference would be:\nBulkOperations as the class name\nFactory method names as newCreateItemOperation(T item, PartitionKey partitionKey) or newReadItemOperation(String id, PartitionKey partitionKey)\nI think the bulk can get removed because that is clear from the class name of the factory\nI like the newXXX naming convention for factory methods beter than createXXX - but would prefer either of them over getXXX", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412762", "bodyText": "Have changed class to BulkOperations, seems better actually. Have changed function names too. CreateXXX is confusing to me too as we have create as an operation too. newXXX seems fine, so changed it for now.", "author": "rakkuma", "createdAt": "2020-11-03T03:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MjY5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518042690", "bodyText": "LGTM now - thanks!", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzAxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518437013", "bodyText": "BulkOperations looks good to me too.", "author": "kushagraThapar", "createdAt": "2020-11-05T23:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMjcwMw=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingUtil.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingUtil.java\ndeleted file mode 100644\nindex d289fd727b5..00000000000\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingUtil.java\n+++ /dev/null\n\n@@ -1,265 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.cosmos;\n-\n-import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n-import com.azure.cosmos.models.PartitionKey;\n-import com.azure.cosmos.util.Beta;\n-import reactor.core.publisher.Flux;\n-\n-import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n-\n-/**\n- * Utility for creating bulk operations which can be executed by calling\n- * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n- *\n- * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n- * a {@link BulkItemRequestOptions} while creating the bulk operation.\n- *\n- * See also {@link BulkProcessingOptions}.\n- */\n-@Beta(Beta.SinceVersion.V4_7_0)\n-public final class BulkProcessingUtil {\n-\n-    /**\n-     * Instantiate an operation for Creating item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be created.\n-     *\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkCreateItemOperation(T item, PartitionKey partitionKey) {\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-        return getBulkCreateItemOperation(item, partitionKey, new BulkItemRequestOptions());\n-    }\n-\n-    /**\n-     * Instantiate an operation for Creating item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be created.\n-     *\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation.\n-     * @param requestOptions The options for the item request.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkCreateItemOperation(\n-        T item,\n-        PartitionKey partitionKey,\n-        BulkItemRequestOptions requestOptions) {\n-\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        if (requestOptions == null) {\n-            requestOptions = new BulkItemRequestOptions();\n-        }\n-\n-        return new ItemBulkOperation<>(\n-            CosmosItemOperationType.CREATE,\n-            null,\n-            partitionKey,\n-            requestOptions.toRequestOptions(),\n-            item\n-        );\n-    }\n-\n-    /**\n-     * Instantiate an operation for deleting item in Bulk execution.\n-     *\n-     * @param id The unique id of the item.\n-     * @param partitionKey the partition key for the operation.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static CosmosItemOperation getBulkDeleteItemOperation(String id, PartitionKey partitionKey) {\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        return getBulkDeleteItemOperation(id, partitionKey, new BulkItemRequestOptions());\n-    }\n-\n-    /**\n-     * Instantiate an operation for deleting item in Bulk execution.\n-     *\n-     * @param id The unique id of the item.\n-     * @param partitionKey the partition key for the operation..\n-     * @param requestOptions The options for the item request.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static CosmosItemOperation getBulkDeleteItemOperation(\n-        String id,\n-        PartitionKey partitionKey,\n-        BulkItemRequestOptions requestOptions) {\n-\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        if (requestOptions == null) {\n-            requestOptions = new BulkItemRequestOptions();\n-        }\n-\n-        return new ItemBulkOperation<>(\n-            CosmosItemOperationType.DELETE,\n-            id,\n-            partitionKey,\n-            requestOptions.toRequestOptions(),\n-            null\n-        );\n-    }\n-\n-    /**\n-     * Instantiate an operation for read item in Bulk execution.\n-     *\n-     * @param id The unique id of the item.\n-     * @param partitionKey the partition key for the operation.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static CosmosItemOperation getBulkReadItemOperation(String id, PartitionKey partitionKey) {\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        return getBulkReadItemOperation(id, partitionKey, new BulkItemRequestOptions());\n-    }\n-\n-    /**\n-     * Instantiate an operation for read item in Bulk execution.\n-     *\n-     * @param id The unique id of the item.\n-     * @param partitionKey the partition key for the operation..\n-     * @param requestOptions The options for the item request.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static CosmosItemOperation getBulkReadItemOperation(\n-        String id,\n-        PartitionKey partitionKey,\n-        BulkItemRequestOptions requestOptions) {\n-\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        if (requestOptions == null) {\n-            requestOptions = new BulkItemRequestOptions();\n-        }\n-\n-        return new ItemBulkOperation<>(\n-            CosmosItemOperationType.READ,\n-            id,\n-            partitionKey,\n-            requestOptions.toRequestOptions(),\n-            null\n-        );\n-    }\n-\n-    /**\n-     * Instantiate an operation for replace item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be replaced.\n-     *\n-     * @param id The unique id of the item.\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkReplaceItemOperation(String id, T item, PartitionKey partitionKey) {\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        return getBulkReplaceItemOperation(id, item, partitionKey, new BulkItemRequestOptions());\n-    }\n-\n-    /**\n-     * Instantiate an operation for replace item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be replaced.\n-     *\n-     * @param id The unique id of the item..\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation.\n-     * @param requestOptions The options for the item request.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkReplaceItemOperation(\n-        String id,\n-        T item,\n-        PartitionKey partitionKey,\n-        BulkItemRequestOptions requestOptions) {\n-\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(id, \"expected non-null id\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        if (requestOptions == null) {\n-            requestOptions = new BulkItemRequestOptions();\n-        }\n-\n-        return new ItemBulkOperation<T>(\n-            CosmosItemOperationType.REPLACE,\n-            id,\n-            partitionKey,\n-            requestOptions.toRequestOptions(),\n-            item\n-        );\n-    }\n-\n-    /**\n-     * Instantiate an operation for upsert item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be upserted.\n-     *\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkUpsertItemOperation(T item, PartitionKey partitionKey) {\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-\n-        return getBulkUpsertItemOperation(item, partitionKey, new BulkItemRequestOptions());\n-    }\n-\n-    /**\n-     * Instantiate an operation for upsert item in Bulk execution.\n-     *\n-     * @param <T> The type of item to be upserted.\n-     *\n-     * @param item A JSON serializable object that must contain an id property.\n-     * @param partitionKey the partition key for the operation.\n-     * @param requestOptions The options for the item request.\n-     *\n-     * @return the bulk operation.\n-     */\n-    public static <T> CosmosItemOperation getBulkUpsertItemOperation(\n-        T item,\n-        PartitionKey partitionKey,\n-        BulkItemRequestOptions requestOptions) {\n-\n-        checkNotNull(item, \"expected non-null item\");\n-        checkNotNull(partitionKey, \"expected non-null partitionKey\");\n-        \n-        if (requestOptions == null) {\n-            requestOptions = new BulkItemRequestOptions();\n-        }\n-\n-        return new ItemBulkOperation<T>(\n-            CosmosItemOperationType.UPSERT,\n-            null,\n-            partitionKey,\n-            requestOptions.toRequestOptions(),\n-            item\n-        );\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNTUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513625527", "bodyText": "if the input operations Flux sends error signal, what is the expected behaviour?\nWe should have a test for this scenario to validate the behaviour.", "author": "moderakh", "createdAt": "2020-10-28T17:20:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,71 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n+     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_7_0)\n+    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations) {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NTQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513655457", "bodyText": "Ack. Will do that. Thanks.", "author": "rakkuma", "createdAt": "2020-10-28T18:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNTUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex 9a06aac5ea0..d9ab658c360 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -590,25 +590,24 @@ public class CosmosAsyncContainer {\n      * Executes flux of operations in Bulk.\n      *\n      * @param <TContext> The context for the bulk processing.\n-     *\n      * @param operations Flux of operation which will be executed by this container.\n      *\n-     * @return A Flux of {@link CosmosBulkOperationRequestAndResponse} which contains operation and it's response or exception.\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n      * <p>\n-     *     To create a operation which can be executed here, use {@link BulkProcessingUtil}. For eg.\n-     *     for a upsert operation use {@link BulkProcessingUtil#getBulkUpsertItemOperation(Object, PartitionKey)}\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n      * </p>\n      * <p>\n-     *     We can get the corresponding operation using {@link CosmosBulkOperationRequestAndResponse#getOperation()} and\n-     *     it's response using {@link CosmosBulkOperationRequestAndResponse#getResponse()}. If the operation was executed\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n      *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n      *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n      * </p>\n-     * To check if the operation had any exception, use {@link CosmosBulkOperationRequestAndResponse#getThrowable()} to\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n      * get the exception.\n      */\n-    @Beta(Beta.SinceVersion.V4_7_0)\n-    public <TContext> Flux<CosmosBulkOperationRequestAndResponse<TContext>> processBulkOperations(\n+    @Beta(Beta.SinceVersion.V4_8_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n         Flux<CosmosItemOperation> operations) {\n \n         return this.processBulkOperations(operations, new BulkProcessingOptions<>());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513627941", "bodyText": "Could you paste a sample CosmosDiagnostics for bulk operation somewhere in the PR description? I wonder with all the newly introduced retries how it will look like.", "author": "moderakh", "createdAt": "2020-10-28T17:23:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {\n+        T item = null;\n+\n+        if (this.getResourceObject() != null) {\n+            item = new JsonSerializable(this.getResourceObject()).toObject(type);\n+        }\n+\n+        return item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfterDuration() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code associated with the current result.\n+     *\n+     * @return the sub status code\n+     */\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.statusCode && this.statusCode <= 299;\n+    }\n+\n+    /**\n+     * Gets the HTTP status code associated with the current result.\n+     *\n+     * @return the status code.\n+     */\n+    public int getStatusCode() {\n+        return this.statusCode;\n+    }\n+\n+    /**\n+     * Gets the cosmos diagnostic for this operation.\n+     *\n+     * @return the CosmosDiagnostics{@link CosmosDiagnostics}\n+     */\n+    public CosmosDiagnostics getCosmosDiagnostics() {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1MjI1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513652252", "bodyText": "Right now in case there is a partial retry, it will have diagnostic for the last successful batch request as we don't have diagnostic operation wise.\nIf it's permissible to initialize one diagnostic operation wise then we can do some sort of merging there every time a batch request is executed? This will also help in adding diagnostic for getting partition key range id.", "author": "rakkuma", "createdAt": "2020-10-28T17:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mjk3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515892974", "bodyText": "Let's start with providing the sample here - then we can review whether it is sufficient or how we want to evolve it - makes sense?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyNzMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516727318", "bodyText": "Sure. So this is the sample for a direct TCP. You can see operation type batch and it's headers here. The response has session token and all.\n{\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":3533,\"requestStartTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"requestEndTimeUTC\":\"2020-11-03T14:09:58.209Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[{\"storeResult\":{\"storePhysicalAddress\":\"rntbd://cdb-ms-stage-eastus2-fd4.documents-staging.windows-ppe.net:14013/apps/b5716ed2-296e-4856-89aa-03d65f8dd46b/services/715cd67d-5ed6-4dd0-a256-bc574a605d13/partitions/6fb56c52-6f2f-4a37-a578-199d36bac8d2/replicas/132488385023590763p/\",\"lsn\":4,\"globalCommittedLsn\":3,\"partitionKeyRangeId\":\"1\",\"isValid\":true,\"statusCode\":200,\"subStatusCode\":0,\"isGone\":false,\"isNotFound\":false,\"isInvalidPartition\":false,\"requestCharge\":606.67,\"itemLSN\":-1,\"sessionToken\":\"-1#4\",\"exception\":null,\"transportRequestTimeline\":[{\"eventName\":\"created\",\"startTimeUTC\":\"2020-11-03T14:09:55.567Z\"},{\"eventName\":\"queued\",\"startTimeUTC\":\"2020-11-03T14:09:55.652Z\"},{\"eventName\":\"channelAcquisitionStarted\",\"startTimeUTC\":\"2020-11-03T14:09:55.652Z\"},{\"eventName\":\"pipelined\",\"startTimeUTC\":\"2020-11-03T14:09:57.185Z\"},{\"eventName\":\"transitTime\",\"startTimeUTC\":\"2020-11-03T14:09:57.256Z\"},{\"eventName\":\"received\",\"startTimeUTC\":\"2020-11-03T14:09:58.195Z\"},{\"eventName\":\"completed\",\"startTimeUTC\":\"2020-11-03T14:09:58.209Z\"}],\"rntbdRequestLengthInBytes\":22674,\"rntbdResponseLengthInBytes\":43263,\"requestPayloadLengthInBytes\":22186,\"responsePayloadLengthInBytes\":42934,\"channelTaskQueueSize\":0,\"pendingRequestsCount\":0,\"serviceEndpointStatistics\":{\"availableChannels\":0,\"acquiredChannels\":0,\"executorTaskQueueSize\":0,\"inflightRequests\":1,\"lastSuccessfulRequestTime\":\"2020-11-03T14:09:55.600Z\",\"lastRequestTime\":\"2020-11-03T14:09:55.600Z\",\"createdTime\":\"2020-11-03T14:09:55.578Z\",\"isClosed\":false}},\"requestResponseTimeUTC\":\"2020-11-03T14:09:58.209Z\",\"requestResourceType\":\"Document\",\"requestOperationType\":\"Batch\"}],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{\"3fa7837d-1dde-11eb-804d-03762526cb03\":{\"startTimeUTC\":\"2020-11-03T14:09:55.282Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.561Z\",\"targetEndpoint\":\"https://rakkumastage-eastus2.documents-staging.windows-ppe.net:443/addresses/?$resolveFor=dbs%2FwEo8AA%3D%3D%2Fcolls%2FwEo8AJyCb1o%3D%2Fdocs&$filter=protocol%20eq%20rntbd&$partitionKeyRangeIds=1\",\"errorMessage\":null,\"inflightRequest\":false}},\"regionsContacted\":[\"https://rakkumastage-eastus2.documents-staging.windows-ppe.net:443/\"],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":[{\"metaDataName\":\"CONTAINER_LOOK_UP\",\"startTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.281Z\",\"durationinMS\":605},{\"metaDataName\":\"SERVER_ADDRESS_LOOKUP\",\"startTimeUTC\":\"2020-11-03T14:09:55.282Z\",\"endTimeUTC\":\"2020-11-03T14:09:55.561Z\",\"durationinMS\":279}]},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"endTimeUTC\":\"2020-11-03T14:09:54.676Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"46861 KB\",\"availableMemory\":\"1817331 KB\",\"systemCpuLoad\":\"(2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.474Z 12.9%), (2020-11-03T14:09:49.588Z 12.9%), (2020-11-03T14:09:54.596Z 8.6%)\"},\"clientCfgs\":{\"id\":-3,\"numberOfClients\":4,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}\nFor a gone exception(changed the pk range in code to get a gone):\nException:\nPartitionKeyRangeGoneException{userAgent=azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211, error={\"Errors\":[\"The requested resource is no longer available at the server.\"]}, resourceAddress='null', requestUri='null', statusCode=410, message=[\"The requested resource is no longer available at the server.\"], {\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":0,\"requestStartTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"requestEndTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{},\"regionsContacted\":[],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":null},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"endTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"59794 KB\",\"availableMemory\":\"1804398 KB\",\"systemCpuLoad\":\"(2020-11-03T14:48:01.426Z 20.5%), (2020-11-03T14:48:05.116Z 9.8%), (2020-11-03T14:48:10.120Z 16.0%)\"},\"clientCfgs\":{\"id\":-1,\"numberOfClients\":2,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}, causeInfo=null, responseHeaders={x-ms-current-replica-set-size=4, x-ms-last-state-change-utc=Fri, 30 Oct 2020 16:31:52.563 GMT, lsn=1, x-ms-request-charge=0.00, x-ms-schemaversion=1.10, x-ms-transport-request-id=2, x-ms-number-of-read-regions=0, x-ms-current-write-quorum=3, x-ms-cosmos-quorum-acked-llsn=1, x-ms-quorum-acked-lsn=1, x-ms-activity-id=98d2de0c-1de3-11eb-8335-5de6f3380958, x-ms-xp-role=1, x-ms-global-Committed-lsn=1, x-ms-item-count=10, x-ms-cosmos-llsn=1, x-ms-serviceversion= version=2.11.0.0, x-ms-substatus=1002}, requestHeaders=null}\nDiagnostic for the same:\n{\"userAgent\":\"azsdk-java-cosmos/4.9.0-beta.1 Windows10/10.0 JRE/1.8.0_211\",\"requestLatencyInMs\":0,\"requestStartTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"requestEndTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"connectionMode\":\"DIRECT\",\"responseStatisticsList\":[],\"supplementalResponseStatisticsList\":[],\"addressResolutionStatistics\":{},\"regionsContacted\":[],\"retryContext\":{\"retryCount\":0,\"statusAndSubStatusCodes\":null,\"retryLatency\":0},\"metadataDiagnosticsContext\":{\"metadataDiagnosticList\":null},\"serializationDiagnosticsContext\":{\"serializationDiagnosticsList\":[{\"serializationType\":\"ITEM_SERIALIZATION\",\"startTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"endTimeUTC\":\"2020-11-03T14:48:12.367Z\",\"durationInMicroSec\":0}]},\"gatewayStatistics\":null,\"systemInformation\":{\"usedMemory\":\"59794 KB\",\"availableMemory\":\"1804398 KB\",\"systemCpuLoad\":\"(2020-11-03T14:48:01.426Z 20.5%), (2020-11-03T14:48:05.116Z 9.8%), (2020-11-03T14:48:10.120Z 16.0%)\"},\"clientCfgs\":{\"id\":-1,\"numberOfClients\":2,\"connCfg\":{\"rntbd\":\"(cto:PT5S, rto:PT5S, icto:PT0S, ieto:PT1H, mcpe:130, mrpc:30, cer:false)\",\"gw\":\"(cps:1000, rto:PT5S, icto:null, p:false)\",\"other\":\"(ed: true, cs: false)\"},\"consistencyCfg\":\"(consistency: Session, mm: true, prgns: [])\"}}", "author": "rakkuma", "createdAt": "2020-11-03T14:54:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516729103", "bodyText": "The retry logic works in gone, have tested all the test case with a one time gone exception such that if retry attempt is one, keep the valid pk range. But we need to fix the diagnostic such that it tracks this retry and any retry due to partial  throttling.", "author": "rakkuma", "createdAt": "2020-11-03T14:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNzk0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex 1fc24f0f003..ee9cada8884 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -19,7 +19,7 @@ import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNo\n  * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n  *\n  */\n-@Beta(Beta.SinceVersion.V4_7_0)\n+@Beta(Beta.SinceVersion.V4_8_0)\n public final class CosmosBulkItemResponse {\n \n     private final String eTag;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513635788", "bodyText": "now that we are setting partitionKeyRangeId explicitly how do we support partition split scenario?\nIf after populating pkrangeId here partition gets splitted how do we react? what would be the the sequence of actions on partition split?", "author": "moderakh", "createdAt": "2020-10-28T17:34:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1330,8 @@ private RxDocumentServiceRequest addBatchHeaders(RxDocumentServiceRequest reques\n \n             request.setPartitionKeyInternal(partitionKeyInternal);\n             request.getHeaders().put(HttpConstants.HttpHeaders.PARTITION_KEY, Utils.escapeNonAscii(partitionKeyInternal.toJson()));\n+        } else if(serverBatchRequest instanceof PartitionKeyRangeServerBatchRequest) {\n+            request.setPartitionKeyRangeIdentity(new PartitionKeyRangeIdentity(((PartitionKeyRangeServerBatchRequest) serverBatchRequest).getPartitionKeyRangeId()));", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1MzY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513653643", "bodyText": "Right now we will just return a gone and we can expect user to retry. To support that retry we have to move sink before grouping operations or keep two sinks for different retries i.e. one for throttling and one for gone.", "author": "rakkuma", "createdAt": "2020-10-28T18:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NTI5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515895299", "bodyText": "I think we need to provide that retry-logic out-of-the-box (vs. expecting users to do it)", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwNzAyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520307025", "bodyText": "The older bulk executor has support for partition splits... we should try to get at least the same with the new implementation.\nI think this whole retry logic might need some careful thought; ideally for any CosmosItemOperation that needs to be retried, it gets added back into the producer (Flux) after some initial logic that will take care of delays or handling partition splitting...", "author": "milismsft", "createdAt": "2020-11-10T06:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxNTc2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520315767", "bodyText": "Do we get any delay information for split case? If yes we can add logic for it, otherwise we have retry for individual operations and does it only once.", "author": "rakkuma", "createdAt": "2020-11-10T06:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMTk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520321943", "bodyText": "Yes, there's a substatus code that indicates the failure is caused by a split; see https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java#L128", "author": "milismsft", "createdAt": "2020-11-10T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMzc3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520323776", "bodyText": "Yeah, so we are using it to put the operation in correct sink or if retry option is exhausted, return the exception.", "author": "rakkuma", "createdAt": "2020-11-10T06:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMDUyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520930527", "bodyText": "physical partitioning of data and partition split are internal details of our service implementation. We should not expose this to the end user as contract.\nThe sdk needs to retry on partition spit internally. we do this for other operations today.\nThis can go to a different PR, but without it we can't announce bulk as feature.", "author": "moderakh", "createdAt": "2020-11-10T23:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MDcxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521080714", "bodyText": "we are retrying here. And I am keeping the retry policy in ItemBulkOperation but we are not returning ItemBulkOperation, we are returning CosmosItemOperation.", "author": "rakkuma", "createdAt": "2020-11-11T03:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTc4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513638484", "bodyText": "previously RxClientCollectionCache was only used in RxDocumentClientImp and we always ensured that the passed connectionLink is normalized on leading or ending \"/\".\nThat's important as it ensures due to a mismatch on leading or ending \"/\" we don't get a mismatch.\nWe should ensure we are doing normalization of the containerLink similarly here.\nCould you validate this?", "author": "moderakh", "createdAt": "2020-10-28T17:38:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n+import com.azure.cosmos.implementation.routing.CollectionRoutingMap;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper.getEffectivePartitionKeyString;\n+\n+final class BulkExecutorUtil {\n+\n+    static ServerOperationBatchRequest createBatchRequest(List<CosmosItemOperation> operations, String partitionKeyRangeId) {\n+\n+        return PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+            partitionKeyRangeId,\n+            operations,\n+            BatchRequestResponseConstant.MAX_DIRECT_MODE_BATCH_REQUEST_BODY_SIZE_IN_BYTES,\n+            BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST);\n+    }\n+\n+    static void setRetryPolicyForBulk(CosmosItemOperation cosmosItemOperation, ThrottlingRetryOptions throttlingRetryOptions) {\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+\n+            ResourceThrottleRetryPolicy resourceThrottleRetryPolicy = new ResourceThrottleRetryPolicy(\n+                throttlingRetryOptions.getMaxRetryAttemptsOnThrottledRequests(),\n+                throttlingRetryOptions.getMaxRetryWaitTime());\n+\n+            itemBulkOperation.setRetryPolicy(resourceThrottleRetryPolicy);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    static Mono<IRetryPolicy.ShouldRetryResult> shouldRetryForOperationResult(TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+        CosmosItemOperation cosmosItemOperation = result.getOperation();\n+\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+\n+            // Create CosmosException for the next retry policy to understand:\n+            CosmosException exception = BridgeInternal.createCosmosException(\n+                result.getStatusCode(),\n+                null,\n+                BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+            ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+            return itemBulkOperation.getRetryPolicy().shouldRetry(exception);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static Map<String, String> getResponseHeadersFromBatchOperationResult(TransactionalBatchOperationResult result) {\n+        final Map<String, String> headers = new HashMap<>();\n+\n+        headers.put(HttpConstants.HttpHeaders.SUB_STATUS, String.valueOf(result.getSubStatusCode()));\n+        headers.put(HttpConstants.HttpHeaders.E_TAG, result.getETag());\n+        headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, String.valueOf(result.getRequestCharge()));\n+\n+        if (result.getRetryAfterDuration() != null) {\n+            headers.put(HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS, String.valueOf(result.getRetryAfterDuration().toMillis()));\n+        }\n+\n+        return headers;\n+    }\n+\n+    // TODO: metaDataDiagnosticContext is passed as null. Better way is to add this context to the cosmos diagnostic.\n+    static Mono<String> resolvePartitionKeyRangeId(\n+        AsyncDocumentClient docClientWrapper,\n+        CosmosAsyncContainer container,\n+        CosmosItemOperation operation) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        if(operation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) operation;\n+\n+            final Mono<String> pkRangeIdMono = BulkExecutorUtil.getCollectionInfoAsync(docClientWrapper, container)\n+                .flatMap(collection -> {\n+                    final PartitionKeyDefinition definition = collection.getPartitionKey();\n+                    final PartitionKeyInternal partitionKeyInternal = getPartitionKeyInternal(operation, definition);\n+                    itemBulkOperation.setPartitionKeyJson(partitionKeyInternal.toJson());\n+\n+                    return docClientWrapper.getPartitionKeyRangeCache()\n+                        .tryLookupAsync(null, collection.getResourceId(), null, null)\n+                        .map((Utils.ValueHolder<CollectionRoutingMap> routingMap) -> {\n+\n+                            return routingMap.v.getRangeByEffectivePartitionKey(\n+                                getEffectivePartitionKeyString(\n+                                    partitionKeyInternal,\n+                                    definition)).getId();\n+                        });\n+                });\n+\n+            return pkRangeIdMono;\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static PartitionKeyInternal getPartitionKeyInternal(\n+        final CosmosItemOperation operation,\n+        final PartitionKeyDefinition partitionKeyDefinition) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        final PartitionKey partitionKey = operation.getPartitionKeyValue();\n+        if (partitionKey == null) {\n+            return ModelBridgeInternal.getNonePartitionKey(partitionKeyDefinition);\n+        } else {\n+            return BridgeInternal.getPartitionKeyInternal(partitionKey);\n+        }\n+    }\n+\n+    private static Mono<DocumentCollection> getCollectionInfoAsync(AsyncDocumentClient documentClient,\n+                                                                   CosmosAsyncContainer container) {\n+        final RxClientCollectionCache clientCollectionCache = documentClient.getCollectionCache();\n+        return clientCollectionCache\n+            .resolveByNameAsync(\n+                null,\n+                BridgeInternal.getLink(container),", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY0MDg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516640862", "bodyText": "Have used the same way we sanitize in RxDocumentClientImp, using Utils.joinPath(BridgeInternal.getLink(container), null). This should ensure the above condition is always satisified.", "author": "rakkuma", "createdAt": "2020-11-03T12:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\nindex 14c5ba0904c..07ee8f6a06d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\n\n@@ -5,14 +5,12 @@ package com.azure.cosmos.implementation.batch;\n \n import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.CosmosAsyncContainer;\n-import com.azure.cosmos.CosmosException;\n import com.azure.cosmos.CosmosItemOperation;\n import com.azure.cosmos.ThrottlingRetryOptions;\n import com.azure.cosmos.TransactionalBatchOperationResult;\n import com.azure.cosmos.implementation.AsyncDocumentClient;\n import com.azure.cosmos.implementation.DocumentCollection;\n import com.azure.cosmos.implementation.HttpConstants;\n-import com.azure.cosmos.implementation.IRetryPolicy;\n import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513638797", "bodyText": "doesn't passing null, result in missing to add this step to request diagnostics?", "author": "moderakh", "createdAt": "2020-10-28T17:38:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n+import com.azure.cosmos.implementation.routing.CollectionRoutingMap;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+import static com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper.getEffectivePartitionKeyString;\n+\n+final class BulkExecutorUtil {\n+\n+    static ServerOperationBatchRequest createBatchRequest(List<CosmosItemOperation> operations, String partitionKeyRangeId) {\n+\n+        return PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+            partitionKeyRangeId,\n+            operations,\n+            BatchRequestResponseConstant.MAX_DIRECT_MODE_BATCH_REQUEST_BODY_SIZE_IN_BYTES,\n+            BatchRequestResponseConstant.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST);\n+    }\n+\n+    static void setRetryPolicyForBulk(CosmosItemOperation cosmosItemOperation, ThrottlingRetryOptions throttlingRetryOptions) {\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+\n+            ResourceThrottleRetryPolicy resourceThrottleRetryPolicy = new ResourceThrottleRetryPolicy(\n+                throttlingRetryOptions.getMaxRetryAttemptsOnThrottledRequests(),\n+                throttlingRetryOptions.getMaxRetryWaitTime());\n+\n+            itemBulkOperation.setRetryPolicy(resourceThrottleRetryPolicy);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    static Mono<IRetryPolicy.ShouldRetryResult> shouldRetryForOperationResult(TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+        CosmosItemOperation cosmosItemOperation = result.getOperation();\n+\n+        if(cosmosItemOperation instanceof ItemBulkOperation<?>) {\n+\n+            // Create CosmosException for the next retry policy to understand:\n+            CosmosException exception = BridgeInternal.createCosmosException(\n+                result.getStatusCode(),\n+                null,\n+                BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+            ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) cosmosItemOperation;\n+            return itemBulkOperation.getRetryPolicy().shouldRetry(exception);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static Map<String, String> getResponseHeadersFromBatchOperationResult(TransactionalBatchOperationResult result) {\n+        final Map<String, String> headers = new HashMap<>();\n+\n+        headers.put(HttpConstants.HttpHeaders.SUB_STATUS, String.valueOf(result.getSubStatusCode()));\n+        headers.put(HttpConstants.HttpHeaders.E_TAG, result.getETag());\n+        headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, String.valueOf(result.getRequestCharge()));\n+\n+        if (result.getRetryAfterDuration() != null) {\n+            headers.put(HttpConstants.HttpHeaders.RETRY_AFTER_IN_MILLISECONDS, String.valueOf(result.getRetryAfterDuration().toMillis()));\n+        }\n+\n+        return headers;\n+    }\n+\n+    // TODO: metaDataDiagnosticContext is passed as null. Better way is to add this context to the cosmos diagnostic.\n+    static Mono<String> resolvePartitionKeyRangeId(\n+        AsyncDocumentClient docClientWrapper,\n+        CosmosAsyncContainer container,\n+        CosmosItemOperation operation) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        if(operation instanceof ItemBulkOperation<?>) {\n+            final ItemBulkOperation<?> itemBulkOperation = (ItemBulkOperation<?>) operation;\n+\n+            final Mono<String> pkRangeIdMono = BulkExecutorUtil.getCollectionInfoAsync(docClientWrapper, container)\n+                .flatMap(collection -> {\n+                    final PartitionKeyDefinition definition = collection.getPartitionKey();\n+                    final PartitionKeyInternal partitionKeyInternal = getPartitionKeyInternal(operation, definition);\n+                    itemBulkOperation.setPartitionKeyJson(partitionKeyInternal.toJson());\n+\n+                    return docClientWrapper.getPartitionKeyRangeCache()\n+                        .tryLookupAsync(null, collection.getResourceId(), null, null)\n+                        .map((Utils.ValueHolder<CollectionRoutingMap> routingMap) -> {\n+\n+                            return routingMap.v.getRangeByEffectivePartitionKey(\n+                                getEffectivePartitionKeyString(\n+                                    partitionKeyInternal,\n+                                    definition)).getId();\n+                        });\n+                });\n+\n+            return pkRangeIdMono;\n+        } else {\n+            throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+        }\n+    }\n+\n+    private static PartitionKeyInternal getPartitionKeyInternal(\n+        final CosmosItemOperation operation,\n+        final PartitionKeyDefinition partitionKeyDefinition) {\n+\n+        checkNotNull(operation, \"expected non-null operation\");\n+\n+        final PartitionKey partitionKey = operation.getPartitionKeyValue();\n+        if (partitionKey == null) {\n+            return ModelBridgeInternal.getNonePartitionKey(partitionKeyDefinition);\n+        } else {\n+            return BridgeInternal.getPartitionKeyInternal(partitionKey);\n+        }\n+    }\n+\n+    private static Mono<DocumentCollection> getCollectionInfoAsync(AsyncDocumentClient documentClient,\n+                                                                   CosmosAsyncContainer container) {\n+        final RxClientCollectionCache clientCollectionCache = documentClient.getCollectionCache();\n+        return clientCollectionCache\n+            .resolveByNameAsync(\n+                null,", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMDk3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520930978", "bodyText": "I still see that this hasn't been done. could you please add a TODO in the code with your alias?", "author": "moderakh", "createdAt": "2020-11-10T23:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4NzkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521087904", "bodyText": "Apologise Mo. Will add one. This all should be handled when we are adding diagnostic operation wise.", "author": "rakkuma", "createdAt": "2020-11-11T03:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzODc5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\nindex 14c5ba0904c..07ee8f6a06d 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutorUtil.java\n\n@@ -5,14 +5,12 @@ package com.azure.cosmos.implementation.batch;\n \n import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.CosmosAsyncContainer;\n-import com.azure.cosmos.CosmosException;\n import com.azure.cosmos.CosmosItemOperation;\n import com.azure.cosmos.ThrottlingRetryOptions;\n import com.azure.cosmos.TransactionalBatchOperationResult;\n import com.azure.cosmos.implementation.AsyncDocumentClient;\n import com.azure.cosmos.implementation.DocumentCollection;\n import com.azure.cosmos.implementation.HttpConstants;\n-import com.azure.cosmos.implementation.IRetryPolicy;\n import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.caches.RxClientCollectionCache;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0MzA1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513643052", "bodyText": "still we are passing RxDocumentServiceRequest to the lower part of stack.\nPartitionKeyRangeServerBatchRequest at some point will be translated to a RxDocumentServiceRequest. am I right?", "author": "moderakh", "createdAt": "2020-10-28T17:44:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class PartitionKeyRangeServerBatchRequest extends ServerBatchRequest {", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NDk5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513654994", "bodyText": "Yeah, this is just a container to get values when we are converting to RxDocumentServiceRequest.", "author": "rakkuma", "createdAt": "2020-10-28T18:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0MzA1Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513645455", "bodyText": "PartitionKeyRangeServerBatchRequest at some point will be translated to a RxDocumentServiceRequest. right? how does partition split proofing work?\nPartitionKeyRangeServerBatchRequest may contain multiple documents. we create one RxDocumentServiceRequest out of all those documents. now if a partition split happens we cannot just retry the same RxDocumentServiceRequest as some documents may go to a left child some to the right child partition. how are we handling that scenario with retries?", "author": "moderakh", "createdAt": "2020-10-28T17:48:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class PartitionKeyRangeServerBatchRequest extends ServerBatchRequest {\n+\n+    private final String partitionKeyRangeId;", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTA5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515909092", "bodyText": "+1 - we need a separate retry policy that will cover splitting the individual operations into the \"right\" partition. I assume this means we need to back-channel documents impacted into a GoneRetryQueue (which is handled in parallel with the incoming flux of operations). Bulk executor library is handling this similarly...", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNTEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515935123", "bodyText": "Have handled it using a sink, which will re-evaluate the partition key range id. And we definitely need sink for overflows as handling overflow parallelly can multiple the parallelism factor, so seems fine to use it in case of Gone also.", "author": "rakkuma", "createdAt": "2020-11-02T12:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzMzA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520933062", "bodyText": "@rakkuma we need tests for partition split. please add TODO and create github item to track this.\nwithout partition split support we cannot announce bulk.\n\nmocked unit tests: see DocumentProducerTest as a mocked unit tests for partition split on quer.\nend to end integration tests. see ReadMyWritesConsistencyTest as a e2e tests which tests partition split. essentially some of our CIs target prod, you can scale the throughput of the cosmos container which will result in partition split.\n\nI think tests for partition split and its implementation require more work. please capture this work after this PR gets in.", "author": "moderakh", "createdAt": "2020-11-10T23:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4ODcwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r521088707", "bodyText": "Partition split is handled already. Yeah the test case is remaining. I will try to add those in this PR only. Thanks.", "author": "rakkuma", "createdAt": "2020-11-11T03:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NTQ1NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r513646512", "bodyText": "could you please also add tests for case when the input flux cosmosItemOperationFlux errors.", "author": "moderakh", "createdAt": "2020-10-28T17:49:50Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java", "diffHunk": "@@ -0,0 +1,401 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.models.PartitionKey;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.assertj.core.api.Assertions;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class CosmosBulkTest extends BatchTestBase {\n+\n+    private CosmosAsyncClient bulkClient;\n+    private CosmosAsyncContainer bulkAsyncContainer;\n+\n+    @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n+    public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @BeforeClass(groups = {\"simple\"}, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosBulkTest() {\n+        assertThat(this.bulkClient).isNull();\n+        this.bulkClient = getClientBuilder().buildAsyncClient();\n+        bulkAsyncContainer = getSharedMultiPartitionCosmosContainer(this.bulkClient);\n+    }\n+\n+    @AfterClass(groups = {\"simple\"}, timeOut = SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        safeCloseAsync(this.bulkClient);\n+    }\n+\n+    @Test(groups = {\"simple\"}, timeOut = TIMEOUT)\n+    public void createItem_withBulk() {\n+        int totalRequest = getTotalRequest();\n+\n+        Flux<CosmosItemOperation> cosmosItemOperationFlux = Flux.merge(\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                TestDoc testDoc = this.populateTestDoc(partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(testDoc, new PartitionKey(partitionKey));\n+            }),\n+            Flux.range(0, totalRequest).map(i -> {\n+                String partitionKey = UUID.randomUUID().toString();\n+                EventDoc eventDoc = new EventDoc(UUID.randomUUID().toString(), 2, 4, \"type1\", partitionKey);\n+\n+                return BulkProcessingUtil.getBulkCreateItemOperation(eventDoc, new PartitionKey(partitionKey));\n+            }));\n+\n+        BulkProcessingOptions<CosmosBulkTest> bulkProcessingOptions = new BulkProcessingOptions<>();\n+        bulkProcessingOptions.setMaxMicroBatchSize(100);\n+        bulkProcessingOptions.setMaxMicroBatchConcurrency(5);\n+\n+        Flux<CosmosBulkOperationRequestAndResponse<CosmosBulkTest>> responseFlux = bulkAsyncContainer\n+            .processBulkOperations(cosmosItemOperationFlux, bulkProcessingOptions);", "originalCommit": "83543a6cb9517cf9945c47d5b0ea3c93d1730d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMjE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516412143", "bodyText": "Have added one Mo and will make it better. Right now we are eating up the errors passed, and I cannot find another way. I wanted to have a response for it too, with the operation/response null and user passed exception in CosmosBulkOperationResponse. Is ignoring the error signal a valid way?", "author": "rakkuma", "createdAt": "2020-11-03T03:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NjUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\nindex f73a265dbd4..aafc359d8e5 100644\n--- a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\n+++ b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosBulkTest.java\n\n@@ -5,27 +5,27 @@ package com.azure.cosmos;\n \n import com.azure.cosmos.models.PartitionKey;\n import io.netty.handler.codec.http.HttpResponseStatus;\n-import org.assertj.core.api.Assertions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Factory;\n import org.testng.annotations.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Random;\n import java.util.UUID;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-public class CosmosBulkTest extends BatchTestBase {\n+public class CosmosBulkTest  extends BatchTestBase {\n \n-    private CosmosAsyncClient bulkClient;\n-    private CosmosAsyncContainer bulkAsyncContainer;\n+    private final static Logger logger = LoggerFactory.getLogger(CosmosBulkAsyncTest.class);\n+\n+    private CosmosClient bulkClient;\n+    private CosmosContainer bulkContainer;\n \n     @Factory(dataProvider = \"clientBuildersWithDirectSession\")\n     public CosmosBulkTest(CosmosClientBuilder clientBuilder) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MjQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515892446", "bodyText": "200 >= instead of <=", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:56:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {\n+        T item = null;\n+\n+        if (this.getResourceObject() != null) {\n+            item = new JsonSerializable(this.getResourceObject()).toObject(type);\n+        }\n+\n+        return item;\n+    }\n+\n+    /**\n+     * Gets retry after.\n+     *\n+     * @return the retry after\n+     */\n+    public Duration getRetryAfterDuration() {\n+        return this.retryAfter;\n+    }\n+\n+    /**\n+     * Gets sub status code associated with the current result.\n+     *\n+     * @return the sub status code\n+     */\n+    public int getSubStatusCode() {\n+        return this.subStatusCode;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the current operation completed successfully.\n+     *\n+     * @return {@code true} if the current operation completed successfully; {@code false} otherwise.\n+     */\n+    public boolean isSuccessStatusCode() {\n+        return 200 <= this.statusCode && this.statusCode <= 299;", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516639742", "bodyText": "Done. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T12:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MjQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex 1fc24f0f003..ee9cada8884 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -19,7 +19,7 @@ import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNo\n  * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n  *\n  */\n-@Beta(Beta.SinceVersion.V4_7_0)\n+@Beta(Beta.SinceVersion.V4_8_0)\n public final class CosmosBulkItemResponse {\n \n     private final String eTag;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mzk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515893977", "bodyText": "IMO CosmosBulkOperationResposne is sufficient - like in HttpClient's API HttpResponseMessage also has a link back to request.", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T10:59:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkOperationRequestAndResponse<TContext> {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTkwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516639907", "bodyText": "Fixed. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T12:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5Mzk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java\ndeleted file mode 100644\nindex 1a2153216ed..00000000000\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java\n+++ /dev/null\n\n@@ -1,64 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.cosmos;\n-\n-import com.azure.cosmos.util.Beta;\n-import reactor.core.publisher.Flux;\n-\n-/**\n- * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n- * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n- */\n-@Beta(Beta.SinceVersion.V4_7_0)\n-public final class CosmosBulkOperationRequestAndResponse<TContext> {\n-\n-    private final CosmosItemOperation operation;\n-    private final CosmosBulkItemResponse response;\n-    private final Throwable throwable;\n-    private final TContext batchContext;\n-\n-    /**\n-     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n-     *\n-     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n-     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n-     * @param batchContext the context of this bulk request.\n-     */\n-    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n-        this.operation = operation;\n-        this.response = response;\n-        this.throwable = null;\n-        this.batchContext = batchContext;\n-    }\n-\n-    /**\n-     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n-     *\n-     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n-     * @param throwable the {@link Throwable} for this request.\n-     * @param batchContext the context of this bulk request.\n-     */\n-    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n-        this.operation = operation;\n-        this.response = null;\n-        this.throwable = throwable;\n-        this.batchContext = batchContext;\n-    }\n-\n-    public CosmosItemOperation getOperation() {\n-        return operation;\n-    }\n-\n-    public CosmosBulkItemResponse getResponse() {\n-        return response;\n-    }\n-\n-    public Throwable getThrowable() {\n-        return throwable;\n-    }\n-\n-    public TContext getBatchContext() {\n-        return batchContext;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515894446", "bodyText": "Do we have to keep this as Throwable - or can we make it CosmosException? When would it ever contain a Throwable which is not wrapped as CosmosException?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:00:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_7_0)\n+public final class CosmosBulkOperationRequestAndResponse<TContext> {\n+\n+    private final CosmosItemOperation operation;\n+    private final CosmosBulkItemResponse response;\n+    private final Throwable throwable;\n+    private final TContext batchContext;\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = response;\n+        this.throwable = null;\n+        this.batchContext = batchContext;\n+    }\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param throwable the {@link Throwable} for this request.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = null;\n+        this.throwable = throwable;\n+        this.batchContext = batchContext;\n+    }\n+\n+    public CosmosItemOperation getOperation() {\n+        return operation;\n+    }\n+\n+    public CosmosBulkItemResponse getResponse() {\n+        return response;\n+    }\n+\n+    public Throwable getThrowable() {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0OTY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515949691", "bodyText": "Ideally we can keep CosmosException. But At most of the places I can see in try/catch we put Exception instead of CosmosException. So I am not sure if we should keep CosmosException?", "author": "rakkuma", "createdAt": "2020-11-02T12:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDI5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520934299", "bodyText": "I think it would be better to translate to CosmosException or at least Exception.\nthere are very few errors which are Throwable but not Exception. (e.g. StackOverFlowError or OutofMemeryError).\nif you get a throwable which is not exception you should fail the whole operation rather than the individual request/response.", "author": "moderakh", "createdAt": "2020-11-10T23:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0NTk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525845943", "bodyText": "Sure. Exception is cool. will do it. Thanks.", "author": "rakkuma", "createdAt": "2020-11-18T06:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5NDQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java\ndeleted file mode 100644\nindex 1a2153216ed..00000000000\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationRequestAndResponse.java\n+++ /dev/null\n\n@@ -1,64 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.cosmos;\n-\n-import com.azure.cosmos.util.Beta;\n-import reactor.core.publisher.Flux;\n-\n-/**\n- * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n- * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n- */\n-@Beta(Beta.SinceVersion.V4_7_0)\n-public final class CosmosBulkOperationRequestAndResponse<TContext> {\n-\n-    private final CosmosItemOperation operation;\n-    private final CosmosBulkItemResponse response;\n-    private final Throwable throwable;\n-    private final TContext batchContext;\n-\n-    /**\n-     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n-     *\n-     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n-     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n-     * @param batchContext the context of this bulk request.\n-     */\n-    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n-        this.operation = operation;\n-        this.response = response;\n-        this.throwable = null;\n-        this.batchContext = batchContext;\n-    }\n-\n-    /**\n-     * Initialises a new instance of {@link CosmosBulkOperationRequestAndResponse}.\n-     *\n-     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n-     * @param throwable the {@link Throwable} for this request.\n-     * @param batchContext the context of this bulk request.\n-     */\n-    CosmosBulkOperationRequestAndResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n-        this.operation = operation;\n-        this.response = null;\n-        this.throwable = throwable;\n-        this.batchContext = batchContext;\n-    }\n-\n-    public CosmosItemOperation getOperation() {\n-        return operation;\n-    }\n-\n-    public CosmosBulkItemResponse getResponse() {\n-        return response;\n-    }\n-\n-    public Throwable getThrowable() {\n-        return throwable;\n-    }\n-\n-    public TContext getBatchContext() {\n-        return batchContext;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNTgxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515905810", "bodyText": "Shouldn't this retry policy also inherit from RetryPolicyWithDiagnostics?", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:21:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.HttpConstants.StatusCodes;\n+import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * A container to keep retry policies and functions for bulk.\n+ */\n+final class BulkOperationRetryPolicy {", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NTQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515955426", "bodyText": "Yeah, can help if/when we add some diagnostic info op wise.", "author": "rakkuma", "createdAt": "2020-11-02T13:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNTgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\nindex d59a8b2b737..408233b8eaf 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\n\n@@ -10,6 +10,7 @@ import com.azure.cosmos.implementation.HttpConstants.StatusCodes;\n import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n import com.azure.cosmos.implementation.IRetryPolicy;\n import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n import reactor.core.publisher.Mono;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTQwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r515909404", "bodyText": "Please fix this before check-in", "author": "FabianMeiswinkel", "createdAt": "2020-11-02T11:28:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java", "diffHunk": "@@ -59,27 +59,31 @@\n         final ArrayNode arrayNode =  Utils.getSimpleObjectMapper().createArrayNode();\n \n         for(CosmosItemOperation operation : operations) {\n+            JsonSerializable operationJsonSerializable;\n+\n             if (operation instanceof ItemBatchOperation<?>) {\n-                final ItemBatchOperation<?> itemBatchOperation = (ItemBatchOperation<?>) operation;\n-                final JsonSerializable operationJsonSerializable = itemBatchOperation.serializeOperation();\n+                operationJsonSerializable = ((ItemBatchOperation<?>) operation).serializeOperation();\n+            } else if (operation instanceof ItemBulkOperation<?>) {\n+                operationJsonSerializable = ((ItemBulkOperation<?>) operation).serializeOperation();\n+            } else {\n+                throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+            }\n \n-                // TODO(rakkuma): If the string contains unicode the byte encoding len will be more. Fix it.\n-                // Issue: https://github.com/Azure/azure-sdk-for-java/issues/16112\n-                final int operationSerializedLength = operationJsonSerializable.toString().length();\n+            // TODO(rakkuma): If the string contains unicode the byte encoding len will be more. Fix it.", "originalCommit": "19697287761e083bfb1e45d7f26060b144a94a65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMTM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r516411389", "bodyText": "Done. Have added test cases too to verify size overflow. Thanks.", "author": "rakkuma", "createdAt": "2020-11-03T03:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwOTQwNA=="}], "type": "inlineReview", "revised_code": {"commit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java\nindex 6c4c694908d..c8598bacd7b 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/ServerBatchRequest.java\n\n@@ -69,9 +69,7 @@ public abstract class ServerBatchRequest {\n                 throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n             }\n \n-            // TODO(rakkuma): If the string contains unicode the byte encoding len will be more. Fix it.\n-            // Issue: https://github.com/Azure/azure-sdk-for-java/issues/16112\n-            final int operationSerializedLength = operationJsonSerializable.toString().length();\n+            int operationSerializedLength = getOperationSerializedLength(operationJsonSerializable);\n \n             if (totalOperationCount != 0 &&\n                 (totalSerializedLength + operationSerializedLength > this.maxBodyLength || totalOperationCount + 1 > this.maxOperationCount)) {\n"}}, {"oid": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "message": "Bulk\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-02T17:12:48Z", "type": "commit"}, {"oid": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "message": "Bulk\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-02T17:12:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MTg2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518041860", "bodyText": "Needs to be 4.9.0 now - 4.8.0 was already released - Non-blocking of course - just make sure to update this before merging.", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:16:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkOperations}.\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\nindex 3637669724a..cab3aa467ee 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n\n@@ -12,53 +12,96 @@ import com.azure.cosmos.util.Beta;\n  */\n @Beta(Beta.SinceVersion.V4_8_0)\n public final class BulkItemRequestOptions {\n-    private ConsistencyLevel consistencyLevel;\n-    private String sessionToken;\n+    private String ifMatchETag;\n+    private String ifNoneMatchETag;\n+    private Boolean contentResponseOnWriteEnabled;\n \n     /**\n-     * Gets the consistency level required for the request.\n+     * Gets the If-Match (ETag) associated with the operation in {@link CosmosItemOperation}.\n      *\n-     * @return the consistency level.\n+     * @return ifMatchETag the ifMatchETag associated with the request.\n      */\n-    ConsistencyLevel getConsistencyLevel() {\n-        return consistencyLevel;\n+    public String getIfMatchETag() {\n+        return this.ifMatchETag;\n     }\n \n     /**\n-     * Sets the consistency level required for the request.\n+     * Sets the If-Match (ETag) associated with the operation in {@link CosmosItemOperation}.\n      *\n-     * @param consistencyLevel the consistency level.\n-     * @return the BulkItemRequestOptions.\n+     * @param ifMatchETag the ifMatchETag associated with the request.\n+     * @return the current request options\n      */\n-    BulkItemRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {\n-        this.consistencyLevel = consistencyLevel;\n+    public BulkItemRequestOptions setIfMatchETag(final String ifMatchETag) {\n+        this.ifMatchETag = ifMatchETag;\n         return this;\n     }\n \n     /**\n-     * Gets the token for use with session consistency.\n+     * Gets the If-None-Match (ETag) associated with the request in operation in {@link CosmosItemOperation}.\n      *\n-     * @return the session token.\n+     * @return the ifNoneMatchETag associated with the request.\n      */\n-    public String getSessionToken() {\n-        return sessionToken;\n+    public String getIfNoneMatchETag() {\n+        return this.ifNoneMatchETag;\n     }\n \n     /**\n-     * Sets the token for use with session consistency.\n+     * Sets the If-None-Match (ETag) associated with the request in operation in {@link CosmosItemOperation}.\n      *\n-     * @param sessionToken the session token.\n-     * @return the BulkItemRequestOptions.\n+     * @param ifNoneMatchEtag the ifNoneMatchETag associated with the request.\n+     * @return the current request options.\n      */\n-    public BulkItemRequestOptions setSessionToken(String sessionToken) {\n-        this.sessionToken = sessionToken;\n+    public BulkItemRequestOptions setIfNoneMatchETag(final String ifNoneMatchEtag) {\n+        this.ifNoneMatchETag = ifNoneMatchEtag;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the boolean to only return the headers and status code in Cosmos DB response\n+     * in case of Create, Update and Delete operations in {@link CosmosItemOperation}.\n+     *\n+     * If set to false, service doesn't return payload in the response. It reduces networking\n+     * and CPU load by not sending the payload back over the network and serializing it on the client.\n+     *\n+     * This feature does not impact RU usage for read or write operations.\n+     *\n+     * By-default, this is null.\n+     *\n+     * @return a boolean indicating whether payload will be included in the response or not for this operation.\n+     */\n+    public Boolean isContentResponseOnWriteEnabled() {\n+        return contentResponseOnWriteEnabled;\n+    }\n+\n+    /**\n+     * Sets the boolean to only return the headers and status code in Cosmos DB response\n+     * in case of Create, Update and Delete operations in {@link CosmosItemOperation}.\n+     *\n+     * If set to false, service doesn't return payload in the response. It reduces networking\n+     * and CPU load by not sending the payload back over the network and serializing it on the client.\n+     *\n+     * This feature does not impact RU usage for read or write operations.\n+     *\n+     * By-default, this is null.\n+     *\n+     * NOTE: This flag is also present on {@link com.azure.cosmos.CosmosClientBuilder}, however if specified\n+     * here, it will override the value specified in {@link com.azure.cosmos.CosmosClientBuilder} for this request.\n+     *\n+     * @param contentResponseOnWriteEnabled a boolean indicating whether payload will be included\n+     * in the response or not for this operation.\n+     *\n+     * @return the current request options.\n+     */\n+    public BulkItemRequestOptions setContentResponseOnWriteEnabled(Boolean contentResponseOnWriteEnabled) {\n+        this.contentResponseOnWriteEnabled = contentResponseOnWriteEnabled;\n         return this;\n     }\n \n     RequestOptions toRequestOptions() {\n         final RequestOptions requestOptions = new RequestOptions();\n-        requestOptions.setConsistencyLevel(getConsistencyLevel());\n-        requestOptions.setSessionToken(sessionToken);\n+        requestOptions.setIfMatchETag(getIfMatchETag());\n+        requestOptions.setIfNoneMatchETag(getIfNoneMatchETag());\n+        requestOptions.setContentResponseOnWriteEnabled(isContentResponseOnWriteEnabled());\n         return requestOptions;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0OTUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518049506", "bodyText": "NIT: normalize indentation", "author": "FabianMeiswinkel", "createdAt": "2020-11-05T13:28:27Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java", "diffHunk": "@@ -0,0 +1,172 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.CosmosItemOperationType;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.PartitionKey;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class PartitionKeyRangeServerBatchRequestTests {\n+\n+    private static final int TIMEOUT = 40000;\n+\n+    private CosmosItemOperation createItemBulkOperation(String id) {\n+        ItemBulkOperation<?> operation = new ItemBulkOperation<>(\n+            CosmosItemOperationType.CREATE,\n+            id,\n+            PartitionKey.NONE,\n+            null,\n+            null\n+        );\n+\n+        return operation;\n+    }\n+\n+    @Test(groups = {\"unit\"}, timeOut = TIMEOUT)\n+    public void fitsAllOperations() {\n+        List<CosmosItemOperation> operations = new ArrayList<CosmosItemOperation>() {{\n+            createItemBulkOperation(\"\");\n+            createItemBulkOperation(\"\");\n+        }};\n+\n+        ServerOperationBatchRequest serverOperationBatchRequest = PartitionKeyRangeServerBatchRequest.createBatchRequest(\n+        \"0\",\n+            operations,\n+        200000,", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java\nindex 415d4a1f4b8..7d85a246070 100644\n--- a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java\n+++ b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/batch/PartitionKeyRangeServerBatchRequestTests.java\n\n@@ -39,10 +39,10 @@ public class PartitionKeyRangeServerBatchRequestTests {\n         }};\n \n         ServerOperationBatchRequest serverOperationBatchRequest = PartitionKeyRangeServerBatchRequest.createBatchRequest(\n-        \"0\",\n+            \"0\",\n             operations,\n-        200000,\n-        2);\n+            200000,\n+            2);\n \n         assertThat(serverOperationBatchRequest.getBatchRequest().getOperations().size()).isEqualTo(operations.size());\n         assertThat(serverOperationBatchRequest.getBatchRequest().getOperations()).isEqualTo(operations);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518181884", "bodyText": "nit: should it be BatchRequestResponseConstants?", "author": "xinlian12", "createdAt": "2020-11-05T16:23:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstant.java", "diffHunk": "@@ -7,12 +7,15 @@\n  * This contains all the extra constants needed for batch/bulk. This will be usefull even if Hybrid row comes in.\n  * This contains all the constants we have in Backend. Any addition to backend should be added here.\n  */\n-public class BatchRequestResponseConstant {\n+public final class BatchRequestResponseConstant {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDY3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518204671", "bodyText": "So technically bulk is also a batching, just that it is non-txn, and internally we use batch API.", "author": "rakkuma", "createdAt": "2020-11-05T16:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518209756", "bodyText": "oh, sorry, I was more around the naming part. Since this class contains multiple constants, so i think it should also reflect on the class name as well, *Constant -> *Constants", "author": "xinlian12", "createdAt": "2020-11-05T17:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIxMzY1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518213651", "bodyText": "Oh. Apologies. Will change it. Nice catch! Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T17:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM5NjQzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518396430", "bodyText": "thanks", "author": "xinlian12", "createdAt": "2020-11-05T22:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4MTg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstant.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstants.java\nsimilarity index 97%\nrename from sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstant.java\nrename to sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstants.java\nindex b9e08d64774..32930a62d53 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstant.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BatchRequestResponseConstants.java\n\n@@ -7,7 +7,7 @@ package com.azure.cosmos.implementation.batch;\n  * This contains all the extra constants needed for batch/bulk. This will be usefull even if Hybrid row comes in.\n  * This contains all the constants we have in Backend. Any addition to backend should be added here.\n  */\n-public final class BatchRequestResponseConstant {\n+public final class BatchRequestResponseConstants {\n \n     // Size limits:\n     public static final int MAX_DIRECT_MODE_BATCH_REQUEST_BODY_SIZE_IN_BYTES = 220201;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODUxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518188518", "bodyText": "nit: statusCode is int, so may never be null?", "author": "xinlian12", "createdAt": "2020-11-05T16:32:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNTA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518205086", "bodyText": "Agreed. Will remove the check. Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T16:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex ee9cada8884..feb066bb1ff 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -43,7 +43,6 @@ public final class CosmosBulkItemResponse {\n                            Map<String, String> responseHeaders,\n                            CosmosDiagnostics cosmosDiagnostics) {\n \n-        checkNotNull(statusCode, \"expected non-null statusCode\");\n         checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n \n         this.eTag = eTag;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518196724", "bodyText": "not sure, but just thinking should isContentResponseOnWriteEnabled add here?", "author": "xinlian12", "createdAt": "2020-11-05T16:43:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.RequestOptions;\n+import com.azure.cosmos.util.Beta;\n+\n+/**\n+ * Encapsulates options that can be specified for an operation used in Bulk execution. It can be passed while\n+ * creating bulk request using {@link BulkOperations}.\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class BulkItemRequestOptions {\n+    private ConsistencyLevel consistencyLevel;\n+    private String sessionToken;\n+\n+    /**\n+     * Gets the consistency level required for the request.\n+     *\n+     * @return the consistency level.\n+     */\n+    ConsistencyLevel getConsistencyLevel() {\n+        return consistencyLevel;\n+    }\n+\n+    /**\n+     * Sets the consistency level required for the request.\n+     *\n+     * @param consistencyLevel the consistency level.\n+     * @return the BulkItemRequestOptions.\n+     */\n+    BulkItemRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {\n+        this.consistencyLevel = consistencyLevel;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the token for use with session consistency.\n+     *\n+     * @return the session token.\n+     */\n+    public String getSessionToken() {\n+        return sessionToken;\n+    }\n+\n+    /**\n+     * Sets the token for use with session consistency.\n+     *\n+     * @param sessionToken the session token.\n+     * @return the BulkItemRequestOptions.\n+     */\n+    public BulkItemRequestOptions setSessionToken(String sessionToken) {\n+        this.sessionToken = sessionToken;\n+        return this;\n+    }\n+\n+    RequestOptions toRequestOptions() {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwOTEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518209136", "bodyText": "Yeah that should be added. Will add it. Thanks.", "author": "rakkuma", "createdAt": "2020-11-05T17:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMjc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518402762", "bodyText": "thanks~", "author": "xinlian12", "createdAt": "2020-11-05T22:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\nindex 3637669724a..cab3aa467ee 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkItemRequestOptions.java\n\n@@ -12,53 +12,96 @@ import com.azure.cosmos.util.Beta;\n  */\n @Beta(Beta.SinceVersion.V4_8_0)\n public final class BulkItemRequestOptions {\n-    private ConsistencyLevel consistencyLevel;\n-    private String sessionToken;\n+    private String ifMatchETag;\n+    private String ifNoneMatchETag;\n+    private Boolean contentResponseOnWriteEnabled;\n \n     /**\n-     * Gets the consistency level required for the request.\n+     * Gets the If-Match (ETag) associated with the operation in {@link CosmosItemOperation}.\n      *\n-     * @return the consistency level.\n+     * @return ifMatchETag the ifMatchETag associated with the request.\n      */\n-    ConsistencyLevel getConsistencyLevel() {\n-        return consistencyLevel;\n+    public String getIfMatchETag() {\n+        return this.ifMatchETag;\n     }\n \n     /**\n-     * Sets the consistency level required for the request.\n+     * Sets the If-Match (ETag) associated with the operation in {@link CosmosItemOperation}.\n      *\n-     * @param consistencyLevel the consistency level.\n-     * @return the BulkItemRequestOptions.\n+     * @param ifMatchETag the ifMatchETag associated with the request.\n+     * @return the current request options\n      */\n-    BulkItemRequestOptions setConsistencyLevel(ConsistencyLevel consistencyLevel) {\n-        this.consistencyLevel = consistencyLevel;\n+    public BulkItemRequestOptions setIfMatchETag(final String ifMatchETag) {\n+        this.ifMatchETag = ifMatchETag;\n         return this;\n     }\n \n     /**\n-     * Gets the token for use with session consistency.\n+     * Gets the If-None-Match (ETag) associated with the request in operation in {@link CosmosItemOperation}.\n      *\n-     * @return the session token.\n+     * @return the ifNoneMatchETag associated with the request.\n      */\n-    public String getSessionToken() {\n-        return sessionToken;\n+    public String getIfNoneMatchETag() {\n+        return this.ifNoneMatchETag;\n     }\n \n     /**\n-     * Sets the token for use with session consistency.\n+     * Sets the If-None-Match (ETag) associated with the request in operation in {@link CosmosItemOperation}.\n      *\n-     * @param sessionToken the session token.\n-     * @return the BulkItemRequestOptions.\n+     * @param ifNoneMatchEtag the ifNoneMatchETag associated with the request.\n+     * @return the current request options.\n      */\n-    public BulkItemRequestOptions setSessionToken(String sessionToken) {\n-        this.sessionToken = sessionToken;\n+    public BulkItemRequestOptions setIfNoneMatchETag(final String ifNoneMatchEtag) {\n+        this.ifNoneMatchETag = ifNoneMatchEtag;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the boolean to only return the headers and status code in Cosmos DB response\n+     * in case of Create, Update and Delete operations in {@link CosmosItemOperation}.\n+     *\n+     * If set to false, service doesn't return payload in the response. It reduces networking\n+     * and CPU load by not sending the payload back over the network and serializing it on the client.\n+     *\n+     * This feature does not impact RU usage for read or write operations.\n+     *\n+     * By-default, this is null.\n+     *\n+     * @return a boolean indicating whether payload will be included in the response or not for this operation.\n+     */\n+    public Boolean isContentResponseOnWriteEnabled() {\n+        return contentResponseOnWriteEnabled;\n+    }\n+\n+    /**\n+     * Sets the boolean to only return the headers and status code in Cosmos DB response\n+     * in case of Create, Update and Delete operations in {@link CosmosItemOperation}.\n+     *\n+     * If set to false, service doesn't return payload in the response. It reduces networking\n+     * and CPU load by not sending the payload back over the network and serializing it on the client.\n+     *\n+     * This feature does not impact RU usage for read or write operations.\n+     *\n+     * By-default, this is null.\n+     *\n+     * NOTE: This flag is also present on {@link com.azure.cosmos.CosmosClientBuilder}, however if specified\n+     * here, it will override the value specified in {@link com.azure.cosmos.CosmosClientBuilder} for this request.\n+     *\n+     * @param contentResponseOnWriteEnabled a boolean indicating whether payload will be included\n+     * in the response or not for this operation.\n+     *\n+     * @return the current request options.\n+     */\n+    public BulkItemRequestOptions setContentResponseOnWriteEnabled(Boolean contentResponseOnWriteEnabled) {\n+        this.contentResponseOnWriteEnabled = contentResponseOnWriteEnabled;\n         return this;\n     }\n \n     RequestOptions toRequestOptions() {\n         final RequestOptions requestOptions = new RequestOptions();\n-        requestOptions.setConsistencyLevel(getConsistencyLevel());\n-        requestOptions.setSessionToken(sessionToken);\n+        requestOptions.setIfMatchETag(getIfMatchETag());\n+        requestOptions.setIfNoneMatchETag(getIfNoneMatchETag());\n+        requestOptions.setContentResponseOnWriteEnabled(isContentResponseOnWriteEnabled());\n         return requestOptions;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518235724", "bodyText": "This is a purely question.\nWhen I check the UnicastProcessor documentation, it says it will be removed in 3.5. Should we change to something else just in case in the future we upgrade to > 3.5.0? Currently we are using 3.3.9\n\"Deprecated.\nto be removed in 3.5, prefer clear cut usage of Sinks through variations under Sinks.many().unicast().\"", "author": "xinlian12", "createdAt": "2020-11-05T17:38:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.BulkProcessingOptions;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.CosmosBulkItemResponse;\n+import com.azure.cosmos.CosmosBulkOperationResponse;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.GroupedFlux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class BulkExecutor<TContext> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n+\n+    private final CosmosAsyncContainer container;\n+    private final AsyncDocumentClient docClientWrapper;\n+    private final ThrottlingRetryOptions throttlingRetryOptions;\n+    private final Flux<CosmosItemOperation> inputOperations;\n+\n+    // Options for bulk execution.\n+    private final int maxMicroBatchSize;\n+    private final int maxMicroBatchConcurrency;\n+    private final Duration maxMicroBatchInterval;\n+    private final TContext batchContext;\n+\n+    // Handle gone error:\n+    private final AtomicBoolean mainSourceCompleted;\n+    private final AtomicInteger totalCount;\n+    private final FluxProcessor<CosmosItemOperation, CosmosItemOperation> mainFluxProcessor;\n+    private final FluxSink<CosmosItemOperation> mainSink;\n+    private final List<FluxSink<CosmosItemOperation>> groupSinks;\n+\n+    public BulkExecutor(CosmosAsyncContainer container,\n+                        Flux<CosmosItemOperation> inputOperations,\n+                        BulkProcessingOptions<TContext> bulkOptions) {\n+\n+        checkNotNull(container, \"expected non-null container\");\n+        checkNotNull(inputOperations, \"expected non-null inputOperations\");\n+        checkNotNull(bulkOptions, \"expected non-null bulkOptions\");\n+\n+        this.container = container;\n+        this.inputOperations = inputOperations;\n+        this.docClientWrapper = CosmosBridgeInternal.getAsyncDocumentClient(container.getDatabase());\n+        this.throttlingRetryOptions = docClientWrapper.getConnectionPolicy().getThrottlingRetryOptions();\n+\n+        // Fill the option first, to make the BulkProcessingOptions immutable, as if accessed directly, we might get\n+        // different values when a new group is created.\n+        maxMicroBatchSize = bulkOptions.getMaxMicroBatchSize();\n+        maxMicroBatchConcurrency = bulkOptions.getMaxMicroBatchConcurrency();\n+        maxMicroBatchInterval = bulkOptions.getMaxMicroBatchInterval();\n+        batchContext = bulkOptions.getBatchContext();\n+\n+        // Initialize sink for handling gone error.\n+        mainSourceCompleted = new AtomicBoolean(false);\n+        totalCount = new AtomicInteger(0);\n+        mainFluxProcessor = UnicastProcessor.<CosmosItemOperation>create().serialize();", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1MDA2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518250061", "bodyText": "As far as I know, they are just making it bit easy to use. SInk.Many.Unicast I think will serve this purpose (i.e. multiple producer one consumer). New one also have complete and emit options, so should be few init changes when we bump up the version.", "author": "rakkuma", "createdAt": "2020-11-05T17:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI1NjI4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518256283", "bodyText": "https://github.com/reactor/reactor-core/blob/master/docs/asciidoc/processors.adoc", "author": "rakkuma", "createdAt": "2020-11-05T18:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMzA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518403067", "bodyText": "I see, thanks for sharing the doc and sharing the details~", "author": "xinlian12", "createdAt": "2020-11-05T22:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\nindex 7c2b9255fc5..4b5d0499952 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\n\n@@ -35,6 +35,26 @@ import java.util.concurrent.atomic.AtomicInteger;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n+/**\n+ * The Core logic of bulk execution is here.\n+ *\n+ * The actual execution of the flux of operations. It is done in following steps:\n+\n+ * 1. Getting partition key range ID and grouping operations using that id.\n+ * 2. For the flux of operations in a group, adding buffering based on size and a duration.\n+ * 3. For the operation we get in after buffering, process it using a batch request and return\n+ *    a wrapper having request, response(if-any) and exception(if-any). Either response or exception will be there.\n+ *\n+ * 4. Any internal retry is done by adding in an intermediate sink for each grouped flux.\n+ * 5. Any operation which failed due to partition key range gone is retried by putting it in the main sink which leads\n+ *    to re-calculation of partition key range id.\n+ * 6. At the end and this is very essential, we close all the sinks as the sink continues to waits for more and the\n+ *    execution isn't finished even if all the operations have been executed(figured out by completion call of source)\n+ *    Sink will more to a new interface from 3.5 and this is documentation for it:\n+ *    * https://github.com/reactor/reactor-core/blob/master/docs/asciidoc/processors.adoc\n+ *\n+ *    For our use case, Sinks.many().unicast() will work.\n+ */\n public final class BulkExecutor<TContext> {\n \n     private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518285503", "bodyText": "We can optimize this by not serializing and converting everytime this method is called. Also, I see that diagnostics are added at some places. So if that is in scope of this PR, we could add serialization diagnostic here.  Refer CosmosItemResponse#getItem() for ideas", "author": "mbhaskar", "createdAt": "2020-11-05T18:52:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,189 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_8_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(statusCode, \"expected non-null statusCode\");\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5OTc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518299795", "bodyText": "That optimization we thought we can do it later possibly. For the diagnostic part, the issue is for all the operations which were executed in same batch will have one instance of diagnostic, so any addition will get reflected in all the other responses which will be confusing to debug. To have a different diagnostic we need to have some kind of merge context where each bulk item response has a separate instance and the batch execution diag. context is merged in that, similarly this serialization context and pk range lookup context should be merged in that. And we can do this or some other implementation in a separate PR.", "author": "rakkuma", "createdAt": "2020-11-05T19:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNDE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518934190", "bodyText": "Sure, make sure these are tracked. Thankyou", "author": "mbhaskar", "createdAt": "2020-11-06T18:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NTUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex ee9cada8884..feb066bb1ff 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -43,7 +43,6 @@ public final class CosmosBulkItemResponse {\n                            Map<String, String> responseHeaders,\n                            CosmosDiagnostics cosmosDiagnostics) {\n \n-        checkNotNull(statusCode, \"expected non-null statusCode\");\n         checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n \n         this.eTag = eTag;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518387026", "bodyText": "I have two questions here:\n\n\nWhen these two exceptions happens, it will go back to the main sink and re-calculate the partitionKeyRangeId, but without refreshing the cache, we may get the same/old partitionKeyRangeId back. Where the cache is refreshed?\n\n\nCurrently we check for PARTITION_KEY_RANGE_GONE  and NAME_CACHE_IS_STALE exception, what about COMPLETING_SPLIT etc?", "author": "xinlian12", "createdAt": "2020-11-05T21:43:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.implementation.HttpConstants.StatusCodes;\n+import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * A container to keep retry policies and functions for bulk.\n+ */\n+final class BulkOperationRetryPolicy extends RetryPolicyWithDiagnostics {\n+\n+    private static final int MAX_RETRIES = 1;\n+\n+    private final ResourceThrottleRetryPolicy resourceThrottleRetryPolicy;\n+    private int attemptedRetries;\n+\n+    BulkOperationRetryPolicy(ResourceThrottleRetryPolicy resourceThrottleRetryPolicy) {\n+        this.resourceThrottleRetryPolicy = resourceThrottleRetryPolicy;\n+    }\n+\n+    final Mono<IRetryPolicy.ShouldRetryResult> shouldRetry(final TransactionalBatchOperationResult result) {\n+\n+        checkNotNull(result, \"expected non-null result\");\n+\n+        // Create CosmosException for the next retry policy to understand:\n+        CosmosException exception = BridgeInternal.createCosmosException(\n+            result.getStatusCode(),\n+            null,\n+            BulkExecutorUtil.getResponseHeadersFromBatchOperationResult(result));\n+\n+        if (this.resourceThrottleRetryPolicy == null) {\n+            return Mono.just(IRetryPolicy.ShouldRetryResult.noRetry());\n+        }\n+\n+        return this.resourceThrottleRetryPolicy.shouldRetry(exception);\n+    }\n+\n+    @Override\n+    public Mono<IRetryPolicy.ShouldRetryResult> shouldRetry(Exception exception) {\n+\n+        if (this.resourceThrottleRetryPolicy == null) {\n+            return Mono.just(IRetryPolicy.ShouldRetryResult.noRetry());\n+        }\n+\n+        return this.resourceThrottleRetryPolicy.shouldRetry(exception);\n+    }\n+\n+    boolean shouldRetryForGone(int statusCode, int subStatusCode) {\n+\n+        if (statusCode == StatusCodes.GONE\n+            && (subStatusCode == SubStatusCodes.PARTITION_KEY_RANGE_GONE || subStatusCode == SubStatusCodes.NAME_CACHE_IS_STALE)\n+            && this.attemptedRetries < MAX_RETRIES) {", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MTUyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518491520", "bodyText": "I can see different refreshes for different substatus codes. For pk range, I don't see any thing to handle forceRefresh. Even in function  RxPartitionKeyRangeCache::getPartitionKeyRange function, forceRefresh variable is unused. Will make some changes to address collection cache refresh.\nWill add COMPLETING_SPLIT and COMPLETING_PARTITION_MIGRATION.\n\nThanks.", "author": "rakkuma", "createdAt": "2020-11-06T02:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5OTcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518999711", "bodyText": "Thanks Rakesh.\nI read the flow one more time, and I think I understand the general flow better now.\nSo ultimately it will be an RxDocumentServiceRequest, underlying with GoneAndRetryWithRetryPolicy, RenameCollectionAwareClientRetryPolicy will be applied. Since we do not retry for COMPLETING_SPLIT etc for write operations(but will refresh the range cache), so the exceptions will be throwned and eventually captured in BulkOperationRetryPolicy for each bulkItemOperation.\nBy the way, InvalidPartitionExceptionRetryPolicy is doing similar collection cache refresh~", "author": "xinlian12", "createdAt": "2020-11-06T20:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\nindex 408233b8eaf..5693053efff 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkOperationRetryPolicy.java\n\n@@ -11,6 +11,7 @@ import com.azure.cosmos.implementation.HttpConstants.SubStatusCodes;\n import com.azure.cosmos.implementation.IRetryPolicy;\n import com.azure.cosmos.implementation.ResourceThrottleRetryPolicy;\n import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import com.azure.cosmos.implementation.caches.RxCollectionCache;\n import reactor.core.publisher.Mono;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518388643", "bodyText": "nit: if (...) (space between)", "author": "xinlian12", "createdAt": "2020-11-05T21:46:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.batch;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.BulkProcessingOptions;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosBridgeInternal;\n+import com.azure.cosmos.CosmosBulkItemResponse;\n+import com.azure.cosmos.CosmosBulkOperationResponse;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.CosmosItemOperation;\n+import com.azure.cosmos.ThrottlingRetryOptions;\n+import com.azure.cosmos.TransactionalBatchOperationResult;\n+import com.azure.cosmos.TransactionalBatchResponse;\n+import com.azure.cosmos.implementation.AsyncDocumentClient;\n+import com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.GroupedFlux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+public final class BulkExecutor<TContext> {\n+\n+    private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n+\n+    private final CosmosAsyncContainer container;\n+    private final AsyncDocumentClient docClientWrapper;\n+    private final ThrottlingRetryOptions throttlingRetryOptions;\n+    private final Flux<CosmosItemOperation> inputOperations;\n+\n+    // Options for bulk execution.\n+    private final int maxMicroBatchSize;\n+    private final int maxMicroBatchConcurrency;\n+    private final Duration maxMicroBatchInterval;\n+    private final TContext batchContext;\n+\n+    // Handle gone error:\n+    private final AtomicBoolean mainSourceCompleted;\n+    private final AtomicInteger totalCount;\n+    private final FluxProcessor<CosmosItemOperation, CosmosItemOperation> mainFluxProcessor;\n+    private final FluxSink<CosmosItemOperation> mainSink;\n+    private final List<FluxSink<CosmosItemOperation>> groupSinks;\n+\n+    public BulkExecutor(CosmosAsyncContainer container,\n+                        Flux<CosmosItemOperation> inputOperations,\n+                        BulkProcessingOptions<TContext> bulkOptions) {\n+\n+        checkNotNull(container, \"expected non-null container\");\n+        checkNotNull(inputOperations, \"expected non-null inputOperations\");\n+        checkNotNull(bulkOptions, \"expected non-null bulkOptions\");\n+\n+        this.container = container;\n+        this.inputOperations = inputOperations;\n+        this.docClientWrapper = CosmosBridgeInternal.getAsyncDocumentClient(container.getDatabase());\n+        this.throttlingRetryOptions = docClientWrapper.getConnectionPolicy().getThrottlingRetryOptions();\n+\n+        // Fill the option first, to make the BulkProcessingOptions immutable, as if accessed directly, we might get\n+        // different values when a new group is created.\n+        maxMicroBatchSize = bulkOptions.getMaxMicroBatchSize();\n+        maxMicroBatchConcurrency = bulkOptions.getMaxMicroBatchConcurrency();\n+        maxMicroBatchInterval = bulkOptions.getMaxMicroBatchInterval();\n+        batchContext = bulkOptions.getBatchContext();\n+\n+        // Initialize sink for handling gone error.\n+        mainSourceCompleted = new AtomicBoolean(false);\n+        totalCount = new AtomicInteger(0);\n+        mainFluxProcessor = UnicastProcessor.<CosmosItemOperation>create().serialize();\n+        mainSink = mainFluxProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+        groupSinks = new ArrayList<>();\n+    }\n+\n+    /**\n+     * The actual execution of the flux of operations. It is done in 5 steps:\n+\n+     * 1. Getting partition key range ID and grouping operations using that id.\n+     * 2. For the flux of operations in a group, adding buffering based on size and a duration.\n+     * 3. For the operation we get in after buffering, process it using a batch request and return\n+     *    a wrapper having request, response(if-any) and exception(if-any). Either response or exception will be there.\n+     *\n+     * 4. Any internal retry is done by adding in an intermediate sink for each grouped flux.\n+     * 5. Any operation which failed due to partition key range gone is retried by re calculating it's range id.\n+     */\n+    public Flux<CosmosBulkOperationResponse<TContext>> execute() {\n+\n+        Flux<CosmosBulkOperationResponse<TContext>> responseFlux = this.inputOperations\n+            .onErrorResume((error) -> {\n+                // eat up the error signals\n+                return Mono.empty();\n+            })\n+            .doOnNext((CosmosItemOperation cosmosItemOperation) -> {\n+\n+                // Set the retry policy before starting execution. Should only happens once.\n+                BulkExecutorUtil.setRetryPolicyForBulk(cosmosItemOperation, this.throttlingRetryOptions);\n+\n+                totalCount.incrementAndGet();\n+            })\n+            .doOnComplete(() -> {\n+                mainSourceCompleted.set(true);\n+\n+                if (totalCount.get() == 0) {\n+                    // This is needed as there can be case that onComplete was called after last element was processed\n+                    // So complete the sink here also if count is 0, if source has completed and count isn't zero,\n+                    // then the last element in the doOnNext will close it. Sink doesn't mind in case of a double close.\n+\n+                    completeAllSinks();\n+                }\n+            })\n+            .mergeWith(mainFluxProcessor)\n+            .flatMap(operation -> {\n+\n+                // resolve partition key range id again for operations which comes in main sink due to gone retry.\n+                return BulkExecutorUtil.resolvePartitionKeyRangeId(this.docClientWrapper, this.container, operation)\n+                    .map((String pkRangeId) -> Pair.of(pkRangeId, operation));\n+            })\n+            .groupBy(Pair::getKey, Pair::getValue)\n+            .flatMap(this::executePartitionedGroup)\n+            .doOnNext(requestAndResponse -> {\n+\n+                if (totalCount.decrementAndGet() == 0 && mainSourceCompleted.get()) {\n+                    // It is possible that count is zero but there are more elements in the source.\n+                    // Count 0 also signifies that there are no pending elements in any sink.\n+\n+                    completeAllSinks();\n+                }\n+            });\n+\n+        return responseFlux;\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executePartitionedGroup(\n+        GroupedFlux<String, CosmosItemOperation> partitionedGroupFluxOfInputOperations) {\n+\n+        final String pkRange = partitionedGroupFluxOfInputOperations.key();\n+\n+        final FluxProcessor<CosmosItemOperation, CosmosItemOperation> groupFluxProcessor =\n+            UnicastProcessor.<CosmosItemOperation>create().serialize();\n+        final FluxSink<CosmosItemOperation> groupSink = groupFluxProcessor.sink(FluxSink.OverflowStrategy.BUFFER);\n+        groupSinks.add(groupSink);\n+\n+        return partitionedGroupFluxOfInputOperations\n+            .mergeWith(groupFluxProcessor)\n+            .bufferTimeout(this.maxMicroBatchSize, this.maxMicroBatchInterval)\n+            .onBackpressureBuffer()\n+            .flatMap((List<CosmosItemOperation> cosmosItemOperations) -> {\n+                return executeOperations(cosmosItemOperations, pkRange, groupSink);\n+            }, this.maxMicroBatchConcurrency);\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executeOperations(\n+        List<CosmosItemOperation> operations,\n+        String pkRange,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        ServerOperationBatchRequest serverOperationBatchRequest = BulkExecutorUtil.createBatchRequest(operations, pkRange);\n+        if (serverOperationBatchRequest.getBatchPendingOperations().size() > 0) {\n+            serverOperationBatchRequest.getBatchPendingOperations().forEach(groupSink::next);\n+        }\n+\n+        return Flux.just(serverOperationBatchRequest.getBatchRequest())\n+            .publishOn(Schedulers.elastic())\n+            .flatMap((PartitionKeyRangeServerBatchRequest serverRequest) -> {\n+                return this.executePartitionKeyRangeServerBatchRequest(serverRequest, groupSink);\n+            });\n+    }\n+\n+    private Flux<CosmosBulkOperationResponse<TContext>> executePartitionKeyRangeServerBatchRequest(\n+        PartitionKeyRangeServerBatchRequest serverRequest,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        return this.executeBatchRequest(serverRequest)\n+            .flatMapMany(response -> {\n+\n+                return Flux.fromIterable(response.getResults()).flatMap((TransactionalBatchOperationResult result) -> {\n+                    return handleTransactionalBatchOperationResult(response, result, groupSink);\n+                });\n+            })\n+            .onErrorResume((Throwable throwable) -> {\n+\n+                return Flux.fromIterable(serverRequest.getOperations()).flatMap((CosmosItemOperation itemOperation) -> {\n+                    return handleTransactionalBatchExecutionException(itemOperation, throwable, groupSink);\n+                });\n+            });\n+    }\n+\n+    // Helper functions\n+    private Mono<CosmosBulkOperationResponse<TContext>> handleTransactionalBatchOperationResult(\n+        TransactionalBatchResponse response,\n+        TransactionalBatchOperationResult operationResult,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        CosmosBulkItemResponse cosmosBulkItemResponse = BridgeInternal.createCosmosBulkItemResponse(operationResult, response);\n+        CosmosItemOperation itemOperation = operationResult.getOperation();\n+\n+        if (!operationResult.isSuccessStatusCode()) {\n+\n+            if(itemOperation instanceof ItemBulkOperation<?>) {\n+\n+                return ((ItemBulkOperation<?>) itemOperation).getRetryPolicy().shouldRetry(operationResult).flatMap(\n+                    result -> {\n+                        if (result.shouldRetry) {\n+                            groupSink.next(itemOperation);\n+                            return Mono.empty();\n+                        } else {\n+                            return Mono.just(BridgeInternal.createCosmosBulkOperationResponse(\n+                                itemOperation, cosmosBulkItemResponse, this.batchContext));\n+                        }\n+                    });\n+\n+            } else {\n+                throw new UnsupportedOperationException(\"Unknown CosmosItemOperation.\");\n+            }\n+        }\n+\n+        return Mono.just(BridgeInternal.createCosmosBulkOperationResponse(\n+            itemOperation,\n+            cosmosBulkItemResponse,\n+            this.batchContext));\n+    }\n+\n+    private Mono<CosmosBulkOperationResponse<TContext>> handleTransactionalBatchExecutionException(\n+        CosmosItemOperation itemOperation,\n+        Throwable throwable,\n+        FluxSink<CosmosItemOperation> groupSink) {\n+\n+        if(throwable instanceof CosmosException && itemOperation instanceof ItemBulkOperation<?>) {\n+            CosmosException cosmosException = (CosmosException) throwable;", "originalCommit": "ffedbec2559ce7e719c459fdb7ad7b80a0ab8968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MDg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518490865", "bodyText": "I can see both \"if( \" ~ without space and \"if (\" ~ with spaces in code. Not sure what we follow.", "author": "rakkuma", "createdAt": "2020-11-06T02:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxODE5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r518518195", "bodyText": "Will change it. The \"if (\" seems to be widely accepted elsewhere. Thanks.", "author": "rakkuma", "createdAt": "2020-11-06T04:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4ODY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\nindex 7c2b9255fc5..4b5d0499952 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/batch/BulkExecutor.java\n\n@@ -35,6 +35,26 @@ import java.util.concurrent.atomic.AtomicInteger;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n+/**\n+ * The Core logic of bulk execution is here.\n+ *\n+ * The actual execution of the flux of operations. It is done in following steps:\n+\n+ * 1. Getting partition key range ID and grouping operations using that id.\n+ * 2. For the flux of operations in a group, adding buffering based on size and a duration.\n+ * 3. For the operation we get in after buffering, process it using a batch request and return\n+ *    a wrapper having request, response(if-any) and exception(if-any). Either response or exception will be there.\n+ *\n+ * 4. Any internal retry is done by adding in an intermediate sink for each grouped flux.\n+ * 5. Any operation which failed due to partition key range gone is retried by putting it in the main sink which leads\n+ *    to re-calculation of partition key range id.\n+ * 6. At the end and this is very essential, we close all the sinks as the sink continues to waits for more and the\n+ *    execution isn't finished even if all the operations have been executed(figured out by completion call of source)\n+ *    Sink will more to a new interface from 3.5 and this is documentation for it:\n+ *    * https://github.com/reactor/reactor-core/blob/master/docs/asciidoc/processors.adoc\n+ *\n+ *    For our use case, Sinks.many().unicast() will work.\n+ */\n public final class BulkExecutor<TContext> {\n \n     private final static Logger logger = LoggerFactory.getLogger(BulkExecutor.class);\n"}}, {"oid": "77189fc3165e2f19006d3f329238e95b2e7e87f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77189fc3165e2f19006d3f329238e95b2e7e87f1", "message": "More test cases, handling collection refresh and few NITs\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T11:32:39Z", "type": "commit"}, {"oid": "dbe39418a26300f5613380c3a420ff043469ea93", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbe39418a26300f5613380c3a420ff043469ea93", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-06T11:46:19Z", "type": "commit"}, {"oid": "ef9f92b276631cd9e042d1dff60b23c6f7943a43", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ef9f92b276631cd9e042d1dff60b23c6f7943a43", "message": "Version bump\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T11:50:43Z", "type": "commit"}, {"oid": "2382a652e626a6ca0890b0401bae068245648fd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2382a652e626a6ca0890b0401bae068245648fd4", "message": "Bug\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-06T14:12:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520292110", "bodyText": "\"new\" prefix sounds very odd actually... are there any other options to consider here? \"insert\" or \"compose\" may be?", "author": "milismsft", "createdAt": "2020-11-10T05:18:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class BulkOperations {\n+\n+    /**\n+     * Instantiate an operation for Creating item in Bulk execution.\n+     *\n+     * @param <T> The type of item to be created.\n+     *\n+     * @param item A JSON serializable object that must contain an id property.\n+     * @param partitionKey the partition key for the operation\n+     *\n+     * @return the bulk operation.\n+     */\n+    public static <T> CosmosItemOperation newCreateItemOperation(T item, PartitionKey partitionKey) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxNjUxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520316510", "bodyText": "Insert seems like we are putting in a container. But we are returning the operation right.", "author": "rakkuma", "createdAt": "2020-11-10T06:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyNjk4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520326981", "bodyText": "How about \"compose\" or a similar wording? \"newCreate...\" and \"newDelete..\" just does not sound right... Plus \"new\" has a whole different meaning in Java, and in that case it's better if using a constructor method and not a static one; though I will guess that will add an explosion of new classes, for each operation type...", "author": "milismsft", "createdAt": "2020-11-10T06:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNTQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520935401", "bodyText": "to me as well \"new\" prefix seems odd. how about not having any prefix at all? (e.g., newCreateItemOperation() -> createItemOperation()", "author": "moderakh", "createdAt": "2020-11-10T23:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3Nzk0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525877946", "bodyText": "But this might seem like BulkOperation is executing the operation rather than returning the operation to be executed by another function. So that's why I was thinking to have a get/new or some similar verb.", "author": "rakkuma", "createdAt": "2020-11-18T07:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMxMDc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r527310751", "bodyText": "I agree with @rakkuma here, without prefix, it might confuse the user. I am fine with both getCreateItemOperation() or composeCreateItemOperation().", "author": "kushagraThapar", "createdAt": "2020-11-20T00:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMzODg0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r527338844", "bodyText": "Is this something the central SDK team should decide?", "author": "j82w", "createdAt": "2020-11-20T01:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMDQyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r529000422", "bodyText": "the SDK team decided on the \"get\" as the prefix: e.g.: getCreateItemOperation()", "author": "moderakh", "createdAt": "2020-11-23T21:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MjExMA=="}], "type": "inlineReview", "revised_code": {"commit": "dbaa99302bea4927d33455328aadab4130000668", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\nindex f8771d0e42e..892a99e8528 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\n\n@@ -32,6 +32,7 @@ public final class BulkOperations {\n      *\n      * @return the bulk operation.\n      */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n     public static <T> CosmosItemOperation newCreateItemOperation(T item, PartitionKey partitionKey) {\n         checkNotNull(item, \"expected non-null item\");\n         checkNotNull(partitionKey, \"expected non-null partitionKey\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDU2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520294564", "bodyText": "do we really need the TContext here? From the content of the rest of the class and its methods, it does not look like we have any particular logic to be considered based on this TContext.", "author": "milismsft", "createdAt": "2020-11-10T05:27:09Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.BatchRequestResponseConstants;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Encapsulates options for executing a bulk. This is immutable once\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} is called, changing it will have no affect.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class BulkProcessingOptions<TContext> {\n+    private int maxMicroBatchSize = BatchRequestResponseConstants.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST;\n+    private int maxMicroBatchConcurrency = BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_CONCURRENCY;\n+    private Duration maxMicroBatchInterval = Duration.ofMillis(BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_INTERVAL_IN_MILLISECONDS);\n+    private final TContext batchContext;\n+\n+    public BulkProcessingOptions(TContext batchContext) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODU4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520908589", "bodyText": "we'll need it - that is the way how the caller can pass through state needed to update bookmarks etc. We discussed this when we iterated over it in the public surface area discussions. Please leave it for now - we can add samples and then iterate if really needed.", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDU2NA=="}], "type": "inlineReview", "revised_code": {"commit": "f0c652f2406da5f7d3c23f1ee61667defcbb6115", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java\nindex 596e7ffece0..19bd88b84f8 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkProcessingOptions.java\n\n@@ -15,6 +15,7 @@ import java.time.Duration;\n  */\n @Beta(Beta.SinceVersion.V4_9_0)\n public final class BulkProcessingOptions<TContext> {\n+\n     private int maxMicroBatchSize = BatchRequestResponseConstants.MAX_OPERATIONS_IN_DIRECT_MODE_BATCH_REQUEST;\n     private int maxMicroBatchConcurrency = BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_CONCURRENCY;\n     private Duration maxMicroBatchInterval = Duration.ofMillis(BatchRequestResponseConstants.DEFAULT_MAX_MICRO_BATCH_INTERVAL_IN_MILLISECONDS);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520295452", "bodyText": "See my previous comment on TContext... I don't think we need it, so we might just remove this and keep the BulkProcessingOptions simpler.", "author": "milismsft", "createdAt": "2020-11-10T05:28:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -585,6 +586,74 @@ public String getId() {\n             });\n     }\n \n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations Flux of operation which will be executed by this container.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations) {\n+\n+        return this.processBulkOperations(operations, new BulkProcessingOptions<>());\n+    }\n+\n+    /**\n+     * Executes flux of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations Flux of operation which will be executed by this container.\n+     * @param bulkOptions Options that apply for this Bulk request which specifies options regarding execution like\n+     *                    concurrency, batching size, interval and context.\n+     *\n+     * @return A Flux of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> Flux<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        Flux<CosmosItemOperation> operations,\n+        BulkProcessingOptions<TContext> bulkOptions) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520908448", "bodyText": "we'll need it - that is the way how the caller can pass through state needed to update bookmarks etc. We discussed this when we iterated over it in the public surface area discussions. Please leave it for now - we can add samples and then iterate if really needed.", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTQ1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex 6748293160a..fb92f4730be 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -603,7 +603,7 @@ public class CosmosAsyncContainer {\n      *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n      *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n      * </p>\n-     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getException()} to\n      * get the exception.\n      */\n     @Beta(Beta.SinceVersion.V4_9_0)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520298905", "bodyText": "how will someone use an ETAG in the bulk operation context? I don't think it can be used...", "author": "milismsft", "createdAt": "2020-11-10T05:37:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTQ1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520299458", "bodyText": "Neve mind... the CosmosBulkItemResponse is per each operation in the bulk, right?", "author": "milismsft", "createdAt": "2020-11-10T05:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxMzIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520313203", "bodyText": "Yes. And like normal operations, etag will yield NotModified or condition failed", "author": "rakkuma", "createdAt": "2020-11-10T06:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5ODkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "dbaa99302bea4927d33455328aadab4130000668", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex 3619f5f9830..92cef9ee863 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -60,6 +60,7 @@ public final class CosmosBulkItemResponse {\n      *\n      * @return the activity ID that identifies the server request made to execute this operation.\n      */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n     public String getActivityId() {\n         return BatchExecUtils.getActivityId(this.responseHeaders);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520299892", "bodyText": "We should try to stay consistent.. in the above classes we use TContext rather than T", "author": "milismsft", "createdAt": "2020-11-10T05:40:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.batch.BatchExecUtils;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Flux;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Response of a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ *\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkItemResponse {\n+\n+    private final String eTag;\n+    private final double requestCharge;\n+    private final ObjectNode resourceObject;\n+    private final int statusCode;\n+    private final Duration retryAfter;\n+    private final int subStatusCode;\n+    private final Map<String, String> responseHeaders;\n+    private final CosmosDiagnostics cosmosDiagnostics;\n+\n+    /**\n+     * Initializes a new instance of the {@link CosmosBulkItemResponse} class.\n+     */\n+    CosmosBulkItemResponse(String eTag,\n+                           double requestCharge,\n+                           ObjectNode resourceObject,\n+                           int statusCode,\n+                           Duration retryAfter,\n+                           int subStatusCode,\n+                           Map<String, String> responseHeaders,\n+                           CosmosDiagnostics cosmosDiagnostics) {\n+\n+        checkNotNull(responseHeaders, \"expected non-null responseHeaders\");\n+\n+        this.eTag = eTag;\n+        this.requestCharge = requestCharge;\n+        this.resourceObject = resourceObject;\n+        this.statusCode = statusCode;\n+        this.retryAfter = retryAfter;\n+        this.subStatusCode = subStatusCode;\n+        this.responseHeaders = responseHeaders;\n+        this.cosmosDiagnostics = cosmosDiagnostics;\n+    }\n+\n+    /**\n+     * Gets the activity ID that identifies the server request made to execute this operation.\n+     *\n+     * @return the activity ID that identifies the server request made to execute this operation.\n+     */\n+    public String getActivityId() {\n+        return BatchExecUtils.getActivityId(this.responseHeaders);\n+    }\n+\n+    /**\n+     * Gets the entity tag associated with the current item.\n+     *\n+     * ETags are used for concurrency checking when updating resources.\n+     *\n+     * @return Entity tag associated with the current item.\n+     */\n+    public String getETag() {\n+        return this.eTag;\n+    }\n+\n+    /**\n+     * Gets the request charge as request units (RU) consumed by the current operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {\n+        return this.requestCharge;\n+    }\n+\n+    /**\n+     * Gets the item associated with the current result.\n+     *\n+     * @param <T> the type parameter\n+     *\n+     * @param type class type for which deserialization is needed.\n+     *\n+     * @return item associated with the current result.\n+     */\n+    public <T> T getItem(final Class<T> type) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMxMzk1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520313956", "bodyText": "Context is different, this is item type, the same is in TransactionalBatchItemResponse.", "author": "rakkuma", "createdAt": "2020-11-10T06:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyMjk5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520322995", "bodyText": "I'm not sure I understand... TContext is used to specify the POJO when creating a CosmosItemOperation, right? If so, should that be the same here?", "author": "milismsft", "createdAt": "2020-11-10T06:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMyNTEwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520325108", "bodyText": "No no. We are not fixing the type for a bulk execution. TContext is passed in the options. Operations in a bulk can have different class type. This is something for the users to distinguish between bulk executions.", "author": "rakkuma", "createdAt": "2020-11-10T06:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5OTg5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "dbaa99302bea4927d33455328aadab4130000668", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\nindex 3619f5f9830..92cef9ee863 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkItemResponse.java\n\n@@ -60,6 +60,7 @@ public final class CosmosBulkItemResponse {\n      *\n      * @return the activity ID that identifies the server request made to execute this operation.\n      */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n     public String getActivityId() {\n         return BatchExecUtils.getActivityId(this.responseHeaders);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzY1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520937657", "bodyText": "Throwable vs Exception vs CosmosException", "author": "moderakh", "createdAt": "2020-11-10T23:23:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Request, response and the exception(if any) for a {@link CosmosItemOperation} request when processed using Bulk by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)\n+public final class CosmosBulkOperationResponse<TContext> {\n+\n+    private final CosmosItemOperation operation;\n+    private final CosmosBulkItemResponse response;\n+    private final Throwable throwable;\n+    private final TContext batchContext;\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param response the {@link CosmosBulkItemResponse} the bulk response.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationResponse(CosmosItemOperation operation, CosmosBulkItemResponse response, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = response;\n+        this.throwable = null;\n+        this.batchContext = batchContext;\n+    }\n+\n+    /**\n+     * Initialises a new instance of {@link CosmosBulkOperationResponse}.\n+     *\n+     * @param operation the {@link CosmosItemOperation} for which this response object has values.\n+     * @param throwable the {@link Throwable} for this request.\n+     * @param batchContext the context of this bulk request.\n+     */\n+    CosmosBulkOperationResponse(CosmosItemOperation operation, Throwable throwable, TContext batchContext) {\n+        this.operation = operation;\n+        this.response = null;\n+        this.throwable = throwable;\n+        this.batchContext = batchContext;\n+    }\n+\n+    public CosmosItemOperation getOperation() {\n+        return operation;\n+    }\n+\n+    public CosmosBulkItemResponse getResponse() {\n+        return response;\n+    }\n+\n+    public Throwable getThrowable() {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MzY2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525973668", "bodyText": "Have kept it exception.", "author": "rakkuma", "createdAt": "2020-11-18T10:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzY1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java\nindex eb761574047..d7d2197e6b9 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosBulkOperationResponse.java\n\n@@ -15,7 +15,7 @@ public final class CosmosBulkOperationResponse<TContext> {\n \n     private final CosmosItemOperation operation;\n     private final CosmosBulkItemResponse response;\n-    private final Throwable throwable;\n+    private final Exception exception;\n     private final TContext batchContext;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODY2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520938663", "bodyText": "This should be Iterable instead of List.\nIterable is a better translation for Flux in sync world than a List.", "author": "moderakh", "createdAt": "2020-11-10T23:26:03Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -538,6 +554,64 @@ public TransactionalBatchResponse executeTransactionalBatch(\n         return this.blockBatchResponse(asyncContainer.executeTransactionalBatch(transactionalBatch, requestOptions));\n     }\n \n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations list of operation which will be executed by this container.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations) {\n+\n+        return this.blockBulkResponse(asyncContainer.processBulkOperations(Flux.fromIterable(operations)));\n+    }\n+\n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     *\n+     * @param operations list of operation which will be executed by this container.\n+     * @param bulkOptions Options that apply for this Bulk request which specifies options regarding execution like\n+     *                    concurrency, batching size, interval and context.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations,", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MjU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525972562", "bodyText": "Fixed. Thanks mo.", "author": "rakkuma", "createdAt": "2020-11-18T10:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\nindex 837bc1d9eb4..78c7e0f7834 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n\n@@ -571,12 +571,12 @@ public class CosmosContainer {\n      *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n      *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n      * </p>\n-     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getException()} to\n      * get the exception.\n      */\n     @Beta(Beta.SinceVersion.V4_9_0)\n     public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n-        List<CosmosItemOperation> operations) {\n+        Iterable<CosmosItemOperation> operations) {\n \n         return this.blockBulkResponse(asyncContainer.processBulkOperations(Flux.fromIterable(operations)));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzODcwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r520938709", "bodyText": "This should be Iterable instead of List.\nIterable is a better translation for Flux in sync world than a List.", "author": "moderakh", "createdAt": "2020-11-10T23:26:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -538,6 +554,64 @@ public TransactionalBatchResponse executeTransactionalBatch(\n         return this.blockBatchResponse(asyncContainer.executeTransactionalBatch(transactionalBatch, requestOptions));\n     }\n \n+    /**\n+     * Executes list of operations in Bulk.\n+     *\n+     * @param <TContext> The context for the bulk processing.\n+     * @param operations list of operation which will be executed by this container.\n+     *\n+     * @return A list of {@link CosmosBulkOperationResponse} which contains operation and it's response or exception.\n+     * <p>\n+     *     To create a operation which can be executed here, use {@link BulkOperations}. For eg.\n+     *     for a upsert operation use {@link BulkOperations#newUpsertItemOperation(Object, PartitionKey)}\n+     * </p>\n+     * <p>\n+     *     We can get the corresponding operation using {@link CosmosBulkOperationResponse#getOperation()} and\n+     *     it's response using {@link CosmosBulkOperationResponse#getResponse()}. If the operation was executed\n+     *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n+     *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n+     * </p>\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * get the exception.\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n+        List<CosmosItemOperation> operations) {", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\nindex 837bc1d9eb4..78c7e0f7834 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n\n@@ -571,12 +571,12 @@ public class CosmosContainer {\n      *     successfully, the value returned by {@link CosmosBulkItemResponse#isSuccessStatusCode()} will be true. To get\n      *     actual status use {@link CosmosBulkItemResponse#getStatusCode()}.\n      * </p>\n-     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getThrowable()} to\n+     * To check if the operation had any exception, use {@link CosmosBulkOperationResponse#getException()} to\n      * get the exception.\n      */\n     @Beta(Beta.SinceVersion.V4_9_0)\n     public <TContext> List<CosmosBulkOperationResponse<TContext>> processBulkOperations(\n-        List<CosmosItemOperation> operations) {\n+        Iterable<CosmosItemOperation> operations) {\n \n         return this.blockBulkResponse(asyncContainer.processBulkOperations(Flux.fromIterable(operations)));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r525881110", "bodyText": "@milismsft @kushagraThapar should we keep Beta tag on class or all it's functions? What's the best way?", "author": "rakkuma", "createdAt": "2020-11-18T08:03:40Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.batch.ItemBulkOperation;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.util.Beta;\n+import reactor.core.publisher.Flux;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * Utility for creating bulk operations which can be executed by calling\n+ * {@link CosmosAsyncContainer#processBulkOperations(Flux, BulkProcessingOptions)} .\n+ *\n+ * Also while creating these operation, if some options which are only for individual operation can be provided by passing\n+ * a {@link BulkItemRequestOptions} while creating the bulk operation.\n+ *\n+ * See also {@link BulkProcessingOptions}.\n+ */\n+@Beta(Beta.SinceVersion.V4_9_0)", "originalCommit": "2382a652e626a6ca0890b0401bae068245648fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyODU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r526528592", "bodyText": "Discussed with Milis. Beta tag on class makes more sense for newly added class. Also later, if a function is added to in class which is in beta, that function will have new beta.", "author": "rakkuma", "createdAt": "2020-11-19T01:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NDY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16763#discussion_r526544680", "bodyText": "absolutely :-)", "author": "milismsft", "createdAt": "2020-11-19T02:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MTExMA=="}], "type": "inlineReview", "revised_code": {"commit": "dbaa99302bea4927d33455328aadab4130000668", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\nindex f8771d0e42e..892a99e8528 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BulkOperations.java\n\n@@ -32,6 +32,7 @@ public final class BulkOperations {\n      *\n      * @return the bulk operation.\n      */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n     public static <T> CosmosItemOperation newCreateItemOperation(T item, PartitionKey partitionKey) {\n         checkNotNull(item, \"expected non-null item\");\n         checkNotNull(partitionKey, \"expected non-null partitionKey\");\n"}}, {"oid": "6a7be7cbb42113055b4f34602a9e92a91168ce8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6a7be7cbb42113055b4f34602a9e92a91168ce8c", "message": "Code review - exception and todos\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T08:55:03Z", "type": "commit"}, {"oid": "a509dfb049c77ae1fe034b8f09866b3651f66013", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a509dfb049c77ae1fe034b8f09866b3651f66013", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-18T09:09:08Z", "type": "commit"}, {"oid": "1db022fed55b382aad4a609c533e15cb6df305df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1db022fed55b382aad4a609c533e15cb6df305df", "message": "Exception init fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T09:26:09Z", "type": "commit"}, {"oid": "740a175938e2d0d68f19b4400d0c2fb8ebced560", "url": "https://github.com/Azure/azure-sdk-for-java/commit/740a175938e2d0d68f19b4400d0c2fb8ebced560", "message": "Minor fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T11:49:38Z", "type": "commit"}, {"oid": "07779e74c82fe2f7361da17e02251fc8a93aba97", "url": "https://github.com/Azure/azure-sdk-for-java/commit/07779e74c82fe2f7361da17e02251fc8a93aba97", "message": "Merging with master\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T14:54:49Z", "type": "commit"}, {"oid": "10777cdbd8aec0b7f8b2a37001553e9652db1e99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10777cdbd8aec0b7f8b2a37001553e9652db1e99", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-18T15:12:24Z", "type": "commit"}, {"oid": "b812c658c83abf5dcea1511db3e0d863cceeafc7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b812c658c83abf5dcea1511db3e0d863cceeafc7", "message": "Merging with master\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T09:40:42Z", "type": "commit"}, {"oid": "f0c652f2406da5f7d3c23f1ee61667defcbb6115", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0c652f2406da5f7d3c23f1ee61667defcbb6115", "message": "Fix\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T11:33:40Z", "type": "commit"}, {"oid": "dbaa99302bea4927d33455328aadab4130000668", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbaa99302bea4927d33455328aadab4130000668", "message": "Adding beta tags on functions\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-23T17:21:02Z", "type": "commit"}, {"oid": "8541a07fdf2abca507e6099c03e9912c969a2b79", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8541a07fdf2abca507e6099c03e9912c969a2b79", "message": "Merge branch 'master' into users/rakkuma/bulk-executor", "committedDate": "2020-11-24T01:56:03Z", "type": "commit"}, {"oid": "96a54e24182e5e1d3e43b2129ea2faaf360c5659", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96a54e24182e5e1d3e43b2129ea2faaf360c5659", "message": "new to get prefix + few test cases\n\nSigned-off-by: Rakesh Kumar <rakkuma@microsoft.com>", "committedDate": "2020-11-24T02:44:31Z", "type": "commit"}]}