{"pr_number": 11355, "pr_title": "Persistent service principal token cache for MSAL confidential client", "pr_createdAt": "2020-05-21T05:39:48Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/11355", "timeline": [{"oid": "ab170e6a2cfc5ade92bf8f27ac9815e5f26d457e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab170e6a2cfc5ade92bf8f27ac9815e5f26d457e", "message": "Use MSAL token cache for confidential client credentials", "committedDate": "2020-05-21T05:39:13Z", "type": "commit"}, {"oid": "5939411318bfdf625b8410cc3f43ab2345d0654c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5939411318bfdf625b8410cc3f43ab2345d0654c", "message": "Checkstyle: log exception", "committedDate": "2020-05-21T06:15:18Z", "type": "commit"}, {"oid": "9a75ef91f4cf345892f19fe9bb6195769ed690c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a75ef91f4cf345892f19fe9bb6195769ed690c1", "message": "improve cert parse error", "committedDate": "2020-05-21T07:30:08Z", "type": "commit"}, {"oid": "b9bbe33ce041b5bd31a796fa07074b839f5018d3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9bbe33ce041b5bd31a796fa07074b839f5018d3", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into confidentialtokencache", "committedDate": "2020-05-22T01:32:46Z", "type": "commit"}, {"oid": "2146503ac00d0d184f1243c7905761f3df446831", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2146503ac00d0d184f1243c7905761f3df446831", "message": "Remove force refresh for confidential client", "committedDate": "2020-05-26T23:22:40Z", "type": "commit"}, {"oid": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/832b1454993fe3dc61e69b09ceedf2c18218b2c8", "message": "Merge branch 'confidentialtokencache' of github.com:jianghaolu/azure-sdk-for-java into confidentialtokencache", "committedDate": "2020-05-26T23:22:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Nzg5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431477899", "bodyText": "Is there a case where authenticateWithConfidentialClientCache would return null? If not I believe these could be merged into the onErrorResume.", "author": "alzimmermsft", "createdAt": "2020-05-27T22:26:32Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431493659", "bodyText": "It could complete without calling onNext() so we cannot merge them.", "author": "jianghaolu", "createdAt": "2020-05-27T23:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3Nzg5OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431479460", "bodyText": "I don't know if we need the Mono.defer here, I believe switchIfEmpty only processes if the upstream returns empty otherwise it is never ran.", "author": "alzimmermsft", "createdAt": "2020-05-27T22:30:33Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzkyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431493925", "bodyText": "switchIfEmpty only processes the Mono if the upstream returns empty, but the method call identityClient.authenticateWithConfidentialClient() would be executed before the stream starts.", "author": "jianghaolu", "createdAt": "2020-05-27T23:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTQ2MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTM2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431481366", "bodyText": "Not needed, but given this has a lot of nesting and all other conditionals hit terminal states above could the else be removed for a regular code block?", "author": "alzimmermsft", "createdAt": "2020-05-27T22:36:01Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDMzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431494331", "bodyText": "removed.", "author": "jianghaolu", "createdAt": "2020-05-27T23:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MTM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex 189398becb2..20eeeac4573 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -141,79 +138,73 @@ public class IdentityClient {\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n-        } else {\n-            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n-            IClientCredential credential;\n-            if (clientSecret != null) {\n-                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n-            } else if (certificatePath != null) {\n-                try {\n-                    if (certificatePassword == null) {\n-                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n-                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n-                    } else {\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            new FileInputStream(certificatePath), certificatePassword);\n-                    }\n-                } catch (CertificateException\n-                    | UnrecoverableKeyException\n-                    | NoSuchAlgorithmException\n-                    | KeyStoreException\n-                    | NoSuchProviderException\n-                    | IOException e) {\n-                    throw logger.logExceptionAsError(new RuntimeException(\n-                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n-                }\n-            } else {\n-                throw logger.logExceptionAsError(\n-                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n-            }\n-            ConfidentialClientApplication.Builder applicationBuilder =\n-                ConfidentialClientApplication.builder(clientId, credential);\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n             try {\n-                applicationBuilder = applicationBuilder.authority(authorityUrl);\n-            } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n             }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n \n-            // If user supplies the pipeline, then it should override all other properties\n-            // as they should directly be set on the pipeline.\n-            HttpPipeline httpPipeline = options.getHttpPipeline();\n-            if (httpPipeline != null) {\n-                httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+            applicationBuilder.httpClient(httpPipelineAdapter);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n                 applicationBuilder.httpClient(httpPipelineAdapter);\n+            } else if (options.getProxyOptions() != null) {\n+                applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n             } else {\n-                // If http client is set on the credential, then it should override the proxy options if any configured.\n-                HttpClient httpClient = options.getHttpClient();\n-                if (httpClient != null) {\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                } else if (options.getProxyOptions() != null) {\n-                    applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n-                } else {\n-                    //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                }\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n+                applicationBuilder.httpClient(httpPipelineAdapter);\n             }\n+        }\n \n-            if (options.getExecutorService() != null) {\n-                applicationBuilder.executorService(options.getExecutorService());\n-            }\n-            if (options.isSharedTokenCacheEnabled()) {\n-                try {\n-                    applicationBuilder.setTokenCacheAccessAspect(\n-                        new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n-                } catch (Throwable t) {\n-                    throw logger.logExceptionAsError(new ClientAuthenticationException(\n-                        \"Shared token cache is unavailable in this environment.\", null, t));\n-                }\n+        if (options.getExecutorService() != null) {\n+            applicationBuilder.executorService(options.getExecutorService());\n+        }\n+        if (options.isSharedTokenCacheEnabled()) {\n+            try {\n+                applicationBuilder.setTokenCacheAccessAspect(\n+                    new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n+            } catch (Throwable t) {\n+                throw logger.logExceptionAsError(new ClientAuthenticationException(\n+                    \"Shared token cache is unavailable in this environment.\", null, t));\n             }\n-            this.confidentialClientApplication = applicationBuilder.build();\n-            return this.confidentialClientApplication;\n         }\n+        this.confidentialClientApplication = applicationBuilder.build();\n+        return this.confidentialClientApplication;\n     }\n \n     private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MjI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431482255", "bodyText": "Thoughts on merging all these to use their super class GeneralSecurityException.", "author": "alzimmermsft", "createdAt": "2020-05-27T22:38:30Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDYxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431494616", "bodyText": "works like a charm", "author": "jianghaolu", "createdAt": "2020-05-27T23:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MjI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex 189398becb2..20eeeac4573 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -141,79 +138,73 @@ public class IdentityClient {\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n-        } else {\n-            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n-            IClientCredential credential;\n-            if (clientSecret != null) {\n-                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n-            } else if (certificatePath != null) {\n-                try {\n-                    if (certificatePassword == null) {\n-                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n-                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n-                    } else {\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            new FileInputStream(certificatePath), certificatePassword);\n-                    }\n-                } catch (CertificateException\n-                    | UnrecoverableKeyException\n-                    | NoSuchAlgorithmException\n-                    | KeyStoreException\n-                    | NoSuchProviderException\n-                    | IOException e) {\n-                    throw logger.logExceptionAsError(new RuntimeException(\n-                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n-                }\n-            } else {\n-                throw logger.logExceptionAsError(\n-                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n-            }\n-            ConfidentialClientApplication.Builder applicationBuilder =\n-                ConfidentialClientApplication.builder(clientId, credential);\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n             try {\n-                applicationBuilder = applicationBuilder.authority(authorityUrl);\n-            } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n             }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n \n-            // If user supplies the pipeline, then it should override all other properties\n-            // as they should directly be set on the pipeline.\n-            HttpPipeline httpPipeline = options.getHttpPipeline();\n-            if (httpPipeline != null) {\n-                httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+            applicationBuilder.httpClient(httpPipelineAdapter);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n                 applicationBuilder.httpClient(httpPipelineAdapter);\n+            } else if (options.getProxyOptions() != null) {\n+                applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n             } else {\n-                // If http client is set on the credential, then it should override the proxy options if any configured.\n-                HttpClient httpClient = options.getHttpClient();\n-                if (httpClient != null) {\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                } else if (options.getProxyOptions() != null) {\n-                    applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n-                } else {\n-                    //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                }\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n+                applicationBuilder.httpClient(httpPipelineAdapter);\n             }\n+        }\n \n-            if (options.getExecutorService() != null) {\n-                applicationBuilder.executorService(options.getExecutorService());\n-            }\n-            if (options.isSharedTokenCacheEnabled()) {\n-                try {\n-                    applicationBuilder.setTokenCacheAccessAspect(\n-                        new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n-                } catch (Throwable t) {\n-                    throw logger.logExceptionAsError(new ClientAuthenticationException(\n-                        \"Shared token cache is unavailable in this environment.\", null, t));\n-                }\n+        if (options.getExecutorService() != null) {\n+            applicationBuilder.executorService(options.getExecutorService());\n+        }\n+        if (options.isSharedTokenCacheEnabled()) {\n+            try {\n+                applicationBuilder.setTokenCacheAccessAspect(\n+                    new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n+            } catch (Throwable t) {\n+                throw logger.logExceptionAsError(new ClientAuthenticationException(\n+                    \"Shared token cache is unavailable in this environment.\", null, t));\n             }\n-            this.confidentialClientApplication = applicationBuilder.build();\n-            return this.confidentialClientApplication;\n         }\n+        this.confidentialClientApplication = applicationBuilder.build();\n+        return this.confidentialClientApplication;\n     }\n \n     private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MzA1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431483050", "bodyText": "Would this be better off above attempting to retrieve the credential as this will fail without requiring IO or handling security? Basically, this is a lighter exception to have happen first.", "author": "alzimmermsft", "createdAt": "2020-05-27T22:40:42Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,9 +129,93 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be provided for user authentication.\"));\n+        } else {\n+            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+            IClientCredential credential;\n+            if (clientSecret != null) {\n+                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+            } else if (certificatePath != null) {\n+                try {\n+                    if (certificatePassword == null) {\n+                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                    } else {\n+                        credential = ClientCredentialFactory.createFromCertificate(\n+                            new FileInputStream(certificatePath), certificatePassword);\n+                    }\n+                } catch (CertificateException\n+                    | UnrecoverableKeyException\n+                    | NoSuchAlgorithmException\n+                    | KeyStoreException\n+                    | NoSuchProviderException\n+                    | IOException e) {\n+                    throw logger.logExceptionAsError(new RuntimeException(\n+                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+                }\n+            } else {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+            }\n+            ConfidentialClientApplication.Builder applicationBuilder =\n+                ConfidentialClientApplication.builder(clientId, credential);\n+            try {\n+                applicationBuilder = applicationBuilder.authority(authorityUrl);\n+            } catch (MalformedURLException e) {\n+                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+            }", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NzYwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431497604", "bodyText": "Unfortunately the ConfidentialClientApplication.Builder requires the credential to be passed in the constructor of the builder, not as a builder setter. So the authority has to be set after the credential.", "author": "jianghaolu", "createdAt": "2020-05-27T23:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4MzA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex 189398becb2..20eeeac4573 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -141,79 +138,73 @@ public class IdentityClient {\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n-        } else {\n-            String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n-            IClientCredential credential;\n-            if (clientSecret != null) {\n-                credential = ClientCredentialFactory.createFromSecret(clientSecret);\n-            } else if (certificatePath != null) {\n-                try {\n-                    if (certificatePassword == null) {\n-                        byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n-                            CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n-                    } else {\n-                        credential = ClientCredentialFactory.createFromCertificate(\n-                            new FileInputStream(certificatePath), certificatePassword);\n-                    }\n-                } catch (CertificateException\n-                    | UnrecoverableKeyException\n-                    | NoSuchAlgorithmException\n-                    | KeyStoreException\n-                    | NoSuchProviderException\n-                    | IOException e) {\n-                    throw logger.logExceptionAsError(new RuntimeException(\n-                        \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n-                }\n-            } else {\n-                throw logger.logExceptionAsError(\n-                    new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n-            }\n-            ConfidentialClientApplication.Builder applicationBuilder =\n-                ConfidentialClientApplication.builder(clientId, credential);\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n             try {\n-                applicationBuilder = applicationBuilder.authority(authorityUrl);\n-            } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n             }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n \n-            // If user supplies the pipeline, then it should override all other properties\n-            // as they should directly be set on the pipeline.\n-            HttpPipeline httpPipeline = options.getHttpPipeline();\n-            if (httpPipeline != null) {\n-                httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+            applicationBuilder.httpClient(httpPipelineAdapter);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n                 applicationBuilder.httpClient(httpPipelineAdapter);\n+            } else if (options.getProxyOptions() != null) {\n+                applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n             } else {\n-                // If http client is set on the credential, then it should override the proxy options if any configured.\n-                HttpClient httpClient = options.getHttpClient();\n-                if (httpClient != null) {\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                } else if (options.getProxyOptions() != null) {\n-                    applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n-                } else {\n-                    //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n-                    httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n-                    applicationBuilder.httpClient(httpPipelineAdapter);\n-                }\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n+                applicationBuilder.httpClient(httpPipelineAdapter);\n             }\n+        }\n \n-            if (options.getExecutorService() != null) {\n-                applicationBuilder.executorService(options.getExecutorService());\n-            }\n-            if (options.isSharedTokenCacheEnabled()) {\n-                try {\n-                    applicationBuilder.setTokenCacheAccessAspect(\n-                        new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n-                } catch (Throwable t) {\n-                    throw logger.logExceptionAsError(new ClientAuthenticationException(\n-                        \"Shared token cache is unavailable in this environment.\", null, t));\n-                }\n+        if (options.getExecutorService() != null) {\n+            applicationBuilder.executorService(options.getExecutorService());\n+        }\n+        if (options.isSharedTokenCacheEnabled()) {\n+            try {\n+                applicationBuilder.setTokenCacheAccessAspect(\n+                    new PersistenceTokenCacheAccessAspect(options.getConfidentialClientPersistenceSettings()));\n+            } catch (Throwable t) {\n+                throw logger.logExceptionAsError(new ClientAuthenticationException(\n+                    \"Shared token cache is unavailable in this environment.\", null, t));\n             }\n-            this.confidentialClientApplication = applicationBuilder.build();\n-            return this.confidentialClientApplication;\n         }\n+        this.confidentialClientApplication = applicationBuilder.build();\n+        return this.confidentialClientApplication;\n     }\n \n     private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDA0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431484046", "bodyText": "Does Mono.fromFuture wrap the thrown exception into a Mono.error or will this need to be handled as a regular exception?", "author": "alzimmermsft", "createdAt": "2020-05-27T22:43:29Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,19 +493,38 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 throw logger.logExceptionAsError(Exceptions.propagate(e));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    throw logger.logExceptionAsError(Exceptions.propagate(e));", "originalCommit": "832b1454993fe3dc61e69b09ceedf2c18218b2c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5Njc4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r431496787", "bodyText": "I'm not sure how reactor handles it. Since it's not documented even if there's anything, I'm returning CompletableFuture.failedFuture() instead.", "author": "jianghaolu", "createdAt": "2020-05-27T23:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex 189398becb2..20eeeac4573 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -490,7 +480,7 @@ public class IdentityClient {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return CompletableFuture.failedFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n             .filter(t -> !t.isExpired())\n"}}, {"oid": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d525f588c446825fac37a32a36a6c9fb7a9da27", "message": "Address Alan's feedback", "committedDate": "2020-05-27T23:24:49Z", "type": "commit"}, {"oid": "1d525f588c446825fac37a32a36a6c9fb7a9da27", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d525f588c446825fac37a32a36a6c9fb7a9da27", "message": "Address Alan's feedback", "committedDate": "2020-05-27T23:24:49Z", "type": "forcePushed"}, {"oid": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a10c1cc45aae05601eb1561397bfa24f52fafa82", "message": "Add helper to support failed completable future in java 8", "committedDate": "2020-05-28T04:54:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432077141", "bodyText": "the logic to build httpPipelineAdapter from line 177 - 193, can be extracted in a common helper method, and used in getPublicClient / getCofidentialClient methods.", "author": "g2vinay", "createdAt": "2020-05-28T19:43:57Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -114,67 +127,143 @@\n         }\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+        this.certificatePath = certificatePath;\n+        this.certificatePassword = certificatePassword;\n         this.options = options;\n     }\n \n-    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n-        if (publicClientApplication != null) {\n-            return publicClientApplication;\n+    private ConfidentialClientApplication getConfidentialClientApplication() {\n+        if (confidentialClientApplication != null) {\n+            return confidentialClientApplication;\n         } else if (clientId == null) {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"A non-null value for client ID must be provided for user authentication.\"));\n+        }\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId;\n+        IClientCredential credential;\n+        if (clientSecret != null) {\n+            credential = ClientCredentialFactory.createFromSecret(clientSecret);\n+        } else if (certificatePath != null) {\n+            try {\n+                if (certificatePassword == null) {\n+                    byte[] pemCertificateBytes = Files.readAllBytes(Paths.get(certificatePath));\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        CertificateUtil.privateKeyFromPem(pemCertificateBytes),\n+                        CertificateUtil.publicKeyFromPem(pemCertificateBytes));\n+                } else {\n+                    credential = ClientCredentialFactory.createFromCertificate(\n+                        new FileInputStream(certificatePath), certificatePassword);\n+                }\n+            } catch (IOException | GeneralSecurityException e) {\n+                throw logger.logExceptionAsError(new RuntimeException(\n+                    \"Failed to parse the certificate for the credential: \" + e.getMessage(), e));\n+            }\n+        } else {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Must provide client secret or client certificate path\"));\n+        }\n+        ConfidentialClientApplication.Builder applicationBuilder =\n+            ConfidentialClientApplication.builder(clientId, credential);\n+        try {\n+            applicationBuilder = applicationBuilder.authority(authorityUrl);\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsWarning(new IllegalStateException(e));\n+        }\n+\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182065", "bodyText": "That's not possible actually - the public client builder and the confidential client builder extends from a builder base that's not public. So from outside the MSAL library, the public client builder and confidential client builder are totally unrelated classes.", "author": "jianghaolu", "createdAt": "2020-05-28T23:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5OTQxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432199412", "bodyText": "I am talking about this possible change/refactor which can be used in both getPublicClient and getConfidentialClient methods.\n`HttpPipelineAdapter httpPipelineAdapter = getHttpPipelineAdapter();\nif (httpPipelineAdapter != null) {\napplicationBuilder.httpClient(httpPipelineAdapter);\n}  else {\napplicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n}\nprivate HttpPipelineAdapter getHttpPipelineAdapter() {\nHttpPipeline httpPipeline = options.getHttpPipeline();\nif (httpPipeline != null) {\nreturn new HttpPipelineAdapter(httpPipeline);\n} else {\n// If http client is set on the credential, then it should override the proxy options if any configured.\nHttpClient httpClient = options.getHttpClient();\nif (httpClient != null) {\nreturn new HttpPipelineAdapter(setupPipeline(httpClient));\n} else if (options.getProxyOptions() != null) {\nreturn null;\n} else {\nreturn new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n}\n}`", "author": "g2vinay", "createdAt": "2020-05-29T00:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMjgwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432202803", "bodyText": "Refactored.", "author": "jianghaolu", "createdAt": "2020-05-29T01:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NzE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e33fe44957cd9997a132df0776563f4fc7ae61e8", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex e1c0aac26fa..acbf7e9837a 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -171,25 +171,11 @@ public class IdentityClient {\n             throw logger.logExceptionAsWarning(new IllegalStateException(e));\n         }\n \n-        // If user supplies the pipeline, then it should override all other properties\n-        // as they should directly be set on the pipeline.\n-        HttpPipeline httpPipeline = options.getHttpPipeline();\n-        if (httpPipeline != null) {\n-            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        initializeHttpPipelineAdapter();\n+        if (httpPipelineAdapter != null) {\n             applicationBuilder.httpClient(httpPipelineAdapter);\n         } else {\n-            // If http client is set on the credential, then it should override the proxy options if any configured.\n-            HttpClient httpClient = options.getHttpClient();\n-            if (httpClient != null) {\n-                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n-                applicationBuilder.httpClient(httpPipelineAdapter);\n-            } else if (options.getProxyOptions() != null) {\n-                applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n-            } else {\n-                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n-                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));\n-                applicationBuilder.httpClient(httpPipelineAdapter);\n-            }\n+            applicationBuilder.proxy(proxyOptionsToJavaNetProxy(options.getProxyOptions()));\n         }\n \n         if (options.getExecutorService() != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432160140", "bodyText": "we'll need to plumb this change in custom Token Credential Auth policies too where a cache is being maintained.\nWe can open an issue, for now, to track this work and get that change added to Track 2 SDKs when Identity is about to GA.", "author": "g2vinay", "createdAt": "2020-05-28T22:31:52Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -36,16 +34,15 @@ public BearerTokenAuthenticationPolicy(TokenCredential credential, String... sco\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.scopes = scopes;\n-        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n+        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n     }\n \n     @Override\n     public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n         if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n             return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n         }\n-        return cache.getToken()\n+        return credential.getToken(tokenRequestContext)", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjQ3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182470", "bodyText": "Which custom policies? You mean in service SDKs like Key Vault?", "author": "jianghaolu", "createdAt": "2020-05-28T23:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NTk1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432195957", "bodyText": "This is no longer an issue since this change is reverted for now to keep backward compatibility in azure-core until Azure Identity releases a stable version.", "author": "jianghaolu", "createdAt": "2020-05-29T00:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "f224a4529f5849217906dd704083addfe17384cd", "chunk": "diff --git a/sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java b/sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java\nindex 3ab432c07e3..f643b497566 100644\n--- a/sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java\n+++ b/sdk/core/azure-core/src/main/java/com/azure/core/http/policy/BearerTokenAuthenticationPolicy.java\n\n@@ -34,7 +36,8 @@ public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n         Objects.requireNonNull(scopes);\n         assert scopes.length > 0;\n         this.credential = credential;\n-        this.tokenRequestContext = new TokenRequestContext().addScopes(scopes);\n+        this.scopes = scopes;\n+        this.cache = new SimpleTokenCache(() -> credential.getToken(new TokenRequestContext().addScopes(scopes)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MzUzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432163536", "bodyText": "Why is this call not deferred ?", "author": "g2vinay", "createdAt": "2020-05-28T22:41:59Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432182834", "bodyText": "This call can happen when getToken() is called - it's not conditional on anything else.", "author": "jianghaolu", "createdAt": "2020-05-28T23:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MzUzNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164005", "bodyText": "Why is this call not deferred ?", "author": "g2vinay", "createdAt": "2020-05-28T22:43:22Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredential.java", "diffHunk": "@@ -44,13 +42,15 @@\n         identityClient = new IdentityClientBuilder()\n             .tenantId(tenantId)\n             .clientId(clientId)\n+            .clientSecret(clientSecret)\n             .identityClientOptions(identityClientOptions)\n             .build();\n-        this.clientSecret = clientSecret;\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        return identityClient.authenticateWithClientSecret(clientSecret, request);\n+        return identityClient.authenticateWithConfidentialClientCache(request)", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MzQzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183432", "bodyText": "Same as above. We only need to defer a call when certain variables or conditions must be met. For example, 2 lines down - the authenticateWithConfidentialClient() should happen only if there's a cache miss. But for this line, we have all the variables needed initialized, and reading from the cache should always happen without conditions.", "author": "jianghaolu", "createdAt": "2020-05-28T23:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDAwNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDM3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432164370", "bodyText": "Indicates whether to enable ?", "author": "g2vinay", "createdAt": "2020-05-28T22:44:37Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4Mzg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183843", "bodyText": "Fixed.", "author": "jianghaolu", "createdAt": "2020-05-28T23:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "402109c6529f055337161b4213c2fc476f879f5a", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\nindex 12b6a9915c6..1e0c3568b3b 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\n\n@@ -28,7 +28,7 @@ public class ClientSecretCredentialBuilder extends AadCredentialBuilderBase<Clie\n     /**\n      * Sets whether to enable using the shared token cache. This is disabled by default.\n      *\n-     * @param enabled whether to enabled using the shared token cache.\n+     * @param enabled indicates whether to enable using the shared token cache.\n      *\n      * @return An updated instance of this builder with if the shared token cache enabled specified.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169302", "bodyText": "Why are we doing Exceptions.propagate and not directly converting to Runtime Exception ?", "author": "g2vinay", "createdAt": "2020-05-28T22:59:21Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MzkyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432183927", "bodyText": "@alzimmermsft suggested this usage pattern to me.", "author": "jianghaolu", "createdAt": "2020-05-28T23:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NTE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432185153", "bodyText": "Actually I know a reason - if e is already a subclass of RuntimeException, wrapping it in another RuntimeException is bad. Exceptions.propagate(e) will check if e is a RuntimeException first and only wrap if not.", "author": "jianghaolu", "createdAt": "2020-05-28T23:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NTQxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432195415", "bodyText": "Okay,\nBut we already know, MalformedURLException is not a RuntimeException here.\nSo, that check is redundant.", "author": "g2vinay", "createdAt": "2020-05-29T00:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMzgzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432203833", "bodyText": "That's correct. But at this point it's really a personal preference thing. I changed it to new RuntimeException() for the if check it saves. But one could argue in the future if more exceptions are thrown or this code path is refactored to merge with other paths that could throw RuntimeExceptions this could potentially be a point of failure. The point is, it's not critical.", "author": "jianghaolu", "createdAt": "2020-05-29T01:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "1c100d5ba097af9d5ba670b34d010f25d5606681", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex e1c0aac26fa..9b2443aaebd 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -481,7 +452,7 @@ public class IdentityClient {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n             .filter(t -> !t.isExpired())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTg1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432169857", "bodyText": "Do we expect MSAL to return an expired token ?", "author": "g2vinay", "createdAt": "2020-05-28T23:00:56Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -487,22 +481,41 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n-        .filter(t -> !t.isExpired())\n-        .switchIfEmpty(Mono.fromFuture(() -> {\n-            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n-                new HashSet<>(request.getScopes())).forceRefresh(true);\n-            if (account != null) {\n-                forceParametersBuilder = forceParametersBuilder.account(account);\n-            }\n+            .filter(t -> !t.isExpired())\n+            .switchIfEmpty(Mono.fromFuture(() -> {\n+                SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                    new HashSet<>(request.getScopes())).forceRefresh(true);\n+                if (account != null) {\n+                    forceParametersBuilder = forceParametersBuilder.account(account);\n+                }\n+                try {\n+                    return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                } catch (MalformedURLException e) {\n+                    return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                }\n+            }).map(result -> new MsalToken(result, options)));\n+    }\n+\n+    /**\n+     * Asynchronously acquire a token from the currently logged in client.\n+     *\n+     * @param request the details of the token request\n+     * @return a Publisher that emits an AccessToken\n+     */\n+    public Mono<AccessToken> authenticateWithConfidentialClientCache(TokenRequestContext request) {\n+        return Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes()));\n             try {\n-                return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+                return getConfidentialClientApplication().acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                throw logger.logExceptionAsError(Exceptions.propagate(e));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n             }\n-        }).map(result -> new MsalToken(result, options))));\n+        }).map(ar -> (AccessToken) new MsalToken(ar, options))\n+            .filter(t -> !t.isExpired());", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NDM1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432184358", "bodyText": "No. But a non-expired IAuthenticationResult could be an expired AccessToken because of the offset. In my token refresh offset re-work, this line will be changed to .filter(t -> OffsetDateTime.now().isBefore(t.getExpiresAt().minus(identityClientOptions.getTokenRefreshOffset()))); But for now this may look a little confusing.", "author": "jianghaolu", "createdAt": "2020-05-28T23:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2OTg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1c100d5ba097af9d5ba670b34d010f25d5606681", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\nindex e1c0aac26fa..9b2443aaebd 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java\n\n@@ -481,7 +452,7 @@ public class IdentityClient {\n                 return getPublicClientApplication(false)\n                     .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return getFailedCompletableFuture(logger.logExceptionAsError(Exceptions.propagate(e)));\n+                return getFailedCompletableFuture(logger.logExceptionAsError(new RuntimeException(e)));\n             }\n         }).map(ar -> new MsalToken(ar, options))\n             .filter(t -> !t.isExpired())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTE0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432171148", "bodyText": "Is this cache name going to be same across all languages ?", "author": "g2vinay", "createdAt": "2020-05-28T23:04:59Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClientOptions.java", "diffHunk": "@@ -24,15 +24,18 @@\n  */\n public final class IdentityClientOptions {\n     private static final int MAX_RETRY_DEFAULT_LIMIT = 3;\n-    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_PUBLIC_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final String DEFAULT_CONFIDENTIAL_CACHE_FILE_NAME = \"msal.confidential.cache\";", "originalCommit": "a10c1cc45aae05601eb1561397bfa24f52fafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4NDQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432184484", "bodyText": "Yes. This is the name for Windows regardless of languages.", "author": "jianghaolu", "createdAt": "2020-05-28T23:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTE0OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "402109c6529f055337161b4213c2fc476f879f5a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/402109c6529f055337161b4213c2fc476f879f5a", "message": "Add setter for client certificate credential builder and fix javadoc", "committedDate": "2020-05-28T23:50:57Z", "type": "commit"}, {"oid": "f224a4529f5849217906dd704083addfe17384cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f224a4529f5849217906dd704083addfe17384cd", "message": "Revert changes in azure-core for backward compatibility", "committedDate": "2020-05-29T00:28:35Z", "type": "commit"}, {"oid": "e33fe44957cd9997a132df0776563f4fc7ae61e8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e33fe44957cd9997a132df0776563f4fc7ae61e8", "message": "Clean up HttpPipelineAdapter creation", "committedDate": "2020-05-29T01:00:18Z", "type": "commit"}, {"oid": "1c100d5ba097af9d5ba670b34d010f25d5606681", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c100d5ba097af9d5ba670b34d010f25d5606681", "message": "new RuntimeException()", "committedDate": "2020-05-29T01:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDMwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432724308", "bodyText": "Is Mono.defer() necessary? You can simply do switchIfEmpty(identityClient.authenticateWithConfidentialClient(request)) since this gets triggered only if the cache returns empty result and doesn't have to be deferred.", "author": "srnagar", "createdAt": "2020-05-29T20:39:58Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientCertificateCredential.java", "diffHunk": "@@ -40,22 +38,19 @@\n     ClientCertificateCredential(String tenantId, String clientId, String certificatePath, String certificatePassword,\n                                 IdentityClientOptions identityClientOptions) {\n         Objects.requireNonNull(certificatePath, \"'certificatePath' cannot be null.\");\n-        this.clientCertificate = certificatePath;\n-        this.clientCertificatePassword = certificatePassword;\n-        identityClient =\n-            new IdentityClientBuilder()\n-                .tenantId(tenantId)\n-                .clientId(clientId)\n-                .identityClientOptions(identityClientOptions)\n-                .build();\n+        identityClient = new IdentityClientBuilder()\n+            .tenantId(tenantId)\n+            .clientId(clientId)\n+            .certificatePath(certificatePath)\n+            .certificatePassword(certificatePassword)\n+            .identityClientOptions(identityClientOptions)\n+            .build();\n     }\n \n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        if (clientCertificatePassword != null) {\n-            return identityClient.authenticateWithPfxCertificate(clientCertificate, clientCertificatePassword, request);\n-        } else {\n-            return identityClient.authenticateWithPemCertificate(clientCertificate, request);\n-        }\n+        return identityClient.authenticateWithConfidentialClientCache(request)\n+            .onErrorResume(t -> Mono.empty())\n+            .switchIfEmpty(Mono.defer(() -> identityClient.authenticateWithConfidentialClient(request)));", "originalCommit": "1c100d5ba097af9d5ba670b34d010f25d5606681", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MzQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432743453", "bodyText": "@alzimmermsft asked the same question. if we do switchIfEmpty(identityClient.authenticateWithConfidentialClient(request)) the method call identityClient.authenticateWithConfidentialClient(request) will be evaluated first but we do not want that.", "author": "jianghaolu", "createdAt": "2020-05-29T21:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDMwOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNjQxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432726419", "bodyText": "This reads a bit odd. You can simplify this: An updated instance of this builder.", "author": "srnagar", "createdAt": "2020-05-29T20:44:54Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java", "diffHunk": "@@ -25,6 +25,18 @@ public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled indicates whether to enable using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.", "originalCommit": "1c100d5ba097af9d5ba670b34d010f25d5606681", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NTUwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432745505", "bodyText": "Simplified.", "author": "jianghaolu", "createdAt": "2020-05-29T21:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNjQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b606b79df2c05c58f65b92611beca8c4d237f131", "chunk": "diff --git a/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java b/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\nindex 1e0c3568b3b..a5382f14066 100644\n--- a/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\n+++ b/sdk/identity/azure-identity/src/main/java/com/azure/identity/ClientSecretCredentialBuilder.java\n\n@@ -18,7 +18,7 @@ public class ClientSecretCredentialBuilder extends AadCredentialBuilderBase<Clie\n     /**\n      * Sets the client secret for the authentication.\n      * @param clientSecret the secret value of the AAD application.\n-     * @return the ClientSecretCredentialBuilder itself\n+     * @return An updated instance of this builder.\n      */\n     public ClientSecretCredentialBuilder clientSecret(String clientSecret) {\n         this.clientSecret = clientSecret;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432731450", "bodyText": "Should this throw an exception if httpClient is null and proxy options are set?", "author": "srnagar", "createdAt": "2020-05-29T20:57:16Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -877,4 +861,28 @@ void openUrl(String url) throws IOException {\n             logger.error(\"Browser could not be opened - please open {} in a browser on this device.\", url);\n         }\n     }\n+\n+    private CompletableFuture<IAuthenticationResult> getFailedCompletableFuture(Exception e) {\n+        CompletableFuture<IAuthenticationResult> completableFuture = new CompletableFuture<>();\n+        completableFuture.completeExceptionally(e);\n+        return completableFuture;\n+    }\n+\n+    private void initializeHttpPipelineAdapter() {\n+        // If user supplies the pipeline, then it should override all other properties\n+        // as they should directly be set on the pipeline.\n+        HttpPipeline httpPipeline = options.getHttpPipeline();\n+        if (httpPipeline != null) {\n+            httpPipelineAdapter = new HttpPipelineAdapter(httpPipeline);\n+        } else {\n+            // If http client is set on the credential, then it should override the proxy options if any configured.\n+            HttpClient httpClient = options.getHttpClient();\n+            if (httpClient != null) {\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(httpClient));\n+            } else if (options.getProxyOptions() == null) {\n+                //Http Client is null, proxy options are not set, use the default client and build the pipeline.\n+                httpPipelineAdapter = new HttpPipelineAdapter(setupPipeline(HttpClient.createDefault()));", "originalCommit": "1c100d5ba097af9d5ba670b34d010f25d5606681", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NDYxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11355#discussion_r432744613", "bodyText": "No - it's a valid scenario which is handled in line 177: https://github.com/Azure/azure-sdk-for-java/pull/11355/files/1c100d5ba097af9d5ba670b34d010f25d5606681#diff-56093106beda983b28894478869221c6R177. Basically, the only time we don't want to initialize the httpPipelineAdapter is when a proxy option is provided - in which case we pass the proxy option directly to MSAL for backward compatibility. New users should set the proxy options on the httpClient.", "author": "jianghaolu", "createdAt": "2020-05-29T21:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTQ1MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b606b79df2c05c58f65b92611beca8c4d237f131", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b606b79df2c05c58f65b92611beca8c4d237f131", "message": "Simply @return docs on builders", "committedDate": "2020-05-29T21:33:28Z", "type": "commit"}]}