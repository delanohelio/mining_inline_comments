{"pr_number": 13600, "pr_title": "Add TypeReference.createInstance(Class<T>)", "pr_createdAt": "2020-07-29T17:53:16Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/13600", "timeline": [{"oid": "ece7eea2138dcb029d448c1db53b749417119974", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ece7eea2138dcb029d448c1db53b749417119974", "message": "Add TypeReference.createInstance(Class<T>) to create and cache non-parameterized TypeReferences", "committedDate": "2020-07-29T17:51:39Z", "type": "commit"}, {"oid": "535b8dd4c5978a7fa40e58f65d9459bf131fa2cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/535b8dd4c5978a7fa40e58f65d9459bf131fa2cd", "message": "Merge from upstream, fixed merge conflicts", "committedDate": "2020-07-29T17:59:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwNTU5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r462505599", "bodyText": "Several questions here:\n\nDo we only cache the non-Parameterized class? (e.g. Hotel) What about the Parameterized type class like Map<>?\nIs the Class<?> able to compare in Map?\nDo we waste memory by using map cache? Search user might have many different models(hotel, book etc). It might improve a bit in time but you cannot predict how large the cache map is.\n\nE.g. if customer just pass you inner subclass, then it is different classes every time make the call. I am afraid it will crash the system since we do not have LRU clean up as normal cache.", "author": "sima-zhu", "createdAt": "2020-07-29T18:34:47Z", "path": "sdk/core/azure-core-experimental/src/main/java/com/azure/core/experimental/serializer/TypeReference.java", "diffHunk": "@@ -16,6 +19,8 @@\n     private static final ClientLogger LOGGER = new ClientLogger(TypeReference.class);\n     private static final String MISSING_TYPE = \"Type constructed without type information.\";\n \n+    private static final Map<Class<?>, TypeReference<?>> CACHE = new ConcurrentHashMap<>();", "originalCommit": "535b8dd4c5978a7fa40e58f65d9459bf131fa2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxNTQyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r462515423", "bodyText": "Can only cache non-parameterized types as ParameterizedType isn't capable of maintaining T, so it will lose generic functionality in return.\n\n\nClass<?> could be Map but is cannot be Map<String, Object> due to point 1.\n\n\nThe size of this map will be trivial, it would take thousands and thousands of entries for it to register moderate memory usage. It'll help reduce GC pressure when creating a new short-lived TypeReference instance for Class based instances.", "author": "alzimmermsft", "createdAt": "2020-07-29T18:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwNTU5OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODI5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r462508296", "bodyText": "It looks a little weird by having both createInstance and public constructor.", "author": "sima-zhu", "createdAt": "2020-07-29T18:39:31Z", "path": "sdk/core/azure-core-experimental/src/main/java/com/azure/core/experimental/serializer/TypeReference.java", "diffHunk": "@@ -24,19 +29,44 @@\n      * @throws IllegalArgumentException If the reference is constructed without type information.\n      */\n     public TypeReference() {\n-        java.lang.reflect.Type superClass = this.getClass().getGenericSuperclass();\n+        Type superClass = this.getClass().getGenericSuperclass();\n         if (superClass instanceof Class) {\n             throw LOGGER.logExceptionAsError(new IllegalArgumentException(MISSING_TYPE));\n         } else {\n             this.javaType = ((ParameterizedType) superClass).getActualTypeArguments()[0];\n         }\n     }\n \n+    private TypeReference(Class<T> clazz) {\n+        this.javaType = clazz;\n+    }\n+\n     /**\n-     * Return class T type\n-     * @return type\n+     * Returns the {@link Type} representing {@code T}.\n+     *\n+     * @return The {@link Type} representing {@code T}.\n      */\n-    public java.lang.reflect.Type getJavaType() {\n+    public Type getJavaType() {\n         return javaType;\n     }\n+\n+    /**\n+     * Creates and instance of {@link TypeReference} which maintains the generic {@code T} of the passed {@link Class}.\n+     * <p>\n+     * This method will cache the instance of {@link TypeReference} using the passed {@link Class} as the key. This is\n+     * meant to be used with non-generic types such as primitive object types and POJOs, not {@code Map<String, Object>}\n+     * or {@code List<Integer>} parameterized types.\n+     *\n+     * @param clazz {@link Class} that contains generic information used to create the {@link TypeReference}.\n+     * @param <T> The generic type.\n+     * @return Either the cached or new instance of {@link TypeReference}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> TypeReference<T> createInstance(Class<T> clazz) {", "originalCommit": "535b8dd4c5978a7fa40e58f65d9459bf131fa2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxNjg4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r462516881", "bodyText": "They serve different purposes. The public constructor is for anonymous instances that use parameterized types for their T, such as Map<String, String>. This factory method is meant for non-parameterized Class types that can be safely cached and maintain T.", "author": "alzimmermsft", "createdAt": "2020-07-29T18:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTI3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r462585276", "bodyText": "Yeah, this is a bit odd. They serve different purposes but the constructor works for all cases and if the caller always uses the ctor not knowing about the static createInstance method, it may defeat the purpose of caching.\nAlso, in azure-core, there is a TypeUtil that has a utility method to createParameterizedType() that may be useful.", "author": "srnagar", "createdAt": "2020-07-29T20:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MTYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r463151607", "bodyText": "The public constructor work with most of the cases like (concrete class, paramterized type), but not the clazz variable cases.\nE.g.\npublic void someMethod(Class<T> clazz) {\n    TypeReference<T> type = new TypeReference<T>() {} // type is null in this case, no matter what clazz you passed in.\n    ...\n }\n\nIn this case, we must use the createInstance API. However, createInstance API does not serve all purpose as well, we cannot pass the parameterized type here.\nSo both APIs have hard limitations and caching strategy are different behind the API. If I am not expert users I would confuse of the usage here.", "author": "sima-zhu", "createdAt": "2020-07-30T17:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1NDY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13600#discussion_r463154659", "bodyText": "Agreed @sima-zhu, having both does lead to some confusion. Luckily, this type is mainly going to be used internally where determining whether to use createInstance(Class<T>) or the constructor will be based on the API. If the type is known ahead of time and it is parameterized the only choice is to use the constructor, if the type is known but is a Class<T> or is passed into the API createInstance(Class<T>) will be used.", "author": "alzimmermsft", "createdAt": "2020-07-30T17:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODI5Ng=="}], "type": "inlineReview", "revised_code": null}]}