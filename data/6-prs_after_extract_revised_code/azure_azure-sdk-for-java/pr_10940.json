{"pr_number": 10940, "pr_title": "Servicebus track2 sync queue up multiple receive calls ", "pr_createdAt": "2020-05-08T02:48:16Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10940", "timeline": [{"oid": "be7f82b19b7381cf34b92bbfd6388ce6db699537", "url": "https://github.com/Azure/azure-sdk-for-java/commit/be7f82b19b7381cf34b92bbfd6388ce6db699537", "message": "First draft implementation", "committedDate": "2020-05-07T22:30:23Z", "type": "commit"}, {"oid": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "message": "Queue up the receive request queuest", "committedDate": "2020-05-08T02:47:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421906793", "bodyText": "Why is this an atomic reference? If I remember correctly you are synchronizing on a lock. Only one thread can be in the method.", "author": "conniey", "createdAt": "2020-05-08T02:50:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -41,8 +42,11 @@\n         .setIsAutoCompleteEnabled(false)\n         .setMaxAutoLockRenewalDuration(Duration.ZERO);\n \n-    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageProcessor =\n+    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMTIzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422531237", "bodyText": "It is because checkstyle complain, I really do not need atomic reference because I synchronizing.", "author": "hemanttanwar", "createdAt": "2020-05-09T18:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MzYyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423083622", "bodyText": "What does checkstyle complain about?", "author": "conniey", "createdAt": "2020-05-11T14:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2NDIzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423264231", "bodyText": "This is the error we get: The variable field 'messageSource ' of class 'implements' should be final. Classes annotated with @ServiceClient are supposed to be immutable. [ServiceClient]\nAnd we can not define it as final, since we need to init it outside of constructor .", "author": "hemanttanwar", "createdAt": "2020-05-11T19:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNjc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "41cec1e23d6719dd855e917ee664ff0fb524fe57", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 5ac27cd602b..6335cf93221 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -44,8 +44,12 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n     private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =\n         new AtomicReference<>();\n+\n+    /* To hold each recive as work item to be processed.*/\n     private final AtomicReference<EmitterProcessor<SynchronousMessageSubscriber>> workQueueProcessor =\n         new AtomicReference<>(EmitterProcessor.create(false));\n+\n+    /*Subscriber which will process each work item in sequence.*/\n     private final AtomicReference<Disposable> workSubscriber = new AtomicReference<>();\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwODE4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421908183", "bodyText": "Why do you need another emitter processor? Processors are useful when it listens upstream and publishes downstream. In this case, you are using it as a sink.", "author": "conniey", "createdAt": "2020-05-08T02:56:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -41,8 +42,11 @@\n         .setIsAutoCompleteEnabled(false)\n         .setMaxAutoLockRenewalDuration(Duration.ZERO);\n \n-    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageProcessor =\n+    private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =\n         new AtomicReference<>();\n+    private final AtomicReference<EmitterProcessor<SynchronousMessageSubscriber>> workQueueProcessor =", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "41cec1e23d6719dd855e917ee664ff0fb524fe57", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 5ac27cd602b..6335cf93221 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -44,8 +44,12 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n     private final AtomicReference<EmitterProcessor<ServiceBusReceivedMessageContext>> messageSource =\n         new AtomicReference<>();\n+\n+    /* To hold each recive as work item to be processed.*/\n     private final AtomicReference<EmitterProcessor<SynchronousMessageSubscriber>> workQueueProcessor =\n         new AtomicReference<>(EmitterProcessor.create(false));\n+\n+    /*Subscriber which will process each work item in sequence.*/\n     private final AtomicReference<Disposable> workSubscriber = new AtomicReference<>();\n \n     /**\n"}}, {"oid": "41cec1e23d6719dd855e917ee664ff0fb524fe57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/41cec1e23d6719dd855e917ee664ff0fb524fe57", "message": "Improved logging", "committedDate": "2020-05-08T03:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMjMzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r421912334", "bodyText": "These should be done through a sink.", "author": "conniey", "createdAt": "2020-05-08T03:12:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +631,40 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n \n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n             final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+            EmitterProcessor<SynchronousMessageSubscriber> workProcessor = workQueueProcessor.get();\n+            workProcessor.onNext(syncSubscriber);", "originalCommit": "fb34f1c57fdebc62ecfb99b50e6924621c5084a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ed2f312f8b421b6165b71871590befd1f30fdae", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 5ac27cd602b..b63ed063175 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -649,20 +653,20 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n             // make sure message source processor exists.\n             EmitterProcessor<ServiceBusReceivedMessageContext> source = messageSource.get();\n             if (source == null) {\n-                source = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                source = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n                     .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n                 messageSource.set(source);\n-                logger.info(\"Created source for receiving messages.\");\n+                logger.verbose(\"Created source for receiving messages from [{}]\", asyncClient.getEntityPath());\n             }\n \n             // start processing receive requests\n             EmitterProcessor<ServiceBusReceivedMessageContext> finalSource = source;\n-            thisWorkSubscriber = workProcessor\n-                .subscribe(currentWork -> finalSource.subscribe(currentWork), error -> {\n-                    logger.error(\"Error in processing messages [{}]\", error);\n-                }, () -> {\n-                    logger.info(\"Receiving messages completed.\");\n-                });\n+            thisWorkSubscriber = workProcessor.subscribe(currentWork -> {\n+                logger.info(\"Start receiving messages for [{}].\", currentWork.getWork().getId());\n+                finalSource.subscribe(currentWork);\n+            },\n+                error -> logger.error(\"Error in processing messages [{}].\", error),\n+                () -> logger.info(\"Receiving messages completed.\"));\n \n             workSubscriber.set(thisWorkSubscriber);\n         }\n"}}, {"oid": "9ed2f312f8b421b6165b71871590befd1f30fdae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ed2f312f8b421b6165b71871590befd1f30fdae", "message": "spot bugs check resolution", "committedDate": "2020-05-08T03:13:58Z", "type": "commit"}, {"oid": "1a3ff03996ebb782302f99b4cb5e73e29d4208db", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1a3ff03996ebb782302f99b4cb5e73e29d4208db", "message": "work in progress", "committedDate": "2020-05-08T18:27:45Z", "type": "commit"}, {"oid": "5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "message": "Increment package version after release of com.azure azure-messaging-servicebus", "committedDate": "2020-05-08T21:29:37Z", "type": "commit"}, {"oid": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d83193508a88cb3165b18a6df0f9339500c3cd9", "message": "another implementation for multiple receive using BaseSubscriber", "committedDate": "2020-05-09T05:56:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NzY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422467679", "bodyText": "This can be private static.", "author": "conniey", "createdAt": "2020-05-09T08:10:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\nindex 99d940d1aa1..9b6038526c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n\n@@ -7,21 +7,23 @@ import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n import java.util.Queue;\n-import java.util.Timer;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n \n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private Disposable timeoutOperation;\n     private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n+    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n+\n     private volatile Subscription subscription;\n-    private long prefetch;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n \n \n     LongLivedMessageSubscriber(long prefetch) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NzcyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422467720", "bodyText": "Organise variables by final and not.", "author": "conniey", "createdAt": "2020-05-09T08:10:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\nindex 99d940d1aa1..9b6038526c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n\n@@ -7,21 +7,23 @@ import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n import java.util.Queue;\n-import java.util.Timer;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n \n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private Disposable timeoutOperation;\n     private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n+    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n+\n     private volatile Subscription subscription;\n-    private long prefetch;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n \n \n     LongLivedMessageSubscriber(long prefetch) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422468233", "bodyText": "final", "author": "conniey", "createdAt": "2020-05-09T08:16:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUzMDgxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422530818", "bodyText": "I am planning to remove prefetch altogether. We are discussing this on teams.", "author": "hemanttanwar", "createdAt": "2020-05-09T18:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NjI2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423086260", "bodyText": "Why are you planning on removing prefetch? This would be your initial request in hookOnSubscribe", "author": "conniey", "createdAt": "2020-05-11T14:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODIzMw=="}], "type": "inlineReview", "revised_code": {"commit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\nindex 99d940d1aa1..9b6038526c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n\n@@ -7,21 +7,23 @@ import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n import java.util.Queue;\n-import java.util.Timer;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n \n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private Disposable timeoutOperation;\n     private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n+    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n+\n     private volatile Subscription subscription;\n-    private long prefetch;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n \n \n     LongLivedMessageSubscriber(long prefetch) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422468314", "bodyText": "On subscribing you need to request something or it'll throw a debug message.", "author": "conniey", "createdAt": "2020-05-09T08:17:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NzMyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423087326", "bodyText": "I mistook this for the rule about request has to be > 0. However, the documentation suggests hookOnSubscribe is overridden when you want to alter the request.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java#L80-L82", "author": "conniey", "createdAt": "2020-05-11T14:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\nindex 99d940d1aa1..9b6038526c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n\n@@ -7,21 +7,23 @@ import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n import java.util.Queue;\n-import java.util.Timer;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n \n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private Disposable timeoutOperation;\n     private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n+    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n+\n     private volatile Subscription subscription;\n-    private long prefetch;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n \n \n     LongLivedMessageSubscriber(long prefetch) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422470286", "bodyText": "Why just Mono.just(true) and not drainQueue?", "author": "conniey", "createdAt": "2020-05-09T08:39:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.Timer;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private Disposable timeoutOperation;\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private volatile Subscription subscription;\n+    private long prefetch;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param value Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n+        if (!currentWork.isTerminal()) {\n+            currentWork.next(value);\n+        } else {\n+            logger.error(\"[{}] received message but no subscriber Sequence number [{}].\", currentWork.getId(), value.getMessage().getSequenceNumber());\n+            // throw error since we can not send this to current receive.\n+        }\n+\n+        logger.info(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), value.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        Disposable drainQueueDisposable = Mono.just(true)", "originalCommit": "1d83193508a88cb3165b18a6df0f9339500c3cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MTI3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422471276", "bodyText": "or even Mono.empty()", "author": "conniey", "createdAt": "2020-05-09T08:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUyMTAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r422521005", "bodyText": "I want to trigger dainQueue() asynchronously , specially for multithreaded env.  Mono.empty() would not trigger subscribe", "author": "hemanttanwar", "createdAt": "2020-05-09T17:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MDI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\nindex 99d940d1aa1..9b6038526c4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n\n@@ -7,21 +7,23 @@ import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n import java.util.Queue;\n-import java.util.Timer;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n \n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private Disposable timeoutOperation;\n     private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n+    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n+\n     private volatile Subscription subscription;\n-    private long prefetch;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n \n \n     LongLivedMessageSubscriber(long prefetch) {\n"}}, {"oid": "d9b69e82601a1c39deceef83af4b0c0ca353018d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d9b69e82601a1c39deceef83af4b0c0ca353018d", "message": "continue fix some issues", "committedDate": "2020-05-09T15:57:26Z", "type": "commit"}, {"oid": "5a8a9ece13d1bd205387ad4989715a26d4d957f3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5a8a9ece13d1bd205387ad4989715a26d4d957f3", "message": "added test", "committedDate": "2020-05-09T18:36:07Z", "type": "commit"}, {"oid": "01466200aab7f17b08884c3d2589a1dbcbdca391", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01466200aab7f17b08884c3d2589a1dbcbdca391", "message": "fixing unwanted check", "committedDate": "2020-05-09T18:43:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDE3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423084174", "bodyText": "The default ctor sets the boolean to false.", "author": "conniey", "createdAt": "2020-05-11T14:33:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NTU5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423085590", "bodyText": "nit: format your document", "author": "conniey", "createdAt": "2020-05-11T14:35:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4OTc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423089762", "bodyText": "This is only subscribed to once. The null check is unnecessary.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/BaseSubscriber.java#L146", "author": "conniey", "createdAt": "2020-05-11T14:40:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MDg2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423090861", "bodyText": "We don't need to override dispose. This is done in the basesubscriber. We can hook into hookOnCancel().", "author": "conniey", "createdAt": "2020-05-11T14:42:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n+        currentWork.error(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void dispose() {\n+        if (isDisposed.getAndSet(true)) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MTMwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423091309", "bodyText": "nit: format document", "author": "conniey", "createdAt": "2020-05-11T14:43:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n+        currentWork.error(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        dispose();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void dispose() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        subscription.cancel();\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MTY3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423091677", "bodyText": "The BaseSubscriber takes care of disposing for you. This isn't necessary.", "author": "conniey", "createdAt": "2020-05-11T14:43:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n+\n+    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+\n+    private volatile Subscription subscription;\n+\n+    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private SynchronousReceiveWork currentWork = null;\n+    private Disposable timeoutOperation;\n+     private Disposable drainQueueDisposable;\n+\n+\n+    LongLivedMessageSubscriber(long prefetch) {\n+        this.prefetch = prefetch;\n+    }\n+\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     *\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        if (this.subscription == null) {\n+            this.subscription = subscription;\n+        }\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     *\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+\n+        currentWork.next(message);\n+\n+        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n+\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n+        }\n+    }\n+\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0 ) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        subscription.request(currentWork.getNumberOfEvents());\n+\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (!currentWork.isTerminal()) {\n+                    completeCurrentWork(currentWork);\n+                }\n+            });\n+    }\n+\n+\n+    @Override\n+    protected void hookOnComplete() {\n+        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n+        dispose();", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MjAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423092001", "bodyText": "remove indentation.", "author": "conniey", "createdAt": "2020-05-11T14:44:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +627,23 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                                   FluxSink<ServiceBusReceivedMessageContext> emitter) {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MzcyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423093729", "bodyText": "", "author": "conniey", "createdAt": "2020-05-11T14:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5MjAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 98de852cb5d..31b8a846d14 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -627,21 +628,21 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-                                   FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n \n-            LongLivedMessageSubscriber messageSubscriber = longLivedMessageSubscriber.get();\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n             if (messageSubscriber == null) {\n                 messageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(new LongLivedMessageSubscriber(asyncClient.getReceiverOptions().getPrefetchCount()));\n-                logger.verbose(\"Created source for receiving messages from [{}]\", asyncClient.getEntityPath());\n-                longLivedMessageSubscriber.set(messageSubscriber);\n+                    .subscribeWith(new SynchronousMessageSubscriber(asyncClient.getReceiverOptions()\n+                        .getPrefetchCount(), work));\n+                synchronousMessageSubscriber.set(messageSubscriber);\n+            } else {\n+                messageSubscriber.queueWork(work);\n             }\n-\n-            messageSubscriber.queueWork(work);\n             logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA5NDM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423094365", "bodyText": "SynchronousMessageSubscriber is a better name.", "author": "conniey", "createdAt": "2020-05-11T14:47:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+ class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {", "originalCommit": "01466200aab7f17b08884c3d2589a1dbcbdca391", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71cd8d1fce131d9e378b43846e961b794c729e04", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\ndeleted file mode 100644\nindex 9b6038526c4..00000000000\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LongLivedMessageSubscriber.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.azure.messaging.servicebus;\n-\n-import com.azure.core.util.logging.ClientLogger;\n-import org.reactivestreams.Subscription;\n-import reactor.core.Disposable;\n-import reactor.core.publisher.BaseSubscriber;\n-import reactor.core.publisher.Mono;\n-\n-import java.util.Queue;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n- class LongLivedMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n-\n-    private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final AtomicBoolean isDisposed = new AtomicBoolean(false);\n-    private final long prefetch;\n-    private final AtomicInteger wip = new AtomicInteger();\n-\n-    private volatile Subscription subscription;\n-\n-    private Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n-    private SynchronousReceiveWork currentWork = null;\n-    private Disposable timeoutOperation;\n-     private Disposable drainQueueDisposable;\n-\n-\n-    LongLivedMessageSubscriber(long prefetch) {\n-        this.prefetch = prefetch;\n-    }\n-\n-    /**\n-     * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n-     * @param subscription Subscription for upstream.\n-     */\n-    @Override\n-    protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-    }\n-\n-    /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param message Event to publish.\n-     */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n-\n-        currentWork.next(message);\n-\n-        logger.verbose(\"[{}] received message with Sequence Number [{}].\", currentWork.getId(), message.getMessage().getSequenceNumber());\n-\n-        if (currentWork.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n-            completeCurrentWork(currentWork);\n-        }\n-    }\n-\n-    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n-\n-        if (isTerminated()) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n-\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n-            timeoutOperation.dispose();\n-        }\n-        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n-            drainQueueDisposable.dispose();\n-        }\n-\n-        if (wip.decrementAndGet() != 0) {\n-            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker. Value:\"+wip.get());\n-        }\n-\n-        // After current work finished and there more receive requests\n-        if (workQueue.size() > 0 ) {\n-            drain();\n-        }\n-    }\n-\n-    void queueWork(SynchronousReceiveWork work) {\n-        workQueue.add(work);\n-        drain();\n-    }\n-\n-    private void drain() {\n-        // If someone is already in this loop, then we are already clearing the queue.\n-        if (!wip.compareAndSet(0, 1)) {\n-            return;\n-        }\n-        // Drain queue..\n-        drainQueueDisposable = Mono.just(true)\n-            .subscribe(l -> {\n-                drainQueue();\n-            });\n-    }\n-\n-    private void drainQueue() {\n-        if (isTerminated()) {\n-            return;\n-        }\n-        currentWork = workQueue.poll();\n-        if (currentWork == null) {\n-            return;\n-        }\n-        subscription.request(currentWork.getNumberOfEvents());\n-\n-        // timer to complete the current in case of timeout trigger\n-        timeoutOperation = Mono.delay(currentWork.getTimeout())\n-            .subscribe(l -> {\n-                if (!currentWork.isTerminal()) {\n-                    completeCurrentWork(currentWork);\n-                }\n-            });\n-    }\n-\n-\n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", currentWork.getId());\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    protected void hookOnError(Throwable throwable) {\n-        logger.error(\"[{}] Errors occurred upstream\", currentWork.getId(), throwable);\n-        currentWork.error(throwable);\n-        dispose();\n-    }\n-\n-    @Override\n-    protected void hookOnCancel() {\n-        dispose();\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void dispose() {\n-        if (isDisposed.getAndSet(true)) {\n-            return;\n-        }\n-\n-        currentWork.complete();\n-        subscription.cancel();\n-        if (timeoutOperation != null && !timeoutOperation.isDisposed() ) {\n-            timeoutOperation.dispose();\n-        }\n-        super.dispose();\n-    }\n-\n-    private boolean isTerminated(){\n-        return isDisposed.get();\n-    }\n-}\n"}}, {"oid": "71cd8d1fce131d9e378b43846e961b794c729e04", "url": "https://github.com/Azure/azure-sdk-for-java/commit/71cd8d1fce131d9e378b43846e961b794c729e04", "message": "REview comments", "committedDate": "2020-05-11T19:02:15Z", "type": "commit"}, {"oid": "452d557230b6e07e2efe64a368002ef933312f54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/452d557230b6e07e2efe64a368002ef933312f54", "message": "Incorporating review comments", "committedDate": "2020-05-11T19:18:25Z", "type": "commit"}, {"oid": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "message": "Removing unused import.", "committedDate": "2020-05-11T19:23:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNTQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423325476", "bodyText": "This isn't thread-safe.\nIt's possible two different threads see messageSubscriber == null, and create the same instance of Subscriber. Then the last one wins and the first one is lost.", "author": "conniey", "createdAt": "2020-05-11T21:17:45Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +627,20 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                messageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                    .subscribeWith(new SynchronousMessageSubscriber(asyncClient.getReceiverOptions()\n+                        .getPrefetchCount(), work));\n+                synchronousMessageSubscriber.set(messageSubscriber);", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex b92b2a31d9d..beae873fc7c 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -632,15 +632,19 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n \n             SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n             if (messageSubscriber == null) {\n-                messageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n+                SynchronousMessageSubscriber newMessageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n                     .subscribeWith(new SynchronousMessageSubscriber(asyncClient.getReceiverOptions()\n                         .getPrefetchCount(), work));\n-                synchronousMessageSubscriber.set(messageSubscriber);\n+\n+                if (!synchronousMessageSubscriber.compareAndSet(null, newMessageSubscriber)) {\n+                    newMessageSubscriber.dispose();\n+                }\n+\n             } else {\n+\n                 messageSubscriber.queueWork(work);\n             }\n             logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n         }\n     }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNTgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423325834", "bodyText": "rename: initWork -> initialWork. It makes it more readable.", "author": "conniey", "createdAt": "2020-05-11T21:18:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 9977a3f2460..feece0e71dc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -13,6 +13,7 @@ import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423326855", "bodyText": "There shouldn't be a need for WIP. onNext occurs serially.", "author": "conniey", "createdAt": "2020-05-11T21:20:27Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMDEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423330131", "bodyText": "https://github.com/reactive-streams/reactive-streams-jvm#1.3", "author": "conniey", "createdAt": "2020-05-11T21:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODc4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424098786", "bodyText": "Thanks for link, It is helpful. But It is not just onNext(),  also various timeout situation  ( we need to drain work queue after timeout ) and if there another  queueWork(work) request during timeout when where is no more work request in queue.  This is a safeguard against many such condition.", "author": "hemanttanwar", "createdAt": "2020-05-12T23:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNjg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 9977a3f2460..feece0e71dc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -13,6 +13,7 @@ import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyNzQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423327420", "bodyText": "This can be inside the hookOnNext method. And return if the currentWork is not terminal to save the nested if.", "author": "conniey", "createdAt": "2020-05-11T21:21:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 9977a3f2460..feece0e71dc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -13,6 +13,7 @@ import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328162", "bodyText": "Why do we need to drain? We can see if there is a next one and push it.", "author": "conniey", "createdAt": "2020-05-11T21:23:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0) {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 9977a3f2460..feece0e71dc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -13,6 +13,7 @@ import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODM3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328374", "bodyText": "Why do we need getError? the sink can complete with the error.", "author": "conniey", "createdAt": "2020-05-11T21:23:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java", "diffHunk": "@@ -108,4 +108,12 @@ void error(Throwable error) {\n         this.error = error;\n         emitter.error(error);\n     }\n+\n+    /**\n+     * Indicate is an this work encountered an error.\n+     * @return true if an error occured.\n+     */\n+    Throwable getError() {", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java\nindex 194cbd14ce3..ca893964821 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousReceiveWork.java\n\n@@ -108,12 +108,4 @@ class SynchronousReceiveWork {\n         this.error = error;\n         emitter.error(error);\n     }\n-\n-    /**\n-     * Indicate is an this work encountered an error.\n-     * @return true if an error occured.\n-     */\n-    Throwable getError() {\n-        return this.error;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMyODkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r423328936", "bodyText": "What if we requested 100 events, only 30 showed up in the timeout period, and the next work item wants 10? This logic will add another 10 credits (making it 80 credits) even though we don't need to add more credits to the link.", "author": "conniey", "createdAt": "2020-05-11T21:24:54Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,162 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n-\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+    private Disposable drainQueueDisposable;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        currentWork.next(message);\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork.isTerminal()) {\n+            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", currentWork.getId());\n+            completeCurrentWork(currentWork);\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    private void completeCurrentWork(SynchronousReceiveWork currentWork) {\n+\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        currentWork.complete();\n+        logger.verbose(\"[{}] work completed.\", currentWork.getId());\n+\n+        if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+            timeoutOperation.dispose();\n+        }\n+        if (drainQueueDisposable != null && !drainQueueDisposable.isDisposed()) {\n+            drainQueueDisposable.dispose();\n+        }\n+\n+        if (wip.decrementAndGet() != 0) {\n+            logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+        }\n+\n+        // After current work finished and there more receive requests\n+        if (workQueue.size() > 0) {\n+            drain();\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n+    }\n+\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+        // Drain queue..\n+        drainQueueDisposable = Mono.just(true)\n+            .subscribe(l -> {\n+                drainQueue();\n+            });\n+    }\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+\n+        subscription.request(currentWork.getNumberOfEvents());", "originalCommit": "9b52a989ea7f032c1c1deee295dbe28c4782bdb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 9977a3f2460..feece0e71dc 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -13,6 +13,7 @@ import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n"}}, {"oid": "bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bdd41f3436f2a1a093960f85c32fbbb45285e5d3", "message": "continue work ...", "committedDate": "2020-05-12T19:14:53Z", "type": "commit"}, {"oid": "d8dd7b6190f0d9a02c3de5bcdcdeaec5a55df0d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d8dd7b6190f0d9a02c3de5bcdcdeaec5a55df0d4", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into servicebus-track2-sync-queueup-multiple-receive-calls", "committedDate": "2020-05-12T19:18:49Z", "type": "commit"}, {"oid": "39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "message": "resolve merge conflict", "committedDate": "2020-05-12T19:40:58Z", "type": "commit"}, {"oid": "f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "message": "Merge branch 'azure-sdk-increment-package-version-servicebus-386162'", "committedDate": "2020-05-12T19:50:47Z", "type": "commit"}, {"oid": "098504141281aae7856365937aa5cd2fa9d0bae8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/098504141281aae7856365937aa5cd2fa9d0bae8", "message": "Added loginc for timeout", "committedDate": "2020-05-12T23:50:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424099791", "bodyText": "Example: When there is only one receive(2) request and it time out. But we got two messages after that. During this time we also got request for another   receive(2) . In this case we can use this buffer to send the messages and do not need to ask upstream.", "author": "hemanttanwar", "createdAt": "2020-05-12T23:58:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);", "originalCommit": "098504141281aae7856365937aa5cd2fa9d0bae8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1589a03e33f478d99057de124234c847c25fe37", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 78e533cb518..4c91be39eae 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -97,7 +97,7 @@ class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMess\n      * @param requested credits for current {@link SynchronousReceiveWork}.\n      */\n     private void requestCredits(long requested) {\n-        long creditToAdd = requested - remaining.get();\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n         if (creditToAdd > 0) {\n             remaining.addAndGet(creditToAdd);\n             subscription.request(creditToAdd);\n"}}, {"oid": "d1589a03e33f478d99057de124234c847c25fe37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d1589a03e33f478d99057de124234c847c25fe37", "message": "timeout and remaining messages to request logic", "committedDate": "2020-05-13T00:22:14Z", "type": "commit"}, {"oid": "3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "message": "merge master", "committedDate": "2020-05-13T00:26:33Z", "type": "commit"}, {"oid": "b67ac9b65651a41709584818e2c3417b6aed44ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b67ac9b65651a41709584818e2c3417b6aed44ca", "message": "Merge branch 'master' of github.com:hemanttanwar/azure-sdk-for-java", "committedDate": "2020-05-13T04:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwMzcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424203711", "bodyText": "In the case that two threads are in this, there will be two subscribers in asyncClient and it'll throw. This is what I was hoping to see:\nvar subscriber = synchronousMessageSubscriber.get();\nif (subscriber == null) {\n  var prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n  var newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n\n  if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n    newSubscriber.dispose();\n    var existing = synchronousMessageSubscriber.get();\n    existing.queueWork(work);\n  } else {\n    asyncClient.subscribeWith(newSubscriber);\n    newSubscriber.queueWork(work);\n  }\n}", "author": "conniey", "createdAt": "2020-05-13T06:37:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -627,20 +627,22 @@ private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n         FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                SynchronousMessageSubscriber newMessageSubscriber = asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08c3c870e0ee717089ed409ee11804e7cd891022", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex e881b5168eb..d53f851fda4 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -624,7 +624,7 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                           FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424208203", "bodyText": "This can be verbose. It'll get noisy.", "author": "conniey", "createdAt": "2020-05-13T06:48:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08c3c870e0ee717089ed409ee11804e7cd891022", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 4c91be39eae..2f534f8120b 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -9,6 +9,7 @@ import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n+import java.time.Duration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwOTIxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424209215", "bodyText": "Space after //: // Boundary....", "author": "conniey", "createdAt": "2020-05-13T06:51:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08c3c870e0ee717089ed409ee11804e7cd891022", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 4c91be39eae..2f534f8120b 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -9,6 +9,7 @@ import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n+import java.time.Duration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNjYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424216609", "bodyText": "In the case that this timeout occurs, the completeWork is completed, but it never occurs. So an onNext can happen after this completion. The completeWork will not be null; and it'll try to submit another message to that timed out work.", "author": "conniey", "createdAt": "2020-05-13T07:07:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);\n+            return;\n+        }\n+        currentWork.next(message);\n+        remaining.decrementAndGet();\n+\n+        if (currentWork.isTerminal()) {\n+            currentWork.complete();\n+            if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                timeoutOperation.dispose();\n+            }\n+\n+            // Now see if there is more queued up work\n+            currentWork = workQueue.poll();\n+            if (currentWork != null) {\n+\n+                logger.verbose(\"[{}] Picking up next receive request.\", currentWork.getId());\n+\n+                // timer to complete the current in case of timeout trigger\n+                timeoutOperation = getTimeoutOperation();\n+\n+                requestCredits(currentWork.getNumberOfEvents());\n+            } else {\n+                if (wip.decrementAndGet() != 0) {\n+                    logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+                }\n+            }\n+        }\n+    }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        } else {\n+            logger.verbose(\"[{}] No need to request credit. \", currentWork.getId());\n         }\n+\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation();\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation() {\n+        return Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (currentWork != null && !currentWork.isTerminal()) {\n+                    logger.verbose(\"[{}] Timeout triggered.\", currentWork.getId());\n+                    currentWork.complete();", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08c3c870e0ee717089ed409ee11804e7cd891022", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 4c91be39eae..2f534f8120b 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -9,6 +9,7 @@ import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n+import java.time.Duration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNzExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r424217111", "bodyText": "This isn't how WIP is usually used. WIP is to prevent reentrant onNext/requests which may end up creating a stack overflow.", "author": "conniey", "createdAt": "2020-05-13T07:08:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,203 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n \n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n-\n-        subscription.request(work.getNumberOfEvents());\n+        logger.info(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        if (currentWork == null) {\n+            //Boundary condition(timeout cases), buffer the received message for future requests.\n+            bufferMessages.add(message);\n+            return;\n+        }\n+        currentWork.next(message);\n+        remaining.decrementAndGet();\n+\n+        if (currentWork.isTerminal()) {\n+            currentWork.complete();\n+            if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                timeoutOperation.dispose();\n+            }\n+\n+            // Now see if there is more queued up work\n+            currentWork = workQueue.poll();\n+            if (currentWork != null) {\n+\n+                logger.verbose(\"[{}] Picking up next receive request.\", currentWork.getId());\n+\n+                // timer to complete the current in case of timeout trigger\n+                timeoutOperation = getTimeoutOperation();\n+\n+                requestCredits(currentWork.getNumberOfEvents());\n+            } else {\n+                if (wip.decrementAndGet() != 0) {\n+                    logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+                }\n+            }\n+        }\n+    }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        } else {\n+            logger.verbose(\"[{}] No need to request credit. \", currentWork.getId());\n         }\n+\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation();\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation() {\n+        return Mono.delay(currentWork.getTimeout())\n+            .subscribe(l -> {\n+                if (currentWork != null && !currentWork.isTerminal()) {\n+                    logger.verbose(\"[{}] Timeout triggered.\", currentWork.getId());\n+                    currentWork.complete();\n+                }\n+                if (wip.decrementAndGet() != 0) {", "originalCommit": "d1589a03e33f478d99057de124234c847c25fe37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "08c3c870e0ee717089ed409ee11804e7cd891022", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 4c91be39eae..2f534f8120b 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -9,6 +9,7 @@ import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n \n+import java.time.Duration;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"oid": "08c3c870e0ee717089ed409ee11804e7cd891022", "url": "https://github.com/Azure/azure-sdk-for-java/commit/08c3c870e0ee717089ed409ee11804e7cd891022", "message": "Chaging WIP logic", "committedDate": "2020-05-14T08:03:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4ODk3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425488972", "bodyText": "We don't need a lock object anymore:\nprivate void queueWork(int maximumMessageCount, Duration maxWaitTime, FluxSink<ServiceBusReceivedMessageContext> emitter) {\n    final long id = idGenerator.getAndIncrement();\n    final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter);\n\n    final SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n    if (messageSubscriber == null) {\n        final long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n        final SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n\n        if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n            newSubscriber.dispose();\n\n            final SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n            existing.queueWork(work);\n        } else {\n            asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);\n            newSubscriber.queueWork(work);\n        }\n    } else {\n        messageSubscriber.queueWork(work);\n    }\n\n    logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n}", "author": "conniey", "createdAt": "2020-05-14T23:43:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +624,28 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                           FluxSink<ServiceBusReceivedMessageContext> emitter) {\n         synchronized (lock) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex d53f851fda4..41aaa0626b8 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -625,7 +625,6 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n                            FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4OTY4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425489681", "bodyText": "Keep indentation.", "author": "conniey", "createdAt": "2020-05-14T23:45:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +624,28 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+                           FluxSink<ServiceBusReceivedMessageContext> emitter) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex d53f851fda4..41aaa0626b8 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -625,7 +625,6 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n                            FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        synchronized (lock) {\n             final long id = idGenerator.getAndIncrement();\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MDIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425490213", "bodyText": "you never use the prefetch:\nsubscription.request(prefetch);", "author": "conniey", "createdAt": "2020-05-14T23:47:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425490391", "bodyText": "Missing documentation.", "author": "conniey", "createdAt": "2020-05-14T23:48:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwMjI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425802282", "bodyText": "Why not queue the initial request? You won't need the initialWork as a member variable. And you can use the prefetch.\n    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n        this.prefetch = prefetch;\n        this.workQueue.add(initialWork);\n        // using inititalWork.count + prefetch to figure out how much you should request on a subscription.\n    }\n\n    @Override\n    protected void hookOnSubscribe(Subscription subscription) {\n        this.subscription = subscription;\n        subscription.request(requested);\n    }", "author": "conniey", "createdAt": "2020-05-15T13:29:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNDQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425804492", "bodyText": "In general, keep the methods with the same visibility together. I organise visibility of methods in descending visibility (ie. public, package-private, private) because consumers will interact with the public/package-private ones first.\nAs-is, I need to jump around code to reason about what you are trying to do.", "author": "conniey", "createdAt": "2020-05-15T13:32:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNjMzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425806336", "bodyText": "The comment I was trying to make about WIP is to use it only for if someone is clearing the queue and to control access to the drainQueue method. You also modify this value in hookOnNext, but never decrement it when we exit the drainQueue method.\n    private void drain() {\n        // If someone is already in this loop, then we are already clearing the queue.\n        if (!wip.compareAndSet(0, 1)) {\n            return;\n        }\n\n        try {\n            drainQueue();\n        } finally {\n            final int decremented = wip.decrementAndGet();\n            if (decremented != 0) {\n                logger.warning(\"There should be 0, but was: {}\", decremented);\n            }\n        }\n    }", "author": "conniey", "createdAt": "2020-05-15T13:36:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwNzU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425807554", "bodyText": "There's a lot of logic in this method which will make it hard to debug in the future... why wouldn't the following below work? And have any management of currentWork, or emitting the next work in a single place, inside the drainQueue method.\n    @Override\n    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n        bufferMessages.add(message);\n        drain();\n    }", "author": "conniey", "createdAt": "2020-05-15T13:38:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgwODE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425808199", "bodyText": "This timeout operation is not tied to a work item, it's possible that between the currentWork and when this times out, the item has changed.\n    private Disposable getTimeoutOperation(SynchronousReceiveWork work, Duration timeout) {\n        return Mono.delay(timeout).thenReturn(work)\n            .subscribe(l -> {\n                synchronized (currentWorkLock) {\n                    if (currentWork == work) {\n                        work.complete();\n                    }\n                }\n            });\n    }", "author": "conniey", "createdAt": "2020-05-15T13:39:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+        currentWork = workQueue.poll();\n+        if (currentWork == null) {\n+            return;\n+        }\n+        long sentFromBuffer = 0;\n+        if (bufferMessages.size() > 0) {\n+            // If  we already have messages in buffer, we should send it first\n+\n+            while (!bufferMessages.isEmpty() || sentFromBuffer < currentWork.getNumberOfEvents()) {\n+                currentWork.next(bufferMessages.poll());\n+                remaining.decrementAndGet();\n+                ++sentFromBuffer;\n+            }\n+            if (sentFromBuffer == currentWork.getNumberOfEvents()) {\n+                currentWork.complete();\n+                logger.verbose(\"[{}] Sent [{}] messages from buffer.\", currentWork.getId(), sentFromBuffer);\n+                drainQueue();\n+            }\n+        }\n+        // timer to complete the current in case of timeout trigger\n+        timeoutOperation = getTimeoutOperation(currentWork.getTimeout());\n+\n+        requestCredits(currentWork.getNumberOfEvents() - sentFromBuffer);\n+    }\n+\n+    private Disposable getTimeoutOperation(Duration timeout) {\n+        return Mono.delay(timeout)", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxMDc0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425810744", "bodyText": "There are 4 places in which you set currentWork and these can happen asynchronously. It's possible that the work you're referencing here is one that has been cancelled or timed out. Consider a currentWorkLock that synchronises read-write to this variable and the associated timeout operation.\nLooking at other implementations of subscribers and your current implementation, I would put most of the heavy lifting in this method. (ie. checking to see if we have current work, updating it if need be, setting/requesting more work). As it currently is, there are several ways to emit next items and the currentWork is controlled in many places which will be a pain to debug when this fails.", "author": "conniey", "createdAt": "2020-05-15T13:43:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,220 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final long prefetch;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final SynchronousReceiveWork initialWork;\n+    private final AtomicLong remaining = new AtomicLong();\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    private SynchronousReceiveWork currentWork;\n+    private Disposable timeoutOperation;\n+\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.prefetch = prefetch;\n+        this.initialWork = initialWork;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n-\n-        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n-            work.getTimeout());\n+        this.subscription = subscription;\n \n-        subscription.request(work.getNumberOfEvents());\n+        logger.verbose(\"[{}] onSubscribe Pending: {}, Scheduling receive timeout task '{}'.\", initialWork.getId(),\n+            initialWork.getNumberOfEvents(), initialWork.getTimeout());\n \n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // This will trigger subscription.request(N) and queue up the work\n+        queueWork(initialWork);\n     }\n \n+    /**\n+     *\n+     * @return next work to process from queue.\n+     */\n+    private SynchronousReceiveWork getNextWorkAndRequest() {\n+        // Now see if there is more queued up work\n+        SynchronousReceiveWork nextWork = workQueue.poll();\n+\n+        if (nextWork != null) {\n+\n+            logger.verbose(\"[{}] Picking up next receive request.\", nextWork.getId());\n+\n+            // timer to complete the current in case of timeout trigger\n+            timeoutOperation = getTimeoutOperation(nextWork.getTimeout());\n+\n+            requestCredits(nextWork.getNumberOfEvents());\n+        }\n+        return nextWork;\n+    }\n     /**\n      * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n      * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * @param message Event to publish.\n      */\n     @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        boolean delivered = false;\n+\n+        // Boundary condition(timeout case): if timeout has happened, get next available work.\n+        if (currentWork == null) {\n+            // Now see if there is more queued up work\n+            currentWork = getNextWorkAndRequest();\n+            logger.verbose(\"No current work, Picked up next receive request.\");\n+        }\n+\n+        if (currentWork != null) {\n+            currentWork.next(message);\n+            delivered = true;\n+            remaining.decrementAndGet();\n+            // Check if we have delivered all the messages to current work.\n+            if (currentWork.isTerminal()) {\n+                currentWork.complete();\n+                if (timeoutOperation != null && !timeoutOperation.isDisposed()) {\n+                    timeoutOperation.dispose();\n+                }\n+\n+                // Now see if there is more queued up work\n+                currentWork = getNextWorkAndRequest();\n+                logger.verbose(\"Current work is terminal, Picked up next receive request.\");\n+            }\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        if (currentWork == null) {\n+            if (wip.decrementAndGet() != 0) {\n+                logger.warning(\"There is another worker in drainLoop. But there should only be 1 worker.\");\n+            }\n+            // If message is not delivered to downstream, we will buffer it.\n+            if (!delivered) {\n+                bufferMessages.add(message);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /**\n+     *\n+     * @param requested credits for current {@link SynchronousReceiveWork}.\n+     */\n+    private void requestCredits(long requested) {\n+        long creditToAdd = requested - (remaining.get() + bufferMessages.size());\n+        if (creditToAdd > 0) {\n+            remaining.addAndGet(creditToAdd);\n+            subscription.request(creditToAdd);\n+        }\n+    }\n+\n+    void queueWork(SynchronousReceiveWork work) {\n+\n+        logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n+            work.getTimeout());\n+        workQueue.add(work);\n+        drain();\n     }\n \n+    private void drain() {\n+        if (workQueue.size() == 0) {\n+            return;\n+        }\n+\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n+\n+        // Drain queue..\n+        drainQueue();\n+\n+    }\n+\n+\n+    private void drainQueue() {", "originalCommit": "08c3c870e0ee717089ed409ee11804e7cd891022", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxNTg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r425815898", "bodyText": "You can look at any of the operators for inspiration.\nhttps://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxCreate.java#L716", "author": "conniey", "createdAt": "2020-05-15T13:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgxMDc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2f534f8120b..23de56800f2 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -22,21 +22,25 @@ import java.util.concurrent.atomic.AtomicLong;\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final long prefetch;\n     private final AtomicInteger wip = new AtomicInteger();\n     private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n     private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n-    private final SynchronousReceiveWork initialWork;\n     private final AtomicLong remaining = new AtomicLong();\n \n-    private volatile Subscription subscription;\n+    // Flag to indicate more messages have arrived while we were in drain loop\n+    private final AtomicBoolean moreDeliveryArrived = new AtomicBoolean();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n \n+    private Disposable currentTimeoutOperation;\n     private SynchronousReceiveWork currentWork;\n-    private Disposable timeoutOperation;\n+\n+    private volatile Subscription subscription;\n \n     SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n-        this.prefetch = prefetch;\n-        this.initialWork = initialWork;\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n"}}, {"oid": "0361bc1e109b1eb64493ebb2f5186ccc22961891", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0361bc1e109b1eb64493ebb2f5186ccc22961891", "message": "Changed logic for draining queue", "committedDate": "2020-05-16T01:00:56Z", "type": "commit"}, {"oid": "77b4001a43b53a4c8e1fb905c95b8f74376bd8cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77b4001a43b53a4c8e1fb905c95b8f74376bd8cb", "message": "Changed logic for draining queue", "committedDate": "2020-05-16T01:05:34Z", "type": "commit"}, {"oid": "d473eb5ff8298ca33b7d2c04c6910488c4f5723b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d473eb5ff8298ca33b7d2c04c6910488c4f5723b", "message": " formatting changes", "committedDate": "2020-05-16T01:11:44Z", "type": "commit"}, {"oid": "13ef032c0cad9094bc0fc87d695bb869a69b5277", "url": "https://github.com/Azure/azure-sdk-for-java/commit/13ef032c0cad9094bc0fc87d695bb869a69b5277", "message": " formatting changes", "committedDate": "2020-05-16T01:15:46Z", "type": "commit"}, {"oid": "2e1f98b15f6bef89b9fde4c6e665624ece5beff2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e1f98b15f6bef89b9fde4c6e665624ece5beff2", "message": "removing unwanted flags.git statuys", "committedDate": "2020-05-16T17:33:00Z", "type": "commit"}, {"oid": "7a333f93cf52e3d791e05a0cbede376e48e0870e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7a333f93cf52e3d791e05a0cbede376e48e0870e", "message": "Added lock in ServiceBusReceiverClient", "committedDate": "2020-05-16T17:33:54Z", "type": "commit"}, {"oid": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/64e6b30e6aa48cef93c9a207e002c63c170c04df", "message": "some more optimization", "committedDate": "2020-05-16T17:51:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTEwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427409109", "bodyText": "This doesn't need to be synchronised, does it?", "author": "conniey", "createdAt": "2020-05-19T15:49:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -479,7 +477,8 @@ public ServiceBusReceivedMessage peekAt(long sequenceNumber, String sessionId) {\n      *\n      * @throws IllegalArgumentException if {@code maxMessages} or {@code maxWaitTime} is zero or a negative value.\n      */\n-    public IterableStream<ServiceBusReceivedMessageContext> receive(int maxMessages, Duration maxWaitTime) {\n+    public synchronized IterableStream<ServiceBusReceivedMessageContext> receive(int maxMessages,", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 886590f2daf..6b331187311 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -469,7 +470,9 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n     }\n \n     /**\n-     * Receives an iterable stream of {@link ServiceBusReceivedMessage messages} from the Service Bus entity.\n+     * Receives an iterable stream of {@link ServiceBusReceivedMessage messages} from the Service Bus entity. The\n+     * default receive mode is {@link ReceiveMode#PEEK_LOCK } unless it is changed during creation of\n+     * {@link ServiceBusReceiverClient} using {@link ServiceBusReceiverClientBuilder#receiveMode(ReceiveMode)}.\n      *\n      * @param maxMessages The maximum number of messages to receive.\n      * @param maxWaitTime The time the client waits for receiving a message before it times out.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427411083", "bodyText": "In this case, work is never queued.", "author": "conniey", "createdAt": "2020-05-19T15:52:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -624,23 +623,26 @@ public void close() {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-        synchronized (lock) {\n+            FluxSink<ServiceBusReceivedMessageContext> emitter) {\n             final long id = idGenerator.getAndIncrement();\n-            EmitterProcessor<ServiceBusReceivedMessageContext> emitterProcessor = messageProcessor.get();\n-\n             final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n                 emitter);\n-            final SynchronousMessageSubscriber syncSubscriber = new SynchronousMessageSubscriber(work);\n-            logger.info(\"[{}]: Started synchronous message subscriber.\", id);\n \n-            if (emitterProcessor == null) {\n-                emitterProcessor = this.asyncClient.receive(DEFAULT_RECEIVE_OPTIONS)\n-                    .subscribeWith(EmitterProcessor.create(asyncClient.getReceiverOptions().getPrefetchCount(), false));\n-                messageProcessor.set(emitterProcessor);\n+            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+            if (messageSubscriber == null) {\n+                long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n+                SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n+\n+                if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n+                    newSubscriber.dispose();\n+                    SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n+                    existing.queueWork(work);\n+                } else {\n+                    asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3MDQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427570453", "bodyText": "When a newSubscriber instance is created , we queue the work.. We can not do after subscribeWith is called because you may receive a message before you have anything in the queue.", "author": "hemanttanwar", "createdAt": "2020-05-19T20:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\nindex 886590f2daf..6b331187311 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java\n\n@@ -623,26 +626,26 @@ public final class ServiceBusReceiverClient implements AutoCloseable {\n      * entity.\n      */\n     private void queueWork(int maximumMessageCount, Duration maxWaitTime,\n-            FluxSink<ServiceBusReceivedMessageContext> emitter) {\n-            final long id = idGenerator.getAndIncrement();\n-            final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime,\n-                emitter);\n-\n-            SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n-            if (messageSubscriber == null) {\n-                long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n-                SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n-\n-                if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n-                    newSubscriber.dispose();\n-                    SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n-                    existing.queueWork(work);\n-                } else {\n-                    asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);\n-                }\n+        FluxSink<ServiceBusReceivedMessageContext> emitter) {\n+\n+        final long id = idGenerator.getAndIncrement();\n+        final SynchronousReceiveWork work = new SynchronousReceiveWork(id, maximumMessageCount, maxWaitTime, emitter);\n+\n+        SynchronousMessageSubscriber messageSubscriber = synchronousMessageSubscriber.get();\n+        if (messageSubscriber == null) {\n+            long prefetch = asyncClient.getReceiverOptions().getPrefetchCount();\n+            SynchronousMessageSubscriber newSubscriber = new SynchronousMessageSubscriber(prefetch, work);\n+\n+            if (!synchronousMessageSubscriber.compareAndSet(null, newSubscriber)) {\n+                newSubscriber.dispose();\n+                SynchronousMessageSubscriber existing = synchronousMessageSubscriber.get();\n+                existing.queueWork(work);\n             } else {\n-                messageSubscriber.queueWork(work);\n+                asyncClient.receive(DEFAULT_RECEIVE_OPTIONS).subscribeWith(newSubscriber);\n             }\n-            logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n+        } else {\n+            messageSubscriber.queueWork(work);\n         }\n+        logger.verbose(\"[{}] Receive request queued up.\", work.getId());\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMzI0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427413246", "bodyText": "Do you need this variable? if the subscription != null, I'll assume there is an upstream.\nAlso, if we call hookonSubscribe twice, it'll stomp over the previous subscription. We should guard against this by only setting it when it is null and erroring when someone wants to set it again.\nYou'll see a setOnce in some of the reactor operations.", "author": "conniey", "createdAt": "2020-05-19T15:55:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,226 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final AtomicLong remaining = new AtomicLong();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n+\n+    private Disposable currentTimeoutOperation;\n+    private SynchronousReceiveWork currentWork;\n+    private boolean subscriberInitialized;\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2e4039f8faa..12ef53610c7 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -8,6 +8,7 @@ import org.reactivestreams.Subscription;\n import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n \n import java.time.Duration;\n import java.util.Queue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427461940", "bodyText": "Is there any benefit to setting this to null again (and in a few places)? Once a subscription is disposed calling dispose again is a no-op.", "author": "conniey", "createdAt": "2020-05-19T17:07:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,226 @@\n \n import com.azure.core.util.logging.ClientLogger;\n import org.reactivestreams.Subscription;\n+import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n \n-import java.util.Objects;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.time.Duration;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Subscriber that listens to events and publishes them downstream and publishes events to them in the order received.\n  */\n class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMessageContext> {\n     private final ClientLogger logger = new ClientLogger(SynchronousMessageSubscriber.class);\n-    private final Timer timer = new Timer();\n     private final AtomicBoolean isDisposed = new AtomicBoolean();\n-    private final SynchronousReceiveWork work;\n+    private final AtomicInteger wip = new AtomicInteger();\n+    private final Queue<SynchronousReceiveWork> workQueue = new ConcurrentLinkedQueue<>();\n+    private final Queue<ServiceBusReceivedMessageContext> bufferMessages = new ConcurrentLinkedQueue<>();\n+    private final AtomicLong remaining = new AtomicLong();\n+\n+    private final long requested;\n+    private final Object currentWorkLock = new Object();\n+\n+    private Disposable currentTimeoutOperation;\n+    private SynchronousReceiveWork currentWork;\n+    private boolean subscriberInitialized;\n \n     private volatile Subscription subscription;\n \n-    SynchronousMessageSubscriber(SynchronousReceiveWork work) {\n-        this.work = Objects.requireNonNull(work, \"'work' cannot be null.\");\n+    SynchronousMessageSubscriber(long prefetch, SynchronousReceiveWork initialWork) {\n+        this.workQueue.add(initialWork);\n+        requested = initialWork.getNumberOfEvents() > prefetch ? initialWork.getNumberOfEvents() : prefetch;\n     }\n \n     /**\n      * On an initial subscription, will take the first work item, and request that amount of work for it.\n-     *\n      * @param subscription Subscription for upstream.\n      */\n     @Override\n     protected void hookOnSubscribe(Subscription subscription) {\n-        if (this.subscription == null) {\n-            this.subscription = subscription;\n-        }\n+        this.subscription = subscription;\n+        remaining.addAndGet(requested);\n+        subscription.request(requested);\n+        subscriberInitialized = true;\n+        drain();\n+    }\n+\n+    /**\n+     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n+     * the subscriber.\n+     * @param message Event to publish.\n+     */\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessageContext message) {\n+        bufferMessages.add(message);\n+        drain();\n+    }\n+\n+    /**\n+     * Queue the work to be picked up by drain loop.\n+     * @param work to be queued.\n+     */\n+    void queueWork(SynchronousReceiveWork work) {\n \n         logger.info(\"[{}] Pending: {}, Scheduling receive timeout task '{}'.\", work.getId(), work.getNumberOfEvents(),\n             work.getTimeout());\n+        workQueue.add(work);\n \n-        subscription.request(work.getNumberOfEvents());\n-\n-        timer.schedule(new ReceiveTimeoutTask(work.getId(), this::dispose), work.getTimeout().toMillis());\n+        // Do not drain if another thread want to queue the work before we have subscriber\n+        if (subscriberInitialized) {\n+            drain();\n+        }\n     }\n \n     /**\n-     * Publishes the event to the current {@link SynchronousReceiveWork}. If that work item is complete, will dispose of\n-     * the subscriber.\n-     *\n-     * @param value Event to publish.\n+     * Drain the work, only one thread can be in this loop at a time.\n      */\n-    @Override\n-    protected void hookOnNext(ServiceBusReceivedMessageContext value) {\n-        work.next(value);\n+    private void drain() {\n+        // If someone is already in this loop, then we are already clearing the queue.\n+        if (!wip.compareAndSet(0, 1)) {\n+            return;\n+        }\n \n-        if (work.isTerminal()) {\n-            logger.info(\"[{}] Completed. Closing Flux and cancelling subscription.\", work.getId());\n-            dispose();\n+        try {\n+            drainQueue();\n+        } finally {\n+            final int decremented = wip.decrementAndGet();\n+            if (decremented != 0) {\n+                logger.warning(\"There should be 0, but was: {}\", decremented);\n+            }\n         }\n     }\n \n-    @Override\n-    protected void hookOnComplete() {\n-        logger.info(\"[{}] Completed. No events to listen to.\", work.getId());\n-        dispose();\n+    /***\n+     * Drain the queue using a lock on current work in progress.\n+     */\n+    private void drainQueue() {\n+        if (isTerminated()) {\n+            return;\n+        }\n+\n+        // Acquiring the lock\n+        synchronized (currentWorkLock) {\n+\n+            // Making sure current work not become terminal since last drain queue cycle\n+            if (currentWork != null && currentWork.isTerminal()) {\n+                workQueue.remove(currentWork);\n+                if (currentTimeoutOperation != null & !currentTimeoutOperation.isDisposed()) {\n+                    currentTimeoutOperation.dispose();\n+                }\n+                currentTimeoutOperation = null;", "originalCommit": "64e6b30e6aa48cef93c9a207e002c63c170c04df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MzQxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427463411", "bodyText": "Having a current work is always tied to a timeout operation. Checking currentWork != null should be enough.", "author": "conniey", "createdAt": "2020-05-19T17:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3ODAzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r427578038", "bodyText": "We might pick currentWork more than one time from workQueue. currentTimeoutOperation ==  null will indicate that are we picking up first time.\nWe do not need to process  currentWork if is picked up second time and no bufferMessages to send to it.\nwhile ((currentWork = workQueue.peek()) != null && (currentTimeoutOperation == null || bufferMessages.size() > 0 )) {\nThe timeout Operation is not removing currentWork from he queue, thus currentWork needs be picked up again, thus we need to threat this different and go in the loop and remove this timeout work. setting currentTimeoutOperation = null indicate this case also.", "author": "hemanttanwar", "createdAt": "2020-05-19T20:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2MTk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 2e4039f8faa..12ef53610c7 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -8,6 +8,7 @@ import org.reactivestreams.Subscription;\n import reactor.core.Disposable;\n import reactor.core.publisher.BaseSubscriber;\n import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n \n import java.time.Duration;\n import java.util.Queue;\n"}}, {"oid": "c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c9dcdd013c84793cca5626ea95b2254fc57dfbdb", "message": "incorporated review comments", "committedDate": "2020-05-20T05:13:00Z", "type": "commit"}, {"oid": "a1c24b38134aef41b034c6a7b99e83e4730bde44", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1c24b38134aef41b034c6a7b99e83e4730bde44", "message": "removed unwanted files", "committedDate": "2020-05-20T05:14:57Z", "type": "commit"}, {"oid": "510e76c7ffb58e006a09779558d7b01246f054a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/510e76c7ffb58e006a09779558d7b01246f054a9", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java", "committedDate": "2020-05-20T05:17:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMDMyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10940#discussion_r428110320", "bodyText": "Only thing you need are unit tests. The logic in this subscriber is complex and I can see it being hard to debug.", "author": "conniey", "createdAt": "2020-05-20T15:35:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java", "diffHunk": "@@ -5,114 +5,239 @@\n ", "originalCommit": "a1c24b38134aef41b034c6a7b99e83e4730bde44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe0486c832e96d3f87e00f7616a95e2a5aa6e9c7", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\nindex 12ef53610c7..315e47c289f 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/SynchronousMessageSubscriber.java\n\n@@ -139,7 +139,7 @@ class SynchronousMessageSubscriber extends BaseSubscriber<ServiceBusReceivedMess\n             // from queue when we have delivered all the messages to currentWork.\n \n             while ((currentWork = workQueue.peek()) != null\n-                && (currentTimeoutOperation == null || bufferMessages.size() > 0)) {\n+                && (!currentWork.isProcessingStarted() || bufferMessages.size() > 0)) {\n \n                 // Additional check for safety, but normally this work should never be terminal\n                 if (currentWork.isTerminal()) {\n"}}, {"oid": "b9be8f55b9a372b26d0792a45a199850e8569e3d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9be8f55b9a372b26d0792a45a199850e8569e3d", "message": "Merge master into branch", "committedDate": "2020-05-20T17:42:06Z", "type": "commit"}, {"oid": "fe0486c832e96d3f87e00f7616a95e2a5aa6e9c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe0486c832e96d3f87e00f7616a95e2a5aa6e9c7", "message": "unit test", "committedDate": "2020-05-22T05:30:28Z", "type": "commit"}, {"oid": "8bea4db595d3cbab0c9409ffa40ce5f4bd098ee9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bea4db595d3cbab0c9409ffa40ce5f4bd098ee9", "message": "adding unit test", "committedDate": "2020-05-22T08:39:33Z", "type": "commit"}]}