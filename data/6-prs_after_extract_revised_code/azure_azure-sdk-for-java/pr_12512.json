{"pr_number": 12512, "pr_title": "Testing for Tables Autorest Code", "pr_createdAt": "2020-06-25T15:17:55Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/12512", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MjUzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445742535", "bodyText": "There will be some checkstyle failures such as missing MIT header. And adding documentation to public methods/classes.", "author": "conniey", "createdAt": "2020-06-25T18:05:24Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.azure.data.tables;", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\nindex 4ceaf968969..c5287404a5a 100644\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n\n@@ -1,24 +1,29 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n package com.azure.data.tables;\n \n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.util.CoreUtils;\n import com.azure.storage.common.implementation.StorageImplUtils;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n \n import java.net.URL;\n-import java.text.Collator;\n import java.util.*;\n-import java.util.stream.Collectors;\n \n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n public class TablesSharedKeyCredential {\n \n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKey %s:%s\";\n-    private static final String ACCOUNT_NAME = \"accountname\";\n-    private static final String ACCOUNT_KEY = \"accountkey\";\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n     private final String accountName;\n     private final String accountKey;\n \n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey  key to the storage account\n+     */\n     public TablesSharedKeyCredential(String accountName, String accountKey) {\n         Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n         Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MzE3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445743176", "bodyText": "Undo space.", "author": "conniey", "createdAt": "2020-06-25T18:06:38Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java", "diffHunk": "@@ -270,7 +270,7 @@\n             filterInternal = queryOptions.getFilter();\n         }\n         String filter = filterInternal;\n-        return service.query(\n+         return service.query(", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\nindex b27396d5984..027146409f4 100644\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\n+++ b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\n\n@@ -270,17 +270,17 @@ public final class TablesImpl {\n             filterInternal = queryOptions.getFilter();\n         }\n         String filter = filterInternal;\n-         return service.query(\n-                this.client.getUrl(),\n-                this.client.getVersion(),\n-                requestId,\n-                dataServiceVersion,\n-                format,\n-                top,\n-                select,\n-                filter,\n-                nextTableName,\n-                context);\n+        return service.query(\n+            this.client.getUrl(),\n+            this.client.getVersion(),\n+            requestId,\n+            dataServiceVersion,\n+            format,\n+            top,\n+            select,\n+            filter,\n+            nextTableName,\n+            context);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MzMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445743304", "bodyText": "REmove file if it is commented out.", "author": "conniey", "createdAt": "2020-06-25T18:06:51Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTablesAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+//package com.azure.data.tables;", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTablesAsyncClientTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTablesAsyncClientTest.java\ndeleted file mode 100644\nindex 4ef145357b8..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTablesAsyncClientTest.java\n+++ /dev/null\n\n@@ -1,134 +0,0 @@\n-//package com.azure.data.tables;\n-//\n-//import org.junit.jupiter.api.Test;\n-//import reactor.core.publisher.Mono;\n-//\n-//import java.time.Duration;\n-//import java.util.concurrent.TimeUnit;\n-//\n-//public class AzureTablesAsyncClientTest {\n-//    @Test\n-//    void createTableTest() {\n-//        // Ideally, we'd use a builder to create this rather than a constructor.\n-//        AzureTableAsyncClient client = new AzureTableAsyncClient();\n-//\n-//        // Every time this variable is used in a downstream subscriber, it will invoke the `createTable` operation.\n-//        Mono<AzureTable> createTableMono = client.createTable(\"my-table\");\n-//\n-//        // This is a subscription to the Mono. `subscribe` is a non-blocking call.\n-//        createTableMono.subscribe(table -> {\n-//            System.out.println(\"Table created is: \" + table.getName());\n-//        }, error -> {\n-//            System.err.println(\"There was an error creating the table. \" + error);\n-//        });\n-//\n-//        // Since .subscribe is a non-blocking call, after it hooks up the asynchronous operation, it will move\n-//        // onto the next statement. If `client.createTable` takes 30 seconds, the program would have ended before we\n-//        // ever know the response because it will leave this method.\n-//        // You'll see that there is no \"System.out.println\" console output because the program has ended.\n-//    }\n-//\n-//    /**\n-//     * Notice how \"CREATING TABLE with name: my-table\" errors when we try to add another entrythe second time? This is\n-//     * because, every time we chain the `createTableMono`, it invokes that `createTable` operation again.\n-//     * After an error occurs in one of the operations upstream in the chain, it will call the (error) -> { } handler.\n-//     * You'll see that we didn't try to add another entity (ie. new-key-2).\n-//     *\n-//     * See {@link #createAndUpdateTableFixed()} for a resolved version.\n-//     */\n-//    @Test\n-//    void createAndUpdateTable() throws InterruptedException {\n-//        AzureTableAsyncClient client = new AzureTableAsyncClient();\n-//\n-//        // Every time this variable is used in a downstream subscriber, it will invoke the `createTable` operation.\n-//        Mono<AzureTable> createTableMono = client.createTable(\"my-table\");\n-//\n-//        // FirstMono -> SecondFlatMap -> Map -> Subscribe\n-//        createTableMono.flatMap(azureTable -> {\n-//            // We are chaining another operation to this table creation. We want to use the resulting table and\n-//            // create an entity in it. We use `flatMap` because it is asynchronous (ie. returns Mono or Flux).\n-//            Mono<AzureTableEntity> entity = azureTable.createEntity(\"my-key\", \"my-value\");\n-//            // We return the `createEntity` operation.\n-//            return entity;\n-//        }).map(azureTableEntity -> {\n-//            // This is a transformation, maybe we only care about the value of that entity we added.\n-//            return azureTableEntity.getValue();\n-//        }).subscribe(theValue -> {\n-//            System.out.println(\"This was added: \" + theValue);\n-//        }, error -> {\n-//            System.err.println(\"Error: \" + error);\n-//        });\n-//\n-//        createTableMono.flatMap(azureTable -> {\n-//            // We are chaining another operation to this table creation. We want to use the resulting table and\n-//            // create an entity in it. We use `flatMap` because it is asynchronous (ie. returns Mono or Flux).\n-//            return azureTable.createEntity(\"my-key-2\", \"my-value-2\");\n-//        }).map(azureTableEntity -> {\n-//            // This is a transformation, maybe we only care about the value of that entity we added.\n-//            return azureTableEntity.getValue();\n-//        }).subscribe(theValue -> {\n-//            System.out.println(\"This was added: \" + theValue);\n-//        }, error -> {\n-//            System.err.println(\"Error: \" + error);\n-//        });\n-//\n-//        TimeUnit.SECONDS.sleep(20);\n-//    }\n-//\n-//    /**\n-//     * We've fixed this by caching the result of the `createTable` operation if it is successful. So we don't try to\n-//     * create the table again.\n-//     *\n-//     * See {@link #createAndUpdateTable()}\n-//     */\n-//    @Test\n-//    void createAndUpdateTableFixed() throws InterruptedException {\n-//        AzureTableAsyncClient client = new AzureTableAsyncClient();\n-//\n-//        // Every time this variable is used in a downstream subscriber, it will invoke the `createTable` operation.\n-//        Mono<AzureTable> createTableMono = client.createTable(\"my-table\")\n-//            .cache(success -> {\n-//                System.out.println(\"--- Table added. Caching value.\");\n-//                return Duration.ofSeconds(Long.MAX_VALUE);\n-//            }, error -> {\n-//                System.out.println(\"--- Error while adding table. Not caching value.\");\n-//                return Duration.ZERO;\n-//            }, () -> {\n-//                // This can occur because Monos can output 0 or 1 items. This would be the case where it output 0 items.\n-//                // For example, Mono.empty() will complete, but not output any items.\n-//                System.out.println(\"--- Expected a table to be output, not an empty value. Not caching.\");\n-//                return Duration.ZERO;\n-//            });\n-//\n-//        // FirstMono -> SecondFlatMap -> Map -> Subscribe\n-//        createTableMono.flatMap(azureTable -> {\n-//            // We are chaining another operation to this table creation. We want to use the resulting table and\n-//            // create an entity in it. We use `flatMap` because it is asynchronous (ie. returns Mono or Flux).\n-//            Mono<AzureTableEntity> entity = azureTable.createEntity(\"my-new-key\", \"my-new-value\");\n-//            // We return the `createEntity` operation.\n-//            return entity;\n-//        }).map(azureTableEntity -> {\n-//            // This is a transformation, maybe we only care about the value of that entity we added.\n-//            return azureTableEntity.getValue();\n-//        }).subscribe(theValue -> {\n-//            System.out.println(\"This was added: \" + theValue);\n-//        }, error -> {\n-//            System.err.println(\"ERROR: \" + error);\n-//        });\n-//\n-//        createTableMono.flatMap(azureTable -> {\n-//            // We are chaining another operation to this table creation. We want to use the resulting table and\n-//            // create an entity in it. We use `flatMap` because it is asynchronous (ie. returns Mono or Flux).\n-//            return azureTable.createEntity(\"my-new-key-2\", \"my-new-value-2\");\n-//        }).map(azureTableEntity -> {\n-//            // This is a transformation, maybe we only care about the value of that entity we added.\n-//            return azureTableEntity.getValue();\n-//        }).subscribe(theValue -> {\n-//            System.out.println(\"This was added: \" + theValue);\n-//        }, error -> {\n-//            System.err.println(\"ERROR: \" + error);\n-//        });\n-//\n-//        TimeUnit.SECONDS.sleep(20);\n-//    }\n-//}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0Mzk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445743975", "bodyText": "Names of test files should match class it is testing. autorestTest should be AzureTableImplTest", "author": "conniey", "createdAt": "2020-06-25T18:08:12Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NDg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445744898", "bodyText": "Sort methods by visibility and keep like methods together. For example, all tests should be together @Test. If it is a @BeforeEach or @AfterEach, put them at the top.\nHelper methods like auth() should be made private and at the bottom.", "author": "conniey", "createdAt": "2020-06-25T18:09:45Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NTE0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445745148", "bodyText": "This test should inherit from TestBase.\nIf this test is run on the same resource twice, it will fail. If you look at the AppConfiguration tests, they use testResourceNamer. https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/appconfiguration/azure-data-appconfiguration/src/test/java/com/azure/data/appconfiguration/ConfigurationClientTestBase.java#L56", "author": "conniey", "createdAt": "2020-06-25T18:10:10Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NjIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445746202", "bodyText": "Please clean up unnecessary empty lines.", "author": "conniey", "createdAt": "2020-06-25T18:12:04Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+\n+    void createAndUpdateTableFixed() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        //storagesharedkey object and the storage auth object\n+        policies.add(new AddDatePolicy());\n+        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n+        //HttpLoggingPolicy()\n+\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(null)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n+        AzureTableImpl azureTable = azureTableImplBuilder\n+            .pipeline(pipeline)\n+            .url(\"/https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+\n+        try {\n+            TablesImpl tables = azureTable.getTables();\n+\n+            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n+                .assertNext(response -> {\n+                    System.out.println(response);\n+                    Assertions.assertEquals(200, response.getStatusCode());\n+                })\n+                .expectComplete()\n+                .verify();\n+        } catch (Exception e) {\n+            System.out.print(e);\n+        }\n+\n+    }\n+\n+\n+    static AzureTableImpl auth() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = Arrays.asList(\n+            new AddDatePolicy(),\n+            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n+            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n+            new HttpLoggingPolicy(new HttpLogOptions()\n+                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n+        );\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        AzureTableImpl azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(\"https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+        return azureTable;\n+    }\n+\n+\n+    @BeforeEach\n+    void beforeTests() {\n+        createTableHelper(tableA);\n+        createTableHelper(tableB);\n+\n+        propertiesB.put(\"PartitionKey\", \"Store\");\n+        propertiesB.put(\"RowKey\", \"Boston\");\n+        propertiesB.put(\"Employees\", \"200\");\n+        insertEntityHelper(tableA, propertiesB);\n+\n+        Map<String, Object> propertiesA = new HashMap<>();\n+        propertiesA.put(\"PartitionKey\", \"Store\");\n+        propertiesA.put(\"RowKey\", \"Atlanta\");\n+        propertiesA.put(\"Employees\", \"50\");\n+        insertEntityHelper(tableA, propertiesA);\n+", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NjUzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445746535", "bodyText": "You can call the method deleteTable(...). Helper isn't necessary. DeleteTable is enough to describe the functionality of the method.", "author": "conniey", "createdAt": "2020-06-25T18:12:40Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+\n+    void createAndUpdateTableFixed() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        //storagesharedkey object and the storage auth object\n+        policies.add(new AddDatePolicy());\n+        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n+        //HttpLoggingPolicy()\n+\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(null)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n+        AzureTableImpl azureTable = azureTableImplBuilder\n+            .pipeline(pipeline)\n+            .url(\"/https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+\n+        try {\n+            TablesImpl tables = azureTable.getTables();\n+\n+            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n+                .assertNext(response -> {\n+                    System.out.println(response);\n+                    Assertions.assertEquals(200, response.getStatusCode());\n+                })\n+                .expectComplete()\n+                .verify();\n+        } catch (Exception e) {\n+            System.out.print(e);\n+        }\n+\n+    }\n+\n+\n+    static AzureTableImpl auth() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = Arrays.asList(\n+            new AddDatePolicy(),\n+            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n+            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n+            new HttpLoggingPolicy(new HttpLogOptions()\n+                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n+        );\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        AzureTableImpl azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(\"https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+        return azureTable;\n+    }\n+\n+\n+    @BeforeEach\n+    void beforeTests() {\n+        createTableHelper(tableA);\n+        createTableHelper(tableB);\n+\n+        propertiesB.put(\"PartitionKey\", \"Store\");\n+        propertiesB.put(\"RowKey\", \"Boston\");\n+        propertiesB.put(\"Employees\", \"200\");\n+        insertEntityHelper(tableA, propertiesB);\n+\n+        Map<String, Object> propertiesA = new HashMap<>();\n+        propertiesA.put(\"PartitionKey\", \"Store\");\n+        propertiesA.put(\"RowKey\", \"Atlanta\");\n+        propertiesA.put(\"Employees\", \"50\");\n+        insertEntityHelper(tableA, propertiesA);\n+\n+\n+    }\n+\n+    @AfterEach\n+    void afterTests() throws InterruptedException {\n+        deleteTableHelper(tableA);", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NjgwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445746805", "bodyText": "There's no need to sleep. The .block() call only moves to the next line when it is complete.", "author": "conniey", "createdAt": "2020-06-25T18:13:09Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+\n+    void createAndUpdateTableFixed() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        //storagesharedkey object and the storage auth object\n+        policies.add(new AddDatePolicy());\n+        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n+        //HttpLoggingPolicy()\n+\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(null)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n+        AzureTableImpl azureTable = azureTableImplBuilder\n+            .pipeline(pipeline)\n+            .url(\"/https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+\n+        try {\n+            TablesImpl tables = azureTable.getTables();\n+\n+            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n+                .assertNext(response -> {\n+                    System.out.println(response);\n+                    Assertions.assertEquals(200, response.getStatusCode());\n+                })\n+                .expectComplete()\n+                .verify();\n+        } catch (Exception e) {\n+            System.out.print(e);\n+        }\n+\n+    }\n+\n+\n+    static AzureTableImpl auth() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = Arrays.asList(\n+            new AddDatePolicy(),\n+            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n+            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n+            new HttpLoggingPolicy(new HttpLogOptions()\n+                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n+        );\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        AzureTableImpl azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(\"https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+        return azureTable;\n+    }\n+\n+\n+    @BeforeEach\n+    void beforeTests() {\n+        createTableHelper(tableA);\n+        createTableHelper(tableB);\n+\n+        propertiesB.put(\"PartitionKey\", \"Store\");\n+        propertiesB.put(\"RowKey\", \"Boston\");\n+        propertiesB.put(\"Employees\", \"200\");\n+        insertEntityHelper(tableA, propertiesB);\n+\n+        Map<String, Object> propertiesA = new HashMap<>();\n+        propertiesA.put(\"PartitionKey\", \"Store\");\n+        propertiesA.put(\"RowKey\", \"Atlanta\");\n+        propertiesA.put(\"Employees\", \"50\");\n+        insertEntityHelper(tableA, propertiesA);\n+\n+\n+    }\n+\n+    @AfterEach\n+    void afterTests() throws InterruptedException {\n+        deleteTableHelper(tableA);\n+        deleteTableHelper(tableB);\n+\n+    }\n+\n+    void createTableHelper(String tableName) {\n+        AzureTableImpl azureTable = auth();\n+\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = UUID.randomUUID().toString();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+\n+    }\n+\n+    void deleteTableHelper(String tableName) throws InterruptedException {\n+\n+        AzureTableImpl azureTable = auth();\n+        String requestId = UUID.randomUUID().toString();\n+\n+\n+        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n+            Context.NONE).block();\n+        TimeUnit.SECONDS.sleep(2);", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0Njg5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445746895", "bodyText": "helper is unnecessary.", "author": "conniey", "createdAt": "2020-06-25T18:13:19Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+\n+    void createAndUpdateTableFixed() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        //storagesharedkey object and the storage auth object\n+        policies.add(new AddDatePolicy());\n+        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n+        //HttpLoggingPolicy()\n+\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(null)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n+        AzureTableImpl azureTable = azureTableImplBuilder\n+            .pipeline(pipeline)\n+            .url(\"/https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+\n+        try {\n+            TablesImpl tables = azureTable.getTables();\n+\n+            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n+                .assertNext(response -> {\n+                    System.out.println(response);\n+                    Assertions.assertEquals(200, response.getStatusCode());\n+                })\n+                .expectComplete()\n+                .verify();\n+        } catch (Exception e) {\n+            System.out.print(e);\n+        }\n+\n+    }\n+\n+\n+    static AzureTableImpl auth() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = Arrays.asList(\n+            new AddDatePolicy(),\n+            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n+            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n+            new HttpLoggingPolicy(new HttpLogOptions()\n+                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n+        );\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        AzureTableImpl azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(\"https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+        return azureTable;\n+    }\n+\n+\n+    @BeforeEach\n+    void beforeTests() {\n+        createTableHelper(tableA);\n+        createTableHelper(tableB);\n+\n+        propertiesB.put(\"PartitionKey\", \"Store\");\n+        propertiesB.put(\"RowKey\", \"Boston\");\n+        propertiesB.put(\"Employees\", \"200\");\n+        insertEntityHelper(tableA, propertiesB);\n+\n+        Map<String, Object> propertiesA = new HashMap<>();\n+        propertiesA.put(\"PartitionKey\", \"Store\");\n+        propertiesA.put(\"RowKey\", \"Atlanta\");\n+        propertiesA.put(\"Employees\", \"50\");\n+        insertEntityHelper(tableA, propertiesA);\n+\n+\n+    }\n+\n+    @AfterEach\n+    void afterTests() throws InterruptedException {\n+        deleteTableHelper(tableA);\n+        deleteTableHelper(tableB);\n+\n+    }\n+\n+    void createTableHelper(String tableName) {\n+        AzureTableImpl azureTable = auth();\n+\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = UUID.randomUUID().toString();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+\n+    }\n+\n+    void deleteTableHelper(String tableName) throws InterruptedException {\n+\n+        AzureTableImpl azureTable = auth();\n+        String requestId = UUID.randomUUID().toString();\n+\n+\n+        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n+            Context.NONE).block();\n+        TimeUnit.SECONDS.sleep(2);\n+\n+    }\n+\n+    void insertEntityHelper(String tableName, Map<String, Object> properties) {", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0ODEwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r445748109", "bodyText": "These tests should follow arrange, act, and assert. All declarations should be done before your Act & Assert steps.\nhttps://docs.telerik.com/devtools/justmock/basic-usage/arrange-act-assert#verify-interaction\nAn example:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientTest.java#L165", "author": "conniey", "createdAt": "2020-06-25T18:15:22Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.TablesImpl;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.StorageSharedKeyCredential;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import reactor.test.StepVerifier;\n+\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class autorestTest {\n+    final String tableA = \"tableA\";\n+    final String tableB = \"tableB\";\n+    final String tableZ = \"tableZ\";\n+    final AzureTableImpl azureTable = auth();\n+    final String pk = \"PartitionKey\";\n+    final String rk = \"RowKey\";\n+    Map<String, Object> propertiesB = new HashMap<>();\n+\n+\n+    void createAndUpdateTableFixed() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        //storagesharedkey object and the storage auth object\n+        policies.add(new AddDatePolicy());\n+        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n+        //HttpLoggingPolicy()\n+\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(null)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n+        AzureTableImpl azureTable = azureTableImplBuilder\n+            .pipeline(pipeline)\n+            .url(\"/https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+\n+        try {\n+            TablesImpl tables = azureTable.getTables();\n+\n+            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n+                .assertNext(response -> {\n+                    System.out.println(response);\n+                    Assertions.assertEquals(200, response.getStatusCode());\n+                })\n+                .expectComplete()\n+                .verify();\n+        } catch (Exception e) {\n+            System.out.print(e);\n+        }\n+\n+    }\n+\n+\n+    static AzureTableImpl auth() {\n+        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n+\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = Arrays.asList(\n+            new AddDatePolicy(),\n+            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n+            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n+            new HttpLoggingPolicy(new HttpLogOptions()\n+                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n+        );\n+        final HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        AzureTableImpl azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(\"https://telboytrial.table.core.windows.net\")\n+            .buildClient();\n+        return azureTable;\n+    }\n+\n+\n+    @BeforeEach\n+    void beforeTests() {\n+        createTableHelper(tableA);\n+        createTableHelper(tableB);\n+\n+        propertiesB.put(\"PartitionKey\", \"Store\");\n+        propertiesB.put(\"RowKey\", \"Boston\");\n+        propertiesB.put(\"Employees\", \"200\");\n+        insertEntityHelper(tableA, propertiesB);\n+\n+        Map<String, Object> propertiesA = new HashMap<>();\n+        propertiesA.put(\"PartitionKey\", \"Store\");\n+        propertiesA.put(\"RowKey\", \"Atlanta\");\n+        propertiesA.put(\"Employees\", \"50\");\n+        insertEntityHelper(tableA, propertiesA);\n+\n+\n+    }\n+\n+    @AfterEach\n+    void afterTests() throws InterruptedException {\n+        deleteTableHelper(tableA);\n+        deleteTableHelper(tableB);\n+\n+    }\n+\n+    void createTableHelper(String tableName) {\n+        AzureTableImpl azureTable = auth();\n+\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = UUID.randomUUID().toString();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+\n+    }\n+\n+    void deleteTableHelper(String tableName) throws InterruptedException {\n+\n+        AzureTableImpl azureTable = auth();\n+        String requestId = UUID.randomUUID().toString();\n+\n+\n+        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n+            Context.NONE).block();\n+        TimeUnit.SECONDS.sleep(2);\n+\n+    }\n+\n+    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n+        String requestId = UUID.randomUUID().toString();\n+\n+        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n+            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n+    }\n+\n+    @Test\n+    void createTable() throws InterruptedException {\n+        TableProperties tableProperties = new TableProperties().setTableName(tableZ);", "originalCommit": "f5db0f1192bfa3a67ed2bc438c1f41750e96f55b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\ndeleted file mode 100644\nindex 8072c6d72d5..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/autorestTest.java\n+++ /dev/null\n\n@@ -1,364 +0,0 @@\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.*;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.TablesImpl;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.StorageSharedKeyCredential;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import com.azure.storage.common.policy.StorageSharedKeyCredentialPolicy;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-\n-public class autorestTest {\n-    final String tableA = \"tableA\";\n-    final String tableB = \"tableB\";\n-    final String tableZ = \"tableZ\";\n-    final AzureTableImpl azureTable = auth();\n-    final String pk = \"PartitionKey\";\n-    final String rk = \"RowKey\";\n-    Map<String, Object> propertiesB = new HashMap<>();\n-\n-\n-    void createAndUpdateTableFixed() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        StorageSharedKeyCredential sharedKeyCredential = new StorageSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        //storagesharedkey object and the storage auth object\n-        policies.add(new AddDatePolicy());\n-        policies.add(new StorageSharedKeyCredentialPolicy(sharedKeyCredential));\n-        //HttpLoggingPolicy()\n-\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(null)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-\n-        AzureTableImplBuilder azureTableImplBuilder = new AzureTableImplBuilder();\n-        AzureTableImpl azureTable = azureTableImplBuilder\n-            .pipeline(pipeline)\n-            .url(\"/https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-\n-        try {\n-            TablesImpl tables = azureTable.getTables();\n-\n-            StepVerifier.create(tables.deleteWithResponseAsync(\"ebTable\", \"ID23\", Context.NONE))\n-                .assertNext(response -> {\n-                    System.out.println(response);\n-                    Assertions.assertEquals(200, response.getStatusCode());\n-                })\n-                .expectComplete()\n-                .verify();\n-        } catch (Exception e) {\n-            System.out.print(e);\n-        }\n-\n-    }\n-\n-\n-    static AzureTableImpl auth() {\n-        final String connectionString = System.getenv(\"azure_tables_connection_string\");\n-\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(\"tables\"));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = Arrays.asList(\n-            new AddDatePolicy(),\n-            new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())),\n-            new TablesSharedKeyCredentialPolicy(sharedKeyCredential),\n-            new HttpLoggingPolicy(new HttpLogOptions()\n-                .setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS))\n-        );\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        AzureTableImpl azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(\"https://telboytrial.table.core.windows.net\")\n-            .buildClient();\n-        return azureTable;\n-    }\n-\n-\n-    @BeforeEach\n-    void beforeTests() {\n-        createTableHelper(tableA);\n-        createTableHelper(tableB);\n-\n-        propertiesB.put(\"PartitionKey\", \"Store\");\n-        propertiesB.put(\"RowKey\", \"Boston\");\n-        propertiesB.put(\"Employees\", \"200\");\n-        insertEntityHelper(tableA, propertiesB);\n-\n-        Map<String, Object> propertiesA = new HashMap<>();\n-        propertiesA.put(\"PartitionKey\", \"Store\");\n-        propertiesA.put(\"RowKey\", \"Atlanta\");\n-        propertiesA.put(\"Employees\", \"50\");\n-        insertEntityHelper(tableA, propertiesA);\n-\n-\n-    }\n-\n-    @AfterEach\n-    void afterTests() throws InterruptedException {\n-        deleteTableHelper(tableA);\n-        deleteTableHelper(tableB);\n-\n-    }\n-\n-    void createTableHelper(String tableName) {\n-        AzureTableImpl azureTable = auth();\n-\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-    }\n-\n-    void deleteTableHelper(String tableName) throws InterruptedException {\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-\n-        azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE).block();\n-        TimeUnit.SECONDS.sleep(2);\n-\n-    }\n-\n-    void insertEntityHelper(String tableName, Map<String, Object> properties) {\n-        String requestId = UUID.randomUUID().toString();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() throws InterruptedException {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableZ);\n-        String requestId = UUID.randomUUID().toString();\n-\n-        //successful path\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //error if it tries to create a table with the same name that already exists\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-\n-        //delete table\n-        deleteTableHelper(tableZ);\n-\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-\n-        //create Table\n-        createTableHelper(tableZ);\n-\n-        //delete a table, successful path\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //try to delete table that is already deleted, should return a TableServiceError\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableZ, UUID.randomUUID().toString(),\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        //Verify both are returned with a query without criteria\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setTop(1);\n-\n-        //Verify both only first is returned with top filter\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().size(), 1);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        Map<String, Object> properties = new HashMap<>();\n-        properties.put(pk, \"Store\");\n-        properties.put(rk, \"Seattle\");\n-\n-\n-        AzureTableImpl azureTable = auth();\n-        String requestId = UUID.randomUUID().toString();\n-\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableB, 500,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(201, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        propertiesB.put(\"Address\", \"23 Newbury Street\");\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        propertiesB.remove(\"Size\");\n-        propertiesB.put(\"Manager\", \"Jessica Davis\");\n-\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableA, propertiesB.get(\"PartitionKey\").toString(),\n-            propertiesB.get(\"RowKey\").toString(), 500, UUID.randomUUID().toString(), \"*\", propertiesB, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //TODO: Query and check\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        String requestId = UUID.randomUUID().toString();\n-        Map<String, Object> propertiesC = new HashMap<>();\n-        propertiesC.put(pk, \"Store\");\n-        propertiesC.put(rk, \"Chicago\");\n-        insertEntityHelper(tableB, propertiesC);\n-\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableB, propertiesC.get(\"PartitionKey\").toString(),\n-            propertiesC.get(\"RowKey\").toString(), \"*\", 500, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.println(response);\n-                Assertions.assertEquals(204, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() throws InterruptedException {\n-        String requestId = UUID.randomUUID().toString();\n-        QueryOptions queryOptions = new QueryOptions();\n-\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Atlanta\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        queryOptions.setSelect(\"Employees\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"50\"));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(\"200\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        //queryOptions.setSelect(\"\");\n-        queryOptions.setFilter(\"RowKey eq Boston\");\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableA, null,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                System.out.print(\"Here\");\n-                for (Iterator<Map<String, Object>> it = response.getValue().getValue().iterator(); it.hasNext(); ) {\n-                    Map<String, Object> m = it.next();\n-                    System.out.println(m);\n-\n-                }\n-                Assertions.assertEquals(200, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(\"Boston\"));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-\n-        TimeUnit.SECONDS.sleep(5);\n-    }\n-\n-\n-}\n"}}, {"oid": "0ef4f1c2334a2249f003900014a7ac9634bb9b98", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ef4f1c2334a2249f003900014a7ac9634bb9b98", "message": "fix impl", "committedDate": "2020-07-01T18:15:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgyODA3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448828072", "bodyText": "This can be simplified to. Same with the line below.\nthis.accountName = Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");", "author": "conniey", "createdAt": "2020-07-02T08:15:44Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgyODQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448828463", "bodyText": "requestURL should be requestUrl as-per our naming guidelines.", "author": "conniey", "createdAt": "2020-07-02T08:16:25Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgyODg1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448828850", "bodyText": "It is not necessary to qualify this with this., there are no naming conflicts within this method. Same with the other usages.", "author": "conniey", "createdAt": "2020-07-02T08:17:08Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgyOTE1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448829158", "bodyText": "Remove this.. Same with the instance above.", "author": "conniey", "createdAt": "2020-07-02T08:17:39Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n+            headers));\n+        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n+    }\n+\n+    /**\n+     * creates the String to Sign\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return a string to sign for the request\n+     */\n+    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n+        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n+            \"Date\");\n+        return String.join(\"\\n\",\n+            dateHeader,  //date\n+            this.getCanonicalizedResource(requestURL)); //Canonicalized resource", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgyOTcxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448829715", "bodyText": "The ternary operator is easier to read when it is split like this:\nString dateHeader = headers.containsKey(\"x-ms-date\") \n    ? \"\" \n    : this.getStandardHeaderValue(headers, \"Date\");", "author": "conniey", "createdAt": "2020-07-02T08:18:41Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n+            headers));\n+        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n+    }\n+\n+    /**\n+     * creates the String to Sign\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return a string to sign for the request\n+     */\n+    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n+        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzMDQ0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448830449", "bodyText": "Does the case matter? If it does not, is equalsIgnoreCase() better to use than equals()?", "author": "conniey", "createdAt": "2020-07-02T08:19:56Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n+            headers));\n+        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n+    }\n+\n+    /**\n+     * creates the String to Sign\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return a string to sign for the request\n+     */\n+    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n+        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n+            \"Date\");\n+        return String.join(\"\\n\",\n+            dateHeader,  //date\n+            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n+    }\n+\n+    /**\n+     * gets necessary headers if the request does not already contain them\n+     *\n+     * @param headers a map of the headers which the request has\n+     * @param headerName the name of the header to get the standard header for\n+     * @return the standard header for the given name\n+     */\n+    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n+        String headerValue = headers.get(headerName);\n+        return headerValue == null ? \"\" : headerValue;\n+    }\n+\n+\n+    /**\n+     * returns the canonicalized resource needed for a request\n+     *\n+     * @param requestURL the url of the request\n+     * @return the string that is the canonicalized resource\n+     */\n+    private String getCanonicalizedResource(URL requestURL) {\n+        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n+        canonicalizedResource.append(this.accountName);\n+        if (requestURL.getPath().length() > 0) {\n+            canonicalizedResource.append(requestURL.getPath());\n+        } else {\n+            canonicalizedResource.append('/');\n+        }\n+\n+        if (requestURL.getQuery() != null) {\n+            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n+            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n+            Collections.sort(queryParamNames);\n+\n+            for (String queryParamName : queryParamNames) {\n+                String[] queryParamValues = queryParams.get(queryParamName);\n+                Arrays.sort(queryParamValues);\n+                String queryParamValuesStr = String.join(\",\", queryParamValues);\n+                if (queryParamName.equals(\"comp\")) {", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzMDc0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448830749", "bodyText": "null.? In correct replacement?", "author": "conniey", "createdAt": "2020-07-02T08:20:26Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/package-info.java", "diffHunk": "@@ -0,0 +1,5 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+/** Package containing the inner classes for Azure Tables SDK. null. */", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/package-info.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/package-info.java\ndeleted file mode 100644\nindex 681b49d60f3..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/package-info.java\n+++ /dev/null\n\n@@ -1,5 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-/** Package containing the inner classes for Azure Tables SDK. null. */\n-package com.azure.data.tables;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzMDk1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448830958", "bodyText": "Did you mean to format this class?", "author": "conniey", "createdAt": "2020-07-02T08:20:49Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java", "diffHunk": "@@ -73,164 +73,164 @@\n         @ExpectedResponses({200})", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\nindex 027146409f4..e65eb9d2245 100644\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\n+++ b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesImpl.java\n\n@@ -73,164 +73,164 @@ public final class TablesImpl {\n         @ExpectedResponses({200})\n         @UnexpectedResponseExceptionType(HttpResponseException.class)\n         Mono<TablesQueryResponse> query(\n-            @HostParam(\"url\") String url,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @QueryParam(\"$top\") Integer top,\n-            @QueryParam(\"$select\") String select,\n-            @QueryParam(\"$filter\") String filter,\n-            @QueryParam(\"NextTableName\") String nextTableName,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @QueryParam(\"$top\") Integer top,\n+                @QueryParam(\"$select\") String select,\n+                @QueryParam(\"$filter\") String filter,\n+                @QueryParam(\"NextTableName\") String nextTableName,\n+                Context context);\n \n         @Post(\"/Tables\")\n         @ExpectedResponses({201, 204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesCreateResponse> create(\n-            @HostParam(\"url\") String url,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @HeaderParam(\"Prefer\") ResponseFormat responsePreference,\n-            @BodyParam(\"application/json\") TableProperties tableProperties,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @HeaderParam(\"Prefer\") ResponseFormat responsePreference,\n+                @BodyParam(\"application/json\") TableProperties tableProperties,\n+                Context context);\n \n         @Delete(\"/Tables('{table}')\")\n         @ExpectedResponses({204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesDeleteResponse> delete(\n-            @HostParam(\"url\") String url,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @PathParam(\"table\") String table,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @PathParam(\"table\") String table,\n+                Context context);\n \n         @Get(\"/{table}()\")\n         @ExpectedResponses({200})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesQueryEntitiesResponse> queryEntities(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @QueryParam(\"$top\") Integer top,\n-            @QueryParam(\"$select\") String select,\n-            @QueryParam(\"$filter\") String filter,\n-            @PathParam(\"table\") String table,\n-            @QueryParam(\"NextPartitionKey\") String nextPartitionKey,\n-            @QueryParam(\"NextRowKey\") String nextRowKey,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @QueryParam(\"$top\") Integer top,\n+                @QueryParam(\"$select\") String select,\n+                @QueryParam(\"$filter\") String filter,\n+                @PathParam(\"table\") String table,\n+                @QueryParam(\"NextPartitionKey\") String nextPartitionKey,\n+                @QueryParam(\"NextRowKey\") String nextRowKey,\n+                Context context);\n \n         @Get(\"/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')\")\n         @ExpectedResponses({200})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesQueryEntitiesWithPartitionAndRowKeyResponse> queryEntitiesWithPartitionAndRowKey(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @QueryParam(\"$select\") String select,\n-            @QueryParam(\"$filter\") String filter,\n-            @PathParam(\"table\") String table,\n-            @PathParam(\"partitionKey\") String partitionKey,\n-            @PathParam(\"rowKey\") String rowKey,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @QueryParam(\"$select\") String select,\n+                @QueryParam(\"$filter\") String filter,\n+                @PathParam(\"table\") String table,\n+                @PathParam(\"partitionKey\") String partitionKey,\n+                @PathParam(\"rowKey\") String rowKey,\n+                Context context);\n \n         @Put(\"/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')\")\n         @ExpectedResponses({204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesUpdateEntityResponse> updateEntity(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @PathParam(\"table\") String table,\n-            @PathParam(\"partitionKey\") String partitionKey,\n-            @PathParam(\"rowKey\") String rowKey,\n-            @HeaderParam(\"If-Match\") String ifMatch,\n-            @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @PathParam(\"table\") String table,\n+                @PathParam(\"partitionKey\") String partitionKey,\n+                @PathParam(\"rowKey\") String rowKey,\n+                @HeaderParam(\"If-Match\") String ifMatch,\n+                @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n+                Context context);\n \n         @Patch(\"/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')\")\n         @ExpectedResponses({204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesMergeEntityResponse> mergeEntity(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @PathParam(\"table\") String table,\n-            @PathParam(\"partitionKey\") String partitionKey,\n-            @PathParam(\"rowKey\") String rowKey,\n-            @HeaderParam(\"If-Match\") String ifMatch,\n-            @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @PathParam(\"table\") String table,\n+                @PathParam(\"partitionKey\") String partitionKey,\n+                @PathParam(\"rowKey\") String rowKey,\n+                @HeaderParam(\"If-Match\") String ifMatch,\n+                @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n+                Context context);\n \n         @Delete(\"/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')\")\n         @ExpectedResponses({204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesDeleteEntityResponse> deleteEntity(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @PathParam(\"table\") String table,\n-            @PathParam(\"partitionKey\") String partitionKey,\n-            @PathParam(\"rowKey\") String rowKey,\n-            @HeaderParam(\"If-Match\") String ifMatch,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @PathParam(\"table\") String table,\n+                @PathParam(\"partitionKey\") String partitionKey,\n+                @PathParam(\"rowKey\") String rowKey,\n+                @HeaderParam(\"If-Match\") String ifMatch,\n+                Context context);\n \n         @Post(\"/{table}\")\n         @ExpectedResponses({201, 204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesInsertEntityResponse> insertEntity(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n-            @QueryParam(\"$format\") OdataMetadataFormat format,\n-            @PathParam(\"table\") String table,\n-            @HeaderParam(\"Prefer\") ResponseFormat responsePreference,\n-            @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+                @QueryParam(\"$format\") OdataMetadataFormat format,\n+                @PathParam(\"table\") String table,\n+                @HeaderParam(\"Prefer\") ResponseFormat responsePreference,\n+                @BodyParam(\"application/json\") Map<String, Object> tableEntityProperties,\n+                Context context);\n \n         @Get(\"/{table}\")\n         @ExpectedResponses({200})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesGetAccessPolicyResponse> getAccessPolicy(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @PathParam(\"table\") String table,\n-            @QueryParam(\"comp\") String comp,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @PathParam(\"table\") String table,\n+                @QueryParam(\"comp\") String comp,\n+                Context context);\n \n         @Put(\"/{table}\")\n         @ExpectedResponses({204})\n         @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n         Mono<TablesSetAccessPolicyResponse> setAccessPolicy(\n-            @HostParam(\"url\") String url,\n-            @QueryParam(\"timeout\") Integer timeout,\n-            @HeaderParam(\"x-ms-version\") String version,\n-            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n-            @PathParam(\"table\") String table,\n-            @QueryParam(\"comp\") String comp,\n-            @BodyParam(\"application/xml\") List<SignedIdentifier> tableAcl,\n-            Context context);\n+                @HostParam(\"url\") String url,\n+                @QueryParam(\"timeout\") Integer timeout,\n+                @HeaderParam(\"x-ms-version\") String version,\n+                @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+                @PathParam(\"table\") String table,\n+                @QueryParam(\"comp\") String comp,\n+                @BodyParam(\"application/xml\") List<SignedIdentifier> tableAcl,\n+                Context context);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzMTA4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448831088", "bodyText": "nit: empty line.", "author": "conniey", "createdAt": "2020-07-02T08:21:07Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d9c37cc4358..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        super.beforeTest();\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        final HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzMzM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448833391", "bodyText": "My personal rule of thumb is to add an empty line between all my variable creations and method invocations. I think it makes it easier to reason about as you're reading. In this case, it would look like:\nMap<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\nArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n\nCollections.sort(queryParamNames);\n\nif (requestURL.getQuery() != null) {\n    for (String queryParamName : queryParamNames) {\n        String[] queryParamValues = queryParams.get(queryParamName);\n\n        Arrays.sort(queryParamValues);\n\n        String queryParamValuesStr = String.join(\",\", queryParamValues);\n\n        if (queryParamName.equals(\"comp\")) {\n            canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT))\n                .append(\"=\")\n                .append(queryParamValuesStr);\n        }\n    }\n}\n\nreturn canonicalizedResource.toString();", "author": "conniey", "createdAt": "2020-07-02T08:25:06Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n+            headers));\n+        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n+    }\n+\n+    /**\n+     * creates the String to Sign\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return a string to sign for the request\n+     */\n+    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n+        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n+            \"Date\");\n+        return String.join(\"\\n\",\n+            dateHeader,  //date\n+            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n+    }\n+\n+    /**\n+     * gets necessary headers if the request does not already contain them\n+     *\n+     * @param headers a map of the headers which the request has\n+     * @param headerName the name of the header to get the standard header for\n+     * @return the standard header for the given name\n+     */\n+    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n+        String headerValue = headers.get(headerName);\n+        return headerValue == null ? \"\" : headerValue;\n+    }\n+\n+\n+    /**\n+     * returns the canonicalized resource needed for a request\n+     *\n+     * @param requestURL the url of the request\n+     * @return the string that is the canonicalized resource\n+     */\n+    private String getCanonicalizedResource(URL requestURL) {\n+        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n+        canonicalizedResource.append(this.accountName);\n+        if (requestURL.getPath().length() > 0) {\n+            canonicalizedResource.append(requestURL.getPath());\n+        } else {\n+            canonicalizedResource.append('/');\n+        }\n+\n+        if (requestURL.getQuery() != null) {\n+            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n+            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n+            Collections.sort(queryParamNames);\n+\n+            for (String queryParamName : queryParamNames) {\n+                String[] queryParamValues = queryParams.get(queryParamName);\n+                Arrays.sort(queryParamValues);\n+                String queryParamValuesStr = String.join(\",\", queryParamValues);\n+                if (queryParamName.equals(\"comp\")) {", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzNDYxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448834613", "bodyText": "This can be:\nStringBuilder canonicalizedResource = new StringBuilder(\"/\").append(accountName);", "author": "conniey", "createdAt": "2020-07-02T08:27:08Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n+ * access Azure Tables\n+ */\n+public class TablesSharedKeyCredential {\n+    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n+    private final String accountName;\n+    private final String accountKey;\n+\n+    /**\n+     * Constructor for TableSharedKeyCredential Class\n+     *\n+     * @param accountName name of the storage account\n+     * @param accountKey key to the storage account\n+     */\n+    public TablesSharedKeyCredential(String accountName, String accountKey) {\n+        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n+        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n+        this.accountName = accountName;\n+        this.accountKey = accountKey;\n+    }\n+\n+    /**\n+     * Generates the Auth Headers\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return the auth header\n+     */\n+    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n+        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n+            headers));\n+        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n+    }\n+\n+    /**\n+     * creates the String to Sign\n+     *\n+     * @param requestURL the URL which the request is going to\n+     * @param headers the headers of the request\n+     * @return a string to sign for the request\n+     */\n+    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n+        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n+            \"Date\");\n+        return String.join(\"\\n\",\n+            dateHeader,  //date\n+            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n+    }\n+\n+    /**\n+     * gets necessary headers if the request does not already contain them\n+     *\n+     * @param headers a map of the headers which the request has\n+     * @param headerName the name of the header to get the standard header for\n+     * @return the standard header for the given name\n+     */\n+    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n+        String headerValue = headers.get(headerName);\n+        return headerValue == null ? \"\" : headerValue;\n+    }\n+\n+\n+    /**\n+     * returns the canonicalized resource needed for a request\n+     *\n+     * @param requestURL the url of the request\n+     * @return the string that is the canonicalized resource\n+     */\n+    private String getCanonicalizedResource(URL requestURL) {\n+        StringBuilder canonicalizedResource = new StringBuilder(\"/\");", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\ndeleted file mode 100644\nindex b6ff669a234..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredential.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.storage.common.implementation.StorageImplUtils;\n-\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-/**\n- * A Class which helps generate the shared key credentials for a given storage account to create a Http requests to\n- * access Azure Tables\n- */\n-public class TablesSharedKeyCredential {\n-    private static final String AUTHORIZATION_HEADER_FORMAT = \"SharedKeyLite %s:%s\";\n-    private final String accountName;\n-    private final String accountKey;\n-\n-    /**\n-     * Constructor for TableSharedKeyCredential Class\n-     *\n-     * @param accountName name of the storage account\n-     * @param accountKey key to the storage account\n-     */\n-    public TablesSharedKeyCredential(String accountName, String accountKey) {\n-        Objects.requireNonNull(accountName, \"'accountName' cannot be null.\");\n-        Objects.requireNonNull(accountKey, \"'accountKey' cannot be null.\");\n-        this.accountName = accountName;\n-        this.accountKey = accountKey;\n-    }\n-\n-    /**\n-     * Generates the Auth Headers\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return the auth header\n-     */\n-    public String generateAuthorizationHeader(URL requestURL, Map<String, String> headers) {\n-        String signature = StorageImplUtils.computeHMac256(this.accountKey, this.buildStringToSign(requestURL,\n-            headers));\n-        return String.format(AUTHORIZATION_HEADER_FORMAT, this.accountName, signature);\n-    }\n-\n-    /**\n-     * creates the String to Sign\n-     *\n-     * @param requestURL the URL which the request is going to\n-     * @param headers the headers of the request\n-     * @return a string to sign for the request\n-     */\n-    private String buildStringToSign(URL requestURL, Map<String, String> headers) {\n-        String dateHeader = headers.containsKey(\"x-ms-date\") ? \"\" : this.getStandardHeaderValue(headers,\n-            \"Date\");\n-        return String.join(\"\\n\",\n-            dateHeader,  //date\n-            this.getCanonicalizedResource(requestURL)); //Canonicalized resource\n-    }\n-\n-    /**\n-     * gets necessary headers if the request does not already contain them\n-     *\n-     * @param headers a map of the headers which the request has\n-     * @param headerName the name of the header to get the standard header for\n-     * @return the standard header for the given name\n-     */\n-    private String getStandardHeaderValue(Map<String, String> headers, String headerName) {\n-        String headerValue = headers.get(headerName);\n-        return headerValue == null ? \"\" : headerValue;\n-    }\n-\n-\n-    /**\n-     * returns the canonicalized resource needed for a request\n-     *\n-     * @param requestURL the url of the request\n-     * @return the string that is the canonicalized resource\n-     */\n-    private String getCanonicalizedResource(URL requestURL) {\n-        StringBuilder canonicalizedResource = new StringBuilder(\"/\");\n-        canonicalizedResource.append(this.accountName);\n-        if (requestURL.getPath().length() > 0) {\n-            canonicalizedResource.append(requestURL.getPath());\n-        } else {\n-            canonicalizedResource.append('/');\n-        }\n-\n-        if (requestURL.getQuery() != null) {\n-            Map<String, String[]> queryParams = StorageImplUtils.parseQueryStringSplitValues(requestURL.getQuery());\n-            ArrayList<String> queryParamNames = new ArrayList<>(queryParams.keySet());\n-            Collections.sort(queryParamNames);\n-\n-            for (String queryParamName : queryParamNames) {\n-                String[] queryParamValues = queryParams.get(queryParamName);\n-                Arrays.sort(queryParamValues);\n-                String queryParamValuesStr = String.join(\",\", queryParamValues);\n-                if (queryParamName.equals(\"comp\")) {\n-                    canonicalizedResource.append(\"?\").append(queryParamName.toLowerCase(Locale.ROOT)).append(\"=\")\n-                        .append(queryParamValuesStr);\n-                }\n-            }\n-        }\n-        return canonicalizedResource.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzNDczNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448834735", "bodyText": "nit:new line", "author": "conniey", "createdAt": "2020-07-02T08:27:21Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java\ndeleted file mode 100644\nindex bfdd68f4688..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import reactor.core.publisher.Mono;\n-\n-/**\n- * This class helps authenticate an Http request for the Tables service\n- */\n-public final class TablesSharedKeyCredentialPolicy implements HttpPipelinePolicy {\n-\n-    private final TablesSharedKeyCredential credential;\n-\n-    /**\n-     * constructor for the TablesSharedKeyCredentialPolicy class\n-     *\n-     * @param credential the credentials of the account\n-     */\n-    public TablesSharedKeyCredentialPolicy(TablesSharedKeyCredential credential) {\n-        this.credential = credential;\n-    }\n-\n-    /**\n-     * creates an Http response\n-     *\n-     * @param context the context of the http pipeline\n-     * @param next the next Http pipeline policy\n-     * @return an Http response\n-     */\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        String authorizationValue = this.credential.generateAuthorizationHeader(context.getHttpRequest().getUrl(),\n-            context.getHttpRequest().getHeaders().toMap());\n-        context.getHttpRequest().setHeader(\"Authorization\", authorizationValue);\n-        return next.process();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzNDkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448834904", "bodyText": "Remove this.", "author": "conniey", "createdAt": "2020-07-02T08:27:38Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * This class helps authenticate an Http request for the Tables service\n+ */\n+public final class TablesSharedKeyCredentialPolicy implements HttpPipelinePolicy {\n+\n+    private final TablesSharedKeyCredential credential;\n+\n+    /**\n+     * constructor for the TablesSharedKeyCredentialPolicy class\n+     *\n+     * @param credential the credentials of the account\n+     */\n+    public TablesSharedKeyCredentialPolicy(TablesSharedKeyCredential credential) {\n+        this.credential = credential;\n+    }\n+\n+    /**\n+     * creates an Http response\n+     *\n+     * @param context the context of the http pipeline\n+     * @param next the next Http pipeline policy\n+     * @return an Http response\n+     */\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        String authorizationValue = this.credential.generateAuthorizationHeader(context.getHttpRequest().getUrl(),", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java b/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java\ndeleted file mode 100644\nindex bfdd68f4688..00000000000\n--- a/sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TablesSharedKeyCredentialPolicy.java\n+++ /dev/null\n\n@@ -1,42 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-\n-import com.azure.core.http.HttpPipelineCallContext;\n-import com.azure.core.http.HttpPipelineNextPolicy;\n-import com.azure.core.http.HttpResponse;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import reactor.core.publisher.Mono;\n-\n-/**\n- * This class helps authenticate an Http request for the Tables service\n- */\n-public final class TablesSharedKeyCredentialPolicy implements HttpPipelinePolicy {\n-\n-    private final TablesSharedKeyCredential credential;\n-\n-    /**\n-     * constructor for the TablesSharedKeyCredentialPolicy class\n-     *\n-     * @param credential the credentials of the account\n-     */\n-    public TablesSharedKeyCredentialPolicy(TablesSharedKeyCredential credential) {\n-        this.credential = credential;\n-    }\n-\n-    /**\n-     * creates an Http response\n-     *\n-     * @param context the context of the http pipeline\n-     * @param next the next Http pipeline policy\n-     * @return an Http response\n-     */\n-    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n-        String authorizationValue = this.credential.generateAuthorizationHeader(context.getHttpRequest().getUrl(),\n-            context.getHttpRequest().getHeaders().toMap());\n-        context.getHttpRequest().setHeader(\"Authorization\", authorizationValue);\n-        return next.process();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzNTEyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448835120", "bodyText": "super.beforeTest() is an empty method, you can remove this.", "author": "conniey", "createdAt": "2020-07-02T08:28:00Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        super.beforeTest();", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d9c37cc4358..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        super.beforeTest();\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        final HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzNTUyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r448835520", "bodyText": "I'd be consistent about using final. If you use final here. I'd expect you to use it in all other cases in your code where you don't expect variables to be reassigned.", "author": "conniey", "createdAt": "2020-07-02T08:28:45Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        super.beforeTest();\n+        String connectionString = interceptorManager.isPlaybackMode()\n+            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n+            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        final List<HttpPipelinePolicy> policies = new ArrayList<>();", "originalCommit": "d95454542c0319d874e99fd45dec8191a108cd21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d9c37cc4358..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,521 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        super.beforeTest();\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        final List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        final HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        final HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MzA1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r449183052", "bodyText": "nit: trailing new lines", "author": "conniey", "createdAt": "2020-07-02T17:58:17Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,519 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        String connectionString = interceptorManager.isPlaybackMode()\n+            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n+            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        List<HttpPipelinePolicy> policies = new ArrayList<>();\n+        policies.add(new AddDatePolicy());\n+        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n+            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n+        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n+        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n+\n+        HttpClient httpClientToUse;\n+        if (interceptorManager.isPlaybackMode()) {\n+            httpClientToUse = interceptorManager.getPlaybackClient();\n+        } else {\n+            httpClientToUse = HttpClient.createDefault();\n+            policies.add(interceptorManager.getRecordPolicy());\n+            policies.add(new RetryPolicy());\n+        }\n+        HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(httpClientToUse)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n+            .buildClient();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        QueryOptions queryOptions = new QueryOptions()\n+            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n+\n+        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n+            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n+                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n+                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n+                        testResourceNamer.randomUuid(), Context.NONE);\n+                });\n+            })).block();\n+    }\n+\n+    void createTable(String tableName) {\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+", "originalCommit": "ea32e09cd5702979314b2785c0fc96041edb1d16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d41c262945a..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,519 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MzcwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r449183705", "bodyText": "If you import this, it won't need to be fully qualified.", "author": "conniey", "createdAt": "2020-07-02T17:59:06Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,519 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        String connectionString = interceptorManager.isPlaybackMode()\n+            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n+            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        List<HttpPipelinePolicy> policies = new ArrayList<>();\n+        policies.add(new AddDatePolicy());\n+        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n+            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n+        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n+        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n+\n+        HttpClient httpClientToUse;\n+        if (interceptorManager.isPlaybackMode()) {\n+            httpClientToUse = interceptorManager.getPlaybackClient();\n+        } else {\n+            httpClientToUse = HttpClient.createDefault();\n+            policies.add(interceptorManager.getRecordPolicy());\n+            policies.add(new RetryPolicy());\n+        }\n+        HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(httpClientToUse)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n+            .buildClient();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        QueryOptions queryOptions = new QueryOptions()\n+            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n+\n+        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n+            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n+                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n+                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n+                        testResourceNamer.randomUuid(), Context.NONE);\n+                });\n+            })).block();\n+    }\n+\n+    void createTable(String tableName) {\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+\n+\n+    }\n+\n+    void insertNoETag(String tableName, Map<String, Object> properties) {\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n+            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n+    }\n+\n+    @Test\n+    void createTable() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        int expectedStatusCode = 201;\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n+            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n+            .assertNext(response -> {\n+                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n+            })\n+            .expectComplete()\n+            .verify();\n+    }\n+\n+    @Test\n+    void createTableDuplicateName() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        createTable(tableName);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n+            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n+            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)", "originalCommit": "ea32e09cd5702979314b2785c0fc96041edb1d16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d41c262945a..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,519 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTA5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r449185090", "bodyText": "Adding a couple of assertions may prevent null pointer exceptions and out of bounds exceptions (if there are not 2 elements in the table).\nassertNotNull(response.getValue(), \"Expected there to be a result.\");\n\nvar results = response.getValue().getValue();\n\nassertNotNull(results, \"Expected there to be a set of items.\");\nassertEquals(2, results.getSize());\n\n//... your other assertions.", "author": "conniey", "createdAt": "2020-07-02T18:01:44Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,519 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        String connectionString = interceptorManager.isPlaybackMode()\n+            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n+            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n+\n+        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n+        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n+            authSettings.getAccount().getAccessKey());\n+\n+        List<HttpPipelinePolicy> policies = new ArrayList<>();\n+        policies.add(new AddDatePolicy());\n+        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n+            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n+        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n+        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n+\n+        HttpClient httpClientToUse;\n+        if (interceptorManager.isPlaybackMode()) {\n+            httpClientToUse = interceptorManager.getPlaybackClient();\n+        } else {\n+            httpClientToUse = HttpClient.createDefault();\n+            policies.add(interceptorManager.getRecordPolicy());\n+            policies.add(new RetryPolicy());\n+        }\n+        HttpPipeline pipeline = new HttpPipelineBuilder()\n+            .httpClient(httpClientToUse)\n+            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+        azureTable = new AzureTableImplBuilder()\n+            .pipeline(pipeline)\n+            .version(\"2019-02-02\")\n+            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n+            .buildClient();\n+    }\n+\n+    @Override\n+    protected void afterTest() {\n+        QueryOptions queryOptions = new QueryOptions()\n+            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n+\n+        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n+            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n+                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n+                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n+                        testResourceNamer.randomUuid(), Context.NONE);\n+                });\n+            })).block();\n+    }\n+\n+    void createTable(String tableName) {\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n+            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n+\n+\n+    }\n+\n+    void insertNoETag(String tableName, Map<String, Object> properties) {\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n+            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n+    }\n+\n+    @Test\n+    void createTable() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        int expectedStatusCode = 201;\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n+            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n+            .assertNext(response -> {\n+                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n+            })\n+            .expectComplete()\n+            .verify();\n+    }\n+\n+    @Test\n+    void createTableDuplicateName() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n+        createTable(tableName);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n+            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n+            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n+            .verify();\n+    }\n+\n+    @Test\n+    void deleteTable() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        createTable(tableName);\n+        int expectedStatusCode = 204;\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n+            Context.NONE))\n+            .assertNext(response -> {\n+                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n+            })\n+            .expectComplete()\n+            .verify();\n+    }\n+\n+    @Test\n+    void deleteNonExistentTable() {\n+        // Arrange\n+        String tableName = testResourceNamer.randomName(\"test\", 20);\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n+            Context.NONE))\n+            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n+            .verify();\n+    }\n+\n+    @Test\n+    void queryTable() {\n+        // Arrange\n+        QueryOptions queryOptions = new QueryOptions()\n+            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n+        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n+        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n+        createTable(tableA);\n+        createTable(tableB);\n+        int expectedStatusCode = 200;\n+        String requestId = testResourceNamer.randomUuid();\n+\n+        // Act & Assert\n+        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n+            queryOptions, Context.NONE))\n+            .assertNext(response -> {\n+                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n+                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);", "originalCommit": "ea32e09cd5702979314b2785c0fc96041edb1d16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTI5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r449185298", "bodyText": "Same with any other instances where you do this .getValue().getValue().", "author": "conniey", "createdAt": "2020-07-02T18:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "576d2be4c20b40af506a25084bfa986a265af571", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\ndeleted file mode 100644\nindex d41c262945a..00000000000\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ /dev/null\n\n@@ -1,519 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-\n-package com.azure.data.tables;\n-\n-import com.azure.core.http.HttpClient;\n-import com.azure.core.http.HttpHeaders;\n-import com.azure.core.http.HttpPipeline;\n-import com.azure.core.http.HttpPipelineBuilder;\n-import com.azure.core.http.policy.AddDatePolicy;\n-import com.azure.core.http.policy.AddHeadersPolicy;\n-import com.azure.core.http.policy.HttpLogDetailLevel;\n-import com.azure.core.http.policy.HttpLogOptions;\n-import com.azure.core.http.policy.HttpLoggingPolicy;\n-import com.azure.core.http.policy.HttpPipelinePolicy;\n-import com.azure.core.http.policy.RetryPolicy;\n-import com.azure.core.test.TestBase;\n-import com.azure.core.util.Context;\n-import com.azure.core.util.logging.ClientLogger;\n-import com.azure.data.tables.implementation.AzureTableImpl;\n-import com.azure.data.tables.implementation.AzureTableImplBuilder;\n-import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n-import com.azure.data.tables.implementation.models.QueryOptions;\n-import com.azure.data.tables.implementation.models.ResponseFormat;\n-import com.azure.data.tables.implementation.models.TableProperties;\n-import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n-import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-import reactor.core.publisher.Flux;\n-import reactor.core.publisher.Mono;\n-import reactor.test.StepVerifier;\n-\n-/**\n- * This class tests the Autorest code for the Tables track 2 SDK\n- */\n-public class AzureTableImplTest extends TestBase {\n-    private static final String PARTITION_KEY = \"PartitionKey\";\n-    private static final String ROW_KEY = \"RowKey\";\n-    private static final int TIMEOUT = 5000;\n-    private AzureTableImpl azureTable;\n-\n-    @Override\n-    protected void beforeTest() {\n-        String connectionString = interceptorManager.isPlaybackMode()\n-            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n-            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n-        StorageConnectionString storageConnectionString\n-            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n-\n-        StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n-        TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n-            authSettings.getAccount().getAccessKey());\n-\n-        List<HttpPipelinePolicy> policies = new ArrayList<>();\n-        policies.add(new AddDatePolicy());\n-        policies.add(new AddHeadersPolicy(new HttpHeaders().put(\"Accept\",\n-            OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA.toString())));\n-        policies.add(new TablesSharedKeyCredentialPolicy(sharedKeyCredential));\n-        policies.add(new HttpLoggingPolicy(new HttpLogOptions().setLogLevel(HttpLogDetailLevel.BODY_AND_HEADERS)));\n-\n-        HttpClient httpClientToUse;\n-        if (interceptorManager.isPlaybackMode()) {\n-            httpClientToUse = interceptorManager.getPlaybackClient();\n-        } else {\n-            httpClientToUse = HttpClient.createDefault();\n-            policies.add(interceptorManager.getRecordPolicy());\n-            policies.add(new RetryPolicy());\n-        }\n-        HttpPipeline pipeline = new HttpPipelineBuilder()\n-            .httpClient(httpClientToUse)\n-            .policies(policies.toArray(new HttpPipelinePolicy[0]))\n-            .build();\n-        azureTable = new AzureTableImplBuilder()\n-            .pipeline(pipeline)\n-            .version(\"2019-02-02\")\n-            .url(storageConnectionString.getTableEndpoint().getPrimaryUri())\n-            .buildClient();\n-    }\n-\n-    @Override\n-    protected void afterTest() {\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-\n-        Mono.when(azureTable.getTables().queryWithResponseAsync(testResourceNamer.randomUuid(), null,\n-            queryOptions, Context.NONE).flatMapMany(tablesQueryResponse -> {\n-                return Flux.fromIterable(tablesQueryResponse.getValue().getValue()).flatMap(tableResponseProperty -> {\n-                    return azureTable.getTables().deleteWithResponseAsync(tableResponseProperty.getTableName(),\n-                        testResourceNamer.randomUuid(), Context.NONE);\n-                });\n-            })).block();\n-    }\n-\n-    void createTable(String tableName) {\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().createWithResponseAsync(tableProperties, requestId,\n-            ResponseFormat.RETURN_CONTENT, null, Context.NONE).block();\n-\n-\n-    }\n-\n-    void insertNoETag(String tableName, Map<String, Object> properties) {\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE).log().block();\n-    }\n-\n-    @Test\n-    void createTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void createTableDuplicateName() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        TableProperties tableProperties = new TableProperties().setTableName(tableName);\n-        createTable(tableName);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().createWithResponseAsync(tableProperties,\n-            requestId, ResponseFormat.RETURN_CONTENT, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentTable() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteWithResponseAsync(tableName, requestId,\n-            Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTable() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(response.getValue().getValue().get(0).getTableName(), tableA);\n-                Assertions.assertEquals(response.getValue().getValue().get(1).getTableName(), tableB);\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryTablewithTop() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions()\n-            .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_MINIMALMETADATA);\n-        String tableA = testResourceNamer.randomName(\"AtestA\", 20);\n-        String tableB = testResourceNamer.randomName(\"BtestB\", 20);\n-        createTable(tableA);\n-        createTable(tableB);\n-        int expectedStatusCode = 200;\n-        int expectedSize = 1;\n-        String requestId = testResourceNamer.randomUuid();\n-        queryOptions.setTop(1);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryWithResponseAsync(requestId, null,\n-            queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(expectedSize, response.getValue().getValue().size());\n-                Assertions.assertEquals(tableA, response.getValue().getValue().get(0).getTableName());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void insertNoEtag() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 201;\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().insertEntityWithResponseAsync(tableName, TIMEOUT,\n-            requestId, ResponseFormat.RETURN_CONTENT, properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void mergeNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().mergeEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-        properties.put(\"extraProperty\", testResourceNamer.randomName(\"extraProperty\", 16));\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void updateNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().updateEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, requestId, \"*\", properties, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        int expectedStatusCode = 204;\n-        String requestId = testResourceNamer.randomUuid();\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void deleteNonExistentEntity() {\n-        // Arrange\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        String requestId = testResourceNamer.randomUuid();\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().deleteEntityWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, \"*\", TIMEOUT, requestId, null, Context.NONE))\n-            .expectError(com.azure.data.tables.implementation.models.TableServiceErrorException.class)\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntity() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyB\", 20));\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(partitionKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(partitionKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithSelect() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        //insert entity A\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        String rowKeyEntityA = testResourceNamer.randomName(\"rowKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, rowKeyEntityA);\n-        insertNoETag(tableName, entityA);\n-        //insert entity B\n-        Map<String, Object> entityB = new HashMap<>();\n-        String partitionKeyEntityB = testResourceNamer.randomName(\"partitionKeyB\", 20);\n-        String rowKeyEntityB = testResourceNamer.randomName(\"rowKeyB\", 20);\n-        entityB.put(PARTITION_KEY, partitionKeyEntityB);\n-        entityB.put(ROW_KEY, rowKeyEntityB);\n-        insertNoETag(tableName, entityB);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(ROW_KEY);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-                Assertions.assertEquals(true, response.getValue().getValue().get(0).containsValue(rowKeyEntityA));\n-                Assertions.assertEquals(true, response.getValue().getValue().get(1).containsValue(rowKeyEntityB));\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithFilter() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> entityA = new HashMap<>();\n-        String partitionKeyEntityA = testResourceNamer.randomName(\"partitionKeyA\", 20);\n-        entityA.put(PARTITION_KEY, partitionKeyEntityA);\n-        entityA.put(ROW_KEY, testResourceNamer.randomName(\"rowKeyA\", 20));\n-        insertNoETag(tableName, entityA);\n-        int expectedStatusCode = 200;\n-        queryOptions.setSelect(PARTITION_KEY + \"eq\" + partitionKeyEntityA);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-    @Test\n-    void queryEntityWithTop() {\n-        // Arrange\n-        String requestId = testResourceNamer.randomUuid();\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        int expectedStatusCode = 200;\n-        queryOptions.setTop(0);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithResponseAsync(tableName, TIMEOUT,\n-            requestId, null, null, queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(expectedStatusCode, response.getStatusCode());\n-\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-\n-    @Test\n-    void queryEntitiesWithPartitionAndRowKey() {\n-        // Arrange\n-        QueryOptions queryOptions = new QueryOptions().setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n-        String tableName = testResourceNamer.randomName(\"test\", 20);\n-        createTable(tableName);\n-        Map<String, Object> properties = new HashMap<>();\n-        String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n-        String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        properties.put(PARTITION_KEY, partitionKeyValue);\n-        properties.put(ROW_KEY, rowKeyValue);\n-        insertNoETag(tableName, properties);\n-\n-        // Act & Assert\n-        StepVerifier.create(azureTable.getTables().queryEntitiesWithPartitionAndRowKeyWithResponseAsync(tableName, partitionKeyValue,\n-            rowKeyValue, TIMEOUT, testResourceNamer.randomUuid(), queryOptions, Context.NONE))\n-            .assertNext(response -> {\n-                Assertions.assertEquals(200, response.getStatusCode());\n-            })\n-            .expectComplete()\n-            .verify();\n-    }\n-\n-}\n"}}, {"oid": "576d2be4c20b40af506a25084bfa986a265af571", "url": "https://github.com/Azure/azure-sdk-for-java/commit/576d2be4c20b40af506a25084bfa986a265af571", "message": "apply old", "committedDate": "2020-07-06T16:13:57Z", "type": "commit"}, {"oid": "dea249813611e57055a83221b4d7e5a823b98433", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dea249813611e57055a83221b4d7e5a823b98433", "message": "apply old", "committedDate": "2020-07-06T16:13:57Z", "type": "commit"}, {"oid": "081200a0298e7c731f0166492c7bcf1da7e86dfa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/081200a0298e7c731f0166492c7bcf1da7e86dfa", "message": "testing works on this commit", "committedDate": "2020-07-06T16:13:58Z", "type": "commit"}, {"oid": "f6ea265119493a81cf996c6355a1af8b817ed97f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f6ea265119493a81cf996c6355a1af8b817ed97f", "message": "stashing", "committedDate": "2020-07-06T16:13:58Z", "type": "commit"}, {"oid": "1e1efd8d6f6f398fb9690f84a5e6cc0d59406fa7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1e1efd8d6f6f398fb9690f84a5e6cc0d59406fa7", "message": "additional testing", "committedDate": "2020-07-06T16:13:59Z", "type": "commit"}, {"oid": "2397b8810e7ff99fd5cd3372ed993903861178f9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2397b8810e7ff99fd5cd3372ed993903861178f9", "message": "stashing", "committedDate": "2020-07-06T16:13:59Z", "type": "commit"}, {"oid": "c2e8eb76197132c777e93c39fa4b1b074f56c603", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c2e8eb76197132c777e93c39fa4b1b074f56c603", "message": "stashing", "committedDate": "2020-07-06T16:14:00Z", "type": "commit"}, {"oid": "b2ebec78d42b60b76636c62f583f27333a5d4eac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b2ebec78d42b60b76636c62f583f27333a5d4eac", "message": "adding tests", "committedDate": "2020-07-06T16:14:00Z", "type": "commit"}, {"oid": "d54ae2589a45cb82c2924e3283390ac41416db60", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d54ae2589a45cb82c2924e3283390ac41416db60", "message": "fixing format and POM", "committedDate": "2020-07-06T16:14:01Z", "type": "commit"}, {"oid": "ac21a3d8424c519f6625b942013ccd24be521419", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ac21a3d8424c519f6625b942013ccd24be521419", "message": "arrange-act-assert formatting", "committedDate": "2020-07-06T16:14:01Z", "type": "commit"}, {"oid": "5086d4a027c554f6e92e70dea6826ab490eafef1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5086d4a027c554f6e92e70dea6826ab490eafef1", "message": "stashing", "committedDate": "2020-07-06T16:14:02Z", "type": "commit"}, {"oid": "68f0cea590c956daa39b7d872c4364f3eacdb23b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68f0cea590c956daa39b7d872c4364f3eacdb23b", "message": "adding tests", "committedDate": "2020-07-06T16:14:02Z", "type": "commit"}, {"oid": "f13cca62df7e45a2c50b3d4cd359be7f9f57ce8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f13cca62df7e45a2c50b3d4cd359be7f9f57ce8f", "message": "reformat", "committedDate": "2020-07-06T16:14:03Z", "type": "commit"}, {"oid": "d4c187aa25bd34061ae38ae9e73e78d48452441d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4c187aa25bd34061ae38ae9e73e78d48452441d", "message": "remove system prints", "committedDate": "2020-07-06T16:14:03Z", "type": "commit"}, {"oid": "335d6466c22b1a4627c8421ae3dd755fc116d22b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/335d6466c22b1a4627c8421ae3dd755fc116d22b", "message": "adding playback jsons", "committedDate": "2020-07-06T16:14:04Z", "type": "commit"}, {"oid": "7133df8f93b09eaf4516358afe576aaf4b0cafaa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7133df8f93b09eaf4516358afe576aaf4b0cafaa", "message": "recent changes", "committedDate": "2020-07-06T16:14:04Z", "type": "commit"}, {"oid": "228156326b252966c73e54c7a060c00919aedc1c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/228156326b252966c73e54c7a060c00919aedc1c", "message": "fix pom", "committedDate": "2020-07-06T16:14:04Z", "type": "commit"}, {"oid": "ba399fec3d59a5f153eaa686f55ee19b12669afb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ba399fec3d59a5f153eaa686f55ee19b12669afb", "message": "playback mode", "committedDate": "2020-07-06T16:14:05Z", "type": "commit"}, {"oid": "ca8b84cd7710bc99158f72f9638de6cdd6dbb1fc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca8b84cd7710bc99158f72f9638de6cdd6dbb1fc", "message": "fix incorrect changes in readme", "committedDate": "2020-07-06T16:14:05Z", "type": "commit"}, {"oid": "e849c5e99a39bc9f5689ade548c1ca571eaaeee6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e849c5e99a39bc9f5689ade548c1ca571eaaeee6", "message": "fix pom", "committedDate": "2020-07-06T16:14:06Z", "type": "commit"}, {"oid": "0216fde8f8ff614a2c2f5e2e6bce830cc333d0bf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0216fde8f8ff614a2c2f5e2e6bce830cc333d0bf", "message": "fixing pom", "committedDate": "2020-07-06T16:14:06Z", "type": "commit"}, {"oid": "8b9e9061dfb93cab68e37eff4d7e1b0e89ae7acc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8b9e9061dfb93cab68e37eff4d7e1b0e89ae7acc", "message": "fixing version", "committedDate": "2020-07-06T16:14:07Z", "type": "commit"}, {"oid": "3558d0ff128d30b2c1f2afcfc4904b867f548118", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3558d0ff128d30b2c1f2afcfc4904b867f548118", "message": "fix impl", "committedDate": "2020-07-06T16:14:07Z", "type": "commit"}, {"oid": "5f24375c8497049fc28769cf423b744a64140c54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5f24375c8497049fc28769cf423b744a64140c54", "message": "fixing checkstyles", "committedDate": "2020-07-06T16:14:08Z", "type": "commit"}, {"oid": "229116aaa26c607df3e10bfa61bbb5f9d5789e12", "url": "https://github.com/Azure/azure-sdk-for-java/commit/229116aaa26c607df3e10bfa61bbb5f9d5789e12", "message": "fixing checkstyles p2", "committedDate": "2020-07-06T16:14:08Z", "type": "commit"}, {"oid": "06e255ae3fcb37d56b0412f67375ed574ee4315d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/06e255ae3fcb37d56b0412f67375ed574ee4315d", "message": "connie edits", "committedDate": "2020-07-06T16:14:09Z", "type": "commit"}, {"oid": "8cb259d9e3e0ae67df1298859967542bb5f5d616", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8cb259d9e3e0ae67df1298859967542bb5f5d616", "message": "connie edits 2", "committedDate": "2020-07-06T16:14:09Z", "type": "commit"}, {"oid": "9b19368ddc8c4a2d0502e08fd1d9308b0266f97e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9b19368ddc8c4a2d0502e08fd1d9308b0266f97e", "message": "forgot in last commit", "committedDate": "2020-07-06T16:14:09Z", "type": "commit"}, {"oid": "cef982047a3933ea2dd07bce97f2431e7f3bd446", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cef982047a3933ea2dd07bce97f2431e7f3bd446", "message": "add changelog", "committedDate": "2020-07-06T16:14:10Z", "type": "commit"}, {"oid": "1315b59085b02137cbff91dfafd4f157325aacc7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1315b59085b02137cbff91dfafd4f157325aacc7", "message": "connie comments", "committedDate": "2020-07-06T16:14:10Z", "type": "commit"}, {"oid": "74c33b5ae8b9225a49a75a6f716ae0cc9db69553", "url": "https://github.com/Azure/azure-sdk-for-java/commit/74c33b5ae8b9225a49a75a6f716ae0cc9db69553", "message": "fixing pipeline issues", "committedDate": "2020-07-06T16:14:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NDI3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12512#discussion_r450374270", "bodyText": "I'd add an assertion here so we don't continue the test if the set-up was incorrect.\nAssertions.notNull(connectionString, \"Cannot continue test if connectionString is not set.\");", "author": "conniey", "createdAt": "2020-07-06T17:29:02Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java", "diffHunk": "@@ -0,0 +1,525 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.tables;\n+\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.test.TestBase;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.AzureTableImpl;\n+import com.azure.data.tables.implementation.AzureTableImplBuilder;\n+import com.azure.data.tables.implementation.models.OdataMetadataFormat;\n+import com.azure.data.tables.implementation.models.QueryOptions;\n+import com.azure.data.tables.implementation.models.ResponseFormat;\n+import com.azure.data.tables.implementation.models.TableProperties;\n+import com.azure.data.tables.implementation.models.TableResponseProperties;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.storage.common.implementation.connectionstring.StorageAuthenticationSettings;\n+import com.azure.storage.common.implementation.connectionstring.StorageConnectionString;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * This class tests the Autorest code for the Tables track 2 SDK\n+ */\n+public class AzureTableImplTest extends TestBase {\n+    private static final String PARTITION_KEY = \"PartitionKey\";\n+    private static final String ROW_KEY = \"RowKey\";\n+    private static final int TIMEOUT = 5000;\n+    private AzureTableImpl azureTable;\n+\n+    @Override\n+    protected void beforeTest() {\n+        String connectionString = interceptorManager.isPlaybackMode()\n+            ? \"DefaultEndpointsProtocol=https;AccountName=dummyAccount;AccountKey=xyzDummy;EndpointSuffix=core.windows.net\"\n+            : System.getenv(\"AZURE_TABLES_CONNECTION_STRING\");\n+        StorageConnectionString storageConnectionString\n+            = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n+", "originalCommit": "773e428175ff8253525b1a4501e321d535dedfc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1351fbe5d2be2cfc74fd392bc3a2700e3ef30429", "chunk": "diff --git a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\nindex c8eebd942ff..24f61338386 100644\n--- a/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n+++ b/sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/AzureTableImplTest.java\n\n@@ -54,6 +54,8 @@ public class AzureTableImplTest extends TestBase {\n         StorageConnectionString storageConnectionString\n             = StorageConnectionString.create(connectionString, new ClientLogger(AzureTableImplTest.class));\n \n+        Assertions.assertNotNull(connectionString, \"Cannot continue test if connectionString is not set.\");\n+\n         StorageAuthenticationSettings authSettings = storageConnectionString.getStorageAuthSettings();\n         TablesSharedKeyCredential sharedKeyCredential = new TablesSharedKeyCredential(authSettings.getAccount().getName(),\n             authSettings.getAccount().getAccessKey());\n"}}, {"oid": "1351fbe5d2be2cfc74fd392bc3a2700e3ef30429", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1351fbe5d2be2cfc74fd392bc3a2700e3ef30429", "message": "assertion for setup", "committedDate": "2020-07-06T19:04:51Z", "type": "commit"}, {"oid": "b7f84007ae445a0caabfac87b4a69ad9a81cec3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7f84007ae445a0caabfac87b4a69ad9a81cec3c", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into testingAutorestTables", "committedDate": "2020-07-06T19:08:03Z", "type": "commit"}, {"oid": "b7f84007ae445a0caabfac87b4a69ad9a81cec3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7f84007ae445a0caabfac87b4a69ad9a81cec3c", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into testingAutorestTables", "committedDate": "2020-07-06T19:08:03Z", "type": "forcePushed"}, {"oid": "767bfdf1968d3f9122241ef5a0ac973102ed2aac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/767bfdf1968d3f9122241ef5a0ac973102ed2aac", "message": "fix impl", "committedDate": "2020-07-07T18:38:56Z", "type": "commit"}]}