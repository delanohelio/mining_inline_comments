{"pr_number": 9051, "pr_title": "Settles a service bus message. Allows receiving in both PEEK_LOCK and RECEIVE_AND_DELETE.", "pr_createdAt": "2020-03-13T05:31:56Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9051", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NDg3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392344878", "bodyText": "Any reason why bring back hardcoded value and not using variable senderSettleMode  and receiverSettleMode ?\nLater in configureSender() and configureReceiver() these values are hardcoded.\nShouldn't this use provided values ?", "author": "hemanttanwar", "createdAt": "2020-03-13T16:42:15Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -102,24 +102,19 @@\n         this.replyTo = entityPath.replace(\"$\", \"\") + \"-client-reply-to\";\n         this.messageSerializer = messageSerializer;\n         this.sendLink = session.sender(linkName + \":sender\");\n-        final Target target = new Target();\n-        target.setAddress(entityPath);\n-        this.sendLink.setTarget(target);\n-        sendLink.setSource(new Source());\n-        this.sendLink.setSenderSettleMode(senderSettleMode);", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MDc0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392380747", "bodyText": "I can pass these later. My original design was that these could be overridden in an extending class. I'll revert this.", "author": "conniey", "createdAt": "2020-03-13T17:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NDg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQxNTkxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392415915", "bodyText": "That design is good. Thanks for letting me know.", "author": "hemanttanwar", "createdAt": "2020-03-13T19:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NDg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java b/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java\nindex 2b227f5537..0091a81877 100644\n--- a/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java\n+++ b/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java\n\n@@ -97,13 +96,15 @@ public class RequestResponseChannel implements Disposable {\n         this.operationTimeout = retryOptions.getTryTimeout();\n         this.retryPolicy = RetryUtil.getRetryPolicy(retryOptions);\n         this.senderSettleMode = senderSettleMode;\n-        this.receiverSettleMode = receiverSettleMode;\n \n         this.replyTo = entityPath.replace(\"$\", \"\") + \"-client-reply-to\";\n         this.messageSerializer = messageSerializer;\n         this.sendLink = session.sender(linkName + \":sender\");\n-\n-        configureSender(this.sendLink, new Source(), new Target(), entityPath);\n+        final Target target = new Target();\n+        target.setAddress(entityPath);\n+        this.sendLink.setTarget(target);\n+        sendLink.setSource(new Source());\n+        this.sendLink.setSenderSettleMode(senderSettleMode);\n \n         this.sendLinkHandler = handlerProvider.createSendLinkHandler(connectionId, fullyQualifiedNamespace, linkName,\n             entityPath);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2NDc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392364772", "bodyText": "MessagingEntityType.QUEUE  Is there a need to know the type ? We will not always know for example if user uses connectionString(String connectionStringWithResourceName) in Builder.", "author": "hemanttanwar", "createdAt": "2020-03-13T17:18:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -236,7 +237,8 @@ public ServiceBusReceiverAsyncClient buildAsyncReceiverClient() {\n         final TracerProvider tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));\n \n         return new ServiceBusReceiverAsyncClient(connectionProcessor.getFullyQualifiedNamespace(),\n-            serviceBusResourceName, connectionProcessor, tracerProvider, messageSerializer, receiveMessageOptions);\n+            serviceBusResourceName, MessagingEntityType.QUEUE, false, receiveMessageOptions,\n+            connectionProcessor, tracerProvider, messageSerializer);", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTc1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392375757", "bodyText": "Yes. We do when building the receiver itself. On management operations, they specify what the entity type is before sending the message (in the headers).", "author": "conniey", "createdAt": "2020-03-13T17:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2NDc3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2ODIzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392368235", "bodyText": "We do not know always what is the entity type.", "author": "hemanttanwar", "createdAt": "2020-03-13T17:24:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusAmqpConnection.java", "diffHunk": "@@ -11,14 +11,13 @@\n import reactor.core.publisher.Mono;\n \n public interface ServiceBusAmqpConnection extends AmqpConnection {\n-\n     /**\n      * Gets the management node for a Service Bus resource and performs metadata and management operations using it.\n      *\n      * @param entityPath Name of the Service bus resource.\n      * @return A Mono that completes with that resources's management node.\n      */\n-    Mono<ServiceBusManagementNode> getManagementNode(String entityPath);\n+    Mono<ServiceBusManagementNode> getManagementNode(String entityPath, MessagingEntityType entityType);\n ", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NTkxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392375915", "bodyText": "We do, a management node is tied to an entity path, which is tied to a specific entity.", "author": "conniey", "createdAt": "2020-03-13T17:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2ODIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQxNzcyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392417727", "bodyText": "Just want to clarify that user specify \"EntityName\" and it could be Queue or Topic. So when user provide EntityName connectionString, we will not know is it topic or queue. User can send to a Topic/Queue without knowing what is  EntityType.\nBut you said you are going to infer it, same way  it is done in track1, and that is fine .", "author": "hemanttanwar", "createdAt": "2020-03-13T19:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2ODIzNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2OTQyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392369427", "bodyText": "nit: remove System.out", "author": "hemanttanwar", "createdAt": "2020-03-13T17:26:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -51,9 +51,10 @@ void receiveMessageAutoComplete() {\n             .assertNext(receivedMessage -> {\n                 Assertions.assertEquals(contents, receivedMessage.getBodyAsString());\n                 Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n-                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n             })\n             .verifyComplete();\n+\n+        System.out.println(\"Completed.\");", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\nindex 0411b9ad76..8d65fd6963 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java\n\n@@ -49,12 +49,10 @@ class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n         // Assert & Act\n         StepVerifier.create(sender.send(message).thenMany(receiver.receive().take(1)))\n             .assertNext(receivedMessage -> {\n-                Assertions.assertEquals(contents, receivedMessage.getBodyAsString());\n+                Assertions.assertEquals(contents, new String(receivedMessage.getBody()));\n                 Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n             })\n             .verifyComplete();\n-\n-        System.out.println(\"Completed.\");\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MzA0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392373042", "bodyText": "Do you have test when user do not want autoComplete and  want to call him self ?", "author": "hemanttanwar", "createdAt": "2020-03-13T17:33:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -155,14 +172,28 @@ public void close() {\n     /**\n      * Completes a {@link ServiceBusMessage} using its lock token. This will delete the message from the service.\n      *\n-     * @param message to be used.\n+     * @param message Message to be completed.\n      *\n      * @return The {@link Mono} the finishes this operation on service bus resource.\n      */\n     public Mono<Void> complete(ServiceBusReceivedMessage message) {", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NjE3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392376171", "bodyText": "I'll add that.", "author": "conniey", "createdAt": "2020-03-13T17:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MzA0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\nindex cde818de5c..4cfa9d89e5 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n\n@@ -143,30 +148,28 @@ public final class ServiceBusReceiverAsyncClient implements Closeable {\n     }\n \n     /**\n-     * Abandon {@link ServiceBusMessage} with lock token and updated message property. This will make the message\n-     * available again for processing. Abandoning a message will increase the delivery count on the message.\n+     * Abandon {@link ServiceBusMessage} with lock token. This will make the message available again for processing.\n+     * Abandoning a message will increase the delivery count on the message.\n      *\n      * @param message to be used.\n-     * @param propertiesToModify Message properties to modify.\n      *\n      * @return The {@link Mono} the finishes this operation on service bus resource.\n      */\n-    public Mono<Void> abandon(ServiceBusReceivedMessage message, Map<String, Object> propertiesToModify) {\n-        //TODO(feature-to-implement)\n-        return null;\n+    public Mono<Void> abandon(ServiceBusReceivedMessage message) {\n+        return abandon(message, null);\n     }\n \n     /**\n-     * Abandon {@link ServiceBusMessage} with lock token. This will make the message available again for processing.\n-     * Abandoning a message will increase the delivery count on the message.\n+     * Abandon {@link ServiceBusMessage} with lock token and updated message property. This will make the message\n+     * available again for processing. Abandoning a message will increase the delivery count on the message.\n      *\n      * @param message to be used.\n+     * @param propertiesToModify Message properties to modify.\n      *\n      * @return The {@link Mono} the finishes this operation on service bus resource.\n      */\n-    public Mono<Void> abandon(ServiceBusReceivedMessage message) {\n-        //TODO(feature-to-implement)\n-        return null;\n+    public Mono<Void> abandon(ServiceBusReceivedMessage message, Map<String, Object> propertiesToModify) {\n+        return updateDisposition(message, DispositionStatus.ABANDONED, null, null, propertiesToModify);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MjY0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392372640", "bodyText": "Would we expect anyone to modify the return list? I believe Collections.singletonList returns an immutable list.", "author": "alzimmermsft", "createdAt": "2020-03-13T17:32:16Z", "path": "sdk/eventhubs/azure-messaging-eventhubs/src/main/java/com/azure/messaging/eventhubs/EventHubMessageSerializer.java", "diffHunk": "@@ -134,6 +136,11 @@ public int getSize(Message amqpMessage) {\n         }\n     }\n \n+    @Override\n+    public <T> List<T> deserializeList(Message message, Class<T> clazz) {\n+        return Collections.singletonList(deserialize(message, clazz));", "originalCommit": "c423e9c45ce0ee8e0eb4d3c7cc954ce8c7cf03c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQxNzcyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392417720", "bodyText": "Does this need to return a Boolean? It doesn't appear to be used by the caller, we just default into a then.", "author": "alzimmermsft", "createdAt": "2020-03-13T19:04:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -323,6 +354,65 @@ public Instant renewMessageLock(ServiceBusReceivedMessage message) {\n         return null;\n     }\n \n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        final ArrayList<String> keys = new ArrayList<>(openConsumers.keySet());\n+        for (String key : keys) {\n+            removeLink(key, SignalType.ON_COMPLETE);\n+        }\n+\n+        connectionProcessor.dispose();\n+    }\n+\n+    private Mono<Boolean> isLockTokenValid(UUID lockToken) {", "originalCommit": "f7b5d77f1a20bfbdc89ac9f725f1d8625f917e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2MTQzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r393061432", "bodyText": "Oh yes. Thanks for pointing that out. If it is false, it should just return.", "author": "conniey", "createdAt": "2020-03-16T14:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQxNzcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\nindex cde818de5c..4cfa9d89e5 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n\n@@ -390,11 +372,43 @@ public final class ServiceBusReceiverAsyncClient implements Closeable {\n         return Mono.just(true);\n     }\n \n+    private Mono<Void> updateDisposition(ServiceBusReceivedMessage message, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        if (message == null) {\n+            return Mono.error(new NullPointerException(\"'message' cannot be null.\"));\n+        }\n+\n+        if (receiveMode != ReceiveMode.PEEK_LOCK) {\n+            return Mono.error(logger.logExceptionAsError(new UnsupportedOperationException(String.format(\n+                \"'%s' is not supported on a receiver opened in ReceiveMode.RECEIVE_AND_DELETE.\", dispositionStatus))));\n+        } else if (message.getLockToken() == null) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'message.getLockToken()' cannot be null.\")));\n+        }\n+\n+        logger.info(\"{}: Completing message. Sequence number: {}. Lock: {}. Expiration: {}\", entityPath,\n+            message.getSequenceNumber(), message.getLockToken(), lockTokenExpirationMap.get(message.getLockToken()));\n+\n+        return isLockTokenValid(message.getLockToken()).flatMap(isLocked -> {\n+            return connectionProcessor.flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+                .flatMap(node -> {\n+                    if (isLocked) {\n+                        return node.updateDisposition(message.getLockToken(), dispositionStatus,\n+                            deadLetterReason, deadLetterErrorDescription, propertiesToModify);\n+                    } else {\n+                        //TODO (conniey): in Track 1, I believe there was a way to do this.\n+                        return Mono.error(\n+                            new UnsupportedOperationException(\"Cannot complete a message that is not locked.\"));\n+                    }\n+                });\n+        }).then(Mono.fromRunnable(() -> lockTokenExpirationMap.remove(message.getLockToken())));\n+    }\n+\n     private ServiceBusAsyncConsumer getOrCreateConsumer(String linkName) {\n         return openConsumers.computeIfAbsent(linkName, name -> {\n             logger.info(\"{}: Creating consumer for link '{}'\", entityPath, linkName);\n \n-            final Flux<AmqpReceiveLink> receiveLinkMono =\n+            final Flux<AmqpReceiveLink> receiveLink =\n                 connectionProcessor.flatMap(connection -> connection.createReceiveLink(linkName, entityPath,\n                     receiveMode, isSessionEnabled, null, entityType))\n                     .doOnNext(next -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQxODEzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392418132", "bodyText": "Interesting that this returns false instead of throwing an exception and that the lock token being invalid throws an exception.", "author": "alzimmermsft", "createdAt": "2020-03-13T19:05:34Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -323,6 +354,65 @@ public Instant renewMessageLock(ServiceBusReceivedMessage message) {\n         return null;\n     }\n \n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        final ArrayList<String> keys = new ArrayList<>(openConsumers.keySet());\n+        for (String key : keys) {\n+            removeLink(key, SignalType.ON_COMPLETE);\n+        }\n+\n+        connectionProcessor.dispose();\n+    }\n+\n+    private Mono<Boolean> isLockTokenValid(UUID lockToken) {\n+        final Instant lockedUntilUtc = lockTokenExpirationMap.get(lockToken);\n+        if (lockedUntilUtc == null) {\n+            logger.warning(\"lockToken[{}] is not owned by this receiver.\", lockToken);\n+            return Mono.just(false);\n+        }", "originalCommit": "f7b5d77f1a20bfbdc89ac9f725f1d8625f917e94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\nindex cde818de5c..4cfa9d89e5 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n\n@@ -390,11 +372,43 @@ public final class ServiceBusReceiverAsyncClient implements Closeable {\n         return Mono.just(true);\n     }\n \n+    private Mono<Void> updateDisposition(ServiceBusReceivedMessage message, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        if (message == null) {\n+            return Mono.error(new NullPointerException(\"'message' cannot be null.\"));\n+        }\n+\n+        if (receiveMode != ReceiveMode.PEEK_LOCK) {\n+            return Mono.error(logger.logExceptionAsError(new UnsupportedOperationException(String.format(\n+                \"'%s' is not supported on a receiver opened in ReceiveMode.RECEIVE_AND_DELETE.\", dispositionStatus))));\n+        } else if (message.getLockToken() == null) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'message.getLockToken()' cannot be null.\")));\n+        }\n+\n+        logger.info(\"{}: Completing message. Sequence number: {}. Lock: {}. Expiration: {}\", entityPath,\n+            message.getSequenceNumber(), message.getLockToken(), lockTokenExpirationMap.get(message.getLockToken()));\n+\n+        return isLockTokenValid(message.getLockToken()).flatMap(isLocked -> {\n+            return connectionProcessor.flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+                .flatMap(node -> {\n+                    if (isLocked) {\n+                        return node.updateDisposition(message.getLockToken(), dispositionStatus,\n+                            deadLetterReason, deadLetterErrorDescription, propertiesToModify);\n+                    } else {\n+                        //TODO (conniey): in Track 1, I believe there was a way to do this.\n+                        return Mono.error(\n+                            new UnsupportedOperationException(\"Cannot complete a message that is not locked.\"));\n+                    }\n+                });\n+        }).then(Mono.fromRunnable(() -> lockTokenExpirationMap.remove(message.getLockToken())));\n+    }\n+\n     private ServiceBusAsyncConsumer getOrCreateConsumer(String linkName) {\n         return openConsumers.computeIfAbsent(linkName, name -> {\n             logger.info(\"{}: Creating consumer for link '{}'\", entityPath, linkName);\n \n-            final Flux<AmqpReceiveLink> receiveLinkMono =\n+            final Flux<AmqpReceiveLink> receiveLink =\n                 connectionProcessor.flatMap(connection -> connection.createReceiveLink(linkName, entityPath,\n                     receiveMode, isSessionEnabled, null, entityType))\n                     .doOnNext(next -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyMTA2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9051#discussion_r392421063", "bodyText": "Any reason this is called Mono when it is a Flux?", "author": "alzimmermsft", "createdAt": "2020-03-13T19:12:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -323,6 +354,65 @@ public Instant renewMessageLock(ServiceBusReceivedMessage message) {\n         return null;\n     }\n \n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+\n+        final ArrayList<String> keys = new ArrayList<>(openConsumers.keySet());\n+        for (String key : keys) {\n+            removeLink(key, SignalType.ON_COMPLETE);\n+        }\n+\n+        connectionProcessor.dispose();\n+    }\n+\n+    private Mono<Boolean> isLockTokenValid(UUID lockToken) {\n+        final Instant lockedUntilUtc = lockTokenExpirationMap.get(lockToken);\n+        if (lockedUntilUtc == null) {\n+            logger.warning(\"lockToken[{}] is not owned by this receiver.\", lockToken);\n+            return Mono.just(false);\n+        }\n+\n+        //TODO (conniey): This check is done locally in Track 1. It's possible there is server skew.\n+        // who knows how reliable this is.\n+        final Instant now = Instant.now();\n+        if (lockedUntilUtc.isBefore(now)) {\n+            return Mono.error(logger.logExceptionAsError(new AmqpException(false, String.format(\n+                \"Lock already expired for the lock token. Expiration: '%s'. Now: '%s'\", lockedUntilUtc, now),\n+                getErrorContext())));\n+        }\n+\n+        return Mono.just(true);\n+    }\n+\n+    private ServiceBusAsyncConsumer getOrCreateConsumer(String linkName) {\n+        return openConsumers.computeIfAbsent(linkName, name -> {\n+            logger.info(\"{}: Creating consumer for link '{}'\", entityPath, linkName);\n+\n+            final Flux<AmqpReceiveLink> receiveLinkMono =", "originalCommit": "f7b5d77f1a20bfbdc89ac9f725f1d8625f917e94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "chunk": "diff --git a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\nindex cde818de5c..4cfa9d89e5 100644\n--- a/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n+++ b/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java\n\n@@ -390,11 +372,43 @@ public final class ServiceBusReceiverAsyncClient implements Closeable {\n         return Mono.just(true);\n     }\n \n+    private Mono<Void> updateDisposition(ServiceBusReceivedMessage message, DispositionStatus dispositionStatus,\n+        String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        if (message == null) {\n+            return Mono.error(new NullPointerException(\"'message' cannot be null.\"));\n+        }\n+\n+        if (receiveMode != ReceiveMode.PEEK_LOCK) {\n+            return Mono.error(logger.logExceptionAsError(new UnsupportedOperationException(String.format(\n+                \"'%s' is not supported on a receiver opened in ReceiveMode.RECEIVE_AND_DELETE.\", dispositionStatus))));\n+        } else if (message.getLockToken() == null) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'message.getLockToken()' cannot be null.\")));\n+        }\n+\n+        logger.info(\"{}: Completing message. Sequence number: {}. Lock: {}. Expiration: {}\", entityPath,\n+            message.getSequenceNumber(), message.getLockToken(), lockTokenExpirationMap.get(message.getLockToken()));\n+\n+        return isLockTokenValid(message.getLockToken()).flatMap(isLocked -> {\n+            return connectionProcessor.flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+                .flatMap(node -> {\n+                    if (isLocked) {\n+                        return node.updateDisposition(message.getLockToken(), dispositionStatus,\n+                            deadLetterReason, deadLetterErrorDescription, propertiesToModify);\n+                    } else {\n+                        //TODO (conniey): in Track 1, I believe there was a way to do this.\n+                        return Mono.error(\n+                            new UnsupportedOperationException(\"Cannot complete a message that is not locked.\"));\n+                    }\n+                });\n+        }).then(Mono.fromRunnable(() -> lockTokenExpirationMap.remove(message.getLockToken())));\n+    }\n+\n     private ServiceBusAsyncConsumer getOrCreateConsumer(String linkName) {\n         return openConsumers.computeIfAbsent(linkName, name -> {\n             logger.info(\"{}: Creating consumer for link '{}'\", entityPath, linkName);\n \n-            final Flux<AmqpReceiveLink> receiveLinkMono =\n+            final Flux<AmqpReceiveLink> receiveLink =\n                 connectionProcessor.flatMap(connection -> connection.createReceiveLink(linkName, entityPath,\n                     receiveMode, isSessionEnabled, null, entityType))\n                     .doOnNext(next -> {\n"}}, {"oid": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a77448c046c675b13d0c4bdaaca53fc962a7f82", "message": "Not tying a connection to a single entityPath. (This is specific to Event Hubs.)Not tying a connection to a single entitytPath. (This is specific to Event Hubs.)\n\nUpdate Interface to accept multiple messaging entities.\n\nAdd reactor receiver for service bus.\n\nAdd serialization for list.\n\nAdding MessageWithLockToken\n\nMove deserialization and publish logic to elastic.\n\nAdd implementation for other settlement statuses.", "committedDate": "2020-03-16T20:43:04Z", "type": "commit"}, {"oid": "9a77448c046c675b13d0c4bdaaca53fc962a7f82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a77448c046c675b13d0c4bdaaca53fc962a7f82", "message": "Not tying a connection to a single entityPath. (This is specific to Event Hubs.)Not tying a connection to a single entitytPath. (This is specific to Event Hubs.)\n\nUpdate Interface to accept multiple messaging entities.\n\nAdd reactor receiver for service bus.\n\nAdd serialization for list.\n\nAdding MessageWithLockToken\n\nMove deserialization and publish logic to elastic.\n\nAdd implementation for other settlement statuses.", "committedDate": "2020-03-16T20:43:04Z", "type": "forcePushed"}]}