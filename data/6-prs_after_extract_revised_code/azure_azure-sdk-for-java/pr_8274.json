{"pr_number": 8274, "pr_title": "Add Missing Tests and Remove Exists APIs", "pr_createdAt": "2020-02-18T19:50:52Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8274", "timeline": [{"oid": "285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "message": "Add missing tests", "committedDate": "2020-02-13T18:29:18Z", "type": "commit"}, {"oid": "8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-13T23:01:42Z", "type": "commit"}, {"oid": "ac7af017686088ba00c6189f13271095583cff37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ac7af017686088ba00c6189f13271095583cff37", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-14T00:12:57Z", "type": "commit"}, {"oid": "796248e8c1e8f2d871881f11774628e0f62b60ff", "url": "https://github.com/Azure/azure-sdk-for-java/commit/796248e8c1e8f2d871881f11774628e0f62b60ff", "message": "Merged in master", "committedDate": "2020-02-14T00:13:26Z", "type": "commit"}, {"oid": "b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-14T17:41:00Z", "type": "commit"}, {"oid": "c154b788235d1e9b97042b4ceaceba78103634b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c154b788235d1e9b97042b4ceaceba78103634b4", "message": "General code style refactoring and test cleanup", "committedDate": "2020-02-14T23:54:06Z", "type": "commit"}, {"oid": "868711366e20679c32de29bce9c550758c3fb16e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/868711366e20679c32de29bce9c550758c3fb16e", "message": "Removing more JUnit 4 code and use Java Base64.encodeToString", "committedDate": "2020-02-18T19:48:45Z", "type": "commit"}, {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "message": "Removed Apache Commons code from tests", "committedDate": "2020-02-18T21:35:51Z", "type": "commit"}, {"oid": "f9e9708e4024e0bd38b96df5e5d4b21761463442", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9e9708e4024e0bd38b96df5e5d4b21761463442", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-19T17:36:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381486500", "bodyText": "If you're planning to delete the async tests and inline the base classes into the sync tests, why not do that first? It would make changes like this much easier to make (and to review \ud83d\ude09).", "author": "brjohnstmsft", "createdAt": "2020-02-19T19:12:58Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/SearchTestBase.java", "diffHunk": "@@ -32,6 +31,10 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4NjU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381586544", "bodyText": "I'll delete all the async tests and the base test classes in the next commit \ud83d\ude04", "author": "alzimmermsft", "createdAt": "2020-02-19T22:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNjIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382306218", "bodyText": "Removed most async and base class combinations, I'll hold off on removing the rest for another PR since the few that are left contain more technical details I don't want to handle in this PR.", "author": "alzimmermsft", "createdAt": "2020-02-20T22:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381515764", "bodyText": "Does this encode to a URL-safe variant of Base64? Document keys can be used in URL paths, so certain characters used in vanilla Base64 are not allowed.", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:08:05Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);\n+\n+        StepVerifier.create(client.index(batch))\n+            .expectNextCount(1)\n+            .verifyComplete();\n+\n+        // Select only the fields set in the test case so we don't get superfluous data back.\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", new ArrayList<>(indexedDoc.keySet()), null))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void canGetDocumentWithBase64EncodedKey() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        String complexKey = Base64.getEncoder().encodeToString(new byte[]{1, 2, 3, 4, 5});", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4ODc4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381588787", "bodyText": "Appears that I need to use Base64.getUrlEncoder, that will be URL safe \ud83d\ude04\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Base64.html#getUrlEncoder--", "author": "alzimmermsft", "createdAt": "2020-02-19T22:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MDI1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381590257", "bodyText": "If the URL encoded characters of + and / are expected on the service side this could be wrapped in a called to URLEncode instead.", "author": "alzimmermsft", "createdAt": "2020-02-19T22:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NTcxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381595713", "bodyText": "The service doesn't interpret or try to decode the document key (at least not in this API). It's just that the client needs to construct a valid URL that the service will understand.", "author": "brjohnstmsft", "createdAt": "2020-02-19T22:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java b/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java\ndeleted file mode 100644\nindex 19a69fb6268..00000000000\n--- a/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java\n+++ /dev/null\n\n@@ -1,446 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-package com.azure.search;\n-\n-import com.azure.search.models.GeoPoint;\n-import com.azure.search.models.IndexBatch;\n-import com.azure.search.test.environment.models.Hotel;\n-import com.azure.search.test.environment.models.HotelAddress;\n-import com.azure.search.test.environment.models.HotelRoom;\n-import com.azure.search.test.environment.models.ModelWithPrimitiveCollections;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Base64;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static java.lang.Double.NEGATIVE_INFINITY;\n-import static java.lang.Double.NaN;\n-import static java.lang.Double.POSITIVE_INFINITY;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class LookupAsyncTests extends LookupTestBase {\n-    private SearchIndexAsyncClient client;\n-\n-    @Test\n-    public void canGetStaticallyTypedDocument() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = prepareExpectedHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetStaticallyTypedDocumentWithNullOrEmptyValues() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = prepareEmptyHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetStaticallyTypedDocumentWithPascalCaseFields() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = preparePascalCaseFieldsHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canRoundtripStaticallyTypedPrimitiveCollections() {\n-        String indexName = setupIndexWithDataTypes();\n-\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-        ModelWithPrimitiveCollections expected = preparePrimitivesModel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.key()))\n-            .assertNext(res -> TestHelpers.assetModelsWithPrimitivesEqual(expected, convertToType(res, ModelWithPrimitiveCollections.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void getStaticallyTypedDocumentSetsUnselectedFieldsToNull() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel indexedDoc = prepareSelectedFieldsHotel();\n-\n-        Hotel expected = new Hotel()\n-            .hotelName(\"Countryside Hotel\")\n-            .description(\n-                \"Save up to 50% off traditional hotels.  Free WiFi, great location near downtown, full kitchen, \"\n-                    + \"washer & dryer, 24/7 support, bowling alley, fitness center and more.\")\n-            .address(new HotelAddress().city(\"Durham\"))\n-            .rooms(Arrays.asList(new HotelRoom().baseRate(2.44), new HotelRoom().baseRate(7.69)));\n-\n-        uploadDocument(client, indexedDoc);\n-\n-        List<String> selectedFields = Arrays.asList(\"Description\", \"HotelName\", \"Address/City\", \"Rooms/BaseRate\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(indexedDoc.hotelId(), selectedFields, generateRequestOptions()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetDynamicDocumentWithNullOrEmptyValues() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        Document room = new Document();\n-        room.put(\"BaseRate\", null);\n-        room.put(\"BedOptions\", null);\n-        room.put(\"SleepsCount\", null);\n-        room.put(\"SmokingAllowed\", null);\n-        room.put(\"Tags\", new ArrayList<>());\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"HotelName\", null);\n-        expectedDoc.put(\"Tags\", new ArrayList<>());\n-        expectedDoc.put(\"ParkingIncluded\", null);\n-        expectedDoc.put(\"LastRenovationDate\", null);\n-        expectedDoc.put(\"Rating\", null);\n-        expectedDoc.put(\"Location\", null);\n-        expectedDoc.put(\"Address\", null);\n-        expectedDoc.put(\"Rooms\", Collections.singleton(room));\n-\n-        uploadDocument(client, expectedDoc);\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"HotelName\", \"Tags\", \"ParkingIncluded\", \"LastRenovationDate\", \"Rating\", \"Location\", \"Address\", \"Rooms/BaseRate\", \"Rooms/BedOptions\", \"Rooms/SleepsCount\", \"Rooms/SmokingAllowed\", \"Rooms/Tags\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void getDynamicDocumentWithEmptyObjectsReturnsObjectsFullOfNulls() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Address\", new Document());\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Address\", new Document() {\n-                    {\n-                        put(\"StreetAddress\", null);\n-                        put(\"City\", null);\n-                        put(\"StateProvince\", null);\n-                        put(\"Country\", null);\n-                        put(\"PostalCode\", null);\n-                    }\n-                });\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Address\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicallyTypedPrimitiveCollectionsRoundtripAsObjectArrays() {\n-        String indexName = setupIndexWithDataTypes();\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-\n-        String docKey = \"3\";\n-\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Dates\", new Object[]{});\n-                put(\"Doubles\", new Double[]{});\n-                put(\"Bools\", new boolean[]{});\n-                put(\"Longs\", new Long[]{});\n-                put(\"Strings\", new String[]{});\n-                put(\"Ints\", new int[]{});\n-                put(\"Points\", new Object[]{});\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Doubles\", Collections.emptyList());\n-                put(\"Bools\", Collections.emptyList());\n-                put(\"Longs\", Collections.emptyList());\n-                put(\"Strings\", Collections.emptyList());\n-                put(\"Ints\", Collections.emptyList());\n-                put(\"Points\", Collections.emptyList());\n-                put(\"Dates\", Collections.emptyList());\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-\n-        StepVerifier.create(client.getDocument(docKey))\n-            .assertNext(actualDoc -> assertEquals(expectedDoc, actualDoc))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelected() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document(),\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document() {\n-                        {\n-                            put(\"Description\", null);\n-                            put(\"Description_fr\", null);\n-                            put(\"Type\", null);\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    },\n-                    new Document() {\n-                        {\n-                            put(\"Description\", null);\n-                            put(\"Description_fr\", null);\n-                            put(\"Type\", null);\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        List<Document> rooms = new ArrayList<>();\n-        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n-\n-        Document indexedDoc = new Document();\n-        indexedDoc.put(\"HotelId\", \"1\");\n-        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n-        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n-        indexedDoc.put(\"Rooms\", rooms);\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n-        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n-        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(expectedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", new ArrayList<>(indexedDoc.keySet()), null))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void canGetDocumentWithBase64EncodedKey() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        String complexKey = Base64.getEncoder().encodeToString(new byte[]{1, 2, 3, 4, 5});\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", complexKey);\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(expectedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        StepVerifier.create(client.getDocumentWithResponse(complexKey, new ArrayList<>(expectedDoc.keySet()), null))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void roundTrippingDateTimeOffsetNormalizesToUtc() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-\n-        Document indexedDoc = new Document();\n-        indexedDoc.put(\"HotelId\", \"1\");\n-        indexedDoc.put(\"LastRenovationDate\", dateFormat.parse(\"2010-06-27T00:00:00-08:00\"));\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"LastRenovationDate\", dateFormat.parse(\"2010-06-27T08:00:00Z\"));\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(indexedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        StepVerifier.create(client.getDocument(\"1\"))\n-            .assertNext(actualDoc -> assertEquals(actualDoc, expectedDoc))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicObjectsOmittedFromCollectionOnGetWhenSubFieldsSelected() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document(),\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Collections.singletonList(\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms/BaseRate\", \"Rooms/BedOptions\", \"Rooms/SleepsCount\", \"Rooms/SmokingAllowed\", \"Rooms/Tags\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void dynamicallyTypedPrimitiveCollectionsDoNotAllRoundtripCorrectly() {\n-        String indexName = setupIndexWithDataTypes();\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-\n-        String docKey = \"1\";\n-        OffsetDateTime dateTime = OffsetDateTime.parse(\"2019-08-13T14:30:00Z\");\n-        GeoPoint geoPoint = GeoPoint.create(1.0, 100.0);\n-\n-        Document indexedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Dates\", new OffsetDateTime[]{dateTime});\n-                put(\"Doubles\", new Double[]{0.0, 5.8, POSITIVE_INFINITY, NEGATIVE_INFINITY, NaN});\n-                put(\"Bools\", new Boolean[]{true, false});\n-                put(\"Longs\", new Long[]{9999999999999999L, 832372345832523L});\n-                put(\"Strings\", new String[]{\"hello\", \"bye\"});\n-                put(\"Ints\", new int[]{1, 2, 3, 4, -13, 5, 0});\n-                put(\"Points\", new GeoPoint[]{geoPoint});\n-            }\n-        };\n-\n-        // This is the expected document when querying the document later\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Doubles\", Arrays.asList(0.0, 5.8, \"INF\", \"-INF\", \"NaN\"));\n-                put(\"Bools\", Arrays.asList(true, false));\n-                put(\"Longs\", Arrays.asList(9999999999999999L, 832372345832523L));\n-                put(\"Strings\", Arrays.asList(\"hello\", \"bye\"));\n-                put(\"Ints\", Arrays.asList(1, 2, 3, 4, -13, 5, 0));\n-                put(\"Points\", Collections.singletonList(geoPoint));\n-                put(\"Dates\", Collections.singletonList(dateTime));\n-            }\n-        };\n-\n-        uploadDocument(client, indexedDoc);\n-\n-        StepVerifier.create(client.getDocument(docKey))\n-            .assertNext(actualDoc -> assertEquals(expectedDoc, actualDoc))\n-            .verifyComplete();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381533229", "bodyText": "Changing the casing of these fields/accessors is moving this class further away from its intended purpose (not that it ever properly fulfilled its purpose in the Java tests).\nIn the Track 1 .NET SDK, LoudHotel is used to test scenarios where a customer has implemented their own custom attributes that they use to control how model property names serialize/deserialize to index field names. For LoudHotel specifically, the corresponding index definition has camelCase field names, while LoudHotel has ALLCAPS property names.\nIf I understand correctly, @JsonProperty is part of a JSON library for Java and not something a customer would implement themselves, so this class isn't really fulfilling its intended purpose anyway. Are customer-authored attributes a thing when it comes to Java serialization (@JonathanGiles )? If not, we need to rethink this class.\nIf we keep this class though, the accessor/field names should be ALLCAPS or it isn't really \"loud\" anymore, is it? \ud83d\ude01", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:44:09Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java", "diffHunk": "@@ -12,166 +12,166 @@\n \n public class LoudHotel {\n     @JsonProperty(value = \"HotelId\")\n-    private String HOTELID;\n+    private String hotelId;", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MjU5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381592594", "bodyText": "In tests using LoudHotel the response JSON would be something like the following?\n{\n  \"HOTELID\": \"id\",\n}\nI was changing this to follow Java code style guidelines where camel casing is expected and we have linting rules that fail build if they aren't followed. I will revert these changes and add a suppression on this file.", "author": "alzimmermsft", "createdAt": "2020-02-19T22:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDIzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381594234", "bodyText": "No, the JSON is expected to have camelCase property names (at least, it is in .NET -- looks like the Java tests were setup for PascalCase instead).", "author": "brjohnstmsft", "createdAt": "2020-02-19T22:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzNTMyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382835328", "bodyText": "Reverting the changes made to this class and will add a linting suppression to this class", "author": "alzimmermsft", "createdAt": "2020-02-21T22:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "38b0626ed58b923f68a206b5857b2318e4a41db0", "chunk": "diff --git a/sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java b/sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java\nindex af5057b26aa..d4ed58f1e2d 100644\n--- a/sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java\n+++ b/sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java\n\n@@ -12,166 +12,166 @@ import java.util.List;\n \n public class LoudHotel {\n     @JsonProperty(value = \"HotelId\")\n-    private String hotelId;\n+    private String HOTELID;\n \n     @JsonProperty(value = \"HotelName\")\n-    private String hotelName;\n+    private String HOTELNAME;\n \n     @JsonProperty(value = \"Description\")\n     @JsonInclude(JsonInclude.Include.ALWAYS)\n-    private String description;\n+    private String DESCRIPTION;\n \n     @JsonProperty(value = \"Description_fr\")\n-    private String descriptionFrench;\n+    private String DESCRIPTIONFRENCH;\n \n     @JsonProperty(value = \"Category\")\n-    private String category;\n+    private String CATEGORY;\n \n     @JsonProperty(value = \"Tags\")\n-    private List<String> tags;\n+    private List<String> TAGS;\n \n     @JsonProperty(value = \"ParkingIncluded\")\n-    private Boolean parkingIncluded;\n+    private Boolean PARKINGINCLUDED;\n \n     @JsonProperty(value = \"SmokingAllowed\")\n-    private Boolean smokingAllowed;\n+    private Boolean SMOKINGALLOWED;\n \n     @JsonProperty(value = \"LastRenovationDate\")\n-    private Date lastRenovationDate;\n+    private Date LASTRENOVATIONDATE;\n \n     @JsonProperty(value = \"Rating\")\n-    private Integer rating;\n+    private Integer RATING;\n \n     @JsonProperty(value = \"Location\")\n     @JsonInclude(JsonInclude.Include.ALWAYS)\n-    private GeoPoint location;\n+    private GeoPoint LOCATION;\n \n     @JsonProperty(value = \"Address\")\n-    private HotelAddress address;\n+    private HotelAddress ADDRESS;\n \n     @JsonProperty(value = \"Rooms\")\n-    private List<HotelRoom> rooms;\n+    private List<HotelRoom> ROOMS;\n \n     public LoudHotel() {\n-        this.tags = new ArrayList<>();\n-        this.rooms = new ArrayList<>();\n+        this.TAGS = new ArrayList<>();\n+        this.ROOMS = new ArrayList<>();\n     }\n \n-    public String hotelId() {\n-        return this.hotelId;\n+    public String HOTELID() {\n+        return this.HOTELID;\n     }\n \n-    public LoudHotel hotelId(String hotelId) {\n-        this.hotelId = hotelId;\n+    public LoudHotel HOTELID(String hotelId) {\n+        this.HOTELID = hotelId;\n         return this;\n     }\n \n-    public String hotelName() {\n-        return this.hotelName;\n+    public String HOTELNAME() {\n+        return this.HOTELNAME;\n     }\n \n-    public LoudHotel hotelName(String hotelName) {\n-        this.hotelName = hotelName;\n+    public LoudHotel HOTELNAME(String hotelName) {\n+        this.HOTELNAME = hotelName;\n         return this;\n     }\n \n-    public String description() {\n-        return this.description;\n+    public String DESCRIPTION() {\n+        return this.DESCRIPTION;\n     }\n \n-    public LoudHotel description(String description) {\n-        this.description = description;\n+    public LoudHotel DESCRIPTION(String description) {\n+        this.DESCRIPTION = description;\n         return this;\n     }\n \n-    public String descriptionFrench() {\n-        return this.descriptionFrench;\n+    public String DESCRIPTIONFRENCH() {\n+        return this.DESCRIPTIONFRENCH;\n     }\n \n-    public LoudHotel descriptionFrench(String descriptionFr) {\n-        this.descriptionFrench = descriptionFr;\n+    public LoudHotel DESCRIPTIONFRENCH(String descriptionFr) {\n+        this.DESCRIPTIONFRENCH = descriptionFr;\n         return this;\n     }\n \n-    public String category() {\n-        return this.category;\n+    public String CATEGORY() {\n+        return this.CATEGORY;\n     }\n \n-    public LoudHotel category(String category) {\n-        this.category = category;\n+    public LoudHotel CATEGORY(String category) {\n+        this.CATEGORY = category;\n         return this;\n     }\n \n-    public List<String> tags() {\n-        return this.tags;\n+    public List<String> TAGS() {\n+        return this.TAGS;\n     }\n \n-    public LoudHotel tags(List<String> tags) {\n-        this.tags = tags;\n+    public LoudHotel TAGS(List<String> tags) {\n+        this.TAGS = tags;\n         return this;\n     }\n \n \n-    public Boolean parkingIncluded() {\n-        return this.parkingIncluded;\n+    public Boolean PARKINGINCLUDED() {\n+        return this.PARKINGINCLUDED;\n     }\n \n-    public LoudHotel parkingIncluded(Boolean parkingIncluded) {\n-        this.parkingIncluded = parkingIncluded;\n+    public LoudHotel PARKINGINCLUDED(Boolean parkingIncluded) {\n+        this.PARKINGINCLUDED = parkingIncluded;\n         return this;\n     }\n \n-    public Boolean smokingAllowed() {\n-        return this.smokingAllowed;\n+    public Boolean SMOKINGALLOWED() {\n+        return this.SMOKINGALLOWED;\n     }\n \n-    public LoudHotel smokingAllowed(Boolean smokingAllowed) {\n-        this.smokingAllowed = smokingAllowed;\n+    public LoudHotel SMOKINGALLOWED(Boolean smokingAllowed) {\n+        this.SMOKINGALLOWED = smokingAllowed;\n         return this;\n     }\n \n-    public Date lastRenovationDate() {\n-        return this.lastRenovationDate;\n+    public Date LASTRENOVATIONDATE() {\n+        return this.LASTRENOVATIONDATE;\n     }\n \n-    public LoudHotel lastRenovationDate(Date lastRenovationDate) {\n-        this.lastRenovationDate = lastRenovationDate;\n+    public LoudHotel LASTRENOVATIONDATE(Date lastRenovationDate) {\n+        this.LASTRENOVATIONDATE = lastRenovationDate;\n         return this;\n     }\n \n-    public Integer rating() {\n-        return this.rating;\n+    public Integer RATING() {\n+        return this.RATING;\n     }\n \n-    public LoudHotel rating(Integer rating) {\n-        this.rating = rating;\n+    public LoudHotel RATING(Integer rating) {\n+        this.RATING = rating;\n         return this;\n     }\n \n-    public GeoPoint location() {\n-        return this.location;\n+    public GeoPoint LOCATION() {\n+        return this.LOCATION;\n     }\n \n-    public LoudHotel location(GeoPoint location) {\n-        this.location = location;\n+    public LoudHotel LOCATION(GeoPoint location) {\n+        this.LOCATION = location;\n         return this;\n     }\n \n-    public HotelAddress address() {\n-        return this.address;\n+    public HotelAddress ADDRESS() {\n+        return this.ADDRESS;\n     }\n \n-    public LoudHotel address(HotelAddress address) {\n-        this.address = address;\n+    public LoudHotel ADDRESS(HotelAddress address) {\n+        this.ADDRESS = address;\n         return this;\n     }\n \n-    public List<HotelRoom> rooms() {\n-        return this.rooms;\n+    public List<HotelRoom> ROOMS() {\n+        return this.ROOMS;\n     }\n \n-    public LoudHotel rooms(List<HotelRoom> rooms) {\n-        this.rooms = rooms;\n+    public LoudHotel ROOMS(List<HotelRoom> rooms) {\n+        this.ROOMS = rooms;\n         return this;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzODIzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381538236", "bodyText": "Thank you very much for doing this. \ud83d\udc4d Good docs are so important!", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:54:38Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java b/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\nindex a09da55639b..cd6bdaed78d 100644\n--- a/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\n+++ b/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\n\n@@ -185,11 +185,11 @@ public class SearchIndexAsyncClient {\n      * Merges a collection of documents with existing documents in the target index.\n      * <p>\n      * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n-     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n-     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n-     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n-     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n-     * be of type {@code Integer} instead of {@code int}).\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381539190", "bodyText": "Missing the Javadoc tags used elsewhere in this file", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:56:21Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index. See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Exception IndexBatchException is thrown when some of the indexing actions failed, but other actions succeeded and", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MDgxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381590811", "bodyText": "Was planning to fix those, my IntelliJ started acting up and those dropped off my mind. Will be adding in a commit soon", "author": "alzimmermsft", "createdAt": "2020-02-19T22:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305864", "bodyText": "Updated other JavaDocs", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java b/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\nindex a09da55639b..cd6bdaed78d 100644\n--- a/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\n+++ b/sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java\n\n@@ -185,11 +185,11 @@ public class SearchIndexAsyncClient {\n      * Merges a collection of documents with existing documents in the target index.\n      * <p>\n      * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n-     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n-     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n-     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n-     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n-     * be of type {@code Integer} instead of {@code int}).\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381541244", "bodyText": "I'm assuming that Arrays.asList(null, null) is returning an ArrayList of Object, not String. This is fine (since this SDK has never shipped, there are no backcompat concerns), but the comment and name of the test no longer reflect reality.", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:00:18Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java", "diffHunk": "@@ -242,15 +243,55 @@ public void canReadComplexCollection() {\n         Assert.assertEquals(expectedDoc, actualDoc);\n     }\n \n+    @Test\n+    public void canReadArraysOfMixedTypes() {\n+        // Azure Cognitive Search won't return payloads like this; This test is only for pinning purposes.\n+        String json = \"{\\\"field\\\": [\\\"hello\\\", 123, 3.14, { \\\"type\\\": \\\"Point\\\", \\\"coordinates\\\": [-122.131577, 47.678581] }, { \\\"name\\\": \\\"Arthur\\\", \\\"quest\\\": null }] }\";\n+\n+        GeoPoint point = GeoPoint.create(47.678581, -122.131577);\n+        Document innerDoc = new Document();\n+        innerDoc.put(\"name\", \"Arthur\");\n+        innerDoc.put(\"quest\", null);\n+        List<Object> value = Arrays.asList(\"hello\", 123, 3.14, point, innerDoc);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", value);\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n     @Test\n     public void dateTimeStringsAreReadAsDateTime() {\n         String json = \"{\\\"field1\\\":\\\"\".concat(testDateString).concat(\"\\\",\\\"field2\\\" : [\\\"\").concat(testDateString).concat(\"\\\", \\\"\").concat(testDateString).concat(\"\\\"]}\");\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"field1\", testDate);\n-                put(\"field2\", Arrays.asList(testDate, testDate));\n-            }\n-        };\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field1\", testDate);\n+        expectedDoc.put(\"field2\", Arrays.asList(testDate, testDate));\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void emptyArraysReadAsObjectArrays() {\n+        String json = \"{ \\\"field\\\": [] }\";\n+\n+        // With no elements, we can't tell what type of collection it is, so we default to object.\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", new ArrayList<>());\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void arraysWithOnlyNullsReadAsStringArrays() {\n+        String json = \"{ \\\"field\\\": [null, null] }\";\n+\n+        // With only null elements, we can't tell what type of collection it is. For backward compatibility, we assume type string.", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzNjE1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382836151", "bodyText": "I'll update this to make sure it uses List<String>.", "author": "alzimmermsft", "createdAt": "2020-02-21T22:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java b/sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java\nindex 9dfbfa2cb38..d484b243115 100644\n--- a/sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java\n+++ b/sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java\n\n@@ -240,7 +241,7 @@ public class DocumentConverterTests {\n         };\n \n         Document actualDoc = deserialize(json);\n-        Assert.assertEquals(expectedDoc, actualDoc);\n+        assertEquals(expectedDoc, actualDoc);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381543476", "bodyText": "Looks like the bug from the Track 1 tests got ported over. This should be uploading indexedDoc, not expectedDoc.", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:04:48Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTY5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305696", "bodyText": "Removed this class", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java b/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java\ndeleted file mode 100644\nindex 19a69fb6268..00000000000\n--- a/sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java\n+++ /dev/null\n\n@@ -1,446 +0,0 @@\n-// Copyright (c) Microsoft Corporation. All rights reserved.\n-// Licensed under the MIT License.\n-package com.azure.search;\n-\n-import com.azure.search.models.GeoPoint;\n-import com.azure.search.models.IndexBatch;\n-import com.azure.search.test.environment.models.Hotel;\n-import com.azure.search.test.environment.models.HotelAddress;\n-import com.azure.search.test.environment.models.HotelRoom;\n-import com.azure.search.test.environment.models.ModelWithPrimitiveCollections;\n-import org.junit.jupiter.api.Test;\n-import reactor.test.StepVerifier;\n-\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneOffset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Base64;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static java.lang.Double.NEGATIVE_INFINITY;\n-import static java.lang.Double.NaN;\n-import static java.lang.Double.POSITIVE_INFINITY;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class LookupAsyncTests extends LookupTestBase {\n-    private SearchIndexAsyncClient client;\n-\n-    @Test\n-    public void canGetStaticallyTypedDocument() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = prepareExpectedHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetStaticallyTypedDocumentWithNullOrEmptyValues() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = prepareEmptyHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetStaticallyTypedDocumentWithPascalCaseFields() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel expected = preparePascalCaseFieldsHotel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.hotelId()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canRoundtripStaticallyTypedPrimitiveCollections() {\n-        String indexName = setupIndexWithDataTypes();\n-\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-        ModelWithPrimitiveCollections expected = preparePrimitivesModel();\n-        uploadDocument(client, expected);\n-\n-        StepVerifier.create(client.getDocument(expected.key()))\n-            .assertNext(res -> TestHelpers.assetModelsWithPrimitivesEqual(expected, convertToType(res, ModelWithPrimitiveCollections.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void getStaticallyTypedDocumentSetsUnselectedFieldsToNull() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Hotel indexedDoc = prepareSelectedFieldsHotel();\n-\n-        Hotel expected = new Hotel()\n-            .hotelName(\"Countryside Hotel\")\n-            .description(\n-                \"Save up to 50% off traditional hotels.  Free WiFi, great location near downtown, full kitchen, \"\n-                    + \"washer & dryer, 24/7 support, bowling alley, fitness center and more.\")\n-            .address(new HotelAddress().city(\"Durham\"))\n-            .rooms(Arrays.asList(new HotelRoom().baseRate(2.44), new HotelRoom().baseRate(7.69)));\n-\n-        uploadDocument(client, indexedDoc);\n-\n-        List<String> selectedFields = Arrays.asList(\"Description\", \"HotelName\", \"Address/City\", \"Rooms/BaseRate\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(indexedDoc.hotelId(), selectedFields, generateRequestOptions()))\n-            .assertNext(res -> TestHelpers.assertHotelsEqual(expected, convertToType(res, Hotel.class)))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void canGetDynamicDocumentWithNullOrEmptyValues() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        Document room = new Document();\n-        room.put(\"BaseRate\", null);\n-        room.put(\"BedOptions\", null);\n-        room.put(\"SleepsCount\", null);\n-        room.put(\"SmokingAllowed\", null);\n-        room.put(\"Tags\", new ArrayList<>());\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"HotelName\", null);\n-        expectedDoc.put(\"Tags\", new ArrayList<>());\n-        expectedDoc.put(\"ParkingIncluded\", null);\n-        expectedDoc.put(\"LastRenovationDate\", null);\n-        expectedDoc.put(\"Rating\", null);\n-        expectedDoc.put(\"Location\", null);\n-        expectedDoc.put(\"Address\", null);\n-        expectedDoc.put(\"Rooms\", Collections.singleton(room));\n-\n-        uploadDocument(client, expectedDoc);\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"HotelName\", \"Tags\", \"ParkingIncluded\", \"LastRenovationDate\", \"Rating\", \"Location\", \"Address\", \"Rooms/BaseRate\", \"Rooms/BedOptions\", \"Rooms/SleepsCount\", \"Rooms/SmokingAllowed\", \"Rooms/Tags\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void getDynamicDocumentWithEmptyObjectsReturnsObjectsFullOfNulls() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Address\", new Document());\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Address\", new Document() {\n-                    {\n-                        put(\"StreetAddress\", null);\n-                        put(\"City\", null);\n-                        put(\"StateProvince\", null);\n-                        put(\"Country\", null);\n-                        put(\"PostalCode\", null);\n-                    }\n-                });\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Address\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicallyTypedPrimitiveCollectionsRoundtripAsObjectArrays() {\n-        String indexName = setupIndexWithDataTypes();\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-\n-        String docKey = \"3\";\n-\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Dates\", new Object[]{});\n-                put(\"Doubles\", new Double[]{});\n-                put(\"Bools\", new boolean[]{});\n-                put(\"Longs\", new Long[]{});\n-                put(\"Strings\", new String[]{});\n-                put(\"Ints\", new int[]{});\n-                put(\"Points\", new Object[]{});\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Doubles\", Collections.emptyList());\n-                put(\"Bools\", Collections.emptyList());\n-                put(\"Longs\", Collections.emptyList());\n-                put(\"Strings\", Collections.emptyList());\n-                put(\"Ints\", Collections.emptyList());\n-                put(\"Points\", Collections.emptyList());\n-                put(\"Dates\", Collections.emptyList());\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-\n-        StepVerifier.create(client.getDocument(docKey))\n-            .assertNext(actualDoc -> assertEquals(expectedDoc, actualDoc))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelected() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document(),\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document() {\n-                        {\n-                            put(\"Description\", null);\n-                            put(\"Description_fr\", null);\n-                            put(\"Type\", null);\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    },\n-                    new Document() {\n-                        {\n-                            put(\"Description\", null);\n-                            put(\"Description_fr\", null);\n-                            put(\"Type\", null);\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        List<Document> rooms = new ArrayList<>();\n-        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n-\n-        Document indexedDoc = new Document();\n-        indexedDoc.put(\"HotelId\", \"1\");\n-        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n-        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n-        indexedDoc.put(\"Rooms\", rooms);\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n-        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n-        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(expectedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        // Select only the fields set in the test case so we don't get superfluous data back.\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", new ArrayList<>(indexedDoc.keySet()), null))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void canGetDocumentWithBase64EncodedKey() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        String complexKey = Base64.getEncoder().encodeToString(new byte[]{1, 2, 3, 4, 5});\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", complexKey);\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(expectedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        StepVerifier.create(client.getDocumentWithResponse(complexKey, new ArrayList<>(expectedDoc.keySet()), null))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Override\n-    public void roundTrippingDateTimeOffsetNormalizesToUtc() throws ParseException {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-\n-        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-\n-        Document indexedDoc = new Document();\n-        indexedDoc.put(\"HotelId\", \"1\");\n-        indexedDoc.put(\"LastRenovationDate\", dateFormat.parse(\"2010-06-27T00:00:00-08:00\"));\n-\n-        Document expectedDoc = new Document();\n-        expectedDoc.put(\"HotelId\", \"1\");\n-        expectedDoc.put(\"LastRenovationDate\", dateFormat.parse(\"2010-06-27T08:00:00Z\"));\n-\n-        IndexBatch<Document> batch = new IndexBatch<>();\n-        batch.addUploadAction(indexedDoc);\n-\n-        StepVerifier.create(client.index(batch))\n-            .expectNextCount(1)\n-            .verifyComplete();\n-\n-        StepVerifier.create(client.getDocument(\"1\"))\n-            .assertNext(actualDoc -> assertEquals(actualDoc, expectedDoc))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void emptyDynamicObjectsOmittedFromCollectionOnGetWhenSubFieldsSelected() {\n-        createHotelIndex();\n-        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n-        Document originalDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Arrays.asList(\n-                    new Document(),\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"HotelId\", \"1\");\n-                put(\"Rooms\", Collections.singletonList(\n-                    new Document() {\n-                        {\n-                            put(\"BaseRate\", null);\n-                            put(\"BedOptions\", null);\n-                            put(\"SleepsCount\", null);\n-                            put(\"SmokingAllowed\", null);\n-                            put(\"Tags\", Collections.emptyList());\n-                        }\n-                    }\n-                ));\n-            }\n-        };\n-\n-        uploadDocument(client, originalDoc);\n-        List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms/BaseRate\", \"Rooms/BedOptions\", \"Rooms/SleepsCount\", \"Rooms/SmokingAllowed\", \"Rooms/Tags\");\n-\n-        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n-            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n-            .verifyComplete();\n-    }\n-\n-    @Test\n-    public void dynamicallyTypedPrimitiveCollectionsDoNotAllRoundtripCorrectly() {\n-        String indexName = setupIndexWithDataTypes();\n-        client = getSearchIndexClientBuilder(indexName).buildAsyncClient();\n-\n-        String docKey = \"1\";\n-        OffsetDateTime dateTime = OffsetDateTime.parse(\"2019-08-13T14:30:00Z\");\n-        GeoPoint geoPoint = GeoPoint.create(1.0, 100.0);\n-\n-        Document indexedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Dates\", new OffsetDateTime[]{dateTime});\n-                put(\"Doubles\", new Double[]{0.0, 5.8, POSITIVE_INFINITY, NEGATIVE_INFINITY, NaN});\n-                put(\"Bools\", new Boolean[]{true, false});\n-                put(\"Longs\", new Long[]{9999999999999999L, 832372345832523L});\n-                put(\"Strings\", new String[]{\"hello\", \"bye\"});\n-                put(\"Ints\", new int[]{1, 2, 3, 4, -13, 5, 0});\n-                put(\"Points\", new GeoPoint[]{geoPoint});\n-            }\n-        };\n-\n-        // This is the expected document when querying the document later\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"Key\", docKey);\n-                put(\"Doubles\", Arrays.asList(0.0, 5.8, \"INF\", \"-INF\", \"NaN\"));\n-                put(\"Bools\", Arrays.asList(true, false));\n-                put(\"Longs\", Arrays.asList(9999999999999999L, 832372345832523L));\n-                put(\"Strings\", Arrays.asList(\"hello\", \"bye\"));\n-                put(\"Ints\", Arrays.asList(1, 2, 3, 4, -13, 5, 0));\n-                put(\"Points\", Collections.singletonList(geoPoint));\n-                put(\"Dates\", Collections.singletonList(dateTime));\n-            }\n-        };\n-\n-        uploadDocument(client, indexedDoc);\n-\n-        StepVerifier.create(client.getDocument(docKey))\n-            .assertNext(actualDoc -> assertEquals(expectedDoc, actualDoc))\n-            .verifyComplete();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381546214", "bodyText": "Should be uploading indexedDoc. I'm getting paranoid now that we've made this mistake in many places and copy-pasted. \ud83d\ude2c", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:10:28Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java", "diffHunk": "@@ -266,8 +273,67 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Document actualDoc = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        Assert.assertEquals(expectedDoc, actualDoc);\n+        Response<Document> response = client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions(), Context.NONE);\n+        assertEquals(expectedDoc, response.getValue());\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        client.index(new IndexBatch<>().addUploadAction(expectedDoc));", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTc4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305783", "bodyText": "Using indexDoc now", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "chunk": "diff --git a/sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java b/sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java\nindex a51f1d19d20..96954282ca4 100644\n--- a/sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java\n+++ b/sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java\n\n@@ -277,7 +281,7 @@ public class LookupSyncTests extends LookupTestBase {\n         assertEquals(expectedDoc, response.getValue());\n     }\n \n-    @Override\n+    @Test\n     public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n         createHotelIndex();\n         client = getSearchIndexClientBuilder(INDEX_NAME).buildClient();\n"}}, {"oid": "72d24da813dae886b61905cd2ad893e6e16472df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/72d24da813dae886b61905cd2ad893e6e16472df", "message": "Update Azure Core version to fix dependency conflicts", "committedDate": "2020-02-19T22:15:58Z", "type": "commit"}, {"oid": "1eecc5809988b825e5869b10b76736bc94c9d5ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1eecc5809988b825e5869b10b76736bc94c9d5ab", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-20T17:23:42Z", "type": "commit"}, {"oid": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51541a2f9d18712bffba2d5d452d469d09c1b1c4", "message": "Finished cleaning up client documentation and removed async test classes", "committedDate": "2020-02-20T21:56:47Z", "type": "commit"}, {"oid": "435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "message": "Fixed Java 8 issues and update to use recording framework tools", "committedDate": "2020-02-20T22:39:27Z", "type": "commit"}, {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "url": "https://github.com/Azure/azure-sdk-for-java/commit/04e612bfb79a7f2fe687e7eda3c3457707f8d066", "message": "Fix another Java 8 issue", "committedDate": "2020-02-20T23:06:16Z", "type": "commit"}, {"oid": "fe4d5636d5129cd2363e630fa9000b6ee460bd28", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe4d5636d5129cd2363e630fa9000b6ee460bd28", "message": "Fixing unit tests", "committedDate": "2020-02-21T22:17:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTY4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382855689", "bodyText": "Why do we remove the getCoordinates?", "author": "sima-zhu", "createdAt": "2020-02-21T23:41:48Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/models/GeoPoint.java", "diffHunk": "@@ -116,27 +116,19 @@ public String toString() {\n         return \"\";\n     }\n \n-    /**", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861083", "bodyText": "It was an ask to remove them, #8149", "author": "alzimmermsft", "createdAt": "2020-02-22T00:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTY4OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857562", "bodyText": "Not necessary to have the message.\nConsistent with other class\nthis.apiKey = Objects.requireNonNull(apiKey);", "author": "sima-zhu", "createdAt": "2020-02-21T23:50:43Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchApiKeyPipelinePolicy.java", "diffHunk": "@@ -25,14 +26,13 @@\n      * @throws IllegalArgumentException when the api key is an empty string\n      */\n     public SearchApiKeyPipelinePolicy(SearchApiKeyCredential apiKey) {\n-        Objects.requireNonNull(apiKey);\n+        Objects.requireNonNull(apiKey, \"'apiKey' cannot be null.\");", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861218", "bodyText": "It's been a general guideline to include a message on Objects.requireNonNull calls.", "author": "alzimmermsft", "createdAt": "2020-02-22T00:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzU2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857936", "bodyText": "I changed the API and document in my PR", "author": "sima-zhu", "createdAt": "2020-02-21T23:52:18Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,265 +140,207 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> deleteDocuments(Iterable<?> documents) {\n-        try {\n-            return this.deleteDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> deleteDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> deleteDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.DELETE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.DELETE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Gets Client Api Version.\n+     * Gets the version of the Search service the client is using.\n      *\n-     * @return the apiVersion value.\n+     * @return The version of the Search service the client is using.\n      */\n     public SearchServiceVersion getApiVersion() {", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTI3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861271", "bodyText": "Mind linking the change?", "author": "alzimmermsft", "createdAt": "2020-02-22T00:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzkzNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "38b0626ed58b923f68a206b5857b2318e4a41db0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/38b0626ed58b923f68a206b5857b2318e4a41db0", "message": "Fixing unit tests, making AccessConditionTests a static helper class", "committedDate": "2020-02-22T02:12:13Z", "type": "commit"}, {"oid": "feb0a14240bb75240155f21eda1731ccb72d4eec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/feb0a14240bb75240155f21eda1731ccb72d4eec", "message": "Update session playback records", "committedDate": "2020-02-24T20:47:58Z", "type": "commit"}, {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "message": "Merged in master", "committedDate": "2020-02-24T20:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r383542630", "bodyText": "Why do we remove this API?", "author": "sima-zhu", "createdAt": "2020-02-24T22:05:13Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchServiceAsyncClient.java", "diffHunk": "@@ -1300,265 +1009,187 @@ public String getEndpoint() {\n      * @return the skillset that was created or updated.\n      */\n     public Mono<Skillset> createOrUpdateSkillset(Skillset skillset) {\n-        try {\n-            return this.createOrUpdateSkillsetWithResponse(skillset, null, null)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return createOrUpdateSkillsetWithResponse(skillset, null, null).map(Response::getValue);\n     }\n \n     /**\n      * Creates a new Azure Cognitive Search skillset or updates a skillset if it already exists.\n      *\n      * @param skillset the definition of the skillset to create or update\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response containing the skillset that was created or updated.\n      */\n     public Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                       AccessCondition accessCondition,\n-                                                                       RequestOptions requestOptions) {\n+        AccessCondition accessCondition, RequestOptions requestOptions) {\n+        return withContext(context ->\n+            createOrUpdateSkillsetWithResponse(skillset, accessCondition, requestOptions, context));\n+    }\n+\n+    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset, AccessCondition accessCondition,\n+        RequestOptions requestOptions, Context context) {\n         try {\n-            return withContext(context -> this.createOrUpdateSkillsetWithResponse(skillset,\n-                accessCondition,\n-                requestOptions,\n-                context));\n+            return restClient.skillsets()\n+                .createOrUpdateWithRestResponseAsync(skillset.getName(), skillset, requestOptions, accessCondition,\n+                    context)\n+                .map(Function.identity());\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                AccessCondition accessCondition,\n-                                                                RequestOptions requestOptions,\n-                                                                Context context) {\n-        return restClient\n-            .skillsets()\n-            .createOrUpdateWithRestResponseAsync(skillset.getName(),\n-                skillset, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @return a response signalling completion.\n      */\n     public Mono<Void> deleteSkillset(String skillsetName) {\n-        try {\n-            return this.deleteSkillsetWithResponse(skillsetName, null, null)\n-                .flatMap(FluxUtil::toMono);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteSkillsetWithResponse(skillsetName, null, null).flatMap(FluxUtil::toMono);\n     }\n \n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response signalling completion.\n      */\n-    public Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                           AccessCondition accessCondition,\n-                                                           RequestOptions requestOptions) {\n-        try {\n-            return withContext(context -> this.deleteSkillsetWithResponse(skillsetName, accessCondition, requestOptions,\n-                context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n-    }\n-\n-    Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                    AccessCondition accessCondition,\n-                                                    RequestOptions requestOptions,\n-                                                    Context context) {\n-        return restClient\n-            .skillsets()\n-            .deleteWithRestResponseAsync(skillsetName, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n-    /**\n-     * Determines whether or not the given skillset exists.\n-     *\n-     * @param skillsetName the name of the skillset\n-     * @return true if the skillset exists; false otherwise.\n-     */\n-    public Mono<Boolean> skillsetExists(String skillsetName) {", "originalCommit": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1Mjk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r383552975", "bodyText": "Per request from Bruce, it will be easier to add this back in the future than removing it from our APIs.", "author": "alzimmermsft", "createdAt": "2020-02-24T22:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjYzMA=="}], "type": "inlineReview", "revised_code": null}]}