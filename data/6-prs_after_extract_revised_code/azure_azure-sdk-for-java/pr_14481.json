{"pr_number": 14481, "pr_title": "Adds new API CosmosContainer.readAllItems to retrieve all documents of a logical partition avoiding IO to retrieve query plan", "pr_createdAt": "2020-08-26T11:54:11Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14481", "timeline": [{"oid": "73c9f04c67095734dd71afca1f00d59f1064ad21", "url": "https://github.com/Azure/azure-sdk-for-java/commit/73c9f04c67095734dd71afca1f00d59f1064ad21", "message": "Enabling query metrics by default", "committedDate": "2020-08-24T13:59:28Z", "type": "commit"}, {"oid": "d63712bcf919554bea9134e91c837a20bd338470", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d63712bcf919554bea9134e91c837a20bd338470", "message": "Adding null-value handling to quey metric validation", "committedDate": "2020-08-24T14:11:59Z", "type": "commit"}, {"oid": "ea53fbcd97f7524429eb8bcbd6c8ce61a40cbfca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea53fbcd97f7524429eb8bcbd6c8ce61a40cbfca", "message": "Fix for NPE in GatewayAddressCache", "committedDate": "2020-08-25T00:31:46Z", "type": "commit"}, {"oid": "0bf2117b22d3b44da22330a1ba70e4444a2c81aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0bf2117b22d3b44da22330a1ba70e4444a2c81aa", "message": "Adding comments explaining default value of QueryMetricEnabled", "committedDate": "2020-08-25T00:32:24Z", "type": "commit"}, {"oid": "32179790336a2adb4622e12d0c98f29e79679977", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32179790336a2adb4622e12d0c98f29e79679977", "message": "Adding support for readAllItems of a logical partition", "committedDate": "2020-08-25T22:10:33Z", "type": "commit"}, {"oid": "982cc17ac0fa154471430826b31eca79be2471b6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/982cc17ac0fa154471430826b31eca79be2471b6", "message": "Adding readAllItems for sync CosmosContainer as well", "committedDate": "2020-08-26T11:51:31Z", "type": "commit"}, {"oid": "ef1242b23c3137d170458bbb4366f1204fcf73b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ef1242b23c3137d170458bbb4366f1204fcf73b3", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/EnableQueryMetricsByDefault", "committedDate": "2020-08-26T11:56:03Z", "type": "commit"}, {"oid": "3514516afbf23f185e8e5ed20bc4e678830df587", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3514516afbf23f185e8e5ed20bc4e678830df587", "message": "Adding basic unit test for ReadAllItems(PK)", "committedDate": "2020-08-26T14:39:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM3NjEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477376101", "bodyText": "Is Itemizing (or promoting parts of) request option, to limit to applicable ones?", "author": "kirankumarkolli", "createdAt": "2020-08-26T15:09:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -532,6 +534,102 @@ public String getId() {\n         return withContext(context -> readItemInternal(itemId, requestOptions, itemType, context));\n     }\n \n+    /**\n+     * Reads many documents.\n+     *\n+     * @param <T> the type parameter\n+     * @param itemKeyList document id and partition key pair that needs to be read\n+     * @param classType   class type\n+     * @return a Mono with feed response of cosmos items\n+     */\n+    @Beta(Beta.SinceVersion.V4_4_0)\n+    public <T> Mono<FeedResponse<T>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        Class<T> classType) {\n+\n+        return this.readMany(itemKeyList, null, classType);\n+    }\n+\n+    /**\n+     * Reads many documents.\n+     *\n+     * @param <T> the type parameter\n+     * @param itemKeyList document id and partition key pair that needs to be read\n+     * @param sessionToken the optional Session token - null if the read can be made without specific session token\n+     * @param classType   class type\n+     * @return a Mono with feed response of cosmos items\n+     */\n+    @Beta(Beta.SinceVersion.V4_4_0)\n+    public <T> Mono<FeedResponse<T>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String sessionToken,", "originalCommit": "3514516afbf23f185e8e5ed20bc4e678830df587", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM3OTk2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477379964", "bodyText": "Yes - the only relevant one is SessionToken compared to CosmosQueryRequestOptions", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T15:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM3NjEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex b5e2b9a36bb..6c318d238cd 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -567,7 +567,7 @@ public class CosmosAsyncContainer {\n \n         CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n \n-        if (!StringUtils.isNotBlank(sessionToken)) {\n+        if (!StringUtils.isNotEmpty(sessionToken)) {\n             options = options.setSessionToken(sessionToken);\n         }\n \n"}}, {"oid": "d50091deab09652e00f8a61631b0b834c928e93a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d50091deab09652e00f8a61631b0b834c928e93a", "message": "Adding benchmark for ReadAllItems", "committedDate": "2020-08-26T15:12:23Z", "type": "commit"}, {"oid": "37c1c8a5fbd37d8e2975453964004d363542f2ec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/37c1c8a5fbd37d8e2975453964004d363542f2ec", "message": "Fixing cosmos-benchmark version as well", "committedDate": "2020-08-26T16:17:52Z", "type": "commit"}, {"oid": "a31c1bab620ada5d8da99b1af12f0439fbb7f0c0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a31c1bab620ada5d8da99b1af12f0439fbb7f0c0", "message": "Fixing changelog for cosmos-encryption", "committedDate": "2020-08-26T16:36:48Z", "type": "commit"}, {"oid": "1b400574bf547e277e1a112ce236d7a92026fa36", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1b400574bf547e277e1a112ce236d7a92026fa36", "message": "Fixing versions", "committedDate": "2020-08-26T17:50:48Z", "type": "commit"}, {"oid": "dbc349f46d96ee4545cab42c0b5ec40ad2bfbc5f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbc349f46d96ee4545cab42c0b5ec40ad2bfbc5f", "message": "Fixing current version of azure-cosmos", "committedDate": "2020-08-26T18:01:34Z", "type": "commit"}, {"oid": "b90615590b766a43c19d066326358fca7462573f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b90615590b766a43c19d066326358fca7462573f", "message": "Reverting azure-cosmos version bump", "committedDate": "2020-08-26T18:19:53Z", "type": "commit"}, {"oid": "80b91ca9103f8fe082105fc8bb88981304785ccc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80b91ca9103f8fe082105fc8bb88981304785ccc", "message": "Bumping azure-cosmos version", "committedDate": "2020-08-26T18:31:54Z", "type": "commit"}, {"oid": "835526482974d6f2aaf5459578e1fac57716bf42", "url": "https://github.com/Azure/azure-sdk-for-java/commit/835526482974d6f2aaf5459578e1fac57716bf42", "message": "Reverting unnecessary changelog and readme changes", "committedDate": "2020-08-26T18:40:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NjYzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477466637", "bodyText": "NPE bug if the number of pre-created documents is less than 1000.", "author": "moderakh", "createdAt": "2020-08-26T17:25:31Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncQueryBenchmark.java", "diffHunk": "@@ -123,6 +123,11 @@ protected void performWorkload(BaseSubscriber<FeedResponse<PojoizedJson>> baseSu\n \n             SqlQuerySpec query = queryBuilder.toSqlQuerySpec();\n             obs = cosmosAsyncContainer.queryItems(query, options, PojoizedJson.class).byPage();\n+        } else if (configuration.getOperationType() == Configuration.Operation.ReadAllItemsOfLogicalPartition) {\n+\n+            int index = r.nextInt(1000);\n+            String pk = docsToRead.get(index).getProperty(partitionKey);", "originalCommit": "a31c1bab620ada5d8da99b1af12f0439fbb7f0c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNDY4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477514687", "bodyText": "Fixed for other operation types as well", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T18:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NjYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "977db82d9e74981d8d1e02261bd1e9e63e4dea8c", "chunk": "diff --git a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncQueryBenchmark.java b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncQueryBenchmark.java\nindex fa6b609ae86..ad303f5d223 100644\n--- a/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncQueryBenchmark.java\n+++ b/sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsyncQueryBenchmark.java\n\n@@ -125,7 +125,7 @@ class AsyncQueryBenchmark extends AsyncBenchmark<FeedResponse<PojoizedJson>> {\n             obs = cosmosAsyncContainer.queryItems(query, options, PojoizedJson.class).byPage();\n         } else if (configuration.getOperationType() == Configuration.Operation.ReadAllItemsOfLogicalPartition) {\n \n-            int index = r.nextInt(1000);\n+            int index = r.nextInt(this.configuration.getNumberOfPreCreatedDocuments());\n             String pk = docsToRead.get(index).getProperty(partitionKey);\n             obs = cosmosAsyncContainer.readAllItems(new PartitionKey(pk), options, PojoizedJson.class).byPage();\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDQ4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477470485", "bodyText": "other than V4_4_0 do we need the other ones? perhaps we can start with V4_4_0 only for now?", "author": "moderakh", "createdAt": "2020-08-26T17:32:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.util;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+import static java.lang.annotation.ElementType.TYPE;\n+import static java.lang.annotation.ElementType.CONSTRUCTOR;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Documented\n+@Retention(RetentionPolicy.CLASS)\n+@Target({ TYPE, METHOD, PARAMETER, CONSTRUCTOR })\n+@Inherited\n+/**\n+ * Indicates functionality that is in preview and as such is subject to change in non-backwards compatible ways in future releases,\n+ * including removal, regardless of any compatibility expectations set by the containing library version.\n+ */\n+public @interface Beta {\n+    String warningText() default \"This functionality is in preview and as such is subject to change in non-backwards compatible ways in future releases, including removal, regardless of any compatibility expectations set by the containing library version.\";\n+\n+    /**\n+     * @return the version number when the annotated API was first introduced to the library as in Beta\n+     */\n+    SinceVersion value() default SinceVersion.V4_4_0;\n+\n+    /**\n+     * Azure library version numbers\n+     */\n+    public enum SinceVersion {\n+        /** v4.4.0 */\n+        V4_4_0,\n+\n+        /** v4.5.0 */\n+        V4_5_0,", "originalCommit": "a31c1bab620ada5d8da99b1af12f0439fbb7f0c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNTU1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477515550", "bodyText": "Ported this straight from Milis's change - i think his intention was to force that only at least Minor versions (not patch versions) bumps are allowed. I kind of liked that model. Do you feel strongly about this?", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T18:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzNzQ2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477537467", "bodyText": "it just sounds weird that we have constants for future unreleased versions here. I would rather to just have only the version we have and we don't add not needed version constant here.\nHowever not a big deal. no strong feeling. it is your call, whichever you prefer.\nFeel free to resolve the comment if you want to keep it they way it is.", "author": "moderakh", "createdAt": "2020-08-26T19:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzOTk5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477539999", "bodyText": "In the ARM SDK case since we ship this as a separate library, we do need to capture future versions... Not really needed here but it does not hurt either. It's ok either way.", "author": "milismsft", "createdAt": "2020-08-26T19:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NDA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477544047", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T19:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "10bab43ffe4c6091e816cfcd4c582a8a96af08a1", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java\nindex 947e0cef7a0..71c122eb666 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java\n\n@@ -35,57 +35,6 @@ public @interface Beta {\n      */\n     public enum SinceVersion {\n         /** v4.4.0 */\n-        V4_4_0,\n-\n-        /** v4.5.0 */\n-        V4_5_0,\n-\n-        /** v4.6.0 */\n-        V4_6_0,\n-\n-        /** v4.7.0 */\n-        V4_7_0,\n-\n-        /** v4.8.0 */\n-        V4_8_0,\n-\n-        /** v4.9.0 */\n-        V4_9_0,\n-\n-        /** v4.10.0 */\n-        V4_10_0,\n-\n-        /** v4.11.0 */\n-        V4_11_0,\n-\n-        /** v4.12.0 */\n-        V4_12_0,\n-\n-        /** v4.13.0 */\n-        V4_13_0,\n-\n-        /** v4.14.0 */\n-        V4_14_0,\n-\n-        /** v4.15.0 */\n-        V4_15_0,\n-\n-        /** v4.16.0 */\n-        V4_16_0,\n-\n-        /** v4.17.0 */\n-        V4_17_0,\n-\n-        /** v4.18.0 */\n-        V4_18_0,\n-\n-        /** v4.19.0 */\n-        V4_19_0,\n-\n-        /** v4.20.0 */\n-        V4_20_0,\n-\n-        /** v5.0.0 */\n-        V5_0_0\n+        V4_4_0\n     }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477508865", "bodyText": "why do we need to expose session token here?\nDid anyone ask for it? if not can we remove this?", "author": "moderakh", "createdAt": "2020-08-26T18:40:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -532,6 +534,102 @@ public String getId() {\n         return withContext(context -> readItemInternal(itemId, requestOptions, itemType, context));\n     }\n \n+    /**\n+     * Reads many documents.\n+     *\n+     * @param <T> the type parameter\n+     * @param itemKeyList document id and partition key pair that needs to be read\n+     * @param classType   class type\n+     * @return a Mono with feed response of cosmos items\n+     */\n+    @Beta(Beta.SinceVersion.V4_4_0)\n+    public <T> Mono<FeedResponse<T>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        Class<T> classType) {\n+\n+        return this.readMany(itemKeyList, null, classType);\n+    }\n+\n+    /**\n+     * Reads many documents.\n+     *\n+     * @param <T> the type parameter\n+     * @param itemKeyList document id and partition key pair that needs to be read\n+     * @param sessionToken the optional Session token - null if the read can be made without specific session token\n+     * @param classType   class type\n+     * @return a Mono with feed response of cosmos items\n+     */\n+    @Beta(Beta.SinceVersion.V4_4_0)\n+    public <T> Mono<FeedResponse<T>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String sessionToken,", "originalCommit": "80b91ca9103f8fe082105fc8bb88981304785ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNjY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477516644", "bodyText": "How would a customer who wants to use Session consistency do the ReadMany in this case?", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T18:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNzA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477517062", "bodyText": "The idea was to start exposing this so that not other customers but Adobe take dependency on implementation package", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T18:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNzM5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477517398", "bodyText": "If this needs more discussions I will revert it here and leave it as is to not unblock the Walmart fix on this discusison.", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T18:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxNzYyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477517627", "bodyText": "for the common session scenario session is resolved through internal sessionContainer.\nI would say passing a session token arg is an advanced use case.", "author": "moderakh", "createdAt": "2020-08-26T18:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyNTg3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477525876", "bodyText": "I would argue readMany is only necessary in advanced scenarios anyway. What is the harm in exposing sessionToken as parameter? Is the concern that you would prefer a special ReadManyRequestOptions with just SessionToken for now?", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T19:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyNjMzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477526336", "bodyText": "Or don't want to decide on that model yet?", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T19:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzNTAwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477535006", "bodyText": "I didn't want to decide on the contract/model. but this is beta anyway.\nso makes sense. let's keep it. resolving the comment.", "author": "moderakh", "createdAt": "2020-08-26T19:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\nindex b5e2b9a36bb..6c318d238cd 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java\n\n@@ -567,7 +567,7 @@ public class CosmosAsyncContainer {\n \n         CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n \n-        if (!StringUtils.isNotBlank(sessionToken)) {\n+        if (!StringUtils.isNotEmpty(sessionToken)) {\n             options = options.setSessionToken(sessionToken);\n         }\n \n"}}, {"oid": "977db82d9e74981d8d1e02261bd1e9e63e4dea8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/977db82d9e74981d8d1e02261bd1e9e63e4dea8c", "message": "Fixing azure-cosmos-benchmark to use dynamic number of precreated documents", "committedDate": "2020-08-26T18:50:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyODI3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477528275", "bodyText": "please add one line description to \"-operation\" parameter description, similar to other operations.", "author": "moderakh", "createdAt": "2020-08-26T19:09:00Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -163,7 +163,8 @@ public Duration convert(String value) {\n         Mixed,\n         ReadMyWrites,\n         ReadThroughputWithMultipleClients,\n-        CtlWorkload;\n+        CtlWorkload,\n+        ReadAllItemsOfLogicalPartition;", "originalCommit": "977db82d9e74981d8d1e02261bd1e9e63e4dea8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDk2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477530962", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T19:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyODI3NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyODc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477528785", "bodyText": "dont' rely on StringUtils from micrometer, that's an external dependency.\nPlease use com.azure.cosmos.implementation.apachecommons.lang.StringUtils instead.", "author": "moderakh", "createdAt": "2020-08-26T19:09:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -3,22 +3,30 @@\n \n package com.azure.cosmos;\n \n+import com.azure.cosmos.implementation.apachecommons.lang.tuple.Pair;\n import com.azure.cosmos.models.CosmosItemResponse;\n import com.azure.cosmos.models.CosmosContainerProperties;\n import com.azure.cosmos.models.CosmosContainerRequestOptions;\n import com.azure.cosmos.models.CosmosContainerResponse;\n import com.azure.cosmos.models.CosmosItemRequestOptions;\n import com.azure.cosmos.models.CosmosQueryRequestOptions;\n+import com.azure.cosmos.models.FeedResponse;\n import com.azure.cosmos.models.PartitionKey;\n import com.azure.cosmos.models.SqlQuerySpec;\n import com.azure.cosmos.models.ThroughputProperties;\n import com.azure.cosmos.models.ThroughputResponse;\n+import com.azure.cosmos.util.Beta;\n import com.azure.cosmos.util.CosmosPagedFlux;\n import com.azure.cosmos.util.CosmosPagedIterable;\n import com.azure.cosmos.util.UtilBridgeInternal;\n+import io.micrometer.core.instrument.util.StringUtils;", "originalCommit": "977db82d9e74981d8d1e02261bd1e9e63e4dea8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMjk0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477532947", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T19:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUyODc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\nindex 0c93dfd3bdf..462ec096f38 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java\n\n@@ -19,7 +19,6 @@ import com.azure.cosmos.util.Beta;\n import com.azure.cosmos.util.CosmosPagedFlux;\n import com.azure.cosmos.util.CosmosPagedIterable;\n import com.azure.cosmos.util.UtilBridgeInternal;\n-import io.micrometer.core.instrument.util.StringUtils;\n import reactor.core.Exceptions;\n import reactor.core.publisher.Mono;\n \n"}}, {"oid": "546e1b8e19c23f9e93dee0dd14deaf117549384e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/546e1b8e19c23f9e93dee0dd14deaf117549384e", "message": "Adding benchmark use case description", "committedDate": "2020-08-26T19:14:00Z", "type": "commit"}, {"oid": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a483b4ed80d406054c2ed51243277f3abb65a1c7", "message": "Fixing wrong StringUtils dependency", "committedDate": "2020-08-26T19:17:45Z", "type": "commit"}, {"oid": "10bab43ffe4c6091e816cfcd4c582a8a96af08a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10bab43ffe4c6091e816cfcd4c582a8a96af08a1", "message": "Remove unnecessary constants", "committedDate": "2020-08-26T19:38:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTczMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477555733", "bodyText": "partitionSplit handling.\nDocumentProducer which is used internally for cross-partition query is recursively split-proof.\nPlease verify two things:\n\nthat this code internally uses DocumentProducer (and hence benefit from DB being split proof.)\nplease make sure if partition split happens before DocumentProducer is instantiated still this is split proof.", "author": "moderakh", "createdAt": "2020-08-26T20:00:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1812,6 +1830,75 @@ public QueryCompatibilityMode getQueryCompatibilityMode() {\n         return changeFeedQueryImpl.executeAsync();\n     }\n \n+    @Override\n+    public Flux<FeedResponse<Document>> readAllDocuments(\n+        String collectionLink,\n+        PartitionKey partitionKey,\n+        CosmosQueryRequestOptions options) {\n+\n+        if (StringUtils.isEmpty(collectionLink)) {\n+            throw new IllegalArgumentException(\"collectionLink\");\n+        }\n+\n+        if (partitionKey == null) {\n+            throw new IllegalArgumentException(\"partitionKey\");\n+        }\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink,\n+            null\n+        );\n+\n+        // This should not got to backend\n+        Flux<Utils.ValueHolder<DocumentCollection>> collectionObs =\n+            collectionCache.resolveCollectionAsync(null, request).flux();\n+\n+        return collectionObs\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                PartitionKeyDefinition pkDefinition = collection.getPartitionKey();\n+                String pkSelector = createPkSelector(pkDefinition);\n+                SqlQuerySpec querySpec = createLogicalPartitionScanQuerySpec(partitionKey, pkSelector);\n+\n+                Flux<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = this.partitionKeyRangeCache\n+                    .tryLookupAsync(BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                        collection.getResourceId(),\n+                        null,\n+                        null).flux();\n+                return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n+\n+                    CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                    if (routingMap == null) {\n+                        throw new IllegalStateException(\"Failed to get routing map.\");\n+                    }\n+\n+                    String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                        .getEffectivePartitionKeyString(\n+                            BridgeInternal.getPartitionKeyInternal(partitionKey),\n+                            pkDefinition);\n+\n+                    //use routing map to find the partitionKeyRangeId of each\n+                    // effectivePartitionKey\n+                    PartitionKeyRange range =\n+                        routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+                    final CosmosQueryRequestOptions effectiveOptions =\n+                        ModelBridgeInternal.partitionKeyRangeIdInternal(\n+                            ModelBridgeInternal.createQueryRequestOptions(options),\n+                            range.getId());\n+\n+                    return createQuery(collectionLink, querySpec, effectiveOptions, Document.class, ResourceType.Document);", "originalCommit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NTQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477585420", "bodyText": "Fixed it - basically I had to change the code to include the PkRangeIdLookup within the retry policy as suspected. Thanks for catching this!\nThe Producers are used via the normal QueryexecutionContext factory - so we are good there.", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T20:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNDQxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477614411", "bodyText": "Actually I only moved the InvalidPartitionExceptionRetryPolicy up one level - so the change didn't impact partition splits. For partition splits my assumption is right now that readAllDocuments will behave like normal queries.\nFor queries the relevant PkRangeIds are retrieved form the query plan. The query plan is retrieved from the gateway before creating the QueryExecutionContext which then creates the DocumentProducer. QueryExecutionContext.executeAsync and DocumentProducer are handling partition splits.\nFor readAllDocuments the PkRangeId is set on CosmosQueryRequestOptions and this value is used by the QueryExecutionContext to create the DocumentProducer etc. Everything else is running through the same pipeline\nSo if there is a problem, because the pkValue -> pkRangeId resolution happens before creating the QueryExecutionContext/DocumentProducer in readAllDocuments the same problem exists for normal queries because the queryPlan has been also retrieved before creating ExecutionContext/DocumentProducer.\nWorth some additional investigation and testing - but Mo and I decided offline that it is ok to do that after releasing the initial Beta version.", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T22:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTczMw=="}], "type": "inlineReview", "revised_code": {"commit": "3ae465a3129debd58fee56524f4f11af60ed0710", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\nindex 433b93d19f7..23a4c19c64c 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n\n@@ -1855,48 +1855,70 @@ public class RxDocumentClientImpl implements AsyncDocumentClient, IAuthorization\n         Flux<Utils.ValueHolder<DocumentCollection>> collectionObs =\n             collectionCache.resolveCollectionAsync(null, request).flux();\n \n-        return collectionObs\n-            .flatMap(documentCollectionResourceResponse -> {\n-\n-                DocumentCollection collection = documentCollectionResourceResponse.v;\n-                if (collection == null) {\n-                    throw new IllegalStateException(\"Collection cannot be null\");\n-                }\n-\n-                PartitionKeyDefinition pkDefinition = collection.getPartitionKey();\n-                String pkSelector = createPkSelector(pkDefinition);\n-                SqlQuerySpec querySpec = createLogicalPartitionScanQuerySpec(partitionKey, pkSelector);\n-\n-                Flux<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = this.partitionKeyRangeCache\n-                    .tryLookupAsync(BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n-                        collection.getResourceId(),\n-                        null,\n-                        null).flux();\n-                return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n+        return collectionObs.flatMap(documentCollectionResourceResponse -> {\n \n-                    CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n-                    if (routingMap == null) {\n-                        throw new IllegalStateException(\"Failed to get routing map.\");\n-                    }\n+            DocumentCollection collection = documentCollectionResourceResponse.v;\n+            if (collection == null) {\n+                throw new IllegalStateException(\"Collection cannot be null\");\n+            }\n+\n+            PartitionKeyDefinition pkDefinition = collection.getPartitionKey();\n+            String pkSelector = createPkSelector(pkDefinition);\n+            SqlQuerySpec querySpec = createLogicalPartitionScanQuerySpec(partitionKey, pkSelector);\n+\n+            String resourceLink = parentResourceLinkToQueryLink(collectionLink, ResourceType.Document);\n+            UUID activityId = Utils.randomUUID();\n+            IDocumentQueryClient queryClient = documentQueryClientImpl(RxDocumentClientImpl.this);\n+\n+            final CosmosQueryRequestOptions effectiveOptions =\n+                ModelBridgeInternal.createQueryRequestOptions(options);\n+\n+            // Trying to put this logic as low as the query pipeline\n+            // Since for parallelQuery, each partition will have its own request, so at this point, there will be no request associate with this retry policy.\n+            // For default document context, it already wired up InvalidPartitionExceptionRetry, but there is no harm to wire it again here\n+            InvalidPartitionExceptionRetryPolicy invalidPartitionExceptionRetryPolicy = new InvalidPartitionExceptionRetryPolicy(\n+                this.collectionCache,\n+                null,\n+                resourceLink,\n+                effectiveOptions);\n+\n+            return ObservableHelper.fluxInlineIfPossibleAsObs(\n+                () -> {\n+                    Flux<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = this.partitionKeyRangeCache\n+                        .tryLookupAsync(\n+                            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                            collection.getResourceId(),\n+                            null,\n+                            null).flux();\n+                    return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n \n-                    String effectivePartitionKeyString = PartitionKeyInternalHelper\n-                        .getEffectivePartitionKeyString(\n-                            BridgeInternal.getPartitionKeyInternal(partitionKey),\n-                            pkDefinition);\n+                        CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                        if (routingMap == null) {\n+                            throw new IllegalStateException(\"Failed to get routing map.\");\n+                        }\n \n-                    //use routing map to find the partitionKeyRangeId of each\n-                    // effectivePartitionKey\n-                    PartitionKeyRange range =\n-                        routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+                        String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                            .getEffectivePartitionKeyString(\n+                                BridgeInternal.getPartitionKeyInternal(partitionKey),\n+                                pkDefinition);\n \n-                    final CosmosQueryRequestOptions effectiveOptions =\n-                        ModelBridgeInternal.partitionKeyRangeIdInternal(\n-                            ModelBridgeInternal.createQueryRequestOptions(options),\n-                            range.getId());\n+                        //use routing map to find the partitionKeyRangeId of each\n+                        // effectivePartitionKey\n+                        PartitionKeyRange range =\n+                            routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n \n-                    return createQuery(collectionLink, querySpec, effectiveOptions, Document.class, ResourceType.Document);\n-                });\n-            });\n+                        return createQueryInternal(\n+                            resourceLink,\n+                            querySpec,\n+                            ModelBridgeInternal.partitionKeyRangeIdInternal(effectiveOptions, range.getId()),\n+                            Document.class,\n+                            ResourceType.Document,\n+                            queryClient,\n+                            activityId);\n+                    });\n+                },\n+                invalidPartitionExceptionRetryPolicy);\n+        });\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NjAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477556001", "bodyText": "collection stale situation:\ndelete collection, recreate the collection with the same name.", "author": "moderakh", "createdAt": "2020-08-26T20:01:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1812,6 +1830,75 @@ public QueryCompatibilityMode getQueryCompatibilityMode() {\n         return changeFeedQueryImpl.executeAsync();\n     }\n \n+    @Override\n+    public Flux<FeedResponse<Document>> readAllDocuments(", "originalCommit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxMjA2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477612060", "bodyText": "Fixed by moving InvalidPartitionExceptionRetryPolicy one level up", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T21:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NjAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3ae465a3129debd58fee56524f4f11af60ed0710", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\nindex 433b93d19f7..23a4c19c64c 100644\n--- a/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n+++ b/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n\n@@ -1855,48 +1855,70 @@ public class RxDocumentClientImpl implements AsyncDocumentClient, IAuthorization\n         Flux<Utils.ValueHolder<DocumentCollection>> collectionObs =\n             collectionCache.resolveCollectionAsync(null, request).flux();\n \n-        return collectionObs\n-            .flatMap(documentCollectionResourceResponse -> {\n-\n-                DocumentCollection collection = documentCollectionResourceResponse.v;\n-                if (collection == null) {\n-                    throw new IllegalStateException(\"Collection cannot be null\");\n-                }\n-\n-                PartitionKeyDefinition pkDefinition = collection.getPartitionKey();\n-                String pkSelector = createPkSelector(pkDefinition);\n-                SqlQuerySpec querySpec = createLogicalPartitionScanQuerySpec(partitionKey, pkSelector);\n-\n-                Flux<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = this.partitionKeyRangeCache\n-                    .tryLookupAsync(BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n-                        collection.getResourceId(),\n-                        null,\n-                        null).flux();\n-                return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n+        return collectionObs.flatMap(documentCollectionResourceResponse -> {\n \n-                    CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n-                    if (routingMap == null) {\n-                        throw new IllegalStateException(\"Failed to get routing map.\");\n-                    }\n+            DocumentCollection collection = documentCollectionResourceResponse.v;\n+            if (collection == null) {\n+                throw new IllegalStateException(\"Collection cannot be null\");\n+            }\n+\n+            PartitionKeyDefinition pkDefinition = collection.getPartitionKey();\n+            String pkSelector = createPkSelector(pkDefinition);\n+            SqlQuerySpec querySpec = createLogicalPartitionScanQuerySpec(partitionKey, pkSelector);\n+\n+            String resourceLink = parentResourceLinkToQueryLink(collectionLink, ResourceType.Document);\n+            UUID activityId = Utils.randomUUID();\n+            IDocumentQueryClient queryClient = documentQueryClientImpl(RxDocumentClientImpl.this);\n+\n+            final CosmosQueryRequestOptions effectiveOptions =\n+                ModelBridgeInternal.createQueryRequestOptions(options);\n+\n+            // Trying to put this logic as low as the query pipeline\n+            // Since for parallelQuery, each partition will have its own request, so at this point, there will be no request associate with this retry policy.\n+            // For default document context, it already wired up InvalidPartitionExceptionRetry, but there is no harm to wire it again here\n+            InvalidPartitionExceptionRetryPolicy invalidPartitionExceptionRetryPolicy = new InvalidPartitionExceptionRetryPolicy(\n+                this.collectionCache,\n+                null,\n+                resourceLink,\n+                effectiveOptions);\n+\n+            return ObservableHelper.fluxInlineIfPossibleAsObs(\n+                () -> {\n+                    Flux<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = this.partitionKeyRangeCache\n+                        .tryLookupAsync(\n+                            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                            collection.getResourceId(),\n+                            null,\n+                            null).flux();\n+                    return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n \n-                    String effectivePartitionKeyString = PartitionKeyInternalHelper\n-                        .getEffectivePartitionKeyString(\n-                            BridgeInternal.getPartitionKeyInternal(partitionKey),\n-                            pkDefinition);\n+                        CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                        if (routingMap == null) {\n+                            throw new IllegalStateException(\"Failed to get routing map.\");\n+                        }\n \n-                    //use routing map to find the partitionKeyRangeId of each\n-                    // effectivePartitionKey\n-                    PartitionKeyRange range =\n-                        routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+                        String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                            .getEffectivePartitionKeyString(\n+                                BridgeInternal.getPartitionKeyInternal(partitionKey),\n+                                pkDefinition);\n \n-                    final CosmosQueryRequestOptions effectiveOptions =\n-                        ModelBridgeInternal.partitionKeyRangeIdInternal(\n-                            ModelBridgeInternal.createQueryRequestOptions(options),\n-                            range.getId());\n+                        //use routing map to find the partitionKeyRangeId of each\n+                        // effectivePartitionKey\n+                        PartitionKeyRange range =\n+                            routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n \n-                    return createQuery(collectionLink, querySpec, effectiveOptions, Document.class, ResourceType.Document);\n-                });\n-            });\n+                        return createQueryInternal(\n+                            resourceLink,\n+                            querySpec,\n+                            ModelBridgeInternal.partitionKeyRangeIdInternal(effectiveOptions, range.getId()),\n+                            Document.class,\n+                            ResourceType.Document,\n+                            queryClient,\n+                            activityId);\n+                    });\n+                },\n+                invalidPartitionExceptionRetryPolicy);\n+        });\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NzE0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477557147", "bodyText": "unfortunately some of our existing tests rely on InternalObjectNode which is an internal class.\nCustomers see this and may use this as sample.\nPlease consider replacing InternalObjectNode with ObjectNode for the newly added tests (as this might get used as sample by end users.)", "author": "moderakh", "createdAt": "2020-08-26T20:03:36Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosItemTest.java", "diffHunk": "@@ -200,6 +200,70 @@ public void queryItemsWithContinuationTokenAndPageSize() throws Exception{\n \n     }\n \n+    @Test(groups = { \"simple\" }, timeOut = TIMEOUT)\n+    public void readAllItemsOfLogicalPartition() throws Exception{\n+        String pkValue = UUID.randomUUID().toString();\n+        InternalObjectNode properties = getDocumentDefinition(UUID.randomUUID().toString(), pkValue);", "originalCommit": "a483b4ed80d406054c2ed51243277f3abb65a1c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxMTE0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14481#discussion_r477611147", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-08-26T21:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NzE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "628c150ce8b20a3316e9f58fd7c3acbb9ff4f4c5", "chunk": "diff --git a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosItemTest.java b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosItemTest.java\nindex 37ed767a096..477bb834a51 100644\n--- a/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosItemTest.java\n+++ b/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosItemTest.java\n\n@@ -203,24 +208,24 @@ public class CosmosItemTest extends TestSuiteBase {\n     @Test(groups = { \"simple\" }, timeOut = TIMEOUT)\n     public void readAllItemsOfLogicalPartition() throws Exception{\n         String pkValue = UUID.randomUUID().toString();\n-        InternalObjectNode properties = getDocumentDefinition(UUID.randomUUID().toString(), pkValue);\n-        CosmosItemResponse<InternalObjectNode> itemResponse = container.createItem(properties);\n+        ObjectNode properties = getDocumentDefinition(UUID.randomUUID().toString(), pkValue);\n+        CosmosItemResponse<ObjectNode> itemResponse = container.createItem(properties);\n \n         CosmosQueryRequestOptions cosmosQueryRequestOptions = new CosmosQueryRequestOptions();\n \n-        CosmosPagedIterable<InternalObjectNode> feedResponseIterator1 =\n+        CosmosPagedIterable<ObjectNode> feedResponseIterator1 =\n             container.readAllItems(\n                 new PartitionKey(pkValue),\n                 cosmosQueryRequestOptions,\n-                InternalObjectNode.class);\n+                ObjectNode.class);\n         // Very basic validation\n         assertThat(feedResponseIterator1.iterator().hasNext()).isTrue();\n \n-        CosmosPagedIterable<InternalObjectNode> feedResponseIterator3 =\n+        CosmosPagedIterable<ObjectNode> feedResponseIterator3 =\n             container.readAllItems(\n                 new PartitionKey(pkValue),\n                 cosmosQueryRequestOptions,\n-                InternalObjectNode.class);\n+                ObjectNode.class);\n         assertThat(feedResponseIterator3.iterator().hasNext()).isTrue();\n     }\n \n"}}, {"oid": "3ae465a3129debd58fee56524f4f11af60ed0710", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ae465a3129debd58fee56524f4f11af60ed0710", "message": "Making readAllDocuments partition split safe", "committedDate": "2020-08-26T20:48:55Z", "type": "commit"}, {"oid": "628c150ce8b20a3316e9f58fd7c3acbb9ff4f4c5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/628c150ce8b20a3316e9f58fd7c3acbb9ff4f4c5", "message": "Moving new test in CosmosItemTest to ObjectNode instead of InternalObjectNode", "committedDate": "2020-08-26T21:54:01Z", "type": "commit"}, {"oid": "dcba20bec429ff27bbbbd9c3acdc2e7af00bc623", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dcba20bec429ff27bbbbd9c3acdc2e7af00bc623", "message": "Adding comment that ItemOperations readMany APIs are deprecated", "committedDate": "2020-08-26T22:04:20Z", "type": "commit"}]}