{"pr_number": 16597, "pr_title": "Move JsonPatchDocument from azure-core-experimental to azure-core", "pr_createdAt": "2020-10-20T15:59:38Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16597", "timeline": [{"oid": "e636b4f58bc2184e30475177b997125eb22b7e36", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e636b4f58bc2184e30475177b997125eb22b7e36", "message": "Move JsonPatchDocument from azure-core-experimental to azure-core", "committedDate": "2020-10-20T00:12:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3OTk0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508679947", "bodyText": "wondering whether we really need a Supplier instance or just taking Option is good enough. We seem to invoke the supplier immediately.", "author": "anuchandy", "createdAt": "2020-10-20T16:40:43Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java", "diffHunk": "@@ -89,18 +90,18 @@ public JsonPatchDocument appendAdd(String path, Object value) {\n      *\n      * <p><strong>Code Samples</strong></p>\n      *\n-     * {@codesnippet com.azure.core.experimental.jsonpatch.JsonPatchDocument.appendAddRaw#String-String}\n+     * {@codesnippet com.azure.core.util.jsonpatch.JsonPatchDocument.appendAddRaw#String-String}\n      *\n      * @param path The path to apply the addition.\n      * @param rawJson The raw JSON value that will be added to the path.\n      * @return The updated JsonPatchDocument object.\n      * @throws NullPointerException If {@code path} is null.\n      */\n     public JsonPatchDocument appendAddRaw(String path, String rawJson) {\n-        return appendAddInternal(path, () -> Optional.ofNullable(rawJson));\n+        return appendAddInternal(path, () -> Option.of(rawJson));\n     }\n \n-    private JsonPatchDocument appendAddInternal(String path, Supplier<Optional<String>> jsonSupplier) {\n+    private JsonPatchDocument appendAddInternal(String path, Supplier<Option<String>> jsonSupplier) {", "originalCommit": "e636b4f58bc2184e30475177b997125eb22b7e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzE2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508867161", "bodyText": "Removed, this could be brought back in the future to defer serialization of the Object until serialization or toString is called.", "author": "alzimmermsft", "createdAt": "2020-10-20T22:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3OTk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "433f32832714d0f3889808806be2c18aad395a3d", "chunk": "diff --git a/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java b/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\nindex 83f0fc7dc3e..bf5775161d3 100644\n--- a/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\n+++ b/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\n\n@@ -98,13 +97,13 @@ public class JsonPatchDocument {\n      * @throws NullPointerException If {@code path} is null.\n      */\n     public JsonPatchDocument appendAddRaw(String path, String rawJson) {\n-        return appendAddInternal(path, () -> Option.of(rawJson));\n+        return appendAddInternal(path, Option.of(rawJson));\n     }\n \n-    private JsonPatchDocument appendAddInternal(String path, Supplier<Option<String>> jsonSupplier) {\n+    private JsonPatchDocument appendAddInternal(String path, Option<String> rawJsonOption) {\n         Objects.requireNonNull(path, \"'path' cannot be null.\");\n \n-        return appendOperation(JsonPatchOperationKind.ADD, null, path, jsonSupplier.get());\n+        return appendOperation(JsonPatchOperationKind.ADD, null, path, rawJsonOption);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5MTYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508691607", "bodyText": "not sure but probably static + DCL is safe in latest version of java, I remember spot bug alerting DCL in the past. jfyi, there is also an init-on-demand-holder pattern for these cases which won't require an explicit lock.", "author": "anuchandy", "createdAt": "2020-10-20T16:58:37Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java", "diffHunk": "@@ -236,46 +237,56 @@ public JsonPatchDocument appendTest(String path, Object value) {\n      *\n      * <p><strong>Code Samples</strong></p>\n      *\n-     * {@codesnippet com.azure.core.experimental.jsonpatch.JsonPatchDocument.appendTestRaw#String-String}\n+     * {@codesnippet com.azure.core.util.jsonpatch.JsonPatchDocument.appendTestRaw#String-String}\n      *\n      * @param path The path to test.\n      * @param rawJson The raw JSON value that will be used to test against.\n      * @return The updated JsonPatchDocument object.\n      * @throws NullPointerException If {@code path} is null.\n      */\n     public JsonPatchDocument appendTestRaw(String path, String rawJson) {\n-        return appendTestInternal(path, () -> Optional.ofNullable(rawJson));\n+        return appendTestInternal(path, () -> Option.of(rawJson));\n     }\n \n-    private JsonPatchDocument appendTestInternal(String path, Supplier<Optional<String>> jsonSupplier) {\n+    private JsonPatchDocument appendTestInternal(String path, Supplier<Option<String>> jsonSupplier) {\n         Objects.requireNonNull(path, \"'path' cannot be null.\");\n \n         return appendOperation(JsonPatchOperationKind.TEST, null, path, jsonSupplier.get());\n     }\n \n-    private Optional<String> serializeValue(Object value) {\n+    private Option<String> serializeValue(Object value) {\n         if (value == null) {\n-            return Optional.empty();\n+            return Option.empty();\n         }\n \n         String rawValue;\n         try {\n+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\n             if (serializer == null) {\n-                rawValue = MAPPER.writeValueAsString(value);\n+                if (DEFAULT_SERIALIZER == null) {", "originalCommit": "e636b4f58bc2184e30475177b997125eb22b7e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyMTA3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508721078", "bodyText": "Yeah, I agree that if we want lazy loading use holder pattern. DCL with static might not be safe. If this is a constant then, it should be initialized by the classloader in a static block.", "author": "srnagar", "createdAt": "2020-10-20T17:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5MTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NjkxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508866910", "bodyText": "Made the static violatile.", "author": "alzimmermsft", "createdAt": "2020-10-20T22:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5MTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5Nzc3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16597#discussion_r508897778", "bodyText": "with volatile, happens-before is guaranteed, so DCL should be good now.", "author": "anuchandy", "createdAt": "2020-10-20T23:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5MTYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "433f32832714d0f3889808806be2c18aad395a3d", "chunk": "diff --git a/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java b/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\nindex 83f0fc7dc3e..bf5775161d3 100644\n--- a/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\n+++ b/sdk/core/azure-core/src/main/java/com/azure/core/util/jsonpatch/JsonPatchDocument.java\n\n@@ -245,13 +244,13 @@ public class JsonPatchDocument {\n      * @throws NullPointerException If {@code path} is null.\n      */\n     public JsonPatchDocument appendTestRaw(String path, String rawJson) {\n-        return appendTestInternal(path, () -> Option.of(rawJson));\n+        return appendTestInternal(path, Option.of(rawJson));\n     }\n \n-    private JsonPatchDocument appendTestInternal(String path, Supplier<Option<String>> jsonSupplier) {\n+    private JsonPatchDocument appendTestInternal(String path, Option<String> rawJsonOption) {\n         Objects.requireNonNull(path, \"'path' cannot be null.\");\n \n-        return appendOperation(JsonPatchOperationKind.TEST, null, path, jsonSupplier.get());\n+        return appendOperation(JsonPatchOperationKind.TEST, null, path, rawJsonOption);\n     }\n \n     private Option<String> serializeValue(Object value) {\n"}}, {"oid": "7f788b70780a3d3c86570b4128858b6739cb938b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7f788b70780a3d3c86570b4128858b6739cb938b", "message": "Merge branch 'master' into AzCore_MoveJsonPatchDocument", "committedDate": "2020-10-20T21:28:25Z", "type": "commit"}, {"oid": "433f32832714d0f3889808806be2c18aad395a3d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/433f32832714d0f3889808806be2c18aad395a3d", "message": "Removed circular dependency, fixed lazy JsonSerializer instantiation, removed unnecessary Supplier pattern, created test-only JsonSerializer implementation", "committedDate": "2020-10-20T22:01:13Z", "type": "commit"}, {"oid": "52c92524fc3b3c64cc45e87255ed131f9089db35", "url": "https://github.com/Azure/azure-sdk-for-java/commit/52c92524fc3b3c64cc45e87255ed131f9089db35", "message": "Add missing export to module-info", "committedDate": "2020-10-20T22:03:16Z", "type": "commit"}, {"oid": "e2eb533c215a1fecc894c0e87c9061a9500ed6f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2eb533c215a1fecc894c0e87c9061a9500ed6f8", "message": "Remove exports and opens from azure-core-experimental for jsonpatch", "committedDate": "2020-10-20T22:29:51Z", "type": "commit"}]}