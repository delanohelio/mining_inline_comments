{"pr_number": 17842, "pr_title": "Change scheduler for reactor executor", "pr_createdAt": "2020-11-27T01:38:34Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/17842", "timeline": [{"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3107353c7cabf2879df231a1f90e66a1a83a3f72", "message": "Change scheduler for reactor executor", "committedDate": "2020-11-27T01:30:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531322244", "bodyText": "@conniey Why do we try to acquire the semaphore when closing? We are not doing anything after acquiring the semaphore.", "author": "srnagar", "createdAt": "2020-11-27T01:46:22Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "diffHunk": "@@ -175,14 +175,6 @@ private void scheduleCompletePendingTasks() {\n     public void close() {\n         if (!isDisposed.getAndSet(true)) {\n             close(true, \"ReactorExecutor.close() was called.\");\n-\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }", "originalCommit": "3107353c7cabf2879df231a1f90e66a1a83a3f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxMTU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531711575", "bodyText": "I think this could be removed.\n\nAlso this close() will call scheduleCompletePendingTasks() which again try to acquire the semaphore.\nscheduleCompletePendingTasks() \": This function calls\nreactor.stop();\nreactor.process();\nshouldn't this be called in reverse order i.e.  call reactor.process() first. ?", "author": "hemanttanwar", "createdAt": "2020-11-27T17:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NTIzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r534395234", "bodyText": "the original reason I had added this is because I wanted the rest of the tasks in the task queue to complete before removing the executor.", "author": "conniey", "createdAt": "2020-12-02T18:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537766389", "bodyText": "@conniey This could result in a deadlock as the underlying connection may be closed and the tasks in the queue will not complete and hold on to the semaphore. I profiled this and all the executor threads were stuck waiting to acquire the semaphore.", "author": "srnagar", "createdAt": "2020-12-07T19:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531717399", "bodyText": "Schedulers.single()  always create a daemon thread  and newSingle will create non-daemon thread.\nSo in case of newSingle , Any existing user threads prevent the application from terminating.", "author": "hemanttanwar", "createdAt": "2020-11-27T17:53:55Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "originalCommit": "3107353c7cabf2879df231a1f90e66a1a83a3f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MzgwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r533693803", "bodyText": "There is another API Schedulers.newSingle(String name, boolean daemon) that should be used in this case.", "author": "alzimmermsft", "createdAt": "2020-12-01T20:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537766913", "bodyText": "We discussed this and we didn't want to make this a daemon thread.", "author": "srnagar", "createdAt": "2020-12-07T19:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NTg5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r533695896", "bodyText": "Is there anything we could do to make calls into QPID's Reactor thread safe? If so I'm wondering if it would be safer to use a thread-pooled Scheduler so that we don't create and tear down many, many threads.", "author": "alzimmermsft", "createdAt": "2020-12-01T20:19:45Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.", "originalCommit": "3107353c7cabf2879df231a1f90e66a1a83a3f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTM0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537761345", "bodyText": "I think it is the qpid library that's not thread-safe. So, I don't think we can fix it in this library.", "author": "srnagar", "createdAt": "2020-12-07T19:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NTg5Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NjE1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r534396158", "bodyText": "Since we own this scheduler, we should make sure to dispose of it.", "author": "conniey", "createdAt": "2020-12-02T18:39:23Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "originalCommit": "3107353c7cabf2879df231a1f90e66a1a83a3f72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTk1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537761954", "bodyText": "@conniey we dispose this scheduler it in the ReactorExecutor when close is called.", "author": "srnagar", "createdAt": "2020-12-07T19:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NjE1OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "31ad5d3e01b4316fdfd30789463d9b712d1ebd92", "url": "https://github.com/Azure/azure-sdk-for-java/commit/31ad5d3e01b4316fdfd30789463d9b712d1ebd92", "message": "Move semaphore logic inside user initiated close section", "committedDate": "2020-12-08T04:38:18Z", "type": "commit"}]}