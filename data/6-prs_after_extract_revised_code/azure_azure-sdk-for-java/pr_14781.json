{"pr_number": 14781, "pr_title": "Add models operations to twin lifecycle sample", "pr_createdAt": "2020-09-03T16:44:48Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14781", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExODE3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483118177", "bodyText": ".map(Response::getValue) returns null, which is not a valid return item from a Mono. So we need to map it to Mono.empty() instead.", "author": "abhipsaMisra", "createdAt": "2020-09-03T16:46:19Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -909,7 +909,7 @@ public HttpPipeline getHttpPipeline() {\n     @ServiceMethod(returns = ReturnType.SINGLE)\n     public Mono<Void> deleteModel(String modelId) {\n         return deleteModelWithResponse(modelId)\n-            .map(Response::getValue);\n+            .flatMap(voidResponse -> Mono.empty());", "originalCommit": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExOTE2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483119169", "bodyText": "This implementation is very long and verbose. I am trying to see how I could chain the list and delete operations together, I'll put up an update in the next PR.", "author": "abhipsaMisra", "createdAt": "2020-09-03T16:48:08Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,250 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.", "originalCommit": "9cb2ddef1dfedd2f11a9d60dfbc60f6a26bbab64", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex 812433e8cd3..a1802483fe7 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -244,7 +244,6 @@ public class DigitalTwinsLifecycleAsyncSample {\n         final CountDownLatch createModelsLatch = new CountDownLatch(1);\n \n         // Call API to create the models. For each async operation, once the operation is completed successfully, a latch is counted down.\n-        // TODO: Create is all or none operation??\n         client.createModels(modelsToCreate)\n             .doOnNext(modelData -> System.out.println(\"Created model: \" + modelData.getId()))\n             .doOnError(throwable -> {\n"}}, {"oid": "48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "url": "https://github.com/Azure/azure-sdk-for-java/commit/48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "message": "samples(adt): Add model operations to twin sample", "committedDate": "2020-09-03T16:49:54Z", "type": "commit"}, {"oid": "48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "url": "https://github.com/Azure/azure-sdk-for-java/commit/48c3c3719b5dc9a2b60be934abfc56f70d02ea86", "message": "samples(adt): Add model operations to twin sample", "committedDate": "2020-09-03T16:49:54Z", "type": "forcePushed"}, {"oid": "3f48f680a71b1923b7773bb1092fc2672e571519", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f48f680a71b1923b7773bb1092fc2672e571519", "message": "typo", "committedDate": "2020-09-03T16:53:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyMzE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483123162", "bodyText": "We should have been able to schedule the async API on a single thread, and forced them to run sequentially; however, I didn't have success with that.\nI am blocking the async API call for now, until I figure that out.", "author": "abhipsaMisra", "createdAt": "2020-09-03T16:54:52Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +98,249 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(throwable -> {\n+                    if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"List incoming relationships error: \" + throwable);\n+                    }\n+                })\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(throwable -> {\n+                            if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                                System.err.println(\"List relationships error: \" + throwable);\n+                            }\n+                        })\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n                     .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n+                        if (!(throwable instanceof ErrorResponseException) || ((ErrorResponseException) throwable).getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                            System.err.println(\"Delete twin error: \" + throwable);\n                         }\n                     })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n \n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n+\n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.", "originalCommit": "3f48f680a71b1923b7773bb1092fc2672e571519", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fec01ea7b1d05a4c9efe7d5ada1b2f66b069ecbf", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex 9ef3db99702..407d0ea8831 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -313,7 +313,7 @@ public class DigitalTwinsLifecycleAsyncSample {\n         allRelationships.values().forEach(\n             relationshipContent -> {\n                 try {\n-                    List<BasicRelationship> relationships = mapper.readValue(relationshipContent, new TypeReference<>() { });\n+                    List<BasicRelationship> relationships = mapper.readValue(relationshipContent, new TypeReference<List<BasicRelationship>>() { });\n \n                     // From loaded relationships, get the source Id and Id from each one, and create it with full relationship payload.\n                     relationships\n"}}, {"oid": "fec01ea7b1d05a4c9efe7d5ada1b2f66b069ecbf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fec01ea7b1d05a4c9efe7d5ada1b2f66b069ecbf", "message": "cannot infer type args in anonymous inner classes", "committedDate": "2020-09-03T17:05:05Z", "type": "commit"}, {"oid": "e2ccee82ee92d5bc8620b347a631fe45ce0ccc33", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2ccee82ee92d5bc8620b347a631fe45ce0ccc33", "message": "add static func criteria for ignorning errors", "committedDate": "2020-09-03T19:23:31Z", "type": "commit"}, {"oid": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f02069ded426dc9f8028c6ca8b439650871d2f1f", "message": "remove latch assertions", "committedDate": "2020-09-03T19:26:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483231824", "bodyText": "For each async delete? Can you elaborate what you mean here?", "author": "bikamani", "createdAt": "2020-09-03T20:20:14Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.", "originalCommit": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNDI2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483234266", "bodyText": "What is a latch?", "author": "drwill-ms", "createdAt": "2020-09-03T20:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTc5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483235796", "bodyText": "Appears to be some kind of threadsafe counter, eh?\nI'd reword this to be \"Wait until the latch count reaches zero...\"", "author": "drwill-ms", "createdAt": "2020-09-03T20:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237444", "bodyText": "A countdown latch is a mechanism to block the calling thread until other threads that are running in parallel have completed (counted down). The .countdown() essentially decrements a thread-safe counter.\nFrom this article online: https://www.baeldung.com/java-countdown-latch\nSimply put, a CountDownLatch has a counter field, which you can decrement as we require. We can then use it to block a calling thread until it's been counted down to zero.\nIf we were doing some parallel processing, we could instantiate the CountDownLatch with the same value for the counter as a number of threads we want to work across. Then, we could just call countdown() after each thread finishes, guaranteeing that a dependent thread calling await() will block until the worker threads are finished.", "author": "abhipsaMisra", "createdAt": "2020-09-03T20:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzMTgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex bb4bd7bb6b6..70970ef9081 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -142,9 +142,15 @@ public class DigitalTwinsLifecycleAsyncSample {\n         for (Map.Entry<String, String> twin : twins.entrySet()) {\n             String twinId = twin.getKey();\n \n+            // This list contains all the relations that existing between the twins referenced by this sample.\n             List<BasicRelationship> relationshipList = new ArrayList<>();\n+\n+            // These semaphores indicate when the relationship list and relationship delete operations have completed.\n+            // We cannot use a latch here since we do not know the no. of relationships that will be deleted (so we do cannot set the latch initial count).\n             Semaphore listRelationshipSemaphore = new Semaphore(0);\n             Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+\n+            // This latch is to ensure that we wait for the delete twin operation to complete, before proceeding.\n             CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n \n             // Call APIs to retrieve all relationships.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483235103", "bodyText": "Does Java support string interpolation?", "author": "drwill-ms", "createdAt": "2020-09-03T20:25:43Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());", "originalCommit": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzODg4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483238884", "bodyText": "We can use String.format() to specify a template, but nothing as handy as $ in C#.", "author": "abhipsaMisra", "createdAt": "2020-09-03T20:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNTEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex bb4bd7bb6b6..70970ef9081 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -142,9 +142,15 @@ public class DigitalTwinsLifecycleAsyncSample {\n         for (Map.Entry<String, String> twin : twins.entrySet()) {\n             String twinId = twin.getKey();\n \n+            // This list contains all the relations that existing between the twins referenced by this sample.\n             List<BasicRelationship> relationshipList = new ArrayList<>();\n+\n+            // These semaphores indicate when the relationship list and relationship delete operations have completed.\n+            // We cannot use a latch here since we do not know the no. of relationships that will be deleted (so we do cannot set the latch initial count).\n             Semaphore listRelationshipSemaphore = new Semaphore(0);\n             Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+\n+            // This latch is to ensure that we wait for the delete twin operation to complete, before proceeding.\n             CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n \n             // Call APIs to retrieve all relationships.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzA5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237098", "bodyText": "Unfortunate that you have to know ahead of time how many items you are counting down. This presents a \"magic\" number, which can be confusing to someone else reviewing the code who doesn't realize the significance (this will be used to asynchronously delete 1 dt).\nAlso, in C# we have a general rule of not declaring a variable until it is needed (so it is more contextual). Does Java have a different standard of all variables at the top?\nFWIW, I think this could at least use a comment.", "author": "drwill-ms", "createdAt": "2020-09-03T20:29:46Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);", "originalCommit": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI0MTg5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483241895", "bodyText": "We need to initialize these latches and semaphore within the scope that they are referenced in; but yes, I agree, the count can be confusing to understand.\nI'll add some more comments around this.", "author": "abhipsaMisra", "createdAt": "2020-09-03T20:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex bb4bd7bb6b6..70970ef9081 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -142,9 +142,15 @@ public class DigitalTwinsLifecycleAsyncSample {\n         for (Map.Entry<String, String> twin : twins.entrySet()) {\n             String twinId = twin.getKey();\n \n+            // This list contains all the relations that existing between the twins referenced by this sample.\n             List<BasicRelationship> relationshipList = new ArrayList<>();\n+\n+            // These semaphores indicate when the relationship list and relationship delete operations have completed.\n+            // We cannot use a latch here since we do not know the no. of relationships that will be deleted (so we do cannot set the latch initial count).\n             Semaphore listRelationshipSemaphore = new Semaphore(0);\n             Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+\n+            // This latch is to ensure that we wait for the delete twin operation to complete, before proceeding.\n             CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n \n             // Call APIs to retrieve all relationships.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIzNzcxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483237713", "bodyText": "If Java doesn't have string interpolation, I'd think this would be much more readable as a string format (like below).", "author": "drwill-ms", "createdAt": "2020-09-03T20:31:08Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java", "diffHunk": "@@ -88,108 +100,220 @@ public static void main(String[] args) throws IOException, InterruptedException\n         // Ensure existing twins with the same name are deleted first\n         deleteTwins();\n \n+        // Delete existing models\n+        deleteAllModels();\n+\n+        // Create all the models\n+        createAllModels();\n+\n+        // Get all models\n+        listAllModels();\n+\n         // Create twin counterparts for all the models\n-        createTwins();\n+        createAllTwins();\n+\n+        // TODO: Get all twins\n+        // queryTwins();\n+\n+        // Create all the relationships\n+        connectTwinsTogether();\n+\n+        // TODO: Creating event route\n+        // createEventRoute();\n+\n+        // TODO: Get all event routes\n+        // listEventRoutes();\n+\n+        // TODO: Deleting event route\n+        // deleteEventRoute();\n     }\n \n     /**\n      * Delete a twin, and any relationships it might have.\n      * @throws IOException If an I/O error is thrown when accessing the starting file.\n-     * @throws InterruptedException If the current thread is interrupted while waiting to acquire permits on a semaphore.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n      */\n     public static void deleteTwins() throws IOException, InterruptedException {\n         System.out.println(\"DELETE DIGITAL TWINS\");\n         Map<String, String> twins = FileHelper.loadAllFilesInPath(TwinsPath);\n-        final Semaphore deleteTwinsSemaphore = new Semaphore(0);\n-        final Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n \n         // Call APIs to clean up any pre-existing resources that might be referenced by this sample. If digital twin does not exist, ignore.\n-        twins\n-            .forEach((twinId, twinContent) -> {\n-                // Call APIs to delete all relationships.\n-                client.listRelationships(twinId, BasicRelationship.class)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        relationship -> client.deleteRelationship(twinId, relationship.getId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted relationship: \" + relationship.getId()),\n-                                throwable -> System.err.println(\"Delete relationship error: \" + throwable)\n-                            ));\n-\n-                // Call APIs to delete any incoming relationships.\n-                client.listIncomingRelationships(twinId)\n-                    .doOnComplete(deleteRelationshipsSemaphore::release)\n-                    .doOnError(throwable -> {\n-                        if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                            deleteRelationshipsSemaphore.release();\n-                        } else {\n-                            System.err.println(\"List incoming relationships error: \" + throwable);\n-                        }\n-                    })\n-                    .subscribe(\n-                        incomingRelationship -> client.deleteRelationship(incomingRelationship.getSourceId(), incomingRelationship.getRelationshipId())\n-                            .subscribe(\n-                                aVoid -> System.out.println(\"Found and deleted incoming relationship: \" + incomingRelationship.getRelationshipId()),\n-                                throwable -> System.err.println(\"Delete incoming relationship error: \" + throwable)\n-                            ));\n+        // Once the async API terminates (either successfully, or with an error), the latch count is decremented, or the semaphore is released.\n+        for (Map.Entry<String, String> twin : twins.entrySet()) {\n+            String twinId = twin.getKey();\n+\n+            List<BasicRelationship> relationshipList = new ArrayList<>();\n+            Semaphore listRelationshipSemaphore = new Semaphore(0);\n+            Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+            CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n+\n+            // Call APIs to retrieve all relationships.\n+            client.listRelationships(twinId, BasicRelationship.class)\n+                .doOnNext(relationshipList::add)\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to retrieve all incoming relationships.\n+            client.listIncomingRelationships(twinId)\n+                .doOnNext(e -> relationshipList.add(mapper.convertValue(e, BasicRelationship.class)))\n+                .doOnError(IgnoreNotFoundError)\n+                .doOnTerminate(listRelationshipSemaphore::release)\n+                .subscribe();\n+\n+            // Call APIs to delete all relationships.\n+            if (listRelationshipSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                relationshipList\n+                    .forEach(relationship -> client.deleteRelationship(relationship.getSourceId(), relationship.getId())\n+                        .doOnSuccess(aVoid -> {\n+                            if (twinId.equals(relationship.getSourceId())) {\n+                                System.out.println(\"Found and deleted relationship: \" + relationship.getId());\n+                            } else {\n+                                System.out.println(\"Found and deleted incoming relationship: \" + relationship.getId());\n+                            }\n+                        })\n+                        .doOnError(IgnoreNotFoundError)\n+                        .doOnTerminate(deleteRelationshipsSemaphore::release)\n+                        .subscribe());\n+            }\n+\n+            // Verify that the relationships have been deleted.\n+            if (deleteRelationshipsSemaphore.tryAcquire(relationshipList.size(), MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n+                // Now the digital twin should be safe to delete\n+\n+                // Call APIs to delete the twins.\n+                client.deleteDigitalTwin(twinId)\n+                    .doOnSuccess(aVoid -> System.out.println(\"Deleted digital twin: \" + twinId))\n+                    .doOnError(IgnoreNotFoundError)\n+                    .doOnTerminate(deleteTwinsLatch::countDown)\n+                    .subscribe();\n+\n+                // Wait until the latch has been counted down for each async delete operation, signifying that the async call has completed successfully.\n+                deleteTwinsLatch.await(MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete models created by FullLifecycleSample for the ADT service instance.\n+     * @throws InterruptedException If the current thread is interrupted while waiting to acquire latch.\n+     */\n+    public static void deleteAllModels() throws InterruptedException {\n+        System.out.println(\"DELETING MODELS\");\n+\n+        // This is to ensure models are deleted in an order such that no other models are referencing it.\n+        List<String> models = asList(RoomModelId, WifiModelId, BuildingModelId, FloorModelId, HvacModelId);\n \n+        // Call APIs to delete the models.\n+        // Note that we are blocking the async API call. This is to ensure models are deleted in an order such that no other models are referencing it.\n+        models\n+            .forEach(modelId -> {\n                 try {\n-                    // Verify that the list relationships and list incoming relationships async operations have completed.\n-                    if (deleteRelationshipsSemaphore.tryAcquire(2, MaxWaitTimeAsyncOperationsInSeconds, TimeUnit.SECONDS)) {\n-                        // Now the digital twin should be safe to delete\n-\n-                        // Call APIs to delete the twins.\n-                        client.deleteDigitalTwin(twinId)\n-                            .doOnSuccess(aVoid -> {\n-                                System.out.println(\"Deleted digital twin: \" + twinId);\n-                                deleteTwinsSemaphore.release();\n-                            })\n-                            .doOnError(throwable -> {\n-                                if (throwable instanceof ErrorResponseException && ((ErrorResponseException) throwable).getResponse().getStatusCode() == HttpStatus.SC_NOT_FOUND) {\n-                                    deleteTwinsSemaphore.release();\n-                                } else {\n-                                    System.err.println(\"Could not delete digital twin \" + twinId + \" due to \" + throwable);\n-                                }\n-                            })\n-                            .subscribe();\n+                    client.deleteModel(modelId).block();\n+                    System.out.println(\"Deleted model: \" + modelId);\n+                } catch (ErrorResponseException ex) {\n+                    if (ex.getResponse().getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n+                        System.err.println(\"Could not delete model \" + modelId + \" due to \" + ex);", "originalCommit": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "chunk": "diff --git a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\nindex bb4bd7bb6b6..70970ef9081 100644\n--- a/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n+++ b/sdk/digitaltwins/azure-digitaltwins-core/src/samples/java/com/azure/digitaltwins/core/DigitalTwinsLifecycleAsyncSample.java\n\n@@ -142,9 +142,15 @@ public class DigitalTwinsLifecycleAsyncSample {\n         for (Map.Entry<String, String> twin : twins.entrySet()) {\n             String twinId = twin.getKey();\n \n+            // This list contains all the relations that existing between the twins referenced by this sample.\n             List<BasicRelationship> relationshipList = new ArrayList<>();\n+\n+            // These semaphores indicate when the relationship list and relationship delete operations have completed.\n+            // We cannot use a latch here since we do not know the no. of relationships that will be deleted (so we do cannot set the latch initial count).\n             Semaphore listRelationshipSemaphore = new Semaphore(0);\n             Semaphore deleteRelationshipsSemaphore = new Semaphore(0);\n+\n+            // This latch is to ensure that we wait for the delete twin operation to complete, before proceeding.\n             CountDownLatch deleteTwinsLatch = new CountDownLatch(1);\n \n             // Call APIs to retrieve all relationships.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyMTMzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14781#discussion_r483221331", "bodyText": "Oops", "author": "azabbasi", "createdAt": "2020-09-03T19:59:40Z", "path": "sdk/digitaltwins/azure-digitaltwins-core/src/main/java/com/azure/digitaltwins/core/DigitalTwinsAsyncClient.java", "diffHunk": "@@ -788,7 +788,7 @@ public HttpPipeline getHttpPipeline() {\n                         objectPagedResponse.getHeaders(),\n                         convertedList,\n                         null,\n-                        ((PagedResponseBase) objectPagedResponse).getDeserializedHeaders());\n+                        ((ResponseBase) objectPagedResponse).getDeserializedHeaders());", "originalCommit": "f02069ded426dc9f8028c6ca8b439650871d2f1f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c3212ab6ce4a0fe33c5dcc3bc1df0437ae2ec535", "message": "added additional comments", "committedDate": "2020-09-03T21:51:37Z", "type": "commit"}, {"oid": "267370dcc1c6a32bfa56e8c7b90beb2a5fb41711", "url": "https://github.com/Azure/azure-sdk-for-java/commit/267370dcc1c6a32bfa56e8c7b90beb2a5fb41711", "message": "typo", "committedDate": "2020-09-03T21:57:43Z", "type": "commit"}, {"oid": "c94e5d98aa687357a16c3afcb5497065e366e126", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c94e5d98aa687357a16c3afcb5497065e366e126", "message": "add comments", "committedDate": "2020-09-03T21:59:56Z", "type": "commit"}]}