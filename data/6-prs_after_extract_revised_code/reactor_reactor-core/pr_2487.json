{"pr_number": 2487, "pr_title": "fix #1518 Add cold variants of TestPublisher", "pr_createdAt": "2020-11-13T15:16:51Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2487", "timeline": [{"oid": "757413be4ef97a5fc21f6db43eb600f5fb85fe81", "url": "https://github.com/reactor/reactor-core/commit/757413be4ef97a5fc21f6db43eb600f5fb85fe81", "message": "Add support for Violations, polish API.", "committedDate": "2020-11-17T09:14:57Z", "type": "forcePushed"}, {"oid": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "url": "https://github.com/reactor/reactor-core/commit/c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "message": "Add support for Violations, polish API.", "committedDate": "2020-11-17T09:18:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTc0OQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525001749", "bodyText": "shouldn't it check for emitTerminalSignalIfAny() here too?", "author": "simonbasle", "createdAt": "2020-11-17T09:22:21Z", "path": "reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java", "diffHunk": "@@ -226,6 +221,76 @@ void onComplete() {\n \t\t\tparent.remove(this);\n \t\t\tactual.onComplete();\n \t\t}\n+\n+\t\tprivate void drain(long n) {\n+\t\t\tint i = index;\n+\t\t\tint emitted = 0;\n+\t\t\tfor ( ; ; ) {\n+\t\t\t\tif (cancelled) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (i != parent.values.size()) {\n+\t\t\t\t\tif (emitted == n && !parent.violations.contains(REQUEST_OVERFLOW)) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tT t = parent.values.get(i);\n+\t\t\t\t\tif (t == null && !parent.violations.contains(ALLOW_NULL)) {\n+\t\t\t\t\t\tactual.onError(new NullPointerException(\"The \" + i + \"th element was null\"));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (this.onNext(t)) {\n+\t\t\t\t\t\temitted++;\n+\t\t\t\t\t}\n+\t\t\t\t\ti++;\n+\t\t\t\t\tif (cancelled) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tn = requested;\n+\t\t\t\tif (emitted > n) {\n+\t\t\t\t\tassert parent.violations.contains(Violation.REQUEST_OVERFLOW);\n+\t\t\t\t\tparent.hasOverflown = true;\n+\t\t\t\t\treturn;", "originalCommit": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxNjA3Mg==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525016072", "bodyText": "It could indeed. That branch is the very exceptional case I thought, leaving the publisher in a \"bad state\" state, but it could go the extra mile and also emit terminal signals (which should be also protected against)", "author": "ericbottard", "createdAt": "2020-11-17T09:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\nindex bfd3e4f10..93edb17fb 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n\n@@ -221,76 +216,6 @@ final class ColdTestPublisher<T> extends TestPublisher<T> {\n \t\t\tparent.remove(this);\n \t\t\tactual.onComplete();\n \t\t}\n-\n-\t\tprivate void drain(long n) {\n-\t\t\tint i = index;\n-\t\t\tint emitted = 0;\n-\t\t\tfor ( ; ; ) {\n-\t\t\t\tif (cancelled) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twhile (i != parent.values.size()) {\n-\t\t\t\t\tif (emitted == n && !parent.violations.contains(REQUEST_OVERFLOW)) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tT t = parent.values.get(i);\n-\t\t\t\t\tif (t == null && !parent.violations.contains(ALLOW_NULL)) {\n-\t\t\t\t\t\tactual.onError(new NullPointerException(\"The \" + i + \"th element was null\"));\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (this.onNext(t)) {\n-\t\t\t\t\t\temitted++;\n-\t\t\t\t\t}\n-\t\t\t\t\ti++;\n-\t\t\t\t\tif (cancelled) {\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tn = requested;\n-\t\t\t\tif (emitted > n) {\n-\t\t\t\t\tassert parent.violations.contains(Violation.REQUEST_OVERFLOW);\n-\t\t\t\t\tparent.hasOverflown = true;\n-\t\t\t\t\treturn;\n-\t\t\t\t} else if (n == emitted) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\tn = REQUESTED.addAndGet(this, -emitted);\n-\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (n == 0) {\n-\t\t\t\t\t\tif (parent.errorOnOverflow) {\n-\t\t\t\t\t\t\tthis.onError(Exceptions.failWithOverflow(\"Can't deliver value due to lack of requests\"));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\temitted = 0;\n-\t\t\t\t} else if (n == Long.MAX_VALUE) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\temitted = 0;\n-\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (i == parent.values.size()) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate void emitTerminalSignalIfAny() {\n-\t\t\tif (parent.error == Exceptions.TERMINATED) {\n-\t\t\t\tthis.onComplete();\n-\t\t\t}\n-\t\t\telse if (parent.error != null) {\n-\t\t\t\tthis.onError(parent.error);\n-\t\t\t}\n-\t\t}\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMzUwNg==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525003506", "bodyText": "wouldn't it be possible for the drain to have no parameter, computing the n from its latest requested state?", "author": "simonbasle", "createdAt": "2020-11-17T09:24:59Z", "path": "reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java", "diffHunk": "@@ -338,23 +403,29 @@ public boolean wasRequested() {\n \n \t@Override\n \tpublic ColdTestPublisher<T> assertRequestOverflow() {\n-\t\t//the cold publisher cannot really overflow requests, as it immediately throws\n-\t\tthrow new AssertionError(\"Expected some request overflow\");\n+\t\tif (!hasOverflown) {\n+\t\t\tthrow new AssertionError(\"Expected some request overflow\");\n+\t\t}\n+\t\treturn this;\n \t}\n \n \t@Override\n \tpublic ColdTestPublisher<T> assertNoRequestOverflow() {\n-\t\t//the cold publisher cannot really overflow requests, as it immediately throws\n+\t\tif (hasOverflown) {\n+\t\t\tthrow new AssertionError(\"Unexpected request overflow\");\n+\t\t}\n \t\treturn this;\n \t}\n \n \t@Override\n \tpublic ColdTestPublisher<T> next(@Nullable T t) {\n-\t\tObjects.requireNonNull(t, \"emitted values must be non-null\");\n+\t\tif (!violations.contains(ALLOW_NULL)) {\n+\t\t\tObjects.requireNonNull(t, \"emitted values must be non-null\");\n+\t\t}\n \n \t\tvalues.add(t);\n \t\tfor (ColdTestPublisherSubscription<T> s : subscribers) {\n-\t\t\ts.onNext(t);\n+\t\t\ts.drain(s.requested);", "originalCommit": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxOTg5OQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525019899", "bodyText": "I've always been puzzled by that myself everywhere we see this construct, but I guess for the case where it is called from request(n) we can't, can we?\n\t\tpublic void request(long n) {\n\t\t\tif (Operators.validate(n)) {\n\t\t\t\tif (Operators.addCap(REQUESTED, this, n) == 0) {\n\t\t\t\t\tparent.wasRequested = true;\n\t\t\t\t\tdrain(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}", "author": "ericbottard", "createdAt": "2020-11-17T09:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMzUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMDcxNQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525020715", "bodyText": "Actually, we can, since it is only called if total request now equals n. Hmmm \ud83e\udd14", "author": "ericbottard", "createdAt": "2020-11-17T09:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMzUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\nindex bfd3e4f10..93edb17fb 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n\n@@ -403,29 +328,23 @@ final class ColdTestPublisher<T> extends TestPublisher<T> {\n \n \t@Override\n \tpublic ColdTestPublisher<T> assertRequestOverflow() {\n-\t\tif (!hasOverflown) {\n-\t\t\tthrow new AssertionError(\"Expected some request overflow\");\n-\t\t}\n-\t\treturn this;\n+\t\t//the cold publisher cannot really overflow requests, as it immediately throws\n+\t\tthrow new AssertionError(\"Expected some request overflow\");\n \t}\n \n \t@Override\n \tpublic ColdTestPublisher<T> assertNoRequestOverflow() {\n-\t\tif (hasOverflown) {\n-\t\t\tthrow new AssertionError(\"Unexpected request overflow\");\n-\t\t}\n+\t\t//the cold publisher cannot really overflow requests, as it immediately throws\n \t\treturn this;\n \t}\n \n \t@Override\n \tpublic ColdTestPublisher<T> next(@Nullable T t) {\n-\t\tif (!violations.contains(ALLOW_NULL)) {\n-\t\t\tObjects.requireNonNull(t, \"emitted values must be non-null\");\n-\t\t}\n+\t\tObjects.requireNonNull(t, \"emitted values must be non-null\");\n \n \t\tvalues.add(t);\n \t\tfor (ColdTestPublisherSubscription<T> s : subscribers) {\n-\t\t\ts.drain(s.requested);\n+\t\t\ts.onNext(t);\n \t\t}\n \n \t\treturn this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNTY0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525005645", "bodyText": "drain has to be guarded by a WIP in order to avoid parallel drains (since there is no restriction on which thread calls next from the TestPublisher API vs request from the Subscription API)", "author": "simonbasle", "createdAt": "2020-11-17T09:28:01Z", "path": "reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java", "diffHunk": "@@ -226,6 +221,76 @@ void onComplete() {\n \t\t\tparent.remove(this);\n \t\t\tactual.onComplete();\n \t\t}\n+\n+\t\tprivate void drain(long n) {", "originalCommit": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\nindex bfd3e4f10..93edb17fb 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n\n@@ -221,76 +216,6 @@ final class ColdTestPublisher<T> extends TestPublisher<T> {\n \t\t\tparent.remove(this);\n \t\t\tactual.onComplete();\n \t\t}\n-\n-\t\tprivate void drain(long n) {\n-\t\t\tint i = index;\n-\t\t\tint emitted = 0;\n-\t\t\tfor ( ; ; ) {\n-\t\t\t\tif (cancelled) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\n-\t\t\t\twhile (i != parent.values.size()) {\n-\t\t\t\t\tif (emitted == n && !parent.violations.contains(REQUEST_OVERFLOW)) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tT t = parent.values.get(i);\n-\t\t\t\t\tif (t == null && !parent.violations.contains(ALLOW_NULL)) {\n-\t\t\t\t\t\tactual.onError(new NullPointerException(\"The \" + i + \"th element was null\"));\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (this.onNext(t)) {\n-\t\t\t\t\t\temitted++;\n-\t\t\t\t\t}\n-\t\t\t\t\ti++;\n-\t\t\t\t\tif (cancelled) {\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tn = requested;\n-\t\t\t\tif (emitted > n) {\n-\t\t\t\t\tassert parent.violations.contains(Violation.REQUEST_OVERFLOW);\n-\t\t\t\t\tparent.hasOverflown = true;\n-\t\t\t\t\treturn;\n-\t\t\t\t} else if (n == emitted) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\tn = REQUESTED.addAndGet(this, -emitted);\n-\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (n == 0) {\n-\t\t\t\t\t\tif (parent.errorOnOverflow) {\n-\t\t\t\t\t\t\tthis.onError(Exceptions.failWithOverflow(\"Can't deliver value due to lack of requests\"));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t\temitted = 0;\n-\t\t\t\t} else if (n == Long.MAX_VALUE) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\temitted = 0;\n-\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t} else if (i == parent.values.size()) {\n-\t\t\t\t\tindex = i;\n-\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate void emitTerminalSignalIfAny() {\n-\t\t\tif (parent.error == Exceptions.TERMINATED) {\n-\t\t\t\tthis.onComplete();\n-\t\t\t}\n-\t\t\telse if (parent.error != null) {\n-\t\t\t\tthis.onError(parent.error);\n-\t\t\t}\n-\t\t}\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNjU1MA==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525006550", "bodyText": "it only caches if boolean errorOnOverflow is false", "author": "simonbasle", "createdAt": "2020-11-17T09:29:21Z", "path": "reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java", "diffHunk": "@@ -72,13 +75,43 @@\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * Note that this type of {@link Publisher} isn't\n+\t * The returned publisher will buffer values if there is not enough request from subscribers.\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>();\n+\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n+\t}\n+\n+\t/**\n+\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n+\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n+\t * all subscribers upon subscription.\n+\t * <p>\n+\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n+\t *\n+\t * @param <T> the type of the publisher\n+\t * @return the new {@link TestPublisher}\n+\t */\n+\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n+\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n+\t}\n+\n+\t/**\n+\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n+\t * subscribers. It caches the {@link #next(Object)} events and replays them to", "originalCommit": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxNzE0OA==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525017148", "bodyText": "No, it accumulates values and replays them to new subscribers in all cases. The boolean flag only drives what happens when there is more (total) request than values in the values buffer: wait for more request, or error().", "author": "ericbottard", "createdAt": "2020-11-17T09:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MDg4Nw==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525080887", "bodyText": "ok then I'd rephrase the second paragraph in createCold and createColdNonBuffering above, then. Will comment there.", "author": "simonbasle", "createdAt": "2020-11-17T11:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwNjU1MA=="}], "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\nindex b86b5b4be..d881c5635 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n\n@@ -75,43 +72,13 @@ public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * The returned publisher will buffer values if there is not enough request from subscribers.\n+\t * Note that this type of {@link Publisher} isn't\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n-\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will be non-compliant to the spec according to one or more {@link Violation}s. In addition,\n-\t * its behavior when there is more data than {@link Subscription#request(long) requested} can be set via {@code errorOnOverflow}.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @param errorOnOverflow whether to throw an exception if there are more values than request (true) or buffer values until request becomes available (false)\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonCompliant(boolean errorOnOverflow, Violation firstViolation, Violation... otherViolations) {\n-\t\treturn new ColdTestPublisher<>(errorOnOverflow, EnumSet.of(firstViolation, otherViolations));\n+\t\treturn new ColdTestPublisher<>();\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwODczNQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525008735", "bodyText": "If that test is made that way because the StepVerifier complains that it's under-requesting when adding an expectNext(\"bar\"), that under-requesting check can be disabled using StepVerifierOptions (namely, StepVerifierOptions#checkUnderRequesting(false)).", "author": "simonbasle", "createdAt": "2020-11-17T09:32:24Z", "path": "reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java", "diffHunk": "@@ -111,6 +124,21 @@ public void coldDisallowsOverflow() {\n \t\tpublisher.assertNoRequestOverflow();\n \t}\n \n+\t@Test\n+\tpublic void misbehavingAllowsOverflow() {\n+\t\tTestPublisher<String> publisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.REQUEST_OVERFLOW);\n+\n+\t\tassertThatExceptionOfType(AssertionError.class)", "originalCommit": "c3b7017b8cc7f08a894c9b8a36963c964eaffa99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAxODE5MQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525018191", "bodyText": "I'm not sure I get what you mean by \"made that way\" (do you mean using assertThatExceptionOfType().isThrownBy() (ie direct exception)?).\nThat test was copied and adapted from the DefaultTestPublisher IIRC.", "author": "ericbottard", "createdAt": "2020-11-17T09:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwODczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMTc2MQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r528621761", "bodyText": "after looking at the test again, it appears it is fine, nevermind", "author": "simonbasle", "createdAt": "2020-11-23T11:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwODczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java b/reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java\nindex 0f227a4bf..857284057 100644\n--- a/reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java\n+++ b/reactor-test/src/test/java/reactor/test/publisher/ColdTestPublisherTests.java\n\n@@ -124,21 +111,6 @@ public class ColdTestPublisherTests {\n \t\tpublisher.assertNoRequestOverflow();\n \t}\n \n-\t@Test\n-\tpublic void misbehavingAllowsOverflow() {\n-\t\tTestPublisher<String> publisher = TestPublisher.createColdNonCompliant(false, TestPublisher.Violation.REQUEST_OVERFLOW);\n-\n-\t\tassertThatExceptionOfType(AssertionError.class)\n-\t\t\t\t.isThrownBy(() -> StepVerifier.create(publisher, 1)\n-\t\t\t\t\t\t.then(() -> publisher.emit(\"foo\", \"bar\"))\n-\t\t\t\t\t\t.expectNext(\"foo\")\n-\t\t\t\t\t\t.verifyComplete())\n-\t\t\t\t.withMessageContaining(\"expected production of at most 1;\");\n-\n-\t\tpublisher.assertRequestOverflow();\n-\t}\n-\n-\n \t@Test\n \tpublic void coldAllowsMultipleReplayOnSubscribe() {\n \t\tTestPublisher<String> publisher = TestPublisher.createCold();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NTc2OA==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525085768", "bodyText": "Let's use buffers instead of caches. Also, rephrase the and replays... part to something more along the lines of:\n\nand tracks how many elements have been seen by each subscriber in order to correctly replay the buffer to each subscriber, with backpressure.", "author": "simonbasle", "createdAt": "2020-11-17T11:33:48Z", "path": "reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java", "diffHunk": "@@ -72,13 +75,43 @@\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to", "originalCommit": "cc0585c3a52f64d5607db7ace79c88b604c97145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgxNjM1Mg==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r527816352", "bodyText": "fixed in polish: javadoc, formatting and null detection 84d0afe", "author": "simonbasle", "createdAt": "2020-11-20T16:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NTc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\nindex b86b5b4be..d881c5635 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n\n@@ -75,43 +72,13 @@ public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * The returned publisher will buffer values if there is not enough request from subscribers.\n+\t * Note that this type of {@link Publisher} isn't\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n-\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will be non-compliant to the spec according to one or more {@link Violation}s. In addition,\n-\t * its behavior when there is more data than {@link Subscription#request(long) requested} can be set via {@code errorOnOverflow}.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @param errorOnOverflow whether to throw an exception if there are more values than request (true) or buffer values until request becomes available (false)\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonCompliant(boolean errorOnOverflow, Violation firstViolation, Violation... otherViolations) {\n-\t\treturn new ColdTestPublisher<>(errorOnOverflow, EnumSet.of(firstViolation, otherViolations));\n+\t\treturn new ColdTestPublisher<>();\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4NjIyOQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525086229", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * The returned publisher will buffer values if there is not enough request from subscribers.\n          \n          \n            \n            \t * The publisher honors backpressure, holding off emitting newest items\n          \n          \n            \n            \t * from the buffer if the subscriber doesn't have enough request.", "author": "simonbasle", "createdAt": "2020-11-17T11:34:34Z", "path": "reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java", "diffHunk": "@@ -72,13 +75,43 @@\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * Note that this type of {@link Publisher} isn't\n+\t * The returned publisher will buffer values if there is not enough request from subscribers.", "originalCommit": "cc0585c3a52f64d5607db7ace79c88b604c97145", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\nindex b86b5b4be..d881c5635 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n\n@@ -75,43 +72,13 @@ public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * The returned publisher will buffer values if there is not enough request from subscribers.\n+\t * Note that this type of {@link Publisher} isn't\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n-\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will be non-compliant to the spec according to one or more {@link Violation}s. In addition,\n-\t * its behavior when there is more data than {@link Subscription#request(long) requested} can be set via {@code errorOnOverflow}.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @param errorOnOverflow whether to throw an exception if there are more values than request (true) or buffer values until request becomes available (false)\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonCompliant(boolean errorOnOverflow, Violation firstViolation, Violation... otherViolations) {\n-\t\treturn new ColdTestPublisher<>(errorOnOverflow, EnumSet.of(firstViolation, otherViolations));\n+\t\treturn new ColdTestPublisher<>();\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4ODg2Nw==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525088867", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n          \n          \n            \n            \t * all subscribers upon subscription.\n          \n          \n            \n            \t * <p>\n          \n          \n            \n            \t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n          \n          \n            \n            \t * subscribers. It buffers the {@link #next(Object)} events and tracks how many\n          \n          \n            \n            \t * elements have been seen by each subscriber in order to correctly replay the\n          \n          \n            \n            \t * buffer.\n          \n          \n            \n            \t * <p>\n          \n          \n            \n            \t * The returned publisher will emit an overflow error if a new subscriber's\n          \n          \n            \n            \t * first request is lower than the current buffer size, or if a new element\n          \n          \n            \n            \t * is pushed to a registered subscriber that has zero pending demand.", "author": "simonbasle", "createdAt": "2020-11-17T11:39:25Z", "path": "reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java", "diffHunk": "@@ -72,13 +75,43 @@\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * Note that this type of {@link Publisher} isn't\n+\t * The returned publisher will buffer values if there is not enough request from subscribers.\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>();\n+\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n+\t}\n+\n+\t/**\n+\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n+\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n+\t * all subscribers upon subscription.\n+\t * <p>\n+\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.", "originalCommit": "cc0585c3a52f64d5607db7ace79c88b604c97145", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\nindex b86b5b4be..d881c5635 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n\n@@ -75,43 +72,13 @@ public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * The returned publisher will buffer values if there is not enough request from subscribers.\n+\t * Note that this type of {@link Publisher} isn't\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n-\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will be non-compliant to the spec according to one or more {@link Violation}s. In addition,\n-\t * its behavior when there is more data than {@link Subscription#request(long) requested} can be set via {@code errorOnOverflow}.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @param errorOnOverflow whether to throw an exception if there are more values than request (true) or buffer values until request becomes available (false)\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonCompliant(boolean errorOnOverflow, Violation firstViolation, Violation... otherViolations) {\n-\t\treturn new ColdTestPublisher<>(errorOnOverflow, EnumSet.of(firstViolation, otherViolations));\n+\t\treturn new ColdTestPublisher<>();\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4OTc4MQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r525089781", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n          \n          \n            \n            \t * all subscribers upon subscription.\n          \n          \n            \n            \t * subscribers. It buffers the {@link #next(Object)} events and tracks how many\n          \n          \n            \n            \t * elements have been seen by each subscriber in order to correctly replay the\n          \n          \n            \n            \t * buffer.", "author": "simonbasle", "createdAt": "2020-11-17T11:40:53Z", "path": "reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java", "diffHunk": "@@ -72,13 +75,43 @@\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * Note that this type of {@link Publisher} isn't\n+\t * The returned publisher will buffer values if there is not enough request from subscribers.\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>();\n+\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n+\t}\n+\n+\t/**\n+\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n+\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n+\t * all subscribers upon subscription.\n+\t * <p>\n+\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n+\t *\n+\t * @param <T> the type of the publisher\n+\t * @return the new {@link TestPublisher}\n+\t */\n+\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n+\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n+\t}\n+\n+\t/**\n+\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n+\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n+\t * all subscribers upon subscription.", "originalCommit": "cc0585c3a52f64d5607db7ace79c88b604c97145", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f45e9ef1ca54a682830998abda438ff06d76c69e", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\nindex b86b5b4be..d881c5635 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/TestPublisher.java\n\n@@ -75,43 +72,13 @@ public abstract class TestPublisher<T> implements Publisher<T>, PublisherProbe<T\n \t * subscribers. It caches the {@link #next(Object)} events and replays them to\n \t * all subscribers upon subscription.\n \t * <p>\n-\t * The returned publisher will buffer values if there is not enough request from subscribers.\n+\t * Note that this type of {@link Publisher} isn't\n \t *\n \t * @param <T> the type of the publisher\n \t * @return the new {@link TestPublisher}\n \t */\n \tpublic static <T> TestPublisher<T> createCold() {\n-\t\treturn new ColdTestPublisher<>(false, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will emit an overflow error if there is not enough request from subscribers.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonBuffering() {\n-\t\treturn new ColdTestPublisher<>(true, EnumSet.noneOf(Violation.class));\n-\t}\n-\n-\t/**\n-\t * Create a cold {@link TestPublisher}, which can be subscribed to by multiple\n-\t * subscribers. It caches the {@link #next(Object)} events and replays them to\n-\t * all subscribers upon subscription.\n-\t * <p>\n-\t * The returned publisher will be non-compliant to the spec according to one or more {@link Violation}s. In addition,\n-\t * its behavior when there is more data than {@link Subscription#request(long) requested} can be set via {@code errorOnOverflow}.\n-\t *\n-\t * @param <T> the type of the publisher\n-\t * @param errorOnOverflow whether to throw an exception if there are more values than request (true) or buffer values until request becomes available (false)\n-\t * @return the new {@link TestPublisher}\n-\t */\n-\tpublic static <T> TestPublisher<T> createColdNonCompliant(boolean errorOnOverflow, Violation firstViolation, Violation... otherViolations) {\n-\t\treturn new ColdTestPublisher<>(errorOnOverflow, EnumSet.of(firstViolation, otherViolations));\n+\t\treturn new ColdTestPublisher<>();\n \t}\n \n \t/**\n"}}, {"oid": "f45e9ef1ca54a682830998abda438ff06d76c69e", "url": "https://github.com/reactor/reactor-core/commit/f45e9ef1ca54a682830998abda438ff06d76c69e", "message": "fix: remove unnecessary code into ColdTestPublisher #1518", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "2bdd2e315240ef6ffed53427eae4a253b4aa9d23", "url": "https://github.com/reactor/reactor-core/commit/2bdd2e315240ef6ffed53427eae4a253b4aa9d23", "message": "fix: manage 3 different behaviors for ColdTestPublisher (Misbehave, Error, Backpressure)", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "2c4a5b82dffbb61738fc9a29485316c3d77e9595", "url": "https://github.com/reactor/reactor-core/commit/2c4a5b82dffbb61738fc9a29485316c3d77e9595", "message": "Support request in ColdTestPublisher", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "180075aa54224abb23ae7b9af09f0e8be04f842f", "url": "https://github.com/reactor/reactor-core/commit/180075aa54224abb23ae7b9af09f0e8be04f842f", "message": "Support fusion", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "8c5c95485c50d1155da405686cbd5a00821b9af3", "url": "https://github.com/reactor/reactor-core/commit/8c5c95485c50d1155da405686cbd5a00821b9af3", "message": "Fix on overflow support in some tests", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "eb57257eac5235e1f68578782dff529fb2899419", "url": "https://github.com/reactor/reactor-core/commit/eb57257eac5235e1f68578782dff529fb2899419", "message": "Add support for Violations, polish API.", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "22b48018a062a3b02425f39e0bddb7475bd5f705", "url": "https://github.com/reactor/reactor-core/commit/22b48018a062a3b02425f39e0bddb7475bd5f705", "message": "Remove argument to drain()", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "476e9a0826f54d30e27ca08d2ae37ba3230d6bef", "url": "https://github.com/reactor/reactor-core/commit/476e9a0826f54d30e27ca08d2ae37ba3230d6bef", "message": "Protect drain() from parallel invocations", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "1fd7dedc22e4096bc6aaca64542127af1eacef17", "url": "https://github.com/reactor/reactor-core/commit/1fd7dedc22e4096bc6aaca64542127af1eacef17", "message": "Apply suggestions from code review\n\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>", "committedDate": "2020-11-18T10:25:24Z", "type": "commit"}, {"oid": "1fd7dedc22e4096bc6aaca64542127af1eacef17", "url": "https://github.com/reactor/reactor-core/commit/1fd7dedc22e4096bc6aaca64542127af1eacef17", "message": "Apply suggestions from code review\n\nCo-authored-by: Simon Basl\u00e9 <sbasle@vmware.com>", "committedDate": "2020-11-18T10:25:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY0MzQ2MQ==", "url": "https://github.com/reactor/reactor-core/pull/2487#discussion_r527643461", "bodyText": "you need to perform that check atomically in the decrementAndGet at the end of the loop, rather than here, otherwise it defeats the purpose:\n\nthread A wins the guard and goes into the loop\nthread B looses and exits\nthread A does a first loop, decrements\nthread A does a second loop, corresponding to thread B's event\nthread A decrements to 0\nthread C enters drain and wins the guard (swapping from 0 to 1)\nthread A reads WIP and sees 1\n\ud83d\udc1b both A and C enter the loop and clash", "author": "simonbasle", "createdAt": "2020-11-20T11:56:49Z", "path": "reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java", "diffHunk": "@@ -226,6 +226,95 @@ void onComplete() {\n \t\t\tparent.remove(this);\n \t\t\tactual.onComplete();\n \t\t}\n+\n+\t\tprivate void drain() {\n+\t\t\tif (WIP.getAndIncrement(this) == 0) {\n+\t\t\t\twhile (WIP.get(this) > 0) {", "originalCommit": "1fd7dedc22e4096bc6aaca64542127af1eacef17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ed4dcd5e961c7949d1cf1c9a82c371248b2574d", "chunk": "diff --git a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\nindex c3204ac70..ff950c007 100644\n--- a/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n+++ b/reactor-test/src/main/java/reactor/test/publisher/ColdTestPublisher.java\n\n@@ -228,83 +228,80 @@ final class ColdTestPublisher<T> extends TestPublisher<T> {\n \t\t}\n \n \t\tprivate void drain() {\n-\t\t\tif (WIP.getAndIncrement(this) == 0) {\n-\t\t\t\twhile (WIP.get(this) > 0) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tlong r = requested;\n-\t\t\t\t\t\tint i = index;\n-\t\t\t\t\t\tint emitted = 0;\n-\t\t\t\t\t\tfor (; ; ) {\n-\t\t\t\t\t\t\tif (cancelled) {\n-\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t}\n+\t\t\tif (WIP.getAndIncrement(this) > 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tdo {\n+\t\t\t\tinner:\n+\t\t\t\tfor (; ; ) {\n+\t\t\t\t\tint i = index;\n+\t\t\t\t\tlong r = requested; // Re-read the volatile 'requested' which could have grown via another thread\n+\t\t\t\t\tint emitted = 0;\n+\t\t\t\t\tif (cancelled) {\n+\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t}\n \n-\t\t\t\t\t\t\twhile (i != parent.values.size()) {\n-\t\t\t\t\t\t\t\tif (emitted == r && !parent.violations.contains(REQUEST_OVERFLOW)) {\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tT t = parent.values.get(i);\n-\t\t\t\t\t\t\t\tif (t == null && !parent.violations.contains(ALLOW_NULL)) {\n-\t\t\t\t\t\t\t\t\tactual.onError(new NullPointerException(\"The \" + i + \"th element was null\"));\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tif (this.onNext(t)) {\n-\t\t\t\t\t\t\t\t\temitted++;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\ti++;\n-\t\t\t\t\t\t\t\tif (cancelled) {\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\tint s = parent.values.size(); // This list can only grow while we're in drain()\n+\t\t\t\t\twhile (i < s) {\n+\t\t\t\t\t\tif (emitted == r && !parent.violations.contains(REQUEST_OVERFLOW)) {\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tT t = parent.values.get(i);\n+\t\t\t\t\t\tif (t == null && !parent.violations.contains(ALLOW_NULL)) {\n+\t\t\t\t\t\t\tactual.onError(new NullPointerException(\"The \" + i + \"th element was null\"));\n+\t\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tr = requested;\n-\t\t\t\t\t\t\tif (emitted > r) {\n-\t\t\t\t\t\t\t\tassert parent.violations.contains(Violation.REQUEST_OVERFLOW);\n-\t\t\t\t\t\t\t\tparent.hasOverflown = true;\n-\t\t\t\t\t\t\t\tindex = i;\n-\t\t\t\t\t\t\t\tREQUESTED.addAndGet(this, -emitted);\n-\t\t\t\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse if (r == emitted) {\n-\t\t\t\t\t\t\t\tindex = i;\n-\t\t\t\t\t\t\t\tr = REQUESTED.addAndGet(this, -emitted);\n-\t\t\t\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (r == 0) {\n-\t\t\t\t\t\t\t\t\tif (parent.errorOnOverflow) {\n-\t\t\t\t\t\t\t\t\t\tthis.onError(Exceptions\n-\t\t\t\t\t\t\t\t\t\t\t\t.failWithOverflow(\"Can't deliver value due to lack of requests\"));\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\temitted = 0;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse if (r == Long.MAX_VALUE) {\n-\t\t\t\t\t\t\t\tindex = i;\n-\t\t\t\t\t\t\t\temitted = 0;\n-\t\t\t\t\t\t\t\tif (i == parent.values.size()) {\n-\t\t\t\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse if (i == parent.values.size()) {\n-\t\t\t\t\t\t\t\tindex = i;\n-\t\t\t\t\t\t\t\temitTerminalSignalIfAny();\n-\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\tif (this.onNext(t)) {\n+\t\t\t\t\t\t\temitted++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\t\tif (cancelled) {\n+\t\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (emitted > r) {\n+\t\t\t\t\t\tassert parent.violations.contains(Violation.REQUEST_OVERFLOW);\n+\t\t\t\t\t\tparent.hasOverflown = true;\n+\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\tREQUESTED.addAndGet(this, -emitted);\n+\t\t\t\t\t\tif (i == s) {\n+\t\t\t\t\t\t\temitTerminalSignalIfAny();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (emitted == r) {\n+\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\t// using r2 just for the test below, r will be re-read in the outer loop anyway\n+\t\t\t\t\t\tlong r2 = REQUESTED.addAndGet(this, -emitted);\n+\t\t\t\t\t\tif (i == s) {\n+\t\t\t\t\t\t\temitTerminalSignalIfAny();\n+\t\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (r2 == 0) {\n+\t\t\t\t\t\t\tif (parent.errorOnOverflow) {\n+\t\t\t\t\t\t\t\tthis.onError(Exceptions\n+\t\t\t\t\t\t\t\t\t\t.failWithOverflow(\"Can't deliver value due to lack of requests\"));\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak inner;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (r == Long.MAX_VALUE) {\n+\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\tif (i == s) {\n+\t\t\t\t\t\t\temitTerminalSignalIfAny();\n+\t\t\t\t\t\t\tbreak inner;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tfinally {\n-\t\t\t\t\t\tWIP.decrementAndGet(this);\n+\t\t\t\t\telse if (i == s) {\n+\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\temitTerminalSignalIfAny();\n+\t\t\t\t\t\tbreak inner;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\twhile (WIP.decrementAndGet(this) > 0);\n \t\t}\n \n \t\tprivate void emitTerminalSignalIfAny() {\n"}}, {"oid": "3ed4dcd5e961c7949d1cf1c9a82c371248b2574d", "url": "https://github.com/reactor/reactor-core/commit/3ed4dcd5e961c7949d1cf1c9a82c371248b2574d", "message": "Fix WIP access", "committedDate": "2020-11-20T15:09:19Z", "type": "commit"}, {"oid": "3ed4dcd5e961c7949d1cf1c9a82c371248b2574d", "url": "https://github.com/reactor/reactor-core/commit/3ed4dcd5e961c7949d1cf1c9a82c371248b2574d", "message": "Fix WIP access", "committedDate": "2020-11-20T15:09:19Z", "type": "forcePushed"}, {"oid": "84d0afe277fe01cbff9428fc70328731a6030127", "url": "https://github.com/reactor/reactor-core/commit/84d0afe277fe01cbff9428fc70328731a6030127", "message": "polish: javadoc, formatting and null detection", "committedDate": "2020-11-20T16:21:34Z", "type": "commit"}, {"oid": "f8047eb0e1b0e70c9adb3a49fce28eee714b67d2", "url": "https://github.com/reactor/reactor-core/commit/f8047eb0e1b0e70c9adb3a49fce28eee714b67d2", "message": "fix bug that prevents draining from incremental requests", "committedDate": "2020-11-20T16:22:16Z", "type": "commit"}, {"oid": "7b1ab09cd7f361b6f9e87141637213fa27e8c855", "url": "https://github.com/reactor/reactor-core/commit/7b1ab09cd7f361b6f9e87141637213fa27e8c855", "message": "Rework the whole drain loop, simplify it further", "committedDate": "2020-11-20T16:23:52Z", "type": "commit"}, {"oid": "f3e9835cc5b13f7e2c72a530901fe8d48ba7dc46", "url": "https://github.com/reactor/reactor-core/commit/f3e9835cc5b13f7e2c72a530901fe8d48ba7dc46", "message": "Polish inner next/error/complete methods: clearer name and consistent use", "committedDate": "2020-11-20T16:40:15Z", "type": "commit"}, {"oid": "93ad489195bfdf4b18585b5c099d2361b58fbd1e", "url": "https://github.com/reactor/reactor-core/commit/93ad489195bfdf4b18585b5c099d2361b58fbd1e", "message": "inline doTryNext doComplete doError", "committedDate": "2020-11-23T10:53:29Z", "type": "commit"}]}