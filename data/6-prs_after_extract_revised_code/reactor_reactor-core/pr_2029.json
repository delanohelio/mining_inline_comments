{"pr_number": 2029, "pr_title": "fix #1937 Account for requests made to upstream in FluxBufferPredicate", "pr_createdAt": "2020-02-04T14:12:11Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2029", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MDAwMg==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r374790002", "bodyText": "two times requestedBuffers ?", "author": "robotmrv", "createdAt": "2020-02-04T16:45:23Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -144,7 +151,8 @@ public void request(long n) {\n \t\t\t\t\t// here we request everything from the source. switching to\n \t\t\t\t\t// fastpath will avoid unnecessary request(1) during filling\n \t\t\t\t\tfastpath = true;\n-\t\t\t\t\trequested = Long.MAX_VALUE;\n+\t\t\t\t\trequestedBuffers = Long.MAX_VALUE;\n+\t\t\t\t\trequestedBuffers = Long.MAX_VALUE;", "originalCommit": "931fac02054b9d605113e583951285a0cf8564b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgxNjYyMQ==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r374816621", "bodyText": "nice catch \ud83d\ude05", "author": "simonbasle", "createdAt": "2020-02-04T17:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MDAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\nindex 9cec8bca0..670edd3dd 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n\n@@ -152,7 +152,7 @@ final class FluxBufferPredicate<T, C extends Collection<? super T>>\n \t\t\t\t\t// fastpath will avoid unnecessary request(1) during filling\n \t\t\t\t\tfastpath = true;\n \t\t\t\t\trequestedBuffers = Long.MAX_VALUE;\n-\t\t\t\t\trequestedBuffers = Long.MAX_VALUE;\n+\t\t\t\t\trequestedFromSource = Long.MAX_VALUE;\n \t\t\t\t\ts.request(Long.MAX_VALUE);\n \t\t\t\t}\n \t\t\t\telse {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk3OA==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r374853978", "bodyText": "should not it be added by Operators#addCap() ?", "author": "robotmrv", "createdAt": "2020-02-04T18:45:23Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -156,11 +164,11 @@ public void request(long n) {\n \t\t\t\t\t// we'll continue requesting one by one)\n \t\t\t\t\tif (!DrainUtils.postCompleteRequest(n,\n \t\t\t\t\t\t\tactual,\n-\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\tREQUESTED,\n+\t\t\t\t\t\t\tthis, REQUESTED_BUFFERS,\n \t\t\t\t\t\t\tthis,\n \t\t\t\t\t\t\tthis)) {\n-\t\t\t\t\t\ts.request(1);\n+\t\t\t\t\t\tREQUESTED_FROM_SOURCE.addAndGet(this, n);", "originalCommit": "5fbb1670cd7538510c9c338c2a5784d2d121f1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzMDkxMg==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375130912", "bodyText": "indeed better to use capped add \ud83d\udc4d", "author": "simonbasle", "createdAt": "2020-02-05T09:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1Mzk3OA=="}], "type": "inlineReview", "revised_code": {"commit": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\nindex ccd4b0a9d..670edd3dd 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n\n@@ -167,7 +167,7 @@ final class FluxBufferPredicate<T, C extends Collection<? super T>>\n \t\t\t\t\t\t\tthis, REQUESTED_BUFFERS,\n \t\t\t\t\t\t\tthis,\n \t\t\t\t\t\t\tthis)) {\n-\t\t\t\t\t\tREQUESTED_FROM_SOURCE.addAndGet(this, n);\n+\t\t\t\t\t\tOperators.addCap(REQUESTED_FROM_SOURCE, this, n);\n \t\t\t\t\t\ts.request(n);\n \t\t\t\t\t}\n \t\t\t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3NjgyOA==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375476828", "bodyText": "it will take a lot of time to go down to zero, but anyway why to decrement for a fast path?", "author": "robotmrv", "createdAt": "2020-02-05T19:58:45Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -205,25 +213,31 @@ public boolean tryOnNext(T t) {\n \t\t\t\treturn true;\n \t\t\t}\n \n-\t\t\tboolean requestMore;\n \t\t\tif (mode == Mode.UNTIL && match) {\n \t\t\t\tb.add(t);\n-\t\t\t\trequestMore = onNextNewBuffer();\n+\t\t\t\tonNextNewBuffer();\n \t\t\t}\n \t\t\telse if (mode == Mode.UNTIL_CUT_BEFORE && match) {\n-\t\t\t\trequestMore = onNextNewBuffer();\n+\t\t\t\tonNextNewBuffer();\n \t\t\t\tb = buffer;\n \t\t\t\tb.add(t);\n \t\t\t}\n \t\t\telse if (mode == Mode.WHILE && !match) {\n-\t\t\t\trequestMore = onNextNewBuffer();\n+\t\t\t\tonNextNewBuffer();\n \t\t\t}\n \t\t\telse {\n \t\t\t\tb.add(t);\n-\t\t\t\treturn !(!fastpath && requested != 0);\n \t\t\t}\n \n-\t\t\treturn !requestMore;\n+\t\t\tboolean isNotExpectingFromSource = REQUESTED_FROM_SOURCE.decrementAndGet(this) == 0;", "originalCommit": "c799f2837ce2194677611201d7e35983c560ddb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxNTYyMw==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375715623", "bodyText": "not sure what you mean. maybe that this decrement operation should be skipped in case fastpath == true ?", "author": "simonbasle", "createdAt": "2020-02-06T09:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3NjgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxNzU4Ng==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375717586", "bodyText": "we need to keep separate track of \"how many buffers are wanted by downstream\" (REQUESTED_BUFFERS) vs \"how many elements have been requested upstream\" (REQUESTED_FROM_SOURCE), so that when we're filling a buffer and we see that said buffer is not yet full, we only ask the source for one more element IFF there is no pending request to it already. Otherwise, we know that we should soon receive at least another element which might fulfill the buffer.", "author": "simonbasle", "createdAt": "2020-02-06T09:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3NjgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NDU3NQ==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375754575", "bodyText": "maybe that this decrement operation should be skipped in case fastpath == true ?\n\nyes, I mean this", "author": "robotmrv", "createdAt": "2020-02-06T10:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3NjgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk0OTEwMQ==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r375949101", "bodyText": "updated, by extracting if (fastpath) return true; we take care of the fastpath case more clearly and avoid these atomic operations altogether", "author": "simonbasle", "createdAt": "2020-02-06T16:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3NjgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\nindex d60744a0a..670edd3dd 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java\n\n@@ -229,13 +229,15 @@ final class FluxBufferPredicate<T, C extends Collection<? super T>>\n \t\t\t\tb.add(t);\n \t\t\t}\n \n+\t\t\tif (fastpath) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n \t\t\tboolean isNotExpectingFromSource = REQUESTED_FROM_SOURCE.decrementAndGet(this) == 0;\n \t\t\tboolean isStillExpectingBuffer = REQUESTED_BUFFERS.get(this) > 0;\n-\n-\t\t\tif (!fastpath && isNotExpectingFromSource && isStillExpectingBuffer) {\n-\t\t\t\tif (REQUESTED_FROM_SOURCE.compareAndSet(this, 0, 1)) {\n-\t\t\t\t\treturn false; //explicitly mark as \"needing more\", either in attached conditional or onNext()\n-\t\t\t\t}\n+\t\t\tif (isNotExpectingFromSource && isStillExpectingBuffer\n+\t\t\t\t\t&& REQUESTED_FROM_SOURCE.compareAndSet(this, 0, 1)) {\n+\t\t\t\treturn false; //explicitly mark as \"needing more\", either in attached conditional or onNext()\n \t\t\t}\n \t\t\treturn true;\n \t\t}\n"}}, {"oid": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "url": "https://github.com/reactor/reactor-core/commit/5ee7910e14b2a5aa80562320593eff67ba15ecfb", "message": "fix #1937 Account for requests made to upstream in FluxBufferPredicate\n\nThis commit adds additional request accounting to FluxBufferPredicate,\nallowing it to keep track of when there is remaining upstream request\nand when there is not. In turn, this allows the \"just add to buffer\"\ncase to perform an additional `request(1)` ONLY if necessary (to further\nfill the current buffer).", "committedDate": "2020-02-07T09:21:21Z", "type": "commit"}, {"oid": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "url": "https://github.com/reactor/reactor-core/commit/5ee7910e14b2a5aa80562320593eff67ba15ecfb", "message": "fix #1937 Account for requests made to upstream in FluxBufferPredicate\n\nThis commit adds additional request accounting to FluxBufferPredicate,\nallowing it to keep track of when there is remaining upstream request\nand when there is not. In turn, this allows the \"just add to buffer\"\ncase to perform an additional `request(1)` ONLY if necessary (to further\nfill the current buffer).", "committedDate": "2020-02-07T09:21:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwMTIzMQ==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r376301231", "bodyText": "@simonbasle I have one question about that you said before\n#2027 (comment)\n\na Subscriber is responsible for ensuring the upstream requests it makes are not done in parallel (rule 2.7) so that line MUST NOT be executed at the same time\n\nas far as I understand s.request() could be invoked from BufferPredicateSubscriber#request() and from BufferPredicateSubscriber#onNext() and they could be invoked by different Threads.\nHow does rule 2.7 is satisfied here or it is not applicable here?", "author": "robotmrv", "createdAt": "2020-02-07T09:48:28Z", "path": "reactor-core/src/main/java/reactor/core/publisher/FluxBufferPredicate.java", "diffHunk": "@@ -156,11 +164,11 @@ public void request(long n) {\n \t\t\t\t\t// we'll continue requesting one by one)\n \t\t\t\t\tif (!DrainUtils.postCompleteRequest(n,\n \t\t\t\t\t\t\tactual,\n-\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\tREQUESTED,\n+\t\t\t\t\t\t\tthis, REQUESTED_BUFFERS,\n \t\t\t\t\t\t\tthis,\n \t\t\t\t\t\t\tthis)) {\n-\t\t\t\t\t\ts.request(1);\n+\t\t\t\t\t\tOperators.addCap(REQUESTED_FROM_SOURCE, this, n);\n+\t\t\t\t\t\ts.request(n);", "originalCommit": "5ee7910e14b2a5aa80562320593eff67ba15ecfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMTI1OA==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r376331258", "bodyText": "mmh with the REQUESTED_FROM_SOURCE guard, but we indeed don't really use that to ensure n is correct here.\nlet's unpack that a little:\n\naddCap should lose to compareAndSet (other writes \"happens before\")\nsince parallel requests are illegal, the only way addCap loses is if compareAndSet switched from 0 to 1, so at that point requestedFromSource == 0 or 1\nit should thus be safe to use the return value of addCap (0 or 1) as a modifier to n for the parent request:\n\nlong delta = Operators.addCap(REQUESTED_FROM_SOURCE, this, n);\ns.request(n - delta);", "author": "simonbasle", "createdAt": "2020-02-07T10:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwMTIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQxNzU1OQ==", "url": "https://github.com/reactor/reactor-core/pull/2029#discussion_r376417559", "bodyText": "the above doesn't seem to be necessary. I have added tests around racing request and onNext and validated the current code doesn't lead to backpressure errors.", "author": "simonbasle", "createdAt": "2020-02-07T14:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwMTIzMQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "cd9ed6a4b1e00a2a66422bb423bc75e005271948", "url": "https://github.com/reactor/reactor-core/commit/cd9ed6a4b1e00a2a66422bb423bc75e005271948", "message": "Add tests to ensure no overflow when request and onNext race", "committedDate": "2020-02-07T14:27:02Z", "type": "commit"}]}