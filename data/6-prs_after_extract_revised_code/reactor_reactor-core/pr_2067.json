{"pr_number": 2067, "pr_title": "fix #2055 Flux#from and Mono#flux apply onAssembly hooks", "pr_createdAt": "2020-03-09T15:57:20Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2067", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390870386", "bodyText": "WDYT about splitting it into multiple tests (maybe with some parameterization)?\nIt will be a bit weird when we break one to not know which one exactly :)", "author": "bsideup", "createdAt": "2020-03-11T10:20:13Z", "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java", "diffHunk": "@@ -1591,6 +1593,48 @@ public void splitBugEventuallyHappens() throws Exception {\n \n \t}\n \n+\t@Test\n+\tpublic void fluxFromCallsAssemblyHook() {", "originalCommit": "eca636e5a66bcad7211ad9c0cc8e307d13ec1d07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwNjU0OQ==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390906549", "bodyText": "I could split and do the whole onEachOperator ceremony in multiple shorter tests, but note that we'll know which case breaks exactly thanks to the as description of each assert...", "author": "simonbasle", "createdAt": "2020-03-11T11:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkxNjk2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r390916963", "bodyText": "btw resetOnEachOperator can to go @AfterTest, so that the test becomes a 2-3 liner\nas is nice, but I have bad memory about debugging sequential tests (at least without soft assertions) \ud83d\ude05", "author": "bsideup", "createdAt": "2020-03-11T11:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3MDM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "28bebd02482f36161955392ed69c0959f0503da4", "chunk": "diff --git a/reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java b/reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java\nindex c49581de1..5b70866d1 100644\n--- a/reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java\n+++ b/reactor-core/src/test/java/reactor/core/publisher/scenarios/FluxTests.java\n\n@@ -1594,45 +1603,189 @@ public class FluxTests extends AbstractReactorTest {\n \t}\n \n \t@Test\n-\tpublic void fluxFromCallsAssemblyHook() {\n-\t\tFlux<Integer> fluxSource = Flux.range(1, 10);\n-\t\tMono<String> scalarJust = Mono.just(\"scalarJust\");\n-\t\tMono<String> scalarError = Mono.error(new IllegalStateException(\"scalarError\"));\n-\t\tMono<String> scalarEmpty = Mono.empty();\n-\t\tMono<String> monoFuseable = Mono.just(\"monoFuseable\").map(i -> i);\n-\t\tMono<String> monoNormal = Mono.just(\"monoNormal\").hide().map(i -> i);\n+\tpublic void fluxFromFluxSourceDoesntCallAssemblyHook() {\n+\t\tfinal Flux<Integer> source = Flux.range(1, 10);\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(0);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromScalarJustCallsAssemblyHook() {\n+\t\tfinal Mono<String> source = Mono.just(\"scalarJust\");\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromScalarErrorCallsAssemblyHook() {\n+\t\tfinal Mono<Object> source = Mono.error(new IllegalStateException(\"scalarError\"));\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromScalarEmptyCallsAssemblyHook() {\n+\t\tfinal Mono<Object> source = Mono.empty();\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromMonoFuseableCallsAssemblyHook() {\n+\t\tMono<String> source = Mono.just(\"monoFuseable\").map(i -> i);\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromMonoNormalCallsAssemblyHook() {\n+\t\tfinal Mono<String> source = Mono.just(\"monoNormal\")\n+\t\t                                .hide()\n+\t\t                                .map(i -> i);\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tFlux.from(source);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxFromPublisherCallsAssemblyHook() {\n \t\tPublisher<String> publisher = sub -> sub.onSubscribe(Operators.emptySubscription());\n \n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n \t\tAtomicInteger wrappedCount = new AtomicInteger();\n \t\tHooks.onEachOperator(p -> {\n \t\t\twrappedCount.incrementAndGet();\n \t\t\treturn p;\n \t\t});\n-\t\ttry {\n-\t\t\tFlux.from(fluxSource);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"fluxSource not wrapped\").hasValue(0);\n \n-\t\t\tFlux.from(scalarJust);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"scalarJust wrapped\").hasValue(1);\n+\t\tFlux.from(publisher);\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxNextScalarEmptyCallsAssemblyHook() {\n+\t\tFlux<Integer> source = Flux.empty();\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n \n-\t\t\tFlux.from(scalarError);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"scalarError wrapped\").hasValue(2);\n+\t\tsource.next();\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n \n-\t\t\tFlux.from(scalarEmpty);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"scalarEmpty wrapped\").hasValue(3);\n+\t@Test\n+\tpublic void fluxNextScalarValuedCallsAssemblyHook() {\n+\t\tFlux<Integer> source = Flux.just(1);\n \n-\t\t\tFlux.from(monoFuseable);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"monoFuseable wrapped\").hasValue(4);\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n \n-\t\t\tFlux.from(monoNormal);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"monoNormal wrapped\").hasValue(5);\n+\t\tsource.next();\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n \n-\t\t\tFlux.from(publisher);\n-\t\t\tAssertions.assertThat(wrappedCount).as(\"publisher wrapped\").hasValue(6);\n-\t\t}\n-\t\tfinally {\n-\t\t\tHooks.resetOnEachOperator();\n-\t\t}\n+\t@Test\n+\tpublic void fluxNextScalarErrorCallsAssemblyHook() {\n+\t\tFlux<Integer> source = Flux.error(new IllegalStateException(\"boom\"));\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tsource.next();\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxNextCallableCallsAssemblyHook() {\n+\t\tFlux<Integer> source = Mono.fromCallable(() -> 1).flux();\n+\t\tAssertions.assertThat(source) //smoke test that we go into the right case\n+\t\t          .isInstanceOf(Callable.class)\n+\t\t          .isNotInstanceOf(Mono.class)\n+\t\t          .isNotInstanceOf(Fuseable.ScalarCallable.class);\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tsource.next();\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n+\t}\n+\n+\t@Test\n+\tpublic void fluxNextNormalCallsAssemblyHook() {\n+\t\tFlux<Integer> source = Flux.range(1, 10);\n+\n+\t\t//set the hook AFTER the original operators have been invoked (since they trigger assembly themselves)\n+\t\tAtomicInteger wrappedCount = new AtomicInteger();\n+\t\tHooks.onEachOperator(p -> {\n+\t\t\twrappedCount.incrementAndGet();\n+\t\t\treturn p;\n+\t\t});\n+\n+\t\tsource.next();\n+\t\tAssertions.assertThat(wrappedCount).hasValue(1);\n \t}\n \n \tprivate static final long TIMEOUT = 10_000;\n"}}, {"oid": "28bebd02482f36161955392ed69c0959f0503da4", "url": "https://github.com/reactor/reactor-core/commit/28bebd02482f36161955392ed69c0959f0503da4", "message": "fix #2055 Flux#from and Mono#flux apply onAssembly hooks + wrap API\n\nThis commit streamlines the from vs wrap semantics of conversions,\nwhere `wrap` is introduced in `Mono` (also as a package private method).\n\nAdditionally the `from` methods delegates a maximum to `wrap`, and the\n`wrap` semantics are exposed in the public API in `Hooks`. This is\nbecause the differentiator is that these methods don't apply hooks,\nwhich makes them potentially valuable in setting up simple assembly\nhooks.\n\nWe also take that commit as an opportunity to improve the lift operators\n`stepName()` method, which delegates to the lifted publisher.", "committedDate": "2020-03-13T15:39:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5MzI2NA==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397093264", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif(source instanceof Fuseable){\n          \n          \n            \n            \t\tif(source instanceof Fuseable) {", "author": "bsideup", "createdAt": "2020-03-24T11:49:56Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Mono.java", "diffHunk": "@@ -4532,6 +4529,57 @@ public String toString() {\n \t\t\t\tonCancel));\n \t}\n \n+\t/**\n+\t * Unchecked wrap of {@link Publisher} as {@link Mono}, supporting {@link Fuseable} sources.\n+\t * When converting a {@link Mono} or {@link Mono Monos} that have been converted to a {@link Flux} and back,\n+\t * the original {@link Mono} is returned unwrapped.\n+\t * Note that this bypasses {@link Hooks#onEachOperator(String, Function) assembly hooks}.\n+\t *\n+\t * @param source the {@link Publisher} to wrap\n+\t * @param enforceMonoContract {@code} true to wrap publishers without assumption about their cardinality\n+\t * (first {@link Subscriber#onNext(Object)} will cancel the source), {@code false} to behave like {@link #fromDirect(Publisher)}.\n+\t * @param <T> input upstream type\n+\t * @return a wrapped {@link Mono}\n+\t */\n+\tstatic <T> Mono<T> wrap(Publisher<T> source, boolean enforceMonoContract) {\n+\t\t//some sources can be considered already assembled monos\n+\t\t//all conversion methods (from, fromDirect, wrap) must accommodate for this\n+\t\tif (source instanceof Mono) {\n+\t\t\treturn (Mono<T>) source;\n+\t\t}\n+\t\tif (source instanceof FluxSourceMono\n+\t\t\t\t|| source instanceof FluxSourceMonoFuseable) {\n+\t\t\tFluxFromMonoOperator<T, T> wrapper = (FluxFromMonoOperator<T,T>) source;\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\tMono<T> extracted = (Mono<T>) wrapper.source;\n+\t\t\treturn extracted;\n+\t\t}\n+\n+\t\t//equivalent to what from used to be, without assembly hooks\n+\t\tif (enforceMonoContract) {\n+\t\t\tif (source instanceof Flux && source instanceof Callable) {\n+\t\t\t\t\t@SuppressWarnings(\"unchecked\") Callable<T> m = (Callable<T>) source;\n+\t\t\t\t\treturn Flux.wrapToMono(m);\n+\t\t\t}\n+\t\t\tif (source instanceof Flux) {\n+\t\t\t\treturn new MonoNext<>((Flux<T>) source);\n+\t\t\t}\n+\t\t\treturn new MonoFromPublisher<>(source);\n+\t\t}\n+\n+\t\t//equivalent to what fromDirect used to be without onAssembly\n+\t\tif(source instanceof Flux && source instanceof Fuseable) {\n+\t\t\treturn new MonoSourceFluxFuseable<>((Flux<T>) source);\n+\t\t}\n+\t\tif (source instanceof Flux) {\n+\t\t\treturn new MonoSourceFlux<>((Flux<T>) source);\n+\t\t}\n+\t\tif(source instanceof Fuseable){", "originalCommit": "28bebd02482f36161955392ed69c0959f0503da4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "226abf213a7713ce082ad55e0aa2b96260d9f52c", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/Mono.java b/reactor-core/src/main/java/reactor/core/publisher/Mono.java\nindex 1821ec385..6cd3bd838 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/Mono.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/Mono.java\n\n@@ -4574,7 +4574,7 @@ public abstract class Mono<T> implements Publisher<T> {\n \t\tif (source instanceof Flux) {\n \t\t\treturn new MonoSourceFlux<>((Flux<T>) source);\n \t\t}\n-\t\tif(source instanceof Fuseable){\n+\t\tif(source instanceof Fuseable) {\n \t\t\treturn new MonoSourceFuseable<>(source);\n \t\t}\n \t\treturn new MonoSource<>(source);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5NTMwOA==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397095308", "bodyText": "May I ask why not parameterized? :)", "author": "bsideup", "createdAt": "2020-03-24T11:53:45Z", "path": "reactor-core/src/test/java/reactor/core/publisher/scenarios/MonoTests.java", "diffHunk": "@@ -304,4 +314,156 @@ public void monoCacheContextHistory() {\n \t\tAssertions.assertThat(cacheHit3).as(\"cacheHit3\").isEqualTo(\"GOOD1\");\n \t\tAssertions.assertThat(contextFillCount).as(\"cacheHit3\").hasValue(4);\n \t}\n+\n+\t@Test\n+\tpublic void monoFromMonoDoesntCallAssemblyHook() {\n+\t\tfinal Mono<Integer> source = Mono.just(1);", "originalCommit": "28bebd02482f36161955392ed69c0959f0503da4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE0Nzc4MQ==", "url": "https://github.com/reactor/reactor-core/pull/2067#discussion_r397147781", "bodyText": "didn't go through the trouble, as splitting the test was enough vs changing the test runner and dealing with the boilerplate of providing params (plus with independent tests the name can reflect the style of source, not the concrete name of the operator used)", "author": "simonbasle", "createdAt": "2020-03-24T13:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA5NTMwOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "06c9ec87297aea14723b652aa103d70db5567c04", "url": "https://github.com/reactor/reactor-core/commit/06c9ec87297aea14723b652aa103d70db5567c04", "message": "fix #2055 Flux#from and Mono#flux apply onAssembly hooks + wrap API\n\nThis commit streamlines the from vs wrap semantics of conversions,\nwhere `wrap` is introduced in `Mono` (also as a package private method).\n\nAdditionally the `from` methods delegates a maximum to `wrap`, and the\n`wrap` semantics are exposed in the public API in `Hooks`. This is\nbecause the differentiator is that these methods don't apply hooks,\nwhich makes them potentially valuable in setting up simple assembly\nhooks.\n\nWe also take that commit as an opportunity to improve the lift operators\n`stepName()` method, which delegates to the lifted publisher.", "committedDate": "2020-03-31T18:01:23Z", "type": "commit"}, {"oid": "226abf213a7713ce082ad55e0aa2b96260d9f52c", "url": "https://github.com/reactor/reactor-core/commit/226abf213a7713ce082ad55e0aa2b96260d9f52c", "message": "formatting: add missing space\n\nCo-Authored-By: Sergei Egorov <1050762+bsideup@users.noreply.github.com>", "committedDate": "2020-03-31T18:01:23Z", "type": "commit"}, {"oid": "226abf213a7713ce082ad55e0aa2b96260d9f52c", "url": "https://github.com/reactor/reactor-core/commit/226abf213a7713ce082ad55e0aa2b96260d9f52c", "message": "formatting: add missing space\n\nCo-Authored-By: Sergei Egorov <1050762+bsideup@users.noreply.github.com>", "committedDate": "2020-03-31T18:01:23Z", "type": "forcePushed"}]}