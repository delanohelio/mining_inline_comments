{"pr_number": 2392, "pr_title": "Add multicast sink with best effort/drop on backpressure", "pr_createdAt": "2020-09-21T10:36:20Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2392", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTA1OA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491945058", "bodyText": "\"all cancelled\" is not handled", "author": "bsideup", "createdAt": "2020-09-21T10:40:09Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MTQzMg==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491981432", "bodyText": "it does fall through to the second looping, but yeah I should check length == cancelledCount early in that loop too", "author": "simonbasle", "createdAt": "2020-09-21T11:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\nindex 2d8c6ae77..b6f96a25b 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n\n@@ -94,11 +94,14 @@ final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, Cont\n \t\t\treturn Emission.FAIL_TERMINATED;\n \t\t}\n \n+\t\tint expectedEmitted = subs.length;\n+\t\tint cancelledCount = 0;\n \t\tif (allOrNothing) {\n \t\t\tlong commonRequest = Long.MAX_VALUE;\n \t\t\tfor (Inner<T> sub : subs) {\n \t\t\t\tlong subRequest = sub.requested;\n \t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcancelledCount++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (subRequest < commonRequest) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTc1Mw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491945753", "bodyText": "should we even check for cancelled? I assume it would get removed, and we will only get a cancelled instance due to a race, but that's okay to still push things to a cancelled subscription since cancel() is not guaranteed to be instantly delivered", "author": "bsideup", "createdAt": "2020-09-21T10:41:42Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MzA4MA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491983080", "bodyText": "it is easy enough to check for it and I think it makes sense to unnecessarily avoid pushing elements when we know the downstream is cancelled", "author": "simonbasle", "createdAt": "2020-09-21T11:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4ODA0Mw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491988043", "bodyText": "updated", "author": "simonbasle", "createdAt": "2020-09-21T11:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\nindex 2d8c6ae77..b6f96a25b 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n\n@@ -94,11 +94,14 @@ final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, Cont\n \t\t\treturn Emission.FAIL_TERMINATED;\n \t\t}\n \n+\t\tint expectedEmitted = subs.length;\n+\t\tint cancelledCount = 0;\n \t\tif (allOrNothing) {\n \t\t\tlong commonRequest = Long.MAX_VALUE;\n \t\t\tfor (Inner<T> sub : subs) {\n \t\t\t\tlong subRequest = sub.requested;\n \t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcancelledCount++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (subRequest < commonRequest) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjIwMg==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946202", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tswitch(tryEmitNext(value)) {\n          \n          \n            \n            \t\tswitch (tryEmitNext(value)) {", "author": "bsideup", "createdAt": "2020-09-21T10:42:40Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\nindex 2d8c6ae77..b6f96a25b 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n\n@@ -94,11 +94,14 @@ final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, Cont\n \t\t\treturn Emission.FAIL_TERMINATED;\n \t\t}\n \n+\t\tint expectedEmitted = subs.length;\n+\t\tint cancelledCount = 0;\n \t\tif (allOrNothing) {\n \t\t\tlong commonRequest = Long.MAX_VALUE;\n \t\t\tfor (Inner<T> sub : subs) {\n \t\t\t\tlong subRequest = sub.requested;\n \t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcancelledCount++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (subRequest < commonRequest) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946580", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tcase FAIL_NON_SERIALIZED:\n          \n          \n            \n            \t\t\tdefault:", "author": "bsideup", "createdAt": "2020-09-21T10:43:28Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {\n+\t\t\tcase FAIL_ZERO_SUBSCRIBER:\n+\t\t\t\t//we want to \"discard\" without rendering the sink terminated.\n+\t\t\t\t// effectively NO-OP cause there's no subscriber, so no context :(\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_OVERFLOW:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t//the emitError will onErrorDropped if already terminated\n+\t\t\t\temitError(Exceptions.failWithOverflow(\"Backpressure overflow during Sinks.Many#emitNext\"));\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_CANCELLED:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_TERMINATED:\n+\t\t\t\tOperators.onNextDroppedMulticast(value, subscribers);\n+\t\t\t\tbreak;\n+\t\t\tcase OK:\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_NON_SERIALIZED:", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0OTYzNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491949634", "bodyText": "I have a slight preference for not using default and having full explicit enum coverage, that way if we add an enum value the IDE can be configured to warn us. at least in tryEmitNext, which is the most likely to make use of most enums.", "author": "simonbasle", "createdAt": "2020-09-21T10:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk1MzA1NA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491953054", "bodyText": "(Marked as not resolved, since... it is not resolved yet ;))\nUnless we make our build fail when we forget to handle a new case, I'd say relying on IDE isn't a good idea. Also, not every team member/contributor has this option configured (I don't)", "author": "bsideup", "createdAt": "2020-09-21T10:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MzcxMw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491983713", "bodyText": "I initially thought the compiler would complain too, but it doesn't. ok let's make it a default block", "author": "simonbasle", "createdAt": "2020-09-21T11:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4ODAwNg==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491988006", "bodyText": "updated", "author": "simonbasle", "createdAt": "2020-09-21T11:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0NjU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\nindex 2d8c6ae77..b6f96a25b 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n\n@@ -94,11 +94,14 @@ final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, Cont\n \t\t\treturn Emission.FAIL_TERMINATED;\n \t\t}\n \n+\t\tint expectedEmitted = subs.length;\n+\t\tint cancelledCount = 0;\n \t\tif (allOrNothing) {\n \t\t\tlong commonRequest = Long.MAX_VALUE;\n \t\t\tfor (Inner<T> sub : subs) {\n \t\t\t\tlong subRequest = sub.requested;\n \t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcancelledCount++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (subRequest < commonRequest) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0Njg2OA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491946868", "bodyText": "can't we reuse at least the inner class between this Sink and the existing processor?", "author": "bsideup", "createdAt": "2020-09-21T10:44:03Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.stream.Stream;\n+\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.util.annotation.Nullable;\n+import reactor.util.context.Context;\n+\n+/**\n+ * @author Simon Basl\u00e9\n+ */\n+final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, ContextHolder,\n+                                                             Scannable {\n+\n+\tprivate static final Inner[] EMPTY = new Inner[0];\n+\tprivate static final Inner[] TERMINATED = new Inner[0];\n+\n+\tstatic final <T> SinkManyBestEffort<T> createBestEffort() {\n+\t\treturn new SinkManyBestEffort<>(false);\n+\t}\n+\n+\tstatic final <T> SinkManyBestEffort<T> createAllOrNothing() {\n+\t\treturn new SinkManyBestEffort<>(true);\n+\t}\n+\n+\tfinal boolean allOrNothing;\n+\n+\t/**\n+\t * Stores the error that terminated this sink, for immediate replay to late subscribers\n+\t */\n+\tThrowable error;\n+\n+\tvolatile     Inner<T>[]                                               subscribers;\n+\t@SuppressWarnings(\"rawtypes\")\n+\tstatic final AtomicReferenceFieldUpdater<SinkManyBestEffort, Inner[]> SUBSCRIBERS =\n+\t\t\tAtomicReferenceFieldUpdater.newUpdater(SinkManyBestEffort.class, Inner[].class, \"subscribers\");\n+\n+\tSinkManyBestEffort(boolean allOrNothing) {\n+\t\tthis.allOrNothing = allOrNothing;\n+\t\tSUBSCRIBERS.lazySet(this, EMPTY);\n+\t}\n+\n+\tpublic Context currentContext() {\n+\t\treturn Operators.multiSubscribersContext(subscribers);\n+\t}\n+\n+\t@Override\n+\tpublic Stream<? extends Scannable> inners() {\n+\t\treturn Stream.of(subscribers);\n+\t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic Object scanUnsafe(Attr key) {\n+\t\tif (key == Attr.TERMINATED) return subscribers == TERMINATED;\n+\t\tif (key == Attr.ERROR) return error;\n+\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitNext(T t) {\n+\t\tObjects.requireNonNull(t, \"tryEmitNext(null) is forbidden\");\n+\n+\t\tInner<T>[] subs = subscribers;\n+\n+\t\tif (subs == EMPTY) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER;\n+\t\t}\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tif (allOrNothing) {\n+\t\t\tlong commonRequest = Long.MAX_VALUE;\n+\t\t\tfor (Inner<T> sub : subs) {\n+\t\t\t\tlong subRequest = sub.requested;\n+\t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (subRequest < commonRequest) {\n+\t\t\t\t\tcommonRequest = subRequest;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (commonRequest == 0) {\n+\t\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint expectedEmitted = subs.length;\n+\t\tint emittedCount = 0;\n+\t\tint cancelledCount = 0;\n+\t\tfor (Inner<T> sub : subs) {\n+\t\t\tif (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (sub.tryEmitNext(t)) {\n+\t\t\t\temittedCount++;\n+\t\t\t}\n+\t\t\telse if (sub.isCancelled()) {\n+\t\t\t\tcancelledCount++;\n+\t\t\t}\n+\t\t}\n+\t\tif (cancelledCount == expectedEmitted) {\n+\t\t\treturn Emission.FAIL_ZERO_SUBSCRIBER; //TODO should it be FAIL_CANCELLED ? but technically the sink would still be usable\n+\t\t}\n+\t\telse if (cancelledCount + emittedCount == expectedEmitted) {\n+\t\t\treturn Emission.OK;\n+\t\t}\n+\t\telse {\n+\t\t\treturn Emission.FAIL_OVERFLOW;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitComplete() {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitComplete();\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic Emission tryEmitError(Throwable error) {\n+\t\tObjects.requireNonNull(error, \"tryEmitError(null) is forbidden\");\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tInner<T>[] subs = SUBSCRIBERS.getAndSet(this, TERMINATED);\n+\n+\t\tif (subs == TERMINATED) {\n+\t\t\treturn Emission.FAIL_TERMINATED;\n+\t\t}\n+\n+\t\tthis.error = error;\n+\n+\t\tfor (Inner<?> s : subs) {\n+\t\t\ts.emitError(error);\n+\t\t}\n+\t\treturn Emission.OK;\n+\t}\n+\n+\t@Override\n+\tpublic void emitComplete() {\n+\t\t//no particular error condition handling for onComplete\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tEmission emission = tryEmitComplete();\n+\t}\n+\n+\t@Override\n+\tpublic void emitError(Throwable error) {\n+\t\tEmission result = tryEmitError(error);\n+\t\tif (result == Emission.FAIL_TERMINATED) {\n+\t\t\tOperators.onErrorDroppedMulticast(error, subscribers);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void emitNext(T value) {\n+\t\tswitch(tryEmitNext(value)) {\n+\t\t\tcase FAIL_ZERO_SUBSCRIBER:\n+\t\t\t\t//we want to \"discard\" without rendering the sink terminated.\n+\t\t\t\t// effectively NO-OP cause there's no subscriber, so no context :(\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_OVERFLOW:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\t//the emitError will onErrorDropped if already terminated\n+\t\t\t\temitError(Exceptions.failWithOverflow(\"Backpressure overflow during Sinks.Many#emitNext\"));\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_CANCELLED:\n+\t\t\t\tOperators.onDiscard(value, currentContext());\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_TERMINATED:\n+\t\t\t\tOperators.onNextDroppedMulticast(value, subscribers);\n+\t\t\t\tbreak;\n+\t\t\tcase OK:\n+\t\t\t\tbreak;\n+\t\t\tcase FAIL_NON_SERIALIZED:\n+\t\t\t\tthrow new IllegalStateException(\"Unexpected return code\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int currentSubscriberCount() {\n+\t\treturn subscribers.length;\n+\t}\n+\n+\t@Override\n+\tpublic Flux<T> asFlux() {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic void subscribe(CoreSubscriber<? super T> actual) {\n+\t\tObjects.requireNonNull(actual, \"subscribe(null) is forbidden\");\n+\n+\t\tInner<T> p = new Inner<>(actual, this);\n+\t\tactual.onSubscribe(p);\n+\n+\t\tif (p.isCancelled()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (add(p)) {\n+\t\t\tif (p.isCancelled()) {\n+\t\t\t\tremove(p);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tThrowable e = error;\n+\t\t\tif (e != null) {\n+\t\t\t\tactual.onError(e);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tactual.onComplete();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tboolean add(Inner<T> s) {\n+\t\tInner<T>[] a = subscribers;\n+\t\tif (a == TERMINATED) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized (this) {\n+\t\t\ta = subscribers;\n+\t\t\tif (a == TERMINATED) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tint len = a.length;\n+\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\tInner<T>[] b = new Inner[len + 1];\n+\t\t\tSystem.arraycopy(a, 0, b, 0, len);\n+\t\t\tb[len] = s;\n+\n+\t\t\tsubscribers = b;\n+\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tvoid remove(Inner<T> s) {\n+\t\tInner<T>[] a = subscribers;\n+\t\tif (a == TERMINATED || a == EMPTY) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tsynchronized (this) {\n+\t\t\ta = subscribers;\n+\t\t\tif (a == TERMINATED || a == EMPTY) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tint len = a.length;\n+\n+\t\t\tint j = -1;\n+\n+\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\tif (a[i] == s) {\n+\t\t\t\t\tj = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (j < 0) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (len == 1) {\n+\t\t\t\tsubscribers = EMPTY;\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tInner<T>[] b = new Inner[len - 1];\n+\t\t\tSystem.arraycopy(a, 0, b, 0, j);\n+\t\t\tSystem.arraycopy(a, j + 1, b, j, len - j - 1);\n+\n+\t\t\tsubscribers = b;\n+\t\t}\n+\t}\n+\n+\tstatic class Inner<T> extends AtomicBoolean implements InnerProducer<T> {", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk1MTA5OQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491951099", "bodyText": "not really, since the DirectInner terminates its downstream on backpressure. (also it would imply a common interface for DirectProcessor and SinkManyBestEffort for the inners to access parent.remove method)", "author": "simonbasle", "createdAt": "2020-09-21T10:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0Njg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk1Mzc5Mw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491953793", "bodyText": "But is this common interface a big deal?\nThe termination behaviour can be changed with two methods - emitXxx and tryEmitXxx, so that BestEffort will call \"tryEmitXxx\", while DirectProcessor would stick to emitXxx that calls tryEmitXxx and terminates", "author": "bsideup", "createdAt": "2020-09-21T10:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0Njg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzODU0MQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r492138541", "bodyText": "I've opened draft PR #2393 because I'm still not convinced this is in that much of a better state after trying your suggestion", "author": "simonbasle", "createdAt": "2020-09-21T15:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0Njg2OA=="}], "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\nindex 2d8c6ae77..b6f96a25b 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/SinkManyBestEffort.java\n\n@@ -94,11 +94,14 @@ final class SinkManyBestEffort<T> extends Flux<T> implements Sinks.Many<T>, Cont\n \t\t\treturn Emission.FAIL_TERMINATED;\n \t\t}\n \n+\t\tint expectedEmitted = subs.length;\n+\t\tint cancelledCount = 0;\n \t\tif (allOrNothing) {\n \t\t\tlong commonRequest = Long.MAX_VALUE;\n \t\t\tfor (Inner<T> sub : subs) {\n \t\t\t\tlong subRequest = sub.requested;\n \t\t\t\tif (sub.isCancelled()) {\n+\t\t\t\t\tcancelledCount++;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (subRequest < commonRequest) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDEyNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r491970124", "bodyText": "I'd suggest to not use onBackpressureXxx at all since it is misleading anyways (we only return an Emission and not actually perform anything on backpressure)\nMaybe Sinks.many().multicast().toAnyRequested() and Sinks.many().multicast().allOrNothing() or something similar?", "author": "bsideup", "createdAt": "2020-09-21T11:30:56Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -355,6 +355,48 @@ public Emission getReason() {\n \t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n \t\t */\n \t\t<T> Sinks.Many<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if any of the subscribers\n+\t\t *     cannot process an element, failing fast and backing off from emitting the element at all.\n+\t\t * \t   From the perspective of subscribers, data is dropped and never seen but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed, provided all of the subscribers\n+\t\t *     have demand.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n+\t\t */\n+\t\t//TODO marble <img class=\"marble\" src=\"doc-files/marbles/sinkWarmup.svg\" alt=\"\">\n+\t\t<T> Sinks.Many<T> onBackpressureDropForAll();", "originalCommit": "102b2bd8b103cd46f40571054ea1515e5081cad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NjExNg==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495776116", "bodyText": "resolved ?", "author": "simonbasle", "createdAt": "2020-09-28T08:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/Sinks.java b/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\nindex c5f4f3fa7..ddaa5a62e 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\n\n@@ -362,7 +362,7 @@ public final class Sinks {\n \t\t *     <li>Multicast</li>\n \t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n \t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if any of the subscribers\n-\t\t *     cannot process an element, failing fast and backing off from emitting the element at all.\n+\t\t *     cannot process an element, failing fast and backing off from emitting the element at all (all or nothing).\n \t\t * \t   From the perspective of subscribers, data is dropped and never seen but they are not terminated.\n \t\t *     </li>\n \t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n"}}, {"oid": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "url": "https://github.com/reactor/reactor-core/commit/e2ddb120b22f2dcd121439b88839aa39b519eddd", "message": "Add marble diagrams (optimized)", "committedDate": "2020-09-22T08:30:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTc3NA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495079774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n          \n          \n            \n            \t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case of no demand from any subscriber", "author": "bsideup", "createdAt": "2020-09-25T15:51:56Z", "path": "reactor-core/src/main/java/reactor/core/publisher/Sinks.java", "diffHunk": "@@ -355,6 +355,48 @@ public Emission getReason() {\n \t\t * @param autoCancel should the sink fully shutdowns (not publishing anymore) when the last subscriber cancels\n \t\t */\n \t\t<T> Sinks.Many<T> onBackpressureBuffer(int bufferSize, boolean autoCancel);\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if any of the subscribers\n+\t\t *     cannot process an element, failing fast and backing off from emitting the element at all (all or nothing).\n+\t\t * \t   From the perspective of subscribers, data is dropped and never seen but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed, provided all of the subscribers\n+\t\t *     have demand.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkDirectAllOrNothing.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n+\t\t */\n+\t\t<T> Sinks.Many<T> directAllOrNothing();\n+\n+\t\t/**\n+\t\t A {@link Sinks.Many} with the following characteristics:\n+\t\t * <ul>\n+\t\t *     <li>Multicast</li>\n+\t\t *     <li>Without {@link Subscriber}: fail fast on {@link Many#tryEmitNext(Object) tryEmitNext}.</li>\n+\t\t *     <li>Backpressure : notify the caller with {@link Emission#FAIL_OVERFLOW} if <strong>none</strong>\n+\t\t *     of the subscribers can process an element. Otherwise, it ignores slow subscribers and emits the\n+\t\t *     element to fast ones as a best effort. From the perspective of slow subscribers, data is dropped\n+\t\t *     and never seen, but they are not terminated.\n+\t\t *     </li>\n+\t\t *     <li>Replaying: No replay of elements. Only forwards to a {@link Subscriber} the elements that\n+\t\t *     have been pushed to the sink AFTER this subscriber was subscribed.</li>\n+\t\t * </ul>\n+\t\t * <p>\n+\t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkDirectBestEffort.svg\" alt=\"\">\n+\t\t *\n+\t\t * @param <T> the type of elements to emit\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow", "originalCommit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/main/java/reactor/core/publisher/Sinks.java b/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\nindex ddaa5a62e..095b9a9e4 100644\n--- a/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\n+++ b/reactor-core/src/main/java/reactor/core/publisher/Sinks.java\n\n@@ -394,7 +395,7 @@ public final class Sinks {\n \t\t * <img class=\"marble\" src=\"doc-files/marbles/sinkDirectBestEffort.svg\" alt=\"\">\n \t\t *\n \t\t * @param <T> the type of elements to emit\n-\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case any subscriber is too slow\n+\t\t * @return a multicast {@link Sinks.Many} that \"drops\" in case of no demand from any subscriber\n \t\t */\n \t\t<T> Sinks.Many<T> directBestEffort();\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MzIwMQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495083201", "bodyText": "I get a feeling that we will never start using JCstress if we will keep adding these for-based ones :(\nthis is a new code, goes into master where JCstress is configured, and I see no reason not to use it.", "author": "bsideup", "createdAt": "2020-09-25T15:57:18Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.context.Context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+class SinkManyBestEffortTest {\n+\n+\t@Test\n+\tvoid currentContextReflectSubscriberContext() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.currentContext()).isSameAs(Context.empty());\n+\n+\t\tAssertSubscriber<Integer> subscriber1 = new AssertSubscriber<>(Context.of(\"key\", \"value1\"));\n+\t\tAssertSubscriber<Integer> subscriber2 = new AssertSubscriber<>(Context.of(\"key\", \"value2\"));\n+\t\tsink.subscribe(subscriber1);\n+\t\tsink.subscribe(subscriber2);\n+\n+\t\tassertThat(sink.currentContext()).isEqualTo(subscriber1.currentContext());\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextNoSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_ZERO_SUBSCRIBER);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyComplete();\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitError(new IllegalStateException(\"boom\")).orThrow();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom ignored\"))).as(\"tryEmitError\").isEqualTo(Emission.FAIL_TERMINATED);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tAssertSubscriber<Integer> sub1 = AssertSubscriber.create();\n+\t\tAssertSubscriber<Integer> sub2 = AssertSubscriber.create(0);\n+\t\tsink.subscribe(sub1);\n+\t\tsink.subscribe(sub2);\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tsub1.assertErrorMessage(\"boom\");\n+\t\tsub2.assertErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid addSubscriberThatCancelsOnSubscription() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t@Override\n+\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\tsubscription.cancel();\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tvoid innersReflectsSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.inners()).as(\"before subscribers\").isEmpty();\n+\n+\t\tDisposable sub1 = sink.subscribe();\n+\t\tDisposable sub2 = sink.subscribe();\n+\n+\t\tassertThat(sink.inners()).hasSize(2);\n+\t\tassertThat(sink.inners().map(inner -> inner.scanUnsafe(Scannable.Attr.ACTUAL)))\n+\t\t\t\t.containsExactly(sub1, sub2);\n+\t}\n+\n+\t@Test\n+\tvoid scanSink() {\n+\t\tSinkManyBestEffort<Integer> sinkNormal = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sinkNormal.scan(Scannable.Attr.TERMINATED)).as(\"normal not terminated\").isFalse();\n+\t\tsinkNormal.tryEmitComplete().orThrow();\n+\t\tassertThat(sinkNormal.scan(Scannable.Attr.TERMINATED)).as(\"normal terminated\").isTrue();\n+\n+\t\tSinkManyBestEffort<Integer> sinkError = SinkManyBestEffort.createBestEffort();\n+\t\tThrowable expectedError = new IllegalStateException(\"boom\");\n+\t\tsinkError.tryEmitError(expectedError).orThrow();\n+\n+\t\tassertThat(sinkError.scan(Scannable.Attr.TERMINATED)).as(\"error terminated\").isTrue();\n+\t\tassertThat(sinkError.scan(Scannable.Attr.ERROR)).as(\"error captured\").isSameAs(expectedError);\n+\t}\n+\n+\t@Nested\n+\tclass RaceConditionsAndLoops {", "originalCommit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEyOTYzNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495129634", "bodyText": "I have no idea what I'm doing, but done", "author": "simonbasle", "createdAt": "2020-09-25T17:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MzIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java b/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\nindex 8fa64999c..69862ef28 100644\n--- a/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\n+++ b/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\n\n@@ -16,24 +16,20 @@\n \n package reactor.core.publisher;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.reactivestreams.Subscription;\n \n import reactor.core.Disposable;\n import reactor.core.Scannable;\n+import reactor.core.publisher.SinkManyBestEffort.DirectInner;\n import reactor.core.publisher.Sinks.Emission;\n import reactor.test.StepVerifier;\n import reactor.test.subscriber.AssertSubscriber;\n import reactor.util.context.Context;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.fail;\n+import static org.mockito.Mockito.mock;\n \n class SinkManyBestEffortTest {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDQ4Ng==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495084486", "bodyText": "this test does not seem to assert anything", "author": "bsideup", "createdAt": "2020-09-25T15:59:19Z", "path": "reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright (c) 2011-Present VMware Inc. or its affiliates, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package reactor.core.publisher;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.reactivestreams.Subscription;\n+\n+import reactor.core.Disposable;\n+import reactor.core.Scannable;\n+import reactor.core.publisher.Sinks.Emission;\n+import reactor.test.StepVerifier;\n+import reactor.test.subscriber.AssertSubscriber;\n+import reactor.util.context.Context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+class SinkManyBestEffortTest {\n+\n+\t@Test\n+\tvoid currentContextReflectSubscriberContext() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.currentContext()).isSameAs(Context.empty());\n+\n+\t\tAssertSubscriber<Integer> subscriber1 = new AssertSubscriber<>(Context.of(\"key\", \"value1\"));\n+\t\tAssertSubscriber<Integer> subscriber2 = new AssertSubscriber<>(Context.of(\"key\", \"value2\"));\n+\t\tsink.subscribe(subscriber1);\n+\t\tsink.subscribe(subscriber2);\n+\n+\t\tassertThat(sink.currentContext()).isEqualTo(subscriber1.currentContext());\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextNoSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_ZERO_SUBSCRIBER);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitNextOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitNext(1)).as(\"tryEmitNext\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyComplete();\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitCompleteOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitComplete().orThrow();\n+\n+\t\tassertThat(sink.tryEmitComplete()).as(\"tryEmitComplete\").isEqualTo(Emission.FAIL_TERMINATED);\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorNoSubscribersRetains() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnTerminated() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tsink.tryEmitError(new IllegalStateException(\"boom\")).orThrow();\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom ignored\"))).as(\"tryEmitError\").isEqualTo(Emission.FAIL_TERMINATED);\n+\n+\t\tStepVerifier.create(sink.asFlux())\n+\t\t            .verifyErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid tryEmitErrorOnSubscribers() {\n+\t\tSinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\tAssertSubscriber<Integer> sub1 = AssertSubscriber.create();\n+\t\tAssertSubscriber<Integer> sub2 = AssertSubscriber.create(0);\n+\t\tsink.subscribe(sub1);\n+\t\tsink.subscribe(sub2);\n+\n+\t\tassertThat(sink.tryEmitError(new IllegalStateException(\"boom\"))).as(\"tryEmitError\").isEqualTo(Emission.OK);\n+\n+\t\tsub1.assertErrorMessage(\"boom\");\n+\t\tsub2.assertErrorMessage(\"boom\");\n+\t}\n+\n+\t@Test\n+\tvoid addSubscriberThatCancelsOnSubscription() {", "originalCommit": "e2ddb120b22f2dcd121439b88839aa39b519eddd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1MDYxNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495750614", "bodyText": "fixed", "author": "simonbasle", "createdAt": "2020-09-28T07:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NjM1Mw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495776353", "bodyText": "resolved ?", "author": "simonbasle", "createdAt": "2020-09-28T08:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java b/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\nindex 8fa64999c..69862ef28 100644\n--- a/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\n+++ b/reactor-core/src/test/java/reactor/core/publisher/SinkManyBestEffortTest.java\n\n@@ -16,24 +16,20 @@\n \n package reactor.core.publisher;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-\n import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.reactivestreams.Subscription;\n \n import reactor.core.Disposable;\n import reactor.core.Scannable;\n+import reactor.core.publisher.SinkManyBestEffort.DirectInner;\n import reactor.core.publisher.Sinks.Emission;\n import reactor.test.StepVerifier;\n import reactor.test.subscriber.AssertSubscriber;\n import reactor.util.context.Context;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.fail;\n+import static org.mockito.Mockito.mock;\n \n class SinkManyBestEffortTest {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDM5Ng==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495764396", "bodyText": "if there is no shared code than the abstract class can be avoided (it is not required by JCstress or anything like that)", "author": "bsideup", "createdAt": "2020-09-28T08:16:18Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3Njc1MQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495776751", "bodyText": "the abstract keyword you mean? I still need inner classes for individual tests I guess ?", "author": "simonbasle", "createdAt": "2020-09-28T08:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NTMzOA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495785338", "bodyText": "you can as well have N classes/files, unless you want to group them, of course", "author": "bsideup", "createdAt": "2020-09-28T08:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NzY1NA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495787654", "bodyText": "yeah, I want to group the stress tests here", "author": "simonbasle", "createdAt": "2020-09-28T08:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\nindex a9b9f2009..0f98bf26e 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n\n@@ -26,7 +26,7 @@ import org.reactivestreams.Subscription;\n \n import static org.openjdk.jcstress.annotations.Expect.*;\n \n-public abstract class SinkManyBestEffortStressTest {\n+public class SinkManyBestEffortStressTest {\n \n \t@JCStressTest\n \t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDY4Ng==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495764686", "bodyText": "a stress test with a single actor does not make any sense", "author": "bsideup", "createdAt": "2020-09-28T08:16:50Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NjgyOQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495776829", "bodyText": "will remove", "author": "simonbasle", "createdAt": "2020-09-28T08:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\nindex a9b9f2009..0f98bf26e 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n\n@@ -26,7 +26,7 @@ import org.reactivestreams.Subscription;\n \n import static org.openjdk.jcstress.annotations.Expect.*;\n \n-public abstract class SinkManyBestEffortStressTest {\n+public class SinkManyBestEffortStressTest {\n \n \t@JCStressTest\n \t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NTYzNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495765634", "bodyText": "the whole point of JCstress is to run actors in parallel, so it won't always be \"before\", but before, at the same time and after the subscription", "author": "bsideup", "createdAt": "2020-09-28T08:18:39Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeOneSubscriberStressTest {", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NzQyNA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495777424", "bodyText": "will rename", "author": "simonbasle", "createdAt": "2020-09-28T08:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NTYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\nindex a9b9f2009..0f98bf26e 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n\n@@ -26,7 +26,7 @@ import org.reactivestreams.Subscription;\n \n import static org.openjdk.jcstress.annotations.Expect.*;\n \n-public abstract class SinkManyBestEffortStressTest {\n+public class SinkManyBestEffortStressTest {\n \n \t@JCStressTest\n \t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjA5NQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495766095", "bodyText": "these two can be field initializers", "author": "bsideup", "createdAt": "2020-09-28T08:19:30Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020-Present Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.core.publisher;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Arbiter;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+import org.openjdk.jcstress.infra.results.LI_Result;\n+import org.reactivestreams.Subscription;\n+\n+import static org.openjdk.jcstress.annotations.Expect.*;\n+\n+public abstract class SinkManyBestEffortStressTest {\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n+\t@State\n+\tpublic static class ParallelSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void three() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void four() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void five() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void six() {\n+\t\t\tsink.subscribe(new StressSubscriber<>());\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeOneSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelOnSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\n+\t\t@Actor\n+\t\tpublic void one() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void two() {\n+\t\t\tsink.subscribe(new BaseSubscriber<Integer>() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\t\t\t\tsubscription.cancel();\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"0\"}, expect = ACCEPTABLE, desc = \"No subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeOneSubscriberStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tfinal StressSubscriber<Integer> sub = new StressSubscriber<>(0);\n+\n+\t\t@Actor\n+\t\tpublic void cancellingSub() {\n+\t\t\tsub.cancel();\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub() {\n+\t\t\tsink.subscribe(sub);\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"1\"}, expect = ACCEPTABLE, desc = \"One subscriber counted\")\n+\t@State\n+\tpublic static class CancelledBeforeSubscribeTwoSubscribersStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer> sink = SinkManyBestEffort.createBestEffort();\n+\t\tfinal StressSubscriber<Integer> sub2 = new StressSubscriber<>(0);\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub1() {\n+\t\t\tsink.subscribe(new StressSubscriber<>(0));\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void subscribingSub2() {\n+\t\t\tsink.subscribe(sub2);\n+\t\t}\n+\n+\t\t@Actor\n+\t\tpublic void cancellingSub2() {\n+\t\t\tsub2.cancel();\n+\t\t}\n+\n+\t\t@Arbiter\n+\t\tpublic void arbiter(I_Result r) {\n+\t\t\tr.r1 = sink.currentSubscriberCount();\n+\t\t}\n+\t}\n+\n+\t@JCStressTest\n+\t@Outcome(id = {\"FAIL_ZERO_SUBSCRIBER, 0\"}, expect = ACCEPTABLE, desc = \"Zero Subscriber because cancelled\")\n+\t@Outcome(id = {\"FAIL_OVERFLOW, 0\"}, expect = ACCEPTABLE, desc = \"Overflow because not cancelled nor requested\")\n+\t@Outcome(id = {\"OK, 1\"}, expect = ACCEPTABLE, desc = \"OK because requested before cancelled\")\n+\t@State\n+\tpublic static class InnerTryEmitNextCancelVersusRequestStressTest {\n+\n+\t\tfinal SinkManyBestEffort<Integer>             sink;\n+\t\tfinal StressSubscriber<Integer>               subscriber;\n+\t\tfinal SinkManyBestEffort.DirectInner<Integer> inner;\n+\n+\t\t{\n+\t\t\tsink = SinkManyBestEffort.createBestEffort();\n+\t\t\tsubscriber = new StressSubscriber<>(0);", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDI0Mw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495780243", "bodyText": "done", "author": "simonbasle", "createdAt": "2020-09-28T08:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\nindex a9b9f2009..0f98bf26e 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/SinkManyBestEffortStressTest.java\n\n@@ -26,7 +26,7 @@ import org.reactivestreams.Subscription;\n \n import static org.openjdk.jcstress.annotations.Expect.*;\n \n-public abstract class SinkManyBestEffortStressTest {\n+public class SinkManyBestEffortStressTest {\n \n \t@JCStressTest\n \t@Outcome(id = {\"6\"}, expect = ACCEPTABLE, desc = \"Six parallel subscribes\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjYxMw==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495766613", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t}\n          \n          \n            \n            \t}", "author": "bsideup", "createdAt": "2020-09-28T08:20:22Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java", "diffHunk": "@@ -35,14 +40,36 @@\n \n \tpublic AtomicBoolean concurrentOnComplete = new AtomicBoolean(false);\n \n+\tpublic AtomicBoolean concurrentOnSubscribe = new AtomicBoolean(false);\n+\n \tpublic final AtomicInteger onNextCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onErrorCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onCompleteCalls = new AtomicInteger();\n \n+\tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n+\n+\tpublic StressSubscriber() {\n+\t\tthis(Long.MAX_VALUE);\n+\t}", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3OTU3Ng==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495779576", "bodyText": "fixed along added javadoc", "author": "simonbasle", "createdAt": "2020-09-28T08:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NjYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java b/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\nindex 0b1e2ba67..98a007791 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\n\n@@ -50,9 +50,20 @@ public class StressSubscriber<T> extends BaseSubscriber<T> {\n \n \tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n \n+\t/**\n+\t * Build a {@link StressSubscriber} that makes an unbounded request upon subscription.\n+\t */\n \tpublic StressSubscriber() {\n \t\tthis(Long.MAX_VALUE);\n \t}\n+\n+\t/**\n+\t * Build a {@link StressSubscriber} that requests the provided amount in\n+\t * {@link #onSubscribe(Subscription)}. Use {@code 0} to avoid any initial request\n+\t * upon subscription.\n+\t *\n+\t * @param initRequest the requested amount upon subscription, or zero to disable initial request\n+\t */\n \tpublic StressSubscriber(long initRequest) {\n \t\tthis.initRequest = initRequest;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495767105", "bodyText": "shouldn't the request be strictly positive? I see some new StressSubscriber(0) usages in the tests", "author": "bsideup", "createdAt": "2020-09-28T08:21:17Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java", "diffHunk": "@@ -35,14 +40,36 @@\n \n \tpublic AtomicBoolean concurrentOnComplete = new AtomicBoolean(false);\n \n+\tpublic AtomicBoolean concurrentOnSubscribe = new AtomicBoolean(false);\n+\n \tpublic final AtomicInteger onNextCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onErrorCalls = new AtomicInteger();\n \n \tpublic final AtomicInteger onCompleteCalls = new AtomicInteger();\n \n+\tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n+\n+\tpublic StressSubscriber() {\n+\t\tthis(Long.MAX_VALUE);\n+\t}\n+\tpublic StressSubscriber(long initRequest) {\n+\t\tthis.initRequest = initRequest;\n+\t}\n+\n+\t@Override\n+\tprotected void hookOnSubscribe(Subscription subscription) {\n+\t\tif (!guard.compareAndSet(null, Operation.ON_SUBSCRIBE)) {\n+\t\t\tconcurrentOnSubscribe.set(true);\n+\t\t} else {\n+\t\t\tsubscription.request(initRequest);", "originalCommit": "29953f844bf3bbfadd9d3c08e92d830ab8f80cac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2ODAzMA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495768030", "bodyText": "0 == no initial request", "author": "simonbasle", "createdAt": "2020-09-28T08:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3OTY0Ng==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495779646", "bodyText": "(added javadoc)", "author": "simonbasle", "createdAt": "2020-09-28T08:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4NjQzOQ==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r495786439", "bodyText": "but there is no if (initRequest > 0) check before requesting", "author": "bsideup", "createdAt": "2020-09-28T08:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NTQ3OA==", "url": "https://github.com/reactor/reactor-core/pull/2392#discussion_r497475478", "bodyText": "ah, sorry. good catch indeed", "author": "simonbasle", "createdAt": "2020-09-30T12:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NzEwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "chunk": "diff --git a/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java b/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\nindex 0b1e2ba67..98a007791 100644\n--- a/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\n+++ b/reactor-core/src/jcstress/java/reactor/core/publisher/StressSubscriber.java\n\n@@ -50,9 +50,20 @@ public class StressSubscriber<T> extends BaseSubscriber<T> {\n \n \tpublic final AtomicInteger onSubscribeCalls = new AtomicInteger();\n \n+\t/**\n+\t * Build a {@link StressSubscriber} that makes an unbounded request upon subscription.\n+\t */\n \tpublic StressSubscriber() {\n \t\tthis(Long.MAX_VALUE);\n \t}\n+\n+\t/**\n+\t * Build a {@link StressSubscriber} that requests the provided amount in\n+\t * {@link #onSubscribe(Subscription)}. Use {@code 0} to avoid any initial request\n+\t * upon subscription.\n+\t *\n+\t * @param initRequest the requested amount upon subscription, or zero to disable initial request\n+\t */\n \tpublic StressSubscriber(long initRequest) {\n \t\tthis.initRequest = initRequest;\n \t}\n"}}, {"oid": "2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "url": "https://github.com/reactor/reactor-core/commit/2d200ffcec5b9dd950ad0e1a9e072398a23c0082", "message": "fix review comments on stress test + StressSubscriber", "committedDate": "2020-09-28T14:11:53Z", "type": "forcePushed"}, {"oid": "c39868beb644ec82ee93c9938dbd742bd3ff5529", "url": "https://github.com/reactor/reactor-core/commit/c39868beb644ec82ee93c9938dbd742bd3ff5529", "message": "[polish] StressSubscriber generified, track onSubscribe, initRequest", "committedDate": "2020-09-30T13:00:00Z", "type": "commit"}, {"oid": "818ec001cd6e095c1ef63f36302292f1ba7491a2", "url": "https://github.com/reactor/reactor-core/commit/818ec001cd6e095c1ef63f36302292f1ba7491a2", "message": "Add directAllOrNothing/directBestEffort multicast Sinks (#2392)\n\nThese new Sinks.Many are close to DirectProcessor, except they don't\nterminate on backpressure. Instead, they either drop for all subscribers\n(all or nothing) or for the slow subscribers only (best effort).", "committedDate": "2020-09-30T13:00:20Z", "type": "commit"}, {"oid": "818ec001cd6e095c1ef63f36302292f1ba7491a2", "url": "https://github.com/reactor/reactor-core/commit/818ec001cd6e095c1ef63f36302292f1ba7491a2", "message": "Add directAllOrNothing/directBestEffort multicast Sinks (#2392)\n\nThese new Sinks.Many are close to DirectProcessor, except they don't\nterminate on backpressure. Instead, they either drop for all subscribers\n(all or nothing) or for the slow subscribers only (best effort).", "committedDate": "2020-09-30T13:00:20Z", "type": "forcePushed"}]}