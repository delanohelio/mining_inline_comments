{"pr_number": 3987, "pr_title": "NIFI-7015 - ConsumeJMS supports additional message types", "pr_createdAt": "2020-01-14T17:46:31Z", "pr_url": "https://github.com/apache/nifi/pull/3987", "timeline": [{"oid": "0e1250ddf4eb69ffa4ea911087d9b29d5285017e", "url": "https://github.com/apache/nifi/commit/0e1250ddf4eb69ffa4ea911087d9b29d5285017e", "message": "NIFI-7015 - ConsumeJMS now supports ObjectMessage, MapMessage and StreamMessage types as well. Added optional ERROR_QUEUE property. Result flowfiles get a 'jms.messagetype' attribute that contains the incoming message type (TextMessage, BytesMessage, ObjectMessage, MapMessage or StreamMessage).", "committedDate": "2020-01-14T17:48:50Z", "type": "commit"}, {"oid": "0e1250ddf4eb69ffa4ea911087d9b29d5285017e", "url": "https://github.com/apache/nifi/commit/0e1250ddf4eb69ffa4ea911087d9b29d5285017e", "message": "NIFI-7015 - ConsumeJMS now supports ObjectMessage, MapMessage and StreamMessage types as well. Added optional ERROR_QUEUE property. Result flowfiles get a 'jms.messagetype' attribute that contains the incoming message type (TextMessage, BytesMessage, ObjectMessage, MapMessage or StreamMessage).", "committedDate": "2020-01-14T17:48:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ4NTI1Mg==", "url": "https://github.com/apache/nifi/pull/3987#discussion_r366485252", "bodyText": "Minor: Could be inlined similar to the other test methods.", "author": "tpalfy", "createdAt": "2020-01-14T17:54:11Z", "path": "nifi-nar-bundles/nifi-jms-bundle/nifi-jms-processors/src/test/java/org/apache/nifi/jms/processors/ConsumeJMSIT.java", "diffHunk": "@@ -65,11 +79,183 @@ public void validateSuccessfulConsumeAndTransferToSuccess() throws Exception {\n             successFF.assertAttributeEquals(\"filename\", \"message.txt\");\n             successFF.assertAttributeExists(\"attribute_from_sender\");\n             successFF.assertAttributeEquals(\"attribute_from_sender\", \"some value\");\n+            successFF.assertAttributeExists(\"jms.messagetype\");\n+            successFF.assertAttributeEquals(\"jms.messagetype\", \"BytesMessage\");\n             successFF.assertContentEquals(\"Hey dude!\".getBytes());\n             String sourceDestination = successFF.getAttribute(ConsumeJMS.JMS_SOURCE_DESTINATION_NAME);\n             assertNotNull(sourceDestination);\n         } finally {\n             ((CachingConnectionFactory) jmsTemplate.getConnectionFactory()).destroy();\n         }\n     }\n+\n+    @Test\n+    public void testValidateErrorQueueWhenDestinationIsTopicAndErrorQueueIsSet() throws Exception {\n+        testValidateErrorQueue(ConsumeJMS.TOPIC, \"errorQueue\", false);\n+    }\n+\n+    @Test\n+    public void testValidateErrorQueueWhenDestinationIsTopicAndErrorQueueIsNotSet() throws Exception {\n+        testValidateErrorQueue(ConsumeJMS.TOPIC, null, true);\n+    }\n+\n+    @Test\n+    public void testValidateErrorQueueWhenDestinationIsQueueAndErrorQueueIsSet() throws Exception {\n+        testValidateErrorQueue(ConsumeJMS.QUEUE, \"errorQueue\", true);\n+    }\n+\n+    @Test\n+    public void testValidateErrorQueueWhenDestinationIsQueueAndErrorQueueIsNotSet() throws Exception {\n+        testValidateErrorQueue(ConsumeJMS.QUEUE, null, true);\n+    }\n+\n+    private void testValidateErrorQueue(String destinationType, String errorQueue, boolean expectedValid) throws Exception {\n+        JmsTemplate jmsTemplate = CommonTest.buildJmsTemplateForDestination(false);\n+\n+        try {\n+            TestRunner runner = TestRunners.newTestRunner(new ConsumeJMS());\n+\n+            JMSConnectionFactoryProviderDefinition cfService = mock(JMSConnectionFactoryProviderDefinition.class);\n+            when(cfService.getIdentifier()).thenReturn(\"cfService\");\n+            when(cfService.getConnectionFactory()).thenReturn(jmsTemplate.getConnectionFactory());\n+\n+            runner.addControllerService(\"cfService\", cfService);\n+            runner.enableControllerService(cfService);\n+\n+            runner.setProperty(PublishJMS.CF_SERVICE, \"cfService\");\n+            runner.setProperty(ConsumeJMS.DESTINATION, \"destination\");\n+            runner.setProperty(ConsumeJMS.DESTINATION_TYPE, destinationType);\n+            if (errorQueue != null) {\n+                runner.setProperty(ConsumeJMS.ERROR_QUEUE, errorQueue);\n+            }\n+\n+            if (expectedValid) {\n+                runner.assertValid();\n+            } else {\n+                runner.assertNotValid();\n+            }\n+        } finally {\n+            ((CachingConnectionFactory) jmsTemplate.getConnectionFactory()).destroy();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextMessageTypeAttribute() throws Exception {\n+        testMessageTypeAttribute(\n+            \"testTextMessage\",\n+            Session::createTextMessage,\n+            TextMessage.class.getSimpleName()\n+        );\n+    }\n+\n+    @Test\n+    public void testByteMessageTypeAttribute() throws Exception {\n+        testMessageTypeAttribute(\n+            \"testByteMessage\",\n+            Session::createBytesMessage,\n+            BytesMessage.class.getSimpleName()\n+        );\n+    }\n+\n+    @Test\n+    public void testObjectMessageTypeAttribute() throws Exception {\n+        String destinationName = \"testObjectMessage\";", "originalCommit": "0e1250ddf4eb69ffa4ea911087d9b29d5285017e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}