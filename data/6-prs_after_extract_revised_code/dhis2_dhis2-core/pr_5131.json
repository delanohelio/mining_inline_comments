{"pr_number": 5131, "pr_title": "fix: Soft delete TEI, Enrollment and events", "pr_createdAt": "2020-03-18T12:43:21Z", "pr_url": "https://github.com/dhis2/dhis2-core/pull/5131", "timeline": [{"oid": "1f063c5e77f51cc5ca17e851df952c60690846be", "url": "https://github.com/dhis2/dhis2-core/commit/1f063c5e77f51cc5ca17e851df952c60690846be", "message": "Add delete TEI and Enrollment tests", "committedDate": "2020-03-18T12:42:01Z", "type": "commit"}, {"oid": "9e749289a997bb717825b1daca51e78c40c70fab", "url": "https://github.com/dhis2/dhis2-core/commit/9e749289a997bb717825b1daca51e78c40c70fab", "message": "Implement soft delete store", "committedDate": "2020-03-20T13:35:29Z", "type": "commit"}, {"oid": "a15eaae1a9840468822d26585d3908b2ffc14f2d", "url": "https://github.com/dhis2/dhis2-core/commit/a15eaae1a9840468822d26585d3908b2ffc14f2d", "message": "Fix tests", "committedDate": "2020-03-20T13:43:03Z", "type": "commit"}, {"oid": "1acc3a5d983441a8d5a45ae812f4f89970ac3c5a", "url": "https://github.com/dhis2/dhis2-core/commit/1acc3a5d983441a8d5a45ae812f4f89970ac3c5a", "message": "Fix sonar code smells", "committedDate": "2020-03-20T14:20:30Z", "type": "commit"}, {"oid": "920e0e29c572d4968d571f790fa614765f20409b", "url": "https://github.com/dhis2/dhis2-core/commit/920e0e29c572d4968d571f790fa614765f20409b", "message": "Fix tests", "committedDate": "2020-03-23T09:45:53Z", "type": "commit"}, {"oid": "aad7dfb28e0046f77f108f11440917ee1eb86129", "url": "https://github.com/dhis2/dhis2-core/commit/aad7dfb28e0046f77f108f11440917ee1eb86129", "message": "Merge remote-tracking branch 'origin/master' into DHIS2-7415", "committedDate": "2020-03-23T10:05:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5MjY3Ng==", "url": "https://github.com/dhis2/dhis2-core/pull/5131#discussion_r397692676", "bodyText": "Remove commented out code.", "author": "larshelge", "createdAt": "2020-03-25T08:54:44Z", "path": "dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/trackedentity/TrackedEntityInstanceServiceTest.java", "diffHunk": "@@ -109,6 +169,35 @@ public void testDeleteTrackedEntityInstance()\n         assertNull( entityInstanceService.getTrackedEntityInstance( teiB.getUid() ) );\r\n     }\r\n \r\n+    @Test\r\n+    public void testDeleteTrackedEntityInstanceAndLinkedEnrollmentsAndEvents()\r\n+    {\r\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\r\n+        long psIdA = programInstanceService.addProgramInstance( programInstanceA );\r\n+        long psiIdA = programStageInstanceService.addProgramStageInstance( programStageInstanceA );\r\n+//        programInstanceA.setId( idA );\r", "originalCommit": "aad7dfb28e0046f77f108f11440917ee1eb86129", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "abae66ebf296c5e77d17e72fee178cd8234c4d09", "chunk": "diff --git a/dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/trackedentity/TrackedEntityInstanceServiceTest.java b/dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/trackedentity/TrackedEntityInstanceServiceTest.java\nindex b615683ed8..55955a5939 100644\n--- a/dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/trackedentity/TrackedEntityInstanceServiceTest.java\n+++ b/dhis-2/dhis-services/dhis-service-core/src/test/java/org/hisp/dhis/trackedentity/TrackedEntityInstanceServiceTest.java\n\n@@ -1,237 +1,238 @@\n-package org.hisp.dhis.trackedentity;\n-\n-/*\n- * Copyright (c) 2004-2020, University of Oslo\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- * Redistributions of source code must retain the above copyright notice, this\n- * list of conditions and the following disclaimer.\n- *\n- * Redistributions in binary form must reproduce the above copyright notice,\n- * this list of conditions and the following disclaimer in the documentation\n- * and/or other materials provided with the distribution.\n- * Neither the name of the HISP project nor the names of its contributors may\n- * be used to endorse or promote products derived from this software without\n- * specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-import static org.junit.Assert.*;\n-\n-import com.google.common.collect.Sets;\n-import org.hisp.dhis.DhisSpringTest;\n-import org.hisp.dhis.organisationunit.OrganisationUnit;\n-import org.hisp.dhis.organisationunit.OrganisationUnitService;\n-import org.hisp.dhis.program.Program;\n-import org.hisp.dhis.program.ProgramInstance;\n-import org.hisp.dhis.program.ProgramInstanceService;\n-import org.hisp.dhis.program.ProgramService;\n-import org.hisp.dhis.program.ProgramStage;\n-import org.hisp.dhis.program.ProgramStageInstance;\n-import org.hisp.dhis.program.ProgramStageInstanceService;\n-import org.hisp.dhis.program.ProgramStageService;\n-import org.joda.time.DateTime;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-/**\n- * @author Chau Thu Tran\n- */\n-public class TrackedEntityInstanceServiceTest\n-    extends DhisSpringTest\n-{\n-    @Autowired\n-    private TrackedEntityInstanceService entityInstanceService;\n-\n-    @Autowired\n-    private OrganisationUnitService organisationUnitService;\n-\n-    @Autowired\n-    private ProgramService programService;\n-\n-    @Autowired\n-    private ProgramStageService programStageService;\n-\n-    @Autowired\n-    private ProgramStageInstanceService programStageInstanceService;\n-\n-    @Autowired\n-    private ProgramInstanceService programInstanceService;\n-\n-    @Autowired\n-    private TrackedEntityAttributeService attributeService;\n-\n-    private ProgramStageInstance programStageInstanceA;\n-\n-    private ProgramInstance programInstanceA;\n-\n-    private Program programA;\n-\n-    private TrackedEntityInstance entityInstanceA1;\n-\n-    private TrackedEntityInstance entityInstanceB1;\n-\n-    private TrackedEntityAttribute entityInstanceAttribute;\n-\n-    private OrganisationUnit organisationUnit;\n-\n-    @Override\n-    public void setUpTest()\n-    {\n-        organisationUnit = createOrganisationUnit( 'A' );\n-        organisationUnitService.addOrganisationUnit( organisationUnit );\n-\n-        OrganisationUnit organisationUnitB = createOrganisationUnit( 'B' );\n-        organisationUnitService.addOrganisationUnit( organisationUnitB );\n-\n-        entityInstanceAttribute = createTrackedEntityAttribute( 'A' );\n-        attributeService.addTrackedEntityAttribute( entityInstanceAttribute );\n-\n-        entityInstanceA1 = createTrackedEntityInstance( organisationUnit );\n-        entityInstanceB1 = createTrackedEntityInstance( organisationUnit );\n-        entityInstanceB1.setUid( \"UID-B1\" );\n-\n-        programA = createProgram( 'A', new HashSet<>(), organisationUnit );\n-\n-        programService.addProgram( programA );\n-\n-        ProgramStage stageA = createProgramStage( 'A', programA );\n-        stageA.setSortOrder( 1 );\n-        programStageService.saveProgramStage( stageA );\n-\n-        Set<ProgramStage> programStages = new HashSet<>();\n-        programStages.add( stageA );\n-        programA.setProgramStages( programStages );\n-        programService.updateProgram( programA );\n-\n-        DateTime enrollmentDate = DateTime.now();\n-        enrollmentDate.withTimeAtStartOfDay();\n-        enrollmentDate = enrollmentDate.minusDays( 70 );\n-\n-        DateTime incidenDate = DateTime.now();\n-        incidenDate.withTimeAtStartOfDay();\n-\n-        programInstanceA = new ProgramInstance( enrollmentDate.toDate(), incidenDate.toDate(), entityInstanceA1,\n-            programA );\n-        programInstanceA.setUid( \"UID-A\" );\n-        programInstanceA.setOrganisationUnit( organisationUnit );\n-\n-        programStageInstanceA = new ProgramStageInstance( programInstanceA, stageA );\n-        programInstanceA.setUid( \"UID-PSI-A\" );\n-        programInstanceA.setOrganisationUnit( organisationUnit );\n-    }\n-\n-    @Test\n-    public void testSaveTrackedEntityInstance()\n-    {\n-        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n-\n-        assertNotNull( entityInstanceService.getTrackedEntityInstance( idA ) );\n-        assertNotNull( entityInstanceService.getTrackedEntityInstance( idB ) );\n-    }\n-\n-    @Test\n-    public void testDeleteTrackedEntityInstance()\n-    {\n-        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n-\n-        TrackedEntityInstance teiA = entityInstanceService.getTrackedEntityInstance( idA );\n-        TrackedEntityInstance teiB = entityInstanceService.getTrackedEntityInstance( idB );\n-\n-        assertNotNull( teiA );\n-        assertNotNull( teiB );\n-\n-        entityInstanceService.deleteTrackedEntityInstance( entityInstanceA1 );\n-\n-        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n-        assertNotNull( entityInstanceService.getTrackedEntityInstance( teiB.getUid() ) );\n-\n-        entityInstanceService.deleteTrackedEntityInstance( entityInstanceB1 );\n-\n-        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n-        assertNull( entityInstanceService.getTrackedEntityInstance( teiB.getUid() ) );\n-    }\n-\n-    @Test\n-    public void testDeleteTrackedEntityInstanceAndLinkedEnrollmentsAndEvents()\n-    {\n-        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-        long psIdA = programInstanceService.addProgramInstance( programInstanceA );\n-        long psiIdA = programStageInstanceService.addProgramStageInstance( programStageInstanceA );\n-//        programInstanceA.setId( idA );\n-        programInstanceA.setProgramStageInstances( Sets.newHashSet( programStageInstanceA ) );\n-        entityInstanceA1.setProgramInstances( Sets.newHashSet( programInstanceA ) );\n-\n-        programInstanceService.updateProgramInstance( programInstanceA );\n-        entityInstanceService.updateTrackedEntityInstance( entityInstanceA1 );\n-\n-        TrackedEntityInstance teiA = entityInstanceService.getTrackedEntityInstance( idA );\n-        ProgramInstance psA = programInstanceService.getProgramInstance( psIdA );\n-        ProgramStageInstance psiA = programStageInstanceService.getProgramStageInstance( psiIdA );\n-\n-        assertNotNull( teiA );\n-        assertNotNull( psA );\n-        assertNotNull( psiA );\n-\n-        entityInstanceService.deleteTrackedEntityInstance( entityInstanceA1 );\n-\n-        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n-        assertNull( programInstanceService.getProgramInstance( psIdA ) );\n-        assertNull( programStageInstanceService.getProgramStageInstance( psiIdA ) );\n-\n-    }\n-\n-    @Test\n-    public void testUpdateTrackedEntityInstance()\n-    {\n-        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-\n-        assertNotNull( entityInstanceService.getTrackedEntityInstance( idA ) );\n-\n-        entityInstanceA1.setName( \"B\" );\n-        entityInstanceService.updateTrackedEntityInstance( entityInstanceA1 );\n-\n-        assertEquals( \"B\", entityInstanceService.getTrackedEntityInstance( idA ).getName() );\n-    }\n-\n-    @Test\n-    public void testGetTrackedEntityInstanceById()\n-    {\n-        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n-\n-        assertEquals( entityInstanceA1, entityInstanceService.getTrackedEntityInstance( idA ) );\n-        assertEquals( entityInstanceB1, entityInstanceService.getTrackedEntityInstance( idB ) );\n-    }\n-\n-    @Test\n-    public void testGetTrackedEntityInstanceByUid()\n-    {\n-        entityInstanceA1.setUid( \"A1\" );\n-        entityInstanceB1.setUid( \"B1\" );\n-\n-        entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n-        entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n-\n-        assertEquals( entityInstanceA1, entityInstanceService.getTrackedEntityInstance( \"A1\" ) );\n-        assertEquals( entityInstanceB1, entityInstanceService.getTrackedEntityInstance( \"B1\" ) );\n-    }\n-\n-}\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.hisp.dhis.trackedentity;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.hisp.dhis.DhisSpringTest;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.program.Program;\n+import org.hisp.dhis.program.ProgramInstance;\n+import org.hisp.dhis.program.ProgramInstanceService;\n+import org.hisp.dhis.program.ProgramService;\n+import org.hisp.dhis.program.ProgramStage;\n+import org.hisp.dhis.program.ProgramStageInstance;\n+import org.hisp.dhis.program.ProgramStageInstanceService;\n+import org.hisp.dhis.program.ProgramStageService;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * @author Chau Thu Tran\n+ */\n+public class TrackedEntityInstanceServiceTest\n+    extends\n+    DhisSpringTest\n+{\n+    @Autowired\n+    private TrackedEntityInstanceService entityInstanceService;\n+\n+    @Autowired\n+    private OrganisationUnitService organisationUnitService;\n+\n+    @Autowired\n+    private ProgramService programService;\n+\n+    @Autowired\n+    private ProgramStageService programStageService;\n+\n+    @Autowired\n+    private ProgramStageInstanceService programStageInstanceService;\n+\n+    @Autowired\n+    private ProgramInstanceService programInstanceService;\n+\n+    @Autowired\n+    private TrackedEntityAttributeService attributeService;\n+\n+    private ProgramStageInstance programStageInstanceA;\n+\n+    private ProgramInstance programInstanceA;\n+\n+    private Program programA;\n+\n+    private TrackedEntityInstance entityInstanceA1;\n+\n+    private TrackedEntityInstance entityInstanceB1;\n+\n+    private TrackedEntityAttribute entityInstanceAttribute;\n+\n+    private OrganisationUnit organisationUnit;\n+\n+    @Override\n+    public void setUpTest()\n+    {\n+        organisationUnit = createOrganisationUnit( 'A' );\n+        organisationUnitService.addOrganisationUnit( organisationUnit );\n+\n+        OrganisationUnit organisationUnitB = createOrganisationUnit( 'B' );\n+        organisationUnitService.addOrganisationUnit( organisationUnitB );\n+\n+        entityInstanceAttribute = createTrackedEntityAttribute( 'A' );\n+        attributeService.addTrackedEntityAttribute( entityInstanceAttribute );\n+\n+        entityInstanceA1 = createTrackedEntityInstance( organisationUnit );\n+        entityInstanceB1 = createTrackedEntityInstance( organisationUnit );\n+        entityInstanceB1.setUid( \"UID-B1\" );\n+\n+        programA = createProgram( 'A', new HashSet<>(), organisationUnit );\n+\n+        programService.addProgram( programA );\n+\n+        ProgramStage stageA = createProgramStage( 'A', programA );\n+        stageA.setSortOrder( 1 );\n+        programStageService.saveProgramStage( stageA );\n+\n+        Set<ProgramStage> programStages = new HashSet<>();\n+        programStages.add( stageA );\n+        programA.setProgramStages( programStages );\n+        programService.updateProgram( programA );\n+\n+        DateTime enrollmentDate = DateTime.now();\n+        enrollmentDate.withTimeAtStartOfDay();\n+        enrollmentDate = enrollmentDate.minusDays( 70 );\n+\n+        DateTime incidenDate = DateTime.now();\n+        incidenDate.withTimeAtStartOfDay();\n+\n+        programInstanceA = new ProgramInstance( enrollmentDate.toDate(), incidenDate.toDate(), entityInstanceA1,\n+            programA );\n+        programInstanceA.setUid( \"UID-A\" );\n+        programInstanceA.setOrganisationUnit( organisationUnit );\n+\n+        programStageInstanceA = new ProgramStageInstance( programInstanceA, stageA );\n+        programInstanceA.setUid( \"UID-PSI-A\" );\n+        programInstanceA.setOrganisationUnit( organisationUnit );\n+    }\n+\n+    @Test\n+    public void testSaveTrackedEntityInstance()\n+    {\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n+\n+        assertNotNull( entityInstanceService.getTrackedEntityInstance( idA ) );\n+        assertNotNull( entityInstanceService.getTrackedEntityInstance( idB ) );\n+    }\n+\n+    @Test\n+    public void testDeleteTrackedEntityInstance()\n+    {\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n+\n+        TrackedEntityInstance teiA = entityInstanceService.getTrackedEntityInstance( idA );\n+        TrackedEntityInstance teiB = entityInstanceService.getTrackedEntityInstance( idB );\n+\n+        assertNotNull( teiA );\n+        assertNotNull( teiB );\n+\n+        entityInstanceService.deleteTrackedEntityInstance( entityInstanceA1 );\n+\n+        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n+        assertNotNull( entityInstanceService.getTrackedEntityInstance( teiB.getUid() ) );\n+\n+        entityInstanceService.deleteTrackedEntityInstance( entityInstanceB1 );\n+\n+        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n+        assertNull( entityInstanceService.getTrackedEntityInstance( teiB.getUid() ) );\n+    }\n+\n+    @Test\n+    public void testDeleteTrackedEntityInstanceAndLinkedEnrollmentsAndEvents()\n+    {\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+        long psIdA = programInstanceService.addProgramInstance( programInstanceA );\n+        long psiIdA = programStageInstanceService.addProgramStageInstance( programStageInstanceA );\n+\n+        programInstanceA.setProgramStageInstances( Sets.newHashSet( programStageInstanceA ) );\n+        entityInstanceA1.setProgramInstances( Sets.newHashSet( programInstanceA ) );\n+\n+        programInstanceService.updateProgramInstance( programInstanceA );\n+        entityInstanceService.updateTrackedEntityInstance( entityInstanceA1 );\n+\n+        TrackedEntityInstance teiA = entityInstanceService.getTrackedEntityInstance( idA );\n+        ProgramInstance psA = programInstanceService.getProgramInstance( psIdA );\n+        ProgramStageInstance psiA = programStageInstanceService.getProgramStageInstance( psiIdA );\n+\n+        assertNotNull( teiA );\n+        assertNotNull( psA );\n+        assertNotNull( psiA );\n+\n+        entityInstanceService.deleteTrackedEntityInstance( entityInstanceA1 );\n+\n+        assertNull( entityInstanceService.getTrackedEntityInstance( teiA.getUid() ) );\n+        assertNull( programInstanceService.getProgramInstance( psIdA ) );\n+        assertNull( programStageInstanceService.getProgramStageInstance( psiIdA ) );\n+\n+    }\n+\n+    @Test\n+    public void testUpdateTrackedEntityInstance()\n+    {\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+\n+        assertNotNull( entityInstanceService.getTrackedEntityInstance( idA ) );\n+\n+        entityInstanceA1.setName( \"B\" );\n+        entityInstanceService.updateTrackedEntityInstance( entityInstanceA1 );\n+\n+        assertEquals( \"B\", entityInstanceService.getTrackedEntityInstance( idA ).getName() );\n+    }\n+\n+    @Test\n+    public void testGetTrackedEntityInstanceById()\n+    {\n+        long idA = entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+        long idB = entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n+\n+        assertEquals( entityInstanceA1, entityInstanceService.getTrackedEntityInstance( idA ) );\n+        assertEquals( entityInstanceB1, entityInstanceService.getTrackedEntityInstance( idB ) );\n+    }\n+\n+    @Test\n+    public void testGetTrackedEntityInstanceByUid()\n+    {\n+        entityInstanceA1.setUid( \"A1\" );\n+        entityInstanceB1.setUid( \"B1\" );\n+\n+        entityInstanceService.addTrackedEntityInstance( entityInstanceA1 );\n+        entityInstanceService.addTrackedEntityInstance( entityInstanceB1 );\n+\n+        assertEquals( entityInstanceA1, entityInstanceService.getTrackedEntityInstance( \"A1\" ) );\n+        assertEquals( entityInstanceB1, entityInstanceService.getTrackedEntityInstance( \"B1\" ) );\n+    }\n+\n+}\n"}}, {"oid": "abae66ebf296c5e77d17e72fee178cd8234c4d09", "url": "https://github.com/dhis2/dhis2-core/commit/abae66ebf296c5e77d17e72fee178cd8234c4d09", "message": "Code review fixes", "committedDate": "2020-03-26T10:03:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA5NjIzOA==", "url": "https://github.com/dhis2/dhis2-core/pull/5131#discussion_r400096238", "bodyText": "Are you sure there are no side effects of removing setting the status to CANCELLED ? Maybe you can set it before you send it onwards to the deletion store?", "author": "mortenoh", "createdAt": "2020-03-30T10:46:39Z", "path": "dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramInstanceService.java", "diffHunk": "@@ -112,23 +112,7 @@ public long addProgramInstance( ProgramInstance programInstance )\n     @Transactional\r\n     public void deleteProgramInstance( ProgramInstance programInstance )\r\n     {\r\n-        deleteProgramInstance( programInstance, false );\r\n-    }\r\n-\r\n-    @Override\r\n-    @Transactional\r\n-    public void deleteProgramInstance( ProgramInstance programInstance, boolean forceDelete )\r\n-    {\r\n-        if ( forceDelete )\r\n-        {\r\n-            programInstanceStore.delete( programInstance );\r\n-        }\r\n-        else\r\n-        {\r\n-            programInstance.setDeleted( true );\r\n-            programInstance.setStatus( ProgramStatus.CANCELLED );\r\n-            programInstanceStore.update( programInstance );\r\n-        }\r\n+        programInstanceStore.delete( programInstance );\r", "originalCommit": "abae66ebf296c5e77d17e72fee178cd8234c4d09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27a89af420dd17e9fd8003027dc1f02ebcd21844", "chunk": "diff --git a/dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramInstanceService.java b/dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramInstanceService.java\nindex e68a3151c7..5f1365187c 100644\n--- a/dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramInstanceService.java\n+++ b/dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramInstanceService.java\n\n@@ -1,613 +1,631 @@\n-package org.hisp.dhis.program;\n-\n-/*\n- * Copyright (c) 2004-2020, University of Oslo\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- * Redistributions of source code must retain the above copyright notice, this\n- * list of conditions and the following disclaimer.\n- *\n- * Redistributions in binary form must reproduce the above copyright notice,\n- * this list of conditions and the following disclaimer in the documentation\n- * and/or other materials provided with the distribution.\n- * Neither the name of the HISP project nor the names of its contributors may\n- * be used to endorse or promote products derived from this software without\n- * specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-import static org.hisp.dhis.common.OrganisationUnitSelectionMode.*;\n-\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import org.hisp.dhis.common.*;\n-import org.hisp.dhis.event.EventStatus;\n-import org.hisp.dhis.organisationunit.OrganisationUnit;\n-import org.hisp.dhis.organisationunit.OrganisationUnitService;\n-import org.hisp.dhis.program.notification.event.ProgramEnrollmentCompletionNotificationEvent;\n-import org.hisp.dhis.program.notification.event.ProgramEnrollmentNotificationEvent;\n-import org.hisp.dhis.programrule.engine.EnrollmentEvaluationEvent;\n-import org.hisp.dhis.security.acl.AclService;\n-import org.hisp.dhis.trackedentity.*;\n-import org.hisp.dhis.user.CurrentUserService;\n-import org.hisp.dhis.user.User;\n-import org.hisp.dhis.util.DateUtils;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.context.ApplicationEventPublisher;\n-import org.springframework.stereotype.Service;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * @author Abyot Asalefew\n- */\n-@Slf4j\n-@Service( \"org.hisp.dhis.program.ProgramInstanceService\" )\n-public class DefaultProgramInstanceService\n-    implements ProgramInstanceService\n-{\n-    // -------------------------------------------------------------------------\n-    // Dependencies\n-    // -------------------------------------------------------------------------\n-\n-    @Autowired\n-    private ProgramInstanceStore programInstanceStore;\n-\n-    @Autowired\n-    private ProgramStageInstanceStore programStageInstanceStore;\n-\n-    @Autowired\n-    private ProgramService programService;\n-\n-    @Autowired\n-    private CurrentUserService currentUserService;\n-\n-    @Autowired\n-    private TrackedEntityInstanceService trackedEntityInstanceService;\n-\n-    @Autowired\n-    private OrganisationUnitService organisationUnitService;\n-\n-    @Autowired\n-    private TrackedEntityTypeService trackedEntityTypeService;\n-\n-    @Autowired\n-    private ApplicationEventPublisher eventPublisher;\n-\n-    @Autowired\n-    private TrackerOwnershipManager trackerOwnershipAccessManager;\n-\n-    @Autowired\n-    private AclService aclService;\n-\n-    // -------------------------------------------------------------------------\n-    // Implementation methods\n-    // -------------------------------------------------------------------------\n-\n-    @Override\n-    @Transactional\n-    public long addProgramInstance( ProgramInstance programInstance )\n-    {\n-        programInstanceStore.save( programInstance );\n-        return programInstance.getId();\n-    }\n-\n-    @Override\n-    @Transactional\n-    public void deleteProgramInstance( ProgramInstance programInstance )\n-    {\n-        programInstanceStore.delete( programInstance );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public ProgramInstance getProgramInstance( long id )\n-    {\n-        ProgramInstance programInstance = programInstanceStore.get( id );\n-\n-        User user = currentUserService.getCurrentUser();\n-\n-        return programInstance;\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public ProgramInstance getProgramInstance( String uid )\n-    {\n-        ProgramInstance programInstance = programInstanceStore.getByUid( uid );\n-\n-        User user = currentUserService.getCurrentUser();\n-\n-        return programInstance;\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public boolean programInstanceExists( String uid )\n-    {\n-        return programInstanceStore.exists( uid );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public boolean programInstanceExistsIncludingDeleted( String uid )\n-    {\n-        return programInstanceStore.existsIncludingDeleted( uid );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public List<String> getProgramInstancesUidsIncludingDeleted( List<String> uids )\n-    {\n-        return programInstanceStore.getUidsIncludingDeleted( uids );\n-    }\n-\n-    @Override\n-    @Transactional\n-    public void updateProgramInstance( ProgramInstance programInstance )\n-    {\n-        programInstanceStore.update( programInstance );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public ProgramInstanceQueryParams getFromUrl( Set<String> ou, OrganisationUnitSelectionMode ouMode,\n-        Date lastUpdated, String lastUpdatedDuration, String program, ProgramStatus programStatus,\n-        Date programStartDate, Date programEndDate, String trackedEntityType, String trackedEntityInstance,\n-        Boolean followUp, Integer page, Integer pageSize, boolean totalPages, boolean skipPaging,\n-        boolean includeDeleted )\n-    {\n-        ProgramInstanceQueryParams params = new ProgramInstanceQueryParams();\n-\n-        Set<OrganisationUnit> possibleSearchOrgUnits = new HashSet<>();\n-\n-        User user = currentUserService.getCurrentUser();\n-\n-        if ( user != null )\n-        {\n-            possibleSearchOrgUnits = user.getTeiSearchOrganisationUnitsWithFallback();\n-        }\n-\n-        if ( ou != null )\n-        {\n-            for ( String orgUnit : ou )\n-            {\n-                OrganisationUnit organisationUnit = organisationUnitService.getOrganisationUnit( orgUnit );\n-\n-                if ( organisationUnit == null )\n-                {\n-                    throw new IllegalQueryException( \"Organisation unit does not exist: \" + orgUnit );\n-                }\n-\n-                if ( !organisationUnitService.isInUserHierarchy( organisationUnit.getUid(), possibleSearchOrgUnits ) )\n-                {\n-                    throw new IllegalQueryException( \"Organisation unit is not part of the search scope: \" + orgUnit );\n-                }\n-\n-                params.getOrganisationUnits().add( organisationUnit );\n-            }\n-        }\n-\n-        Program pr = program != null ? programService.getProgram( program ) : null;\n-\n-        if ( program != null && pr == null )\n-        {\n-            throw new IllegalQueryException( \"Program does not exist: \" + program );\n-        }\n-\n-        TrackedEntityType te = trackedEntityType != null ? trackedEntityTypeService.getTrackedEntityType( trackedEntityType ) : null;\n-\n-        if ( trackedEntityType != null && te == null )\n-        {\n-            throw new IllegalQueryException( \"Tracked entity does not exist: \" + program );\n-        }\n-\n-        TrackedEntityInstance tei = trackedEntityInstance != null ? trackedEntityInstanceService.getTrackedEntityInstance( trackedEntityInstance ) : null;\n-\n-        if ( trackedEntityInstance != null && tei == null )\n-        {\n-            throw new IllegalQueryException( \"Tracked entity instance does not exist: \" + program );\n-        }\n-\n-        params.setProgram( pr );\n-        params.setProgramStatus( programStatus );\n-        params.setFollowUp( followUp );\n-        params.setLastUpdated( lastUpdated );\n-        params.setLastUpdatedDuration( lastUpdatedDuration );\n-        params.setProgramStartDate( programStartDate );\n-        params.setProgramEndDate( programEndDate );\n-        params.setTrackedEntityType( te );\n-        params.setTrackedEntityInstance( tei );\n-        params.setOrganisationUnitMode( ouMode );\n-        params.setPage( page );\n-        params.setPageSize( pageSize );\n-        params.setTotalPages( totalPages );\n-        params.setSkipPaging( skipPaging );\n-        params.setIncludeDeleted( includeDeleted );\n-        params.setUser( user );\n-\n-        return params;\n-    }\n-\n-    // TODO consider security\n-    @Override\n-    @Transactional( readOnly = true )\n-    public List<ProgramInstance> getProgramInstances( ProgramInstanceQueryParams params )\n-    {\n-        decideAccess( params );\n-        validate( params );\n-\n-        User user = currentUserService.getCurrentUser();\n-\n-        if ( user != null && params.isOrganisationUnitMode( OrganisationUnitSelectionMode.ACCESSIBLE ) )\n-        {\n-            params.setOrganisationUnits( user.getTeiSearchOrganisationUnitsWithFallback() );\n-            params.setOrganisationUnitMode( OrganisationUnitSelectionMode.DESCENDANTS );\n-        }\n-        else if ( params.isOrganisationUnitMode( CHILDREN ) )\n-        {\n-            Set<OrganisationUnit> organisationUnits = new HashSet<>();\n-            organisationUnits.addAll( params.getOrganisationUnits() );\n-\n-            for ( OrganisationUnit organisationUnit : params.getOrganisationUnits() )\n-            {\n-                organisationUnits.addAll( organisationUnit.getChildren() );\n-            }\n-\n-            params.setOrganisationUnits( organisationUnits );\n-        }\n-\n-        if ( !params.isPaging() && !params.isSkipPaging() )\n-        {\n-            params.setDefaultPaging();\n-        }\n-\n-        List<ProgramInstance> programInstances = programInstanceStore.getProgramInstances( params );\n-\n-        return programInstances;\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public int countProgramInstances( ProgramInstanceQueryParams params )\n-    {\n-        decideAccess( params );\n-        validate( params );\n-\n-        User user = currentUserService.getCurrentUser();\n-\n-        if ( user != null && params.isOrganisationUnitMode( OrganisationUnitSelectionMode.ACCESSIBLE ) )\n-        {\n-            params.setOrganisationUnits( user.getTeiSearchOrganisationUnitsWithFallback() );\n-            params.setOrganisationUnitMode( OrganisationUnitSelectionMode.DESCENDANTS );\n-        }\n-        else if ( params.isOrganisationUnitMode( CHILDREN ) )\n-        {\n-            Set<OrganisationUnit> organisationUnits = new HashSet<>();\n-            organisationUnits.addAll( params.getOrganisationUnits() );\n-\n-            for ( OrganisationUnit organisationUnit : params.getOrganisationUnits() )\n-            {\n-                organisationUnits.addAll( organisationUnit.getChildren() );\n-            }\n-\n-            params.setOrganisationUnits( organisationUnits );\n-        }\n-\n-        params.setSkipPaging( true );\n-\n-        return programInstanceStore.countProgramInstances( params );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public void decideAccess( ProgramInstanceQueryParams params )\n-    {\n-        if ( params.hasProgram() )\n-        {\n-            if ( !aclService.canDataRead( params.getUser(), params.getProgram() ) )\n-            {\n-                throw new IllegalQueryException( \"Current user is not authorized to read data from selected program:  \" + params.getProgram().getUid() );\n-            }\n-\n-            if ( params.getProgram().getTrackedEntityType() != null && !aclService.canDataRead( params.getUser(), params.getProgram().getTrackedEntityType() ) )\n-            {\n-                throw new IllegalQueryException( \"Current user is not authorized to read data from selected program's tracked entity type:  \" + params.getProgram().getTrackedEntityType().getUid() );\n-            }\n-\n-        }\n-\n-        if ( params.hasTrackedEntityType() && !aclService.canDataRead( params.getUser(), params.getTrackedEntityType() ) )\n-        {\n-            throw new IllegalQueryException( \"Current user is not authorized to read data from selected tracked entity type:  \" + params.getTrackedEntityType().getUid() );\n-        }\n-    }\n-\n-    @Override\n-    public void validate( ProgramInstanceQueryParams params ) throws IllegalQueryException\n-    {\n-        String violation = null;\n-\n-        if ( params == null )\n-        {\n-            throw new IllegalQueryException( \"Params cannot be null\" );\n-        }\n-\n-        User user = params.getUser();\n-\n-        if ( !params.hasOrganisationUnits() && !(params.isOrganisationUnitMode( ALL ) || params.isOrganisationUnitMode( ACCESSIBLE )) )\n-        {\n-            violation = \"At least one organisation unit must be specified\";\n-        }\n-\n-        if ( params.isOrganisationUnitMode( ACCESSIBLE ) && (user == null || !user.hasDataViewOrganisationUnitWithFallback()) )\n-        {\n-            violation = \"Current user must be associated with at least one organisation unit when selection mode is ACCESSIBLE\";\n-        }\n-\n-        if ( params.hasProgram() && params.hasTrackedEntityType() )\n-        {\n-            violation = \"Program and tracked entity cannot be specified simultaneously\";\n-        }\n-\n-        if ( params.hasProgramStatus() && !params.hasProgram() )\n-        {\n-            violation = \"Program must be defined when program status is defined\";\n-        }\n-\n-        if ( params.hasFollowUp() && !params.hasProgram() )\n-        {\n-            violation = \"Program must be defined when follow up status is defined\";\n-        }\n-\n-        if ( params.hasProgramStartDate() && !params.hasProgram() )\n-        {\n-            violation = \"Program must be defined when program start date is specified\";\n-        }\n-\n-        if ( params.hasProgramEndDate() && !params.hasProgram() )\n-        {\n-            violation = \"Program must be defined when program end date is specified\";\n-        }\n-\n-        if ( params.hasLastUpdated() && params.hasLastUpdatedDuration() )\n-        {\n-            violation = \"Last updated and last updated duration cannot be specified simultaneously\";\n-        }\n-\n-        if ( params.hasLastUpdatedDuration() && DateUtils.getDuration( params.getLastUpdatedDuration() ) == null )\n-        {\n-            violation = \"Duration is not valid: \" + params.getLastUpdatedDuration();\n-        }\n-\n-        if ( violation != null )\n-        {\n-            log.warn( \"Validation failed: \" + violation );\n-\n-            throw new IllegalQueryException( violation );\n-        }\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public List<ProgramInstance> getProgramInstances( Program program )\n-    {\n-        return programInstanceStore.get( program );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public List<ProgramInstance> getProgramInstances( Program program, ProgramStatus status )\n-    {\n-        return programInstanceStore.get( program, status );\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public List<ProgramInstance> getProgramInstances( TrackedEntityInstance entityInstance, Program program, ProgramStatus status )\n-    {\n-        return programInstanceStore.get( entityInstance, program, status );\n-    }\n-\n-    @Override\n-    @Transactional\n-    public ProgramInstance prepareProgramInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n-        ProgramStatus programStatus, Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit, String uid )\n-    {\n-        if ( program.getTrackedEntityType() != null && !program.getTrackedEntityType().equals( trackedEntityInstance.getTrackedEntityType() ) )\n-        {\n-            throw new IllegalQueryException( \"Tracked entity instance must have same tracked entity as program: \" + program.getUid() );\n-        }\n-\n-        ProgramInstance programInstance = new ProgramInstance();\n-        programInstance.setUid( CodeGenerator.isValidUid( uid ) ? uid : CodeGenerator.generateUid() );\n-        programInstance.setOrganisationUnit( organisationUnit );\n-        programInstance.enrollTrackedEntityInstance( trackedEntityInstance, program );\n-\n-        if ( enrollmentDate != null )\n-        {\n-            programInstance.setEnrollmentDate( enrollmentDate );\n-        }\n-        else\n-        {\n-            programInstance.setEnrollmentDate( new Date() );\n-        }\n-\n-        if ( incidentDate != null )\n-        {\n-            programInstance.setIncidentDate( incidentDate );\n-        }\n-        else\n-        {\n-            programInstance.setIncidentDate( new Date() );\n-        }\n-\n-        programInstance.setStatus( programStatus );\n-\n-        return programInstance;\n-    }\n-\n-    @Override\n-    @Transactional\n-    public ProgramInstance enrollTrackedEntityInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n-        Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit )\n-    {\n-        return enrollTrackedEntityInstance( trackedEntityInstance, program, enrollmentDate,\n-            incidentDate, organisationUnit, CodeGenerator.generateUid() );\n-    }\n-\n-    @Override\n-    @Transactional\n-    public ProgramInstance enrollTrackedEntityInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n-        Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit, String uid )\n-    {\n-        // ---------------------------------------------------------------------\n-        // Add program instance\n-        // ---------------------------------------------------------------------\n-\n-        ProgramInstance programInstance = prepareProgramInstance( trackedEntityInstance, program, ProgramStatus.ACTIVE, enrollmentDate,\n-            incidentDate, organisationUnit, uid );\n-        addProgramInstance( programInstance );\n-\n-        // ---------------------------------------------------------------------\n-        // Add program owner and overwrite if already exists.\n-        // ---------------------------------------------------------------------\n-\n-        trackerOwnershipAccessManager.assignOwnership( trackedEntityInstance, program, organisationUnit, true, true );\n-\n-\n-        // -----------------------------------------------------------------\n-        // Send enrollment notifications (if any)\n-        // -----------------------------------------------------------------\n-\n-        eventPublisher.publishEvent( new ProgramEnrollmentNotificationEvent( this, programInstance.getId() ) );\n-\n-        eventPublisher.publishEvent( new EnrollmentEvaluationEvent( this, programInstance.getId() ) );\n-\n-        // -----------------------------------------------------------------\n-        // Update ProgramInstance and TEI\n-        // -----------------------------------------------------------------\n-\n-        updateProgramInstance( programInstance );\n-        trackedEntityInstanceService.updateTrackedEntityInstance( trackedEntityInstance );\n-\n-        return programInstance;\n-    }\n-\n-    @Override\n-    @Transactional( readOnly = true )\n-    public boolean canAutoCompleteProgramInstanceStatus( ProgramInstance programInstance )\n-    {\n-        Set<ProgramStageInstance> programStageInstances = new HashSet<>( programInstance.getProgramStageInstances() );\n-        Set<ProgramStage> programStages = new HashSet<>();\n-\n-        for ( ProgramStageInstance programStageInstance : programStageInstances )\n-        {\n-            if ( (!programStageInstance.isCompleted() && programStageInstance.getStatus() != EventStatus.SKIPPED)\n-                || programStageInstance.getProgramStage().getRepeatable() )\n-            {\n-                return false;\n-            }\n-\n-            programStages.add( programStageInstance.getProgramStage() );\n-        }\n-\n-        return programStages.size() == programInstance.getProgram().getProgramStages().size();\n-    }\n-\n-    @Override\n-    @Transactional\n-    public void completeProgramInstanceStatus( ProgramInstance programInstance )\n-    {\n-        // -----------------------------------------------------------------\n-        // Update program-instance\n-        // -----------------------------------------------------------------\n-\n-        programInstance.setStatus( ProgramStatus.COMPLETED );\n-        updateProgramInstance( programInstance );\n-\n-        // ---------------------------------------------------------------------\n-        // Send sms-message after program completion\n-        // ---------------------------------------------------------------------\n-\n-        eventPublisher.publishEvent( new ProgramEnrollmentCompletionNotificationEvent( this, programInstance.getId() ) );\n-\n-        eventPublisher.publishEvent( new EnrollmentEvaluationEvent( this, programInstance.getId() ) );\n-    }\n-\n-    @Override\n-    @Transactional\n-    public void cancelProgramInstanceStatus( ProgramInstance programInstance )\n-    {\n-        // ---------------------------------------------------------------------\n-        // Set status of the program-instance\n-        // ---------------------------------------------------------------------\n-        programInstance.setStatus( ProgramStatus.CANCELLED );\n-        updateProgramInstance( programInstance );\n-\n-        // ---------------------------------------------------------------------\n-        // Set statuses of the program-stage-instances\n-        // ---------------------------------------------------------------------\n-\n-        for ( ProgramStageInstance programStageInstance : programInstance.getProgramStageInstances() )\n-        {\n-            if ( programStageInstance.getExecutionDate() == null )\n-            {\n-                // -------------------------------------------------------------\n-                // Set status as skipped for overdue events, or delete\n-                // -------------------------------------------------------------\n-\n-                if ( programStageInstance.getDueDate().before( programInstance.getEndDate() ) )\n-                {\n-                    programStageInstance.setStatus( EventStatus.SKIPPED );\n-                    programStageInstanceStore.update( programStageInstance );\n-                }\n-                else\n-                {\n-                    programStageInstanceStore.delete( programStageInstance );\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    @Transactional\n-    public void incompleteProgramInstanceStatus( ProgramInstance programInstance )\n-    {\n-        Program program = programInstance.getProgram();\n-\n-        TrackedEntityInstance tei = programInstance.getEntityInstance();\n-\n-        if ( getProgramInstances( tei, program, ProgramStatus.ACTIVE ).size() > 0 )\n-        {\n-            log.warn( \"Program has another active enrollment going on. Not possible to incomplete\" );\n-\n-            throw new IllegalQueryException( \"Program has another active enrollment going on. Not possible to incomplete\" );\n-        }\n-\n-        // -----------------------------------------------------------------\n-        // Update program-instance\n-        // -----------------------------------------------------------------\n-\n-        programInstance.setStatus( ProgramStatus.ACTIVE );\n-        programInstance.setEndDate( null );\n-\n-        updateProgramInstance( programInstance );\n-    }\n-}\n+package org.hisp.dhis.program;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import static org.hisp.dhis.common.OrganisationUnitSelectionMode.*;\n+\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import org.hisp.dhis.common.*;\n+import org.hisp.dhis.event.EventStatus;\n+import org.hisp.dhis.organisationunit.OrganisationUnit;\n+import org.hisp.dhis.organisationunit.OrganisationUnitService;\n+import org.hisp.dhis.program.notification.event.ProgramEnrollmentCompletionNotificationEvent;\n+import org.hisp.dhis.program.notification.event.ProgramEnrollmentNotificationEvent;\n+import org.hisp.dhis.programrule.engine.EnrollmentEvaluationEvent;\n+import org.hisp.dhis.security.acl.AclService;\n+import org.hisp.dhis.trackedentity.*;\n+import org.hisp.dhis.user.CurrentUserService;\n+import org.hisp.dhis.user.User;\n+import org.hisp.dhis.util.DateUtils;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+/**\n+ * @author Abyot Asalefew\n+ */\n+@Slf4j\n+@Service( \"org.hisp.dhis.program.ProgramInstanceService\" )\n+public class DefaultProgramInstanceService\n+    implements\n+    ProgramInstanceService\n+{\n+    // -------------------------------------------------------------------------\n+    // Dependencies\n+    // -------------------------------------------------------------------------\n+\n+    @Autowired\n+    private ProgramInstanceStore programInstanceStore;\n+\n+    @Autowired\n+    private ProgramStageInstanceStore programStageInstanceStore;\n+\n+    @Autowired\n+    private ProgramService programService;\n+\n+    @Autowired\n+    private CurrentUserService currentUserService;\n+\n+    @Autowired\n+    private TrackedEntityInstanceService trackedEntityInstanceService;\n+\n+    @Autowired\n+    private OrganisationUnitService organisationUnitService;\n+\n+    @Autowired\n+    private TrackedEntityTypeService trackedEntityTypeService;\n+\n+    @Autowired\n+    private ApplicationEventPublisher eventPublisher;\n+\n+    @Autowired\n+    private TrackerOwnershipManager trackerOwnershipAccessManager;\n+\n+    @Autowired\n+    private AclService aclService;\n+\n+    // -------------------------------------------------------------------------\n+    // Implementation methods\n+    // -------------------------------------------------------------------------\n+\n+    @Override\n+    @Transactional\n+    public long addProgramInstance( ProgramInstance programInstance )\n+    {\n+        programInstanceStore.save( programInstance );\n+        return programInstance.getId();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void deleteProgramInstance( ProgramInstance programInstance )\n+    {\n+        programInstance.setStatus( ProgramStatus.CANCELLED );\n+        programInstanceStore.update( programInstance );\n+        programInstanceStore.delete( programInstance );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public ProgramInstance getProgramInstance( long id )\n+    {\n+        ProgramInstance programInstance = programInstanceStore.get( id );\n+\n+        return programInstance;\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public ProgramInstance getProgramInstance( String uid )\n+    {\n+        ProgramInstance programInstance = programInstanceStore.getByUid( uid );\n+\n+        return programInstance;\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public boolean programInstanceExists( String uid )\n+    {\n+        return programInstanceStore.exists( uid );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public boolean programInstanceExistsIncludingDeleted( String uid )\n+    {\n+        return programInstanceStore.existsIncludingDeleted( uid );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public List<String> getProgramInstancesUidsIncludingDeleted( List<String> uids )\n+    {\n+        return programInstanceStore.getUidsIncludingDeleted( uids );\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void updateProgramInstance( ProgramInstance programInstance )\n+    {\n+        programInstanceStore.update( programInstance );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public ProgramInstanceQueryParams getFromUrl( Set<String> ou, OrganisationUnitSelectionMode ouMode,\n+        Date lastUpdated, String lastUpdatedDuration, String program, ProgramStatus programStatus,\n+        Date programStartDate, Date programEndDate, String trackedEntityType, String trackedEntityInstance,\n+        Boolean followUp, Integer page, Integer pageSize, boolean totalPages, boolean skipPaging,\n+        boolean includeDeleted )\n+    {\n+        ProgramInstanceQueryParams params = new ProgramInstanceQueryParams();\n+\n+        Set<OrganisationUnit> possibleSearchOrgUnits = new HashSet<>();\n+\n+        User user = currentUserService.getCurrentUser();\n+\n+        if ( user != null )\n+        {\n+            possibleSearchOrgUnits = user.getTeiSearchOrganisationUnitsWithFallback();\n+        }\n+\n+        if ( ou != null )\n+        {\n+            for ( String orgUnit : ou )\n+            {\n+                OrganisationUnit organisationUnit = organisationUnitService.getOrganisationUnit( orgUnit );\n+\n+                if ( organisationUnit == null )\n+                {\n+                    throw new IllegalQueryException( \"Organisation unit does not exist: \" + orgUnit );\n+                }\n+\n+                if ( !organisationUnitService.isInUserHierarchy( organisationUnit.getUid(), possibleSearchOrgUnits ) )\n+                {\n+                    throw new IllegalQueryException( \"Organisation unit is not part of the search scope: \" + orgUnit );\n+                }\n+\n+                params.getOrganisationUnits().add( organisationUnit );\n+            }\n+        }\n+\n+        Program pr = program != null ? programService.getProgram( program ) : null;\n+\n+        if ( program != null && pr == null )\n+        {\n+            throw new IllegalQueryException( \"Program does not exist: \" + program );\n+        }\n+\n+        TrackedEntityType te = trackedEntityType != null\n+            ? trackedEntityTypeService.getTrackedEntityType( trackedEntityType )\n+            : null;\n+\n+        if ( trackedEntityType != null && te == null )\n+        {\n+            throw new IllegalQueryException( \"Tracked entity does not exist: \" + program );\n+        }\n+\n+        TrackedEntityInstance tei = trackedEntityInstance != null\n+            ? trackedEntityInstanceService.getTrackedEntityInstance( trackedEntityInstance )\n+            : null;\n+\n+        if ( trackedEntityInstance != null && tei == null )\n+        {\n+            throw new IllegalQueryException( \"Tracked entity instance does not exist: \" + program );\n+        }\n+\n+        params.setProgram( pr );\n+        params.setProgramStatus( programStatus );\n+        params.setFollowUp( followUp );\n+        params.setLastUpdated( lastUpdated );\n+        params.setLastUpdatedDuration( lastUpdatedDuration );\n+        params.setProgramStartDate( programStartDate );\n+        params.setProgramEndDate( programEndDate );\n+        params.setTrackedEntityType( te );\n+        params.setTrackedEntityInstance( tei );\n+        params.setOrganisationUnitMode( ouMode );\n+        params.setPage( page );\n+        params.setPageSize( pageSize );\n+        params.setTotalPages( totalPages );\n+        params.setSkipPaging( skipPaging );\n+        params.setIncludeDeleted( includeDeleted );\n+        params.setUser( user );\n+\n+        return params;\n+    }\n+\n+    // TODO consider security\n+    @Override\n+    @Transactional( readOnly = true )\n+    public List<ProgramInstance> getProgramInstances( ProgramInstanceQueryParams params )\n+    {\n+        decideAccess( params );\n+        validate( params );\n+\n+        User user = currentUserService.getCurrentUser();\n+\n+        if ( user != null && params.isOrganisationUnitMode( OrganisationUnitSelectionMode.ACCESSIBLE ) )\n+        {\n+            params.setOrganisationUnits( user.getTeiSearchOrganisationUnitsWithFallback() );\n+            params.setOrganisationUnitMode( OrganisationUnitSelectionMode.DESCENDANTS );\n+        }\n+        else if ( params.isOrganisationUnitMode( CHILDREN ) )\n+        {\n+            Set<OrganisationUnit> organisationUnits = new HashSet<>();\n+            organisationUnits.addAll( params.getOrganisationUnits() );\n+\n+            for ( OrganisationUnit organisationUnit : params.getOrganisationUnits() )\n+            {\n+                organisationUnits.addAll( organisationUnit.getChildren() );\n+            }\n+\n+            params.setOrganisationUnits( organisationUnits );\n+        }\n+\n+        if ( !params.isPaging() && !params.isSkipPaging() )\n+        {\n+            params.setDefaultPaging();\n+        }\n+\n+        List<ProgramInstance> programInstances = programInstanceStore.getProgramInstances( params );\n+\n+        return programInstances;\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public int countProgramInstances( ProgramInstanceQueryParams params )\n+    {\n+        decideAccess( params );\n+        validate( params );\n+\n+        User user = currentUserService.getCurrentUser();\n+\n+        if ( user != null && params.isOrganisationUnitMode( OrganisationUnitSelectionMode.ACCESSIBLE ) )\n+        {\n+            params.setOrganisationUnits( user.getTeiSearchOrganisationUnitsWithFallback() );\n+            params.setOrganisationUnitMode( OrganisationUnitSelectionMode.DESCENDANTS );\n+        }\n+        else if ( params.isOrganisationUnitMode( CHILDREN ) )\n+        {\n+            Set<OrganisationUnit> organisationUnits = new HashSet<>();\n+            organisationUnits.addAll( params.getOrganisationUnits() );\n+\n+            for ( OrganisationUnit organisationUnit : params.getOrganisationUnits() )\n+            {\n+                organisationUnits.addAll( organisationUnit.getChildren() );\n+            }\n+\n+            params.setOrganisationUnits( organisationUnits );\n+        }\n+\n+        params.setSkipPaging( true );\n+\n+        return programInstanceStore.countProgramInstances( params );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public void decideAccess( ProgramInstanceQueryParams params )\n+    {\n+        if ( params.hasProgram() )\n+        {\n+            if ( !aclService.canDataRead( params.getUser(), params.getProgram() ) )\n+            {\n+                throw new IllegalQueryException( \"Current user is not authorized to read data from selected program:  \"\n+                    + params.getProgram().getUid() );\n+            }\n+\n+            if ( params.getProgram().getTrackedEntityType() != null\n+                && !aclService.canDataRead( params.getUser(), params.getProgram().getTrackedEntityType() ) )\n+            {\n+                throw new IllegalQueryException(\n+                    \"Current user is not authorized to read data from selected program's tracked entity type:  \"\n+                        + params.getProgram().getTrackedEntityType().getUid() );\n+            }\n+\n+        }\n+\n+        if ( params.hasTrackedEntityType()\n+            && !aclService.canDataRead( params.getUser(), params.getTrackedEntityType() ) )\n+        {\n+            throw new IllegalQueryException(\n+                \"Current user is not authorized to read data from selected tracked entity type:  \"\n+                    + params.getTrackedEntityType().getUid() );\n+        }\n+    }\n+\n+    @Override\n+    public void validate( ProgramInstanceQueryParams params )\n+        throws IllegalQueryException\n+    {\n+        String violation = null;\n+\n+        if ( params == null )\n+        {\n+            throw new IllegalQueryException( \"Params cannot be null\" );\n+        }\n+\n+        User user = params.getUser();\n+\n+        if ( !params.hasOrganisationUnits()\n+            && !(params.isOrganisationUnitMode( ALL ) || params.isOrganisationUnitMode( ACCESSIBLE )) )\n+        {\n+            violation = \"At least one organisation unit must be specified\";\n+        }\n+\n+        if ( params.isOrganisationUnitMode( ACCESSIBLE )\n+            && (user == null || !user.hasDataViewOrganisationUnitWithFallback()) )\n+        {\n+            violation = \"Current user must be associated with at least one organisation unit when selection mode is ACCESSIBLE\";\n+        }\n+\n+        if ( params.hasProgram() && params.hasTrackedEntityType() )\n+        {\n+            violation = \"Program and tracked entity cannot be specified simultaneously\";\n+        }\n+\n+        if ( params.hasProgramStatus() && !params.hasProgram() )\n+        {\n+            violation = \"Program must be defined when program status is defined\";\n+        }\n+\n+        if ( params.hasFollowUp() && !params.hasProgram() )\n+        {\n+            violation = \"Program must be defined when follow up status is defined\";\n+        }\n+\n+        if ( params.hasProgramStartDate() && !params.hasProgram() )\n+        {\n+            violation = \"Program must be defined when program start date is specified\";\n+        }\n+\n+        if ( params.hasProgramEndDate() && !params.hasProgram() )\n+        {\n+            violation = \"Program must be defined when program end date is specified\";\n+        }\n+\n+        if ( params.hasLastUpdated() && params.hasLastUpdatedDuration() )\n+        {\n+            violation = \"Last updated and last updated duration cannot be specified simultaneously\";\n+        }\n+\n+        if ( params.hasLastUpdatedDuration() && DateUtils.getDuration( params.getLastUpdatedDuration() ) == null )\n+        {\n+            violation = \"Duration is not valid: \" + params.getLastUpdatedDuration();\n+        }\n+\n+        if ( violation != null )\n+        {\n+            log.warn( \"Validation failed: \" + violation );\n+\n+            throw new IllegalQueryException( violation );\n+        }\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public List<ProgramInstance> getProgramInstances( Program program )\n+    {\n+        return programInstanceStore.get( program );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public List<ProgramInstance> getProgramInstances( Program program, ProgramStatus status )\n+    {\n+        return programInstanceStore.get( program, status );\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public List<ProgramInstance> getProgramInstances( TrackedEntityInstance entityInstance, Program program,\n+        ProgramStatus status )\n+    {\n+        return programInstanceStore.get( entityInstance, program, status );\n+    }\n+\n+    @Override\n+    @Transactional\n+    public ProgramInstance prepareProgramInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n+        ProgramStatus programStatus, Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit,\n+        String uid )\n+    {\n+        if ( program.getTrackedEntityType() != null\n+            && !program.getTrackedEntityType().equals( trackedEntityInstance.getTrackedEntityType() ) )\n+        {\n+            throw new IllegalQueryException(\n+                \"Tracked entity instance must have same tracked entity as program: \" + program.getUid() );\n+        }\n+\n+        ProgramInstance programInstance = new ProgramInstance();\n+        programInstance.setUid( CodeGenerator.isValidUid( uid ) ? uid : CodeGenerator.generateUid() );\n+        programInstance.setOrganisationUnit( organisationUnit );\n+        programInstance.enrollTrackedEntityInstance( trackedEntityInstance, program );\n+\n+        if ( enrollmentDate != null )\n+        {\n+            programInstance.setEnrollmentDate( enrollmentDate );\n+        }\n+        else\n+        {\n+            programInstance.setEnrollmentDate( new Date() );\n+        }\n+\n+        if ( incidentDate != null )\n+        {\n+            programInstance.setIncidentDate( incidentDate );\n+        }\n+        else\n+        {\n+            programInstance.setIncidentDate( new Date() );\n+        }\n+\n+        programInstance.setStatus( programStatus );\n+\n+        return programInstance;\n+    }\n+\n+    @Override\n+    @Transactional\n+    public ProgramInstance enrollTrackedEntityInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n+        Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit )\n+    {\n+        return enrollTrackedEntityInstance( trackedEntityInstance, program, enrollmentDate, incidentDate,\n+            organisationUnit, CodeGenerator.generateUid() );\n+    }\n+\n+    @Override\n+    @Transactional\n+    public ProgramInstance enrollTrackedEntityInstance( TrackedEntityInstance trackedEntityInstance, Program program,\n+        Date enrollmentDate, Date incidentDate, OrganisationUnit organisationUnit, String uid )\n+    {\n+        // ---------------------------------------------------------------------\n+        // Add program instance\n+        // ---------------------------------------------------------------------\n+\n+        ProgramInstance programInstance = prepareProgramInstance( trackedEntityInstance, program, ProgramStatus.ACTIVE,\n+            enrollmentDate, incidentDate, organisationUnit, uid );\n+        addProgramInstance( programInstance );\n+\n+        // ---------------------------------------------------------------------\n+        // Add program owner and overwrite if already exists.\n+        // ---------------------------------------------------------------------\n+\n+        trackerOwnershipAccessManager.assignOwnership( trackedEntityInstance, program, organisationUnit, true, true );\n+\n+        // -----------------------------------------------------------------\n+        // Send enrollment notifications (if any)\n+        // -----------------------------------------------------------------\n+\n+        eventPublisher.publishEvent( new ProgramEnrollmentNotificationEvent( this, programInstance.getId() ) );\n+\n+        eventPublisher.publishEvent( new EnrollmentEvaluationEvent( this, programInstance.getId() ) );\n+\n+        // -----------------------------------------------------------------\n+        // Update ProgramInstance and TEI\n+        // -----------------------------------------------------------------\n+\n+        updateProgramInstance( programInstance );\n+        trackedEntityInstanceService.updateTrackedEntityInstance( trackedEntityInstance );\n+\n+        return programInstance;\n+    }\n+\n+    @Override\n+    @Transactional( readOnly = true )\n+    public boolean canAutoCompleteProgramInstanceStatus( ProgramInstance programInstance )\n+    {\n+        Set<ProgramStageInstance> programStageInstances = new HashSet<>( programInstance.getProgramStageInstances() );\n+        Set<ProgramStage> programStages = new HashSet<>();\n+\n+        for ( ProgramStageInstance programStageInstance : programStageInstances )\n+        {\n+            if ( (!programStageInstance.isCompleted() && programStageInstance.getStatus() != EventStatus.SKIPPED)\n+                || programStageInstance.getProgramStage().getRepeatable() )\n+            {\n+                return false;\n+            }\n+\n+            programStages.add( programStageInstance.getProgramStage() );\n+        }\n+\n+        return programStages.size() == programInstance.getProgram().getProgramStages().size();\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void completeProgramInstanceStatus( ProgramInstance programInstance )\n+    {\n+        // -----------------------------------------------------------------\n+        // Update program-instance\n+        // -----------------------------------------------------------------\n+\n+        programInstance.setStatus( ProgramStatus.COMPLETED );\n+        updateProgramInstance( programInstance );\n+\n+        // ---------------------------------------------------------------------\n+        // Send sms-message after program completion\n+        // ---------------------------------------------------------------------\n+\n+        eventPublisher\n+            .publishEvent( new ProgramEnrollmentCompletionNotificationEvent( this, programInstance.getId() ) );\n+\n+        eventPublisher.publishEvent( new EnrollmentEvaluationEvent( this, programInstance.getId() ) );\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void cancelProgramInstanceStatus( ProgramInstance programInstance )\n+    {\n+        // ---------------------------------------------------------------------\n+        // Set status of the program-instance\n+        // ---------------------------------------------------------------------\n+        programInstance.setStatus( ProgramStatus.CANCELLED );\n+        updateProgramInstance( programInstance );\n+\n+        // ---------------------------------------------------------------------\n+        // Set statuses of the program-stage-instances\n+        // ---------------------------------------------------------------------\n+\n+        for ( ProgramStageInstance programStageInstance : programInstance.getProgramStageInstances() )\n+        {\n+            if ( programStageInstance.getExecutionDate() == null )\n+            {\n+                // -------------------------------------------------------------\n+                // Set status as skipped for overdue events, or delete\n+                // -------------------------------------------------------------\n+\n+                if ( programStageInstance.getDueDate().before( programInstance.getEndDate() ) )\n+                {\n+                    programStageInstance.setStatus( EventStatus.SKIPPED );\n+                    programStageInstanceStore.update( programStageInstance );\n+                }\n+                else\n+                {\n+                    programStageInstanceStore.delete( programStageInstance );\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    @Transactional\n+    public void incompleteProgramInstanceStatus( ProgramInstance programInstance )\n+    {\n+        Program program = programInstance.getProgram();\n+\n+        TrackedEntityInstance tei = programInstance.getEntityInstance();\n+\n+        if ( getProgramInstances( tei, program, ProgramStatus.ACTIVE ).size() > 0 )\n+        {\n+            log.warn( \"Program has another active enrollment going on. Not possible to incomplete\" );\n+\n+            throw new IllegalQueryException(\n+                \"Program has another active enrollment going on. Not possible to incomplete\" );\n+        }\n+\n+        // -----------------------------------------------------------------\n+        // Update program-instance\n+        // -----------------------------------------------------------------\n+\n+        programInstance.setStatus( ProgramStatus.ACTIVE );\n+        programInstance.setEndDate( null );\n+\n+        updateProgramInstance( programInstance );\n+    }\n+}\n"}}, {"oid": "27a89af420dd17e9fd8003027dc1f02ebcd21844", "url": "https://github.com/dhis2/dhis2-core/commit/27a89af420dd17e9fd8003027dc1f02ebcd21844", "message": "Code review fixes", "committedDate": "2020-03-30T12:36:30Z", "type": "forcePushed"}, {"oid": "c6371109f5b04aa1ec6c8f97a46a3dd0e836893c", "url": "https://github.com/dhis2/dhis2-core/commit/c6371109f5b04aa1ec6c8f97a46a3dd0e836893c", "message": "Fix code review comments", "committedDate": "2020-04-01T07:22:59Z", "type": "forcePushed"}, {"oid": "abae66ebf296c5e77d17e72fee178cd8234c4d09", "url": "https://github.com/dhis2/dhis2-core/commit/abae66ebf296c5e77d17e72fee178cd8234c4d09", "message": "Code review fixes", "committedDate": "2020-03-26T10:03:41Z", "type": "forcePushed"}, {"oid": "c7bfe2d9414308085cd785cd58584373b9642cdf", "url": "https://github.com/dhis2/dhis2-core/commit/c7bfe2d9414308085cd785cd58584373b9642cdf", "message": "Code review fixes", "committedDate": "2020-04-01T07:42:11Z", "type": "commit"}, {"oid": "b97c9f797c168b0455fa57e8435f82d99d9d8e51", "url": "https://github.com/dhis2/dhis2-core/commit/b97c9f797c168b0455fa57e8435f82d99d9d8e51", "message": "Merge remote-tracking branch 'origin/master' into HEAD", "committedDate": "2020-04-01T07:53:34Z", "type": "commit"}, {"oid": "01266c84fef6387bef2936abb58fa45ac33a6431", "url": "https://github.com/dhis2/dhis2-core/commit/01266c84fef6387bef2936abb58fa45ac33a6431", "message": "Fix style", "committedDate": "2020-04-01T08:37:01Z", "type": "commit"}, {"oid": "9af491548be57fc4cee4158cbd9831f908f48930", "url": "https://github.com/dhis2/dhis2-core/commit/9af491548be57fc4cee4158cbd9831f908f48930", "message": "Fix style", "committedDate": "2020-04-06T07:54:09Z", "type": "commit"}, {"oid": "d3deba89e896f849e491af7d7fc21a79eb48ab3a", "url": "https://github.com/dhis2/dhis2-core/commit/d3deba89e896f849e491af7d7fc21a79eb48ab3a", "message": "Merge remote-tracking branch 'origin/master' into DHIS2-7415", "committedDate": "2020-04-06T07:57:57Z", "type": "commit"}, {"oid": "25a6c5924d142120f40143613ca780e485751936", "url": "https://github.com/dhis2/dhis2-core/commit/25a6c5924d142120f40143613ca780e485751936", "message": "Fix compilation", "committedDate": "2020-04-06T08:07:14Z", "type": "commit"}, {"oid": "79e97e6d119c6be4aea7d425b8cc05db9193fcd6", "url": "https://github.com/dhis2/dhis2-core/commit/79e97e6d119c6be4aea7d425b8cc05db9193fcd6", "message": "Merge remote-tracking branch 'origin/master' into DHIS2-7415", "committedDate": "2020-04-08T07:32:25Z", "type": "commit"}, {"oid": "945d9fa67f68b1cba3d2420a7caf46c7cfe20907", "url": "https://github.com/dhis2/dhis2-core/commit/945d9fa67f68b1cba3d2420a7caf46c7cfe20907", "message": "Fix line endings", "committedDate": "2020-04-08T07:41:19Z", "type": "commit"}]}