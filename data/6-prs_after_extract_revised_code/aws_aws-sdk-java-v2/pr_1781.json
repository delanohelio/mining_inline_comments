{"pr_number": 1781, "pr_title": "Replace InstantAsInteger with InstantAsString and test", "pr_createdAt": "2020-04-15T23:58:10Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1781", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MTE1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409691157", "bodyText": "Nit: Any reason we broke the alphabetical ordering here?", "author": "bmaizels", "createdAt": "2020-04-16T16:30:05Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java", "diffHunk": "@@ -211,8 +211,8 @@ private static Builder getDefaultBuilder() {\n                                                 .addConverter(DoubleAttributeConverter.create())\n                                                 .addConverter(DurationAttributeConverter.create())\n                                                 .addConverter(FloatAttributeConverter.create())\n-                                                .addConverter(InstantAsIntegerAttributeConverter.create())\n                                                 .addConverter(IntegerAttributeConverter.create())\n+                                                .addConverter(InstantAsStringAttributeConverter.create())", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java\nindex ecb4b9f5f1..34a3f15975 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java\n\n@@ -211,8 +211,8 @@ public final class DefaultAttributeConverterProvider implements AttributeConvert\n                                                 .addConverter(DoubleAttributeConverter.create())\n                                                 .addConverter(DurationAttributeConverter.create())\n                                                 .addConverter(FloatAttributeConverter.create())\n-                                                .addConverter(IntegerAttributeConverter.create())\n                                                 .addConverter(InstantAsStringAttributeConverter.create())\n+                                                .addConverter(IntegerAttributeConverter.create())\n                                                 .addConverter(LocalDateAttributeConverter.create())\n                                                 .addConverter(LocalDateTimeAttributeConverter.create())\n                                                 .addConverter(LocalTimeAttributeConverter.create())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzEzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409693130", "bodyText": "Does this not break the data-loss rule?", "author": "bmaizels", "createdAt": "2020-04-16T16:33:13Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -53,9 +52,9 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link OffsetDateTimeAsStringAttributeConverter} or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times\n- * will be automatically converted to the equivalent {@code Instant} based on the time zone information in the record (e.g.\n+ * This converter can read any values written by itself, {@link OffsetDateTimeAsStringAttributeConverter}\n+ * or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times will be automatically converted to\n+ * the equivalent {@code Instant} based on the time zone information in the record (e.g.", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\nindex 69141ff17a..a70307d734 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n\n@@ -52,11 +53,7 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link OffsetDateTimeAsStringAttributeConverter}\n- * or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times will be automatically converted to\n- * the equivalent {@code Instant} based on the time zone information in the record (e.g.\n- * {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:00+01:00\")} will be converted to\n- * {@code Instant.EPOCH.minus(1, ChronoUnit.HOURS)}).\n+ * This converter can only read any values written by itself.\n  *\n  * <p>\n  * This can be created via {@link #create()}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NDM4OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409694388", "bodyText": "LocalDate should not store timezone information. Writing a valid ISO8601 output here risks it being read as an Instant and breaking the data-loss rule. I would propose having it write \"YYYY-MM-DD\" and allowing LocalDateTime to parse that format.", "author": "bmaizels", "createdAt": "2020-04-16T16:35:14Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java", "diffHunk": "@@ -24,16 +24,17 @@\n import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n import software.amazon.awssdk.enhanced.dynamodb.AttributeValueType;\n import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.ConverterUtils;\n import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n \n /**\n  * A converter between {@link LocalDate} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a String.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDD000000\", where:\n+ * LocalDateTimes are stored in the format \"[-]YYYY-MM-DDT00:00:00Z\", where:", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java\nindex dcdf6ad652..e59680e49d 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java\n\n@@ -25,6 +27,7 @@ import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n import software.amazon.awssdk.enhanced.dynamodb.AttributeValueType;\n import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.ConverterUtils;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.TypeConvertingVisitor;\n import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NjcxNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409696716", "bodyText": "We should not store timezone information for LocalDateTime. The actual string format being proposed omits it, but this description implies it will be there (the 'Z')", "author": "bmaizels", "createdAt": "2020-04-16T16:38:46Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -35,10 +35,13 @@\n  * A converter between {@link LocalDateTime} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDDHHIISS[.NNNNNNNNN]\", where:\n+ * Values are stored in ISO-8601 format, with nanosecond precision and a time zone of UTC.", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\nindex 08e578b9fb..d4fe19e55a 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n\n@@ -38,7 +38,7 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * Values are stored in ISO-8601 format, with nanosecond precision and a time zone of UTC.\n+ * Values are stored in ISO-8601 format, with nanosecond precision.\n  *\n  * <p>\n  * LocalDateTimes are stored in the format \"[-]YYYY-MM-DDTHH:II:SS[.NNNNNNNNN]\", where:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODA3OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409698079", "bodyText": "MonthDay?", "author": "bmaizels", "createdAt": "2020-04-16T16:40:50Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java", "diffHunk": "@@ -28,16 +28,15 @@\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.ConverterUtils;\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.TypeConvertingVisitor;\n import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n-import software.amazon.awssdk.utils.Validate;\n \n /**\n  * A converter between {@link MonthDay} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a String.\n  *\n  * <p>\n- * LocalTimes are stored in the format \"MMDD\", where:\n+ * LocalTimes are stored in the format \"MM-DD\", where:", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java\nindex f6ffd7b2ed..567d3f7138 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java\n\n@@ -36,7 +36,7 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  * This stores and reads values in DynamoDB as a String.\n  *\n  * <p>\n- * LocalTimes are stored in the format \"MM-DD\", where:\n+ * MonthDays are stored in the format \"MM-DD\", where:\n  * <ol>\n  *     <li>M is a 2-character, zero-prefixed month between 01 and 12</li>\n  *     <li>D is a 2-character, zero-prefixed day between 01 and 31</li>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODk0OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409698948", "bodyText": "What about if the ZonedDateTime uses a named Zone, does this not break the data-loss principle?", "author": "bmaizels", "createdAt": "2020-04-16T16:42:10Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java", "diffHunk": "@@ -58,9 +58,9 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link InstantAsStringAttributeConverter}, or {@link ZonedDateTimeAsStringAttributeConverter}. Values written by\n- * {@code Instant} converters are treated as if they are in the UTC time zone (and an offset of 0 seconds will be returned).\n+ * This converter can read any values written by itself, {@link InstantAsStringAttributeConverter},\n+ * or {@link ZonedDateTimeAsStringAttributeConverter}. Values written by {@code Instant} converters\n+ * are treated as if they are in the UTC time zone (and an offset of 0 seconds will be returned).", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19ff01fc8b80925357267958330b451b551a786b", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java\nindex 1caa3b4c21..daa51af145 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java\n\n@@ -58,9 +58,10 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsStringAttributeConverter},\n- * or {@link ZonedDateTimeAsStringAttributeConverter}. Values written by {@code Instant} converters\n- * are treated as if they are in the UTC time zone (and an offset of 0 seconds will be returned).\n+ * This converter can read any values written by itself or {@link InstantAsStringAttributeConverter},\n+ * and values without a time zone named written by{@link ZonedDateTimeAsStringAttributeConverter}.\n+ * Values written by {@code Instant} converters are treated as if they are in the UTC time zone\n+ * (and an offset of 0 seconds will be returned).\n  *\n  * <p>\n  * This can be created via {@link #create()}.\n"}}, {"oid": "19ff01fc8b80925357267958330b451b551a786b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/19ff01fc8b80925357267958330b451b551a786b", "message": "Updated code to resolve comments", "committedDate": "2020-04-16T23:35:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMTE5OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409911198", "bodyText": "Please can we split these into individual tests.", "author": "bmaizels", "createdAt": "2020-04-16T23:44:08Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/GlobalDateTimeAttributeConvertersTest.java", "diffHunk": "@@ -84,8 +48,18 @@ public void instantAsStringAttributeConverterBehaves() {\n         assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"X\")));\n         assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000001-01-01T00:00:00Z\")));\n \n-        // InstantAsIntegerAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromNumber(\"0\"))).isEqualTo(Instant.EPOCH);\n+        // Not accepted types tests\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00[Europe/Paris]\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"05-21\").toAttributeValue()));", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMjg0Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409912846", "bodyText": "Please apply this comment everywhere as we discussed offline.", "author": "bmaizels", "createdAt": "2020-04-16T23:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMTE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/GlobalDateTimeAttributeConvertersTest.java b/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/GlobalDateTimeAttributeConvertersTest.java\ndeleted file mode 100644\nindex 7468782671..0000000000\n--- a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/GlobalDateTimeAttributeConvertersTest.java\n+++ /dev/null\n\n@@ -1,144 +0,0 @@\n-/*\n- * Copyright 2010-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.enhanced.dynamodb.converters.attribute;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.assertFails;\n-import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformFrom;\n-import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformTo;\n-\n-import java.time.Instant;\n-import java.time.OffsetDateTime;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.ZonedDateTime;\n-import java.time.temporal.ChronoUnit;\n-import org.junit.Test;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.EnhancedAttributeValue;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.InstantAsStringAttributeConverter;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.OffsetDateTimeAsStringAttributeConverter;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.ZonedDateTimeAsStringAttributeConverter;\n-\n-public class GlobalDateTimeAttributeConvertersTest {\n-\n-    @Test\n-    public void instantAsStringAttributeConverterBehaves() {\n-        InstantAsStringAttributeConverter converter = InstantAsStringAttributeConverter.create();\n-\n-        assertThat(transformFrom(converter, Instant.MIN).s()).isEqualTo(\"-1000000000-01-01T00:00:00Z\");\n-        assertThat(transformFrom(converter, Instant.EPOCH.minusMillis(1)).s()).isEqualTo(\"1969-12-31T23:59:59.999Z\");\n-        assertThat(transformFrom(converter, Instant.EPOCH).s()).isEqualTo(\"1970-01-01T00:00:00Z\");\n-        assertThat(transformFrom(converter, Instant.EPOCH.plusMillis(1)).s()).isEqualTo(\"1970-01-01T00:00:00.001Z\");\n-        assertThat(transformFrom(converter, Instant.MAX).s()).isEqualTo(\"+1000000000-12-31T23:59:59.999999999Z\");\n-\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"-1000000001-12-31T23:59:59.999999999Z\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"X\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000001-01-01T00:00:00Z\")));\n-\n-        // Not accepted types tests\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001\")\n-                                                                       .toAttributeValue()));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21\")\n-                                                                       .toAttributeValue()));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"00:12:00.000000001\")\n-                                                                       .toAttributeValue()));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00\")\n-                                                                       .toAttributeValue()));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00[Europe/Paris]\")\n-                                                                       .toAttributeValue()));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"05-21\").toAttributeValue()));\n-\n-        // InstantAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"-1000000000-01-01T00:00:00Z\"))).isEqualTo(Instant.MIN);\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1969-12-31T23:59:59.999Z\"))).isEqualTo(Instant.EPOCH.minusMillis(1));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00Z\"))).isEqualTo(Instant.EPOCH);\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00.001Z\"))).isEqualTo(Instant.EPOCH.plusMillis(1));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000000-12-31T23:59:59.999999999Z\"))).isEqualTo(Instant.MAX);\n-\n-    }\n-\n-    @Test\n-    public void offsetDateTimeAsStringAttributeConverterBehaves() {\n-        OffsetDateTimeAsStringAttributeConverter converter = OffsetDateTimeAsStringAttributeConverter.create();\n-\n-        OffsetDateTime epochUtc = Instant.EPOCH.atOffset(ZoneOffset.UTC);\n-\n-        assertThat(transformFrom(converter, OffsetDateTime.MIN).s()).isEqualTo(\"-999999999-01-01T00:00:00+18:00\");\n-        assertThat(transformFrom(converter, epochUtc.minusNanos(1)).s()).isEqualTo(\"1969-12-31T23:59:59.999999999Z\");\n-        assertThat(transformFrom(converter, epochUtc).s()).isEqualTo(\"1970-01-01T00:00:00Z\");\n-        assertThat(transformFrom(converter, epochUtc.plusNanos(1)).s()).isEqualTo(\"1970-01-01T00:00:00.000000001Z\");\n-        assertThat(transformFrom(converter, OffsetDateTime.MAX).s()).isEqualTo(\"+999999999-12-31T23:59:59.999999999-18:00\");\n-\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"-1000000001-12-31T23:59:59.999999999Z\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"X\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000001-01-01T00:00:00Z\")));\n-\n-        // InstantAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00Z\"))).isEqualTo(epochUtc);\n-\n-        // OffsetDateTimeAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00+01:00\")))\n-                .isEqualTo(OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.ofHours(1)));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"-999999999-01-01T00:00:00+18:00\")))\n-                .isEqualTo(OffsetDateTime.MIN);\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1969-12-31T23:59:59.999999999Z\")))\n-                .isEqualTo(epochUtc.minusNanos(1));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00Z\")))\n-                .isEqualTo(epochUtc);\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00.000000001Z\")))\n-                .isEqualTo(epochUtc.plusNanos(1));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"+999999999-12-31T23:59:59.999999999-18:00\")))\n-                .isEqualTo(OffsetDateTime.MAX);\n-\n-    }\n-\n-    @Test\n-    public void zonedDateTimeAsStringAttributeConverterBehaves() {\n-        ZonedDateTimeAsStringAttributeConverter converter = ZonedDateTimeAsStringAttributeConverter.create();\n-\n-        ZonedDateTime epochUtc = Instant.EPOCH.atZone(ZoneOffset.UTC);\n-        ZonedDateTime min = OffsetDateTime.MIN.toZonedDateTime();\n-        ZonedDateTime max = OffsetDateTime.MAX.toZonedDateTime();\n-\n-        assertThat(transformFrom(converter, min).s()).isEqualTo(\"-999999999-01-01T00:00:00+18:00\");\n-        assertThat(transformFrom(converter, epochUtc.minusNanos(1)).s()).isEqualTo(\"1969-12-31T23:59:59.999999999Z\");\n-        assertThat(transformFrom(converter, epochUtc).s()).isEqualTo(\"1970-01-01T00:00:00Z\");\n-        assertThat(transformFrom(converter, Instant.EPOCH.atZone(ZoneId.of(\"Europe/Paris\"))).s())\n-                .isEqualTo(\"1970-01-01T01:00:00+01:00[Europe/Paris]\");\n-        assertThat(transformFrom(converter, epochUtc.plusNanos(1)).s()).isEqualTo(\"1970-01-01T00:00:00.000000001Z\");\n-        assertThat(transformFrom(converter, max).s()).isEqualTo(\"+999999999-12-31T23:59:59.999999999-18:00\");\n-\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"-1000000001-12-31T23:59:59.999999999Z\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"X\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000001-01-01T00:00:00Z\")));\n-        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00+01:00[FakeZone]\")));\n-\n-        // InstantAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00Z\"))).isEqualTo(epochUtc);\n-\n-        // OffsetDateTimeAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T00:00:00+01:00\")))\n-                .isEqualTo(epochUtc.minus(1, ChronoUnit.HOURS));\n-\n-        // ZonedDateTimeAsStringAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"-999999999-01-01T00:00:00+18:00\")))\n-                .isEqualTo(min);\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"1970-01-01T01:00:00+01:00[Europe/Paris]\")))\n-                .isEqualTo(Instant.EPOCH.atZone(ZoneId.of(\"Europe/Paris\")));\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(\"+999999999-12-31T23:59:59.999999999-18:00\")))\n-                .isEqualTo(max);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNjQzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409916433", "bodyText": "Can we have little javadocs on these so it's easier for me to assert they are doing what they are supposed to be doing.", "author": "bmaizels", "createdAt": "2020-04-17T00:01:17Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNjc1OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409916758", "bodyText": "This requires three iterations through the string, can we do it in a single pass?", "author": "bmaizels", "createdAt": "2020-04-17T00:02:34Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzMxNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917315", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:04:30Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzU1NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917555", "bodyText": "Can we have a javadoc so I can assert it's doing what it's supposed to do", "author": "bmaizels", "createdAt": "2020-04-17T00:05:21Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzcwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917705", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:05:57Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzg2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917863", "bodyText": "Can we have a javadoc so I can assert this is doing what it's supposed to do.", "author": "bmaizels", "createdAt": "2020-04-17T00:06:31Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzk5Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917992", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:06:56Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n         }\n+        String[] chunkedDate = valueToChunk.split(\"-\");\n+        chunkedDate[0] = negativeSig + chunkedDate[0];\n+        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n+                         && chunkedDate.length == 3,\n+                        \"Invalid date format, expected [-]YYYY-MM-DD.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxODA3Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409918076", "bodyText": "Can we have a javadoc so I can assert this is doing what it's supposed to do.", "author": "bmaizels", "createdAt": "2020-04-17T00:07:13Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n         }\n+        String[] chunkedDate = valueToChunk.split(\"-\");\n+        chunkedDate[0] = negativeSig + chunkedDate[0];\n+        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n+                         && chunkedDate.length == 3,\n+                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n+        return chunkedDate;\n     }\n \n-    private static int chunkLeft(String valueToChunk, String[] result, int[] splitSizes) {\n-        try {\n-            int splitStartInclusive = 0;\n-\n-            for (int i = 0; i < splitSizes.length; i++) {\n-                int splitEndExclusive = splitStartInclusive + splitSizes[i];\n-                result[i] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitStartInclusive = splitEndExclusive;\n-            }\n-            return splitStartInclusive;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n-        }\n+    public static String[] chunkMonthDay(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 21ef64baad..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -128,52 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n-                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n-                        && chunkedDateTime.length == 6,\n-                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        return chunkedDateTime;\n-    }\n-\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n-                         && chunkedTime.length == 3,\n-                        \"Invalid time format, expected HH:MM:SS.\");\n-        return chunkedTime;\n-    }\n-\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n-                         && chunkedDate.length == 3,\n-                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n-        return chunkedDate;\n-    }\n-\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5, \"Invalid Month/Day length: %s, expected 5 (MM-DD).\",\n-                                                                        valueToChunk.length());\n-        Validate.isTrue(valueToChunk.substring(2, 3).equals(\"-\"), \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxODk3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409918970", "bodyText": "Checking 'ends with' would be faster, and also more accurate.", "author": "bmaizels", "createdAt": "2020-04-17T00:10:19Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -90,6 +86,7 @@ public AttributeValue transformFrom(Instant input) {\n \n     @Override\n     public Instant transformTo(AttributeValue input) {\n+        Validate.isTrue(input.s().contains(\"Z\"), \"Invalid Instant format, should contain 'Z' in it.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\nindex a70307d734..abd2332ffa 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n\n@@ -81,12 +87,31 @@ public final class InstantAsStringAttributeConverter implements AttributeConvert\n \n     @Override\n     public AttributeValue transformFrom(Instant input) {\n-        return TimeConversion.toStringAttributeValue(input);\n+        return AttributeValue.builder().s(input.toString()).build();\n     }\n \n     @Override\n     public Instant transformTo(AttributeValue input) {\n-        Validate.isTrue(input.s().contains(\"Z\"), \"Invalid Instant format, should contain 'Z' in it.\");\n-        return TimeConversion.instantFromAttributeValue(EnhancedAttributeValue.fromAttributeValue(input));\n+        try {\n+            if (input.s() != null) {\n+                return EnhancedAttributeValue.fromString(input.s()).convert(VISITOR);\n+            }\n+\n+            return EnhancedAttributeValue.fromAttributeValue(input).convert(VISITOR);\n+        } catch (RuntimeException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+\n+    }\n+\n+    private static final class Visitor extends TypeConvertingVisitor<Instant> {\n+        private Visitor() {\n+            super(Instant.class, InstantAsStringAttributeConverter.class);\n+        }\n+\n+        @Override\n+        public Instant convertString(String value) {\n+            return Instant.parse(value);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxOTI2MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409919261", "bodyText": "Or OffsetDateTime/ZonedDateTime if offset is 0 (UTC), presumably?", "author": "bmaizels", "createdAt": "2020-04-17T00:11:17Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -53,11 +53,7 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link OffsetDateTimeAsStringAttributeConverter} or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times\n- * will be automatically converted to the equivalent {@code Instant} based on the time zone information in the record (e.g.\n- * {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:00+01:00\")} will be converted to\n- * {@code Instant.EPOCH.minus(1, ChronoUnit.HOURS)}).\n+ * This converter can only read any values written by itself.", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\nindex a70307d734..abd2332ffa 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java\n\n@@ -39,29 +38,36 @@ import software.amazon.awssdk.utils.Validate;\n  * Examples:\n  * <ul>\n  *     <li>{@code Instant.EPOCH.plusSeconds(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:01Z\")}</li>\n+ *     an AttributeValue with the String \"1970-01-01T00:00:01Z\"}</li>\n  *     <li>{@code Instant.EPOCH.minusSeconds(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1969-12-31T23:59:59Z\")}</li>\n+ *     an AttributeValue with the String \"1969-12-31T23:59:59Z\"}</li>\n  *     <li>{@code Instant.EPOCH.plusMillis(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:00.001Z\")}</li>\n+ *     an AttributeValue with the String \"1970-01-01T00:00:00.001Z\"}</li>\n  *     <li>{@code Instant.EPOCH.minusMillis(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1969-12-31T23:59:59.999Z\")}</li>\n+ *     an AttributeValue with the String \"1969-12-31T23:59:59.999Z\"}</li>\n  *     <li>{@code Instant.EPOCH.plusNanos(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:00.000000001Z\")}</li>\n+ *     an AttributeValue with the String \"1970-01-01T00:00:00.000000001Z\"}</li>\n  *     <li>{@code Instant.EPOCH.minusNanos(1)} is stored as\n- *     {@code ItemAttributeValueMapper.fromString(\"1969-12-31T23:59:59.999999999Z\")}</li>\n+ *     an AttributeValue with the String \"1969-12-31T23:59:59.999999999Z\"}</li>\n  * </ul>\n- *\n+ * See {@link Instant} for more details on the serialization format.\n  * <p>\n- * This converter can only read any values written by itself.\n+ * This converter can read any values written by itself, or values with zero offset written by\n+ * {@link OffsetDateTimeAsStringAttributeConverter}, and values with zero offset and without time zone named written by\n+ * {@link ZoneOffsetAttributeConverter}. Offset and zoned times will be automatically converted to the\n+ * equivalent {@link Instant}.\n  *\n  * <p>\n+ * This serialization is lexicographically orderable when the year is not negative.\n+ * <p>\n  * This can be created via {@link #create()}.\n  */\n @SdkInternalApi\n @ThreadSafe\n @Immutable\n public final class InstantAsStringAttributeConverter implements AttributeConverter<Instant> {\n+    private static final Visitor VISITOR = new Visitor();\n+\n     private InstantAsStringAttributeConverter() {\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDM2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409920363", "bodyText": "We probably shouldn't mention 'ISO-8601' format since we're omitting the timezone.", "author": "bmaizels", "createdAt": "2020-04-17T00:14:48Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -35,10 +35,13 @@\n  * A converter between {@link LocalDateTime} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDDHHIISS[.NNNNNNNNN]\", where:\n+ * Values are stored in ISO-8601 format, with nanosecond precision.", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\nindex d4fe19e55a..c33ab2e055 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n\n@@ -38,10 +35,10 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * Values are stored in ISO-8601 format, with nanosecond precision.\n+ * Values are stored with nanosecond precision.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYY-MM-DDTHH:II:SS[.NNNNNNNNN]\", where:\n+ * LocalDateTimes are stored in the official {@link LocalDateTime} format \"[-]YYYY-MM-DDTHH:II:SS[.NNNNNNNNN]\", where:\n  * <ol>\n  *     <li>Y is a year between {@link Year#MIN_VALUE} and {@link Year#MAX_VALUE} (prefixed with - if it is negative)</li>\n  *     <li>M is a 2-character, zero-prefixed month between 01 and 12</li>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDg1Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409920852", "bodyText": "What's this?", "author": "bmaizels", "createdAt": "2020-04-17T00:16:23Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java", "diffHunk": "@@ -49,8 +49,9 @@\n  * <p>\n  * Examples:\n  * <ul>\n- *     <li>{@code LocalTime.of(5, 30, 0)} is stored as {@code ItemAttributeValueMapper.fromNumber(\"053000\")}</li>\n- *     <li>{@code LocalDateTime.of(5, 30, 0, 1)} is stored as {@code ItemAttributeValueMapper.fromNumber(\"053000.000000001\")}</li>\n+ *     <li>{@code LocalTime.of(5, 30, 0)} is stored as {@code ItemAttributeValueMapper.fromString(\"05:30:00\")}</li>\n+ *     <li>{@code LocalDateTime.of(5, 30, 0, 1)} is stored as </li>\n+ *     <li>{@code ItemAttributeValueMapper.fromString(\"05:30:00.000000001\")}</li>", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MTU5NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409981594", "bodyText": "I was trying to let that line not exceed the length restriction. Fixed now", "author": "Quanzzzz", "createdAt": "2020-04-17T04:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java\nindex fe8ecf1e7f..4e52cefdf0 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java\n\n@@ -45,13 +41,16 @@ import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n  *     <li>N is a 9-character, zero-prefixed nanosecond between 000,000,000 and 999,999,999.\n  *     The . and N may be excluded if N is 0.</li>\n  * </ol>\n+ * See {@link LocalTime} for more details on the serialization format.\n  *\n  * <p>\n+ * This serialization is lexicographically orderable.\n+ * <p>\n+ *\n  * Examples:\n  * <ul>\n- *     <li>{@code LocalTime.of(5, 30, 0)} is stored as {@code ItemAttributeValueMapper.fromString(\"05:30:00\")}</li>\n- *     <li>{@code LocalDateTime.of(5, 30, 0, 1)} is stored as </li>\n- *     <li>{@code ItemAttributeValueMapper.fromString(\"05:30:00.000000001\")}</li>\n+ *     <li>{@code LocalTime.of(5, 30, 0)} is stored as an AttributeValue with the String \"05:30\"}</li>\n+ *     <li>{@code LocalTime.of(5, 30, 0, 1)} is stored as an AttributeValue with the String \"05:30:00.000000001\"}</li>\n  * </ul>\n  *\n  * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODAxNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410358015", "bodyText": "This doesn't need to be parameterized since you're not passing in the attribute converter thus it's strongly typed to the class under test. Either drop the parameter  or move this into a shared place where all the tests can use it and pass in the converter to make it fully generic.", "author": "bmaizels", "createdAt": "2020-04-17T17:11:43Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package software.amazon.awssdk.enhanced.dynamodb.converters.attribute;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.assertFails;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformFrom;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformTo;\n+\n+import java.time.LocalTime;\n+import org.junit.Test;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.EnhancedAttributeValue;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.LocalTimeAttributeConverter;\n+\n+public class LocalTimeAttributeConverterTest {\n+\n+    private static AttributeConverter converter = LocalTimeAttributeConverter.create();\n+\n+    @Test\n+    public void LocalTimeAttributeConverterMinTest() {\n+        verifyTransform(LocalTime.MIN, \"00:00:00\");\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNormalTest() {\n+        verifyTransform(LocalTime.of(1, 2, 3, 4), \"01:02:03.000000004\");\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterMaxTest() {\n+        verifyTransform(LocalTime.MAX, \"23:59:59.999999999\");\n+    }\n+\n+\n+    @Test\n+    public void LocalTimeAttributeConverterInvalidFormatTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"-1\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterExceedHigherBoundTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"24:00:00\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterInvalidNanoSecondsTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"00:00:00.9999999999\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptLocalDateTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptInstantTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001Z\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptOffsetTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptZonedTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00[Europe/Paris]\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptLocalDateTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptMonthDayTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"05-21\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    private <T> void verifyTransform(T objectToTransform, String attributeValueString) {\n+        assertThat(transformFrom(converter, objectToTransform))\n+            .isEqualTo(EnhancedAttributeValue.fromString(attributeValueString).toAttributeValue());\n+        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(attributeValueString).toAttributeValue()))\n+            .isEqualTo(objectToTransform);\n+    }", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java b/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java\nindex 586fe7f9e8..584b861484 100644\n--- a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java\n+++ b/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java\n\n@@ -7,17 +7,16 @@ import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.Conv\n \n import java.time.LocalTime;\n import org.junit.Test;\n-import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.EnhancedAttributeValue;\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.LocalTimeAttributeConverter;\n \n public class LocalTimeAttributeConverterTest {\n \n-    private static AttributeConverter converter = LocalTimeAttributeConverter.create();\n+    private static LocalTimeAttributeConverter converter = LocalTimeAttributeConverter.create();\n \n     @Test\n     public void LocalTimeAttributeConverterMinTest() {\n-        verifyTransform(LocalTime.MIN, \"00:00:00\");\n+        verifyTransform(LocalTime.MIN, \"00:00\");\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODYyOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410358629", "bodyText": "As discussed let's start with using parse and work from there. Let's do this for all the transformTo implementations", "author": "bmaizels", "createdAt": "2020-04-17T17:13:01Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -92,49 +95,59 @@ public static LocalDateTimeAttributeConverter create() {\n \n     @Override\n     public AttributeValueType attributeValueType() {\n-        return AttributeValueType.N;\n+        return AttributeValueType.S;\n     }\n \n     @Override\n     public AttributeValue transformFrom(LocalDateTime input) {\n         String value = \"\" +\n-                       input.getYear() +\n-                       padLeft2(input.getMonthValue()) +\n-                       padLeft2(input.getDayOfMonth()) +\n-                       padLeft2(input.getHour()) +\n-                       padLeft2(input.getMinute()) +\n+                       input.getYear() + \"-\" +\n+                       padLeft2(input.getMonthValue()) + \"-\" +\n+                       padLeft2(input.getDayOfMonth()) + \"T\" +\n+                       padLeft2(input.getHour()) + \":\" +\n+                       padLeft2(input.getMinute()) + \":\" +\n                        padLeft2(input.getSecond()) +\n                        (input.getNano() == 0 ? \"\" : \".\" + padLeft(9, input.getNano()));\n-        return AttributeValue.builder().n(value).build();\n+\n+        return AttributeValue.builder().s(value).build();\n     }\n \n     @Override\n     public LocalDateTime transformTo(AttributeValue input) {\n-        if (input.n() != null) {\n-            return EnhancedAttributeValue.fromNumber(input.n()).convert(VISITOR);\n+        if (input.s() != null) {\n+            return EnhancedAttributeValue.fromString(input.s()).convert(VISITOR);\n         }\n \n         return EnhancedAttributeValue.fromAttributeValue(input).convert(VISITOR);\n     }\n \n     private static final class Visitor extends TypeConvertingVisitor<LocalDateTime> {\n         private Visitor() {\n-            super(LocalDateTime.class, InstantAsIntegerAttributeConverter.class);\n+            super(LocalDateTime.class, InstantAsStringAttributeConverter.class);\n         }\n \n         @Override\n-        public LocalDateTime convertNumber(String value) {\n-            String[] splitOnDecimal = ConverterUtils.splitNumberOnDecimal(value);\n-            String[] chunkedDateTime = ConverterUtils.chunkWithLeftOverflow(splitOnDecimal[0], 2, 2, 2, 2, 2);\n+        public LocalDateTime convertString(String value) {\n+            // AttributeValue.S in LocalDateTime format\n+            if (value.contains(\"T\")) {\n+                String[] splitOnDecimal = ConverterUtils.splitNumberOnDecimal(value);\n+                String[] chunkedDateTime = ConverterUtils.chunkDateTime(splitOnDecimal[0]);\n+\n+                return LocalDateTime.of(Integer.parseInt(chunkedDateTime[0]),\n+                                        Integer.parseInt(chunkedDateTime[1]),\n+                                        Integer.parseInt(chunkedDateTime[2]),\n+                                        Integer.parseInt(chunkedDateTime[3]),\n+                                        Integer.parseInt(chunkedDateTime[4]),\n+                                        Integer.parseInt(chunkedDateTime[5]),\n+                                        Integer.parseInt(splitOnDecimal[1]));", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\nindex dcc3bd8c34..c33ab2e055 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java\n\n@@ -100,25 +100,21 @@ public final class LocalDateTimeAttributeConverter implements AttributeConverter\n \n     @Override\n     public AttributeValue transformFrom(LocalDateTime input) {\n-        String value = \"\" +\n-                       input.getYear() + \"-\" +\n-                       padLeft2(input.getMonthValue()) + \"-\" +\n-                       padLeft2(input.getDayOfMonth()) + \"T\" +\n-                       padLeft2(input.getHour()) + \":\" +\n-                       padLeft2(input.getMinute()) + \":\" +\n-                       padLeft2(input.getSecond()) +\n-                       (input.getNano() == 0 ? \"\" : \".\" + padLeft(9, input.getNano()));\n-\n-        return AttributeValue.builder().s(value).build();\n+        return AttributeValue.builder().s(input.toString()).build();\n     }\n \n     @Override\n     public LocalDateTime transformTo(AttributeValue input) {\n-        if (input.s() != null) {\n-            return EnhancedAttributeValue.fromString(input.s()).convert(VISITOR);\n+        try {\n+            if (input.s() != null) {\n+                return EnhancedAttributeValue.fromString(input.s()).convert(VISITOR);\n+            }\n+\n+            return EnhancedAttributeValue.fromAttributeValue(input).convert(VISITOR);\n+        } catch (RuntimeException e) {\n+            throw new IllegalArgumentException(e);\n         }\n \n-        return EnhancedAttributeValue.fromAttributeValue(input).convert(VISITOR);\n     }\n \n     private static final class Visitor extends TypeConvertingVisitor<LocalDateTime> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MTQ3OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410371478", "bodyText": "These uses of regular expressions in this function are very expensive.", "author": "millems", "createdAt": "2020-04-17T17:36:59Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +129,67 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    /**\n+     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n+     * The negative sign is stored in the first element with 'year', if applicable.\n+     * @param valueToChunk\n+     * @return String array storing chunked pieces of Date and Time\n+     */\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(Pattern.matches(\"(?im)^(?=.*?(T))(?!.*?([+Z])).*\", valueToChunk),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 58d47071cb..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -129,67 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    /**\n-     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n-     * The negative sign is stored in the first element with 'year', if applicable.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Date and Time\n-     */\n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(Pattern.matches(\"(?im)^(?=.*?(T))(?!.*?([+Z])).*\", valueToChunk),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(chunkedDateTime.length == 6,\n-                        \"Invalid chunked result, expected {\\\"[-]YYYY\\\", \\\"MM\\\", \\\"DD\\\", \\\"HH\\\", \\\"MM\\\", \\\"SS\\\"}.\");\n-        return chunkedDateTime;\n-    }\n-\n-    /**\n-     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue(chunkedTime.length == 3, \"Invalid chunked result, expected {\\\"HH\\\", \\\"MM\\\", \\\"SS\\\"}.\");\n-        return chunkedTime;\n-    }\n-\n-    /**\n-     * Chunk the Date String into a String array, and validates the format of input string and output result.\n-     * The negative sign is stored in the first element with 'year', if applicable.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(chunkedDate.length == 3, \"Invalid chunked result, expected {\\\"[-]YYYY\\\", \\\"MM\\\", \\\"DD\\\"}.\");\n-        return chunkedDate;\n-    }\n-\n-    /**\n-     * Chunk the Month/Day String into a String array, and validates the format of input string and output result.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5 && valueToChunk.substring(2, 3).equals(\"-\"),\n-                        \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MjU4Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410372583", "bodyText": "Can we not write our own date time parsing? Can we not use DateTimeFormatter for this?", "author": "millems", "createdAt": "2020-04-17T17:39:08Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +129,67 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    /**\n+     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n+     * The negative sign is stored in the first element with 'year', if applicable.\n+     * @param valueToChunk\n+     * @return String array storing chunked pieces of Date and Time\n+     */\n+    public static String[] chunkDateTime(String valueToChunk) {", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\nindex 58d47071cb..13e68b25cc 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java\n\n@@ -129,67 +73,8 @@ public class ConverterUtils {\n         }\n     }\n \n-    /**\n-     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n-     * The negative sign is stored in the first element with 'year', if applicable.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Date and Time\n-     */\n-    public static String[] chunkDateTime(String valueToChunk) {\n-        Validate.isTrue(Pattern.matches(\"(?im)^(?=.*?(T))(?!.*?([+Z])).*\", valueToChunk),\n-                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-\n-        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n-        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n-\n-        Validate.isTrue(chunkedDateTime.length == 6,\n-                        \"Invalid chunked result, expected {\\\"[-]YYYY\\\", \\\"MM\\\", \\\"DD\\\", \\\"HH\\\", \\\"MM\\\", \\\"SS\\\"}.\");\n-        return chunkedDateTime;\n-    }\n-\n-    /**\n-     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkTime(String valueToChunk) {\n-        String[] chunkedTime = valueToChunk.split(\":\");\n-        Validate.isTrue(chunkedTime.length == 3, \"Invalid chunked result, expected {\\\"HH\\\", \\\"MM\\\", \\\"SS\\\"}.\");\n-        return chunkedTime;\n-    }\n-\n-    /**\n-     * Chunk the Date String into a String array, and validates the format of input string and output result.\n-     * The negative sign is stored in the first element with 'year', if applicable.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkDate(String valueToChunk) {\n-        String negativeSig = \"\";\n-        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n-            negativeSig = \"-\";\n-            valueToChunk = valueToChunk.substring(1);\n-        }\n-        String[] chunkedDate = valueToChunk.split(\"-\");\n-        chunkedDate[0] = negativeSig + chunkedDate[0];\n-        Validate.isTrue(chunkedDate.length == 3, \"Invalid chunked result, expected {\\\"[-]YYYY\\\", \\\"MM\\\", \\\"DD\\\"}.\");\n-        return chunkedDate;\n-    }\n-\n-    /**\n-     * Chunk the Month/Day String into a String array, and validates the format of input string and output result.\n-     * @param valueToChunk\n-     * @return String array storing chunked pieces of Time\n-     */\n-    public static String[] chunkMonthDay(String valueToChunk) {\n-        Validate.isTrue(valueToChunk.length() == 5 && valueToChunk.substring(2, 3).equals(\"-\"),\n-                        \"Invalid Month/Day format, expected MM-DD.\");\n-        return valueToChunk.split(\"-\");\n+    public static LocalDateTime convertFromLocalDate(LocalDate localDate) {\n+        return LocalDateTime.of(localDate, LocalTime.MIDNIGHT);\n     }\n \n }\n"}}, {"oid": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f3109f5bb55f5e0feea26b54ad42d0937740e994", "message": "Replace InstantAsInteger with InstantAsString and test if this works.", "committedDate": "2020-04-17T20:38:11Z", "type": "commit"}, {"oid": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f3109f5bb55f5e0feea26b54ad42d0937740e994", "message": "Replace InstantAsInteger with InstantAsString and test if this works.", "committedDate": "2020-04-17T20:38:11Z", "type": "forcePushed"}, {"oid": "08c5042c2bf8308fe489a7e63db7028dcf8a6eb6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08c5042c2bf8308fe489a7e63db7028dcf8a6eb6", "message": "Merge branch 'master' into replace-instantAsInteger", "committedDate": "2020-04-17T20:38:56Z", "type": "commit"}]}