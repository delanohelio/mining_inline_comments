{"pr_number": 1777, "pr_title": "Aws crt dev preview", "pr_createdAt": "2020-04-13T21:26:31Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1777", "timeline": [{"oid": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "url": "https://github.com/aws/aws-sdk-java-v2/commit/511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "message": "Amazon CloudFront Update: Amazon CloudFront adds support for a new security policy, TLSv1.2_2019.", "committedDate": "2020-07-07T18:24:07Z", "type": "commit"}, {"oid": "d73a188a008be177fffd3aa05489461329d43be6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d73a188a008be177fffd3aa05489461329d43be6", "message": "AWS Storage Gateway Update: Adding support for file-system driven directory refresh, Case Sensitivity toggle for SMB File Shares, and S3 Prefixes and custom File Share names", "committedDate": "2020-07-07T18:24:12Z", "type": "commit"}, {"oid": "a288e9b248dd286ae9a238ce2319a61468733e7b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a288e9b248dd286ae9a238ce2319a61468733e7b", "message": "AWS Lake Formation Update: AWS Lake Formation supports sharing tables with other AWS accounts and organizations", "committedDate": "2020-07-07T18:24:16Z", "type": "commit"}, {"oid": "e08735d85758c2239d1a2050e335cf792f107d32", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e08735d85758c2239d1a2050e335cf792f107d32", "message": "Amazon Elastic Compute Cloud Update: DescribeAvailabilityZones now returns additional data about Availability Zones and Local Zones.", "committedDate": "2020-07-07T18:24:22Z", "type": "commit"}, {"oid": "ddc9790598e3872e67e18e37d7b4b196c11c7be6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/ddc9790598e3872e67e18e37d7b4b196c11c7be6", "message": "AWS Glue Update: AWS Glue Data Catalog supports cross account sharing of tables through AWS Lake Formation", "committedDate": "2020-07-07T18:24:29Z", "type": "commit"}, {"oid": "83614f0d50c57933bd27e6488d8e9bbb2536da35", "url": "https://github.com/aws/aws-sdk-java-v2/commit/83614f0d50c57933bd27e6488d8e9bbb2536da35", "message": "Updated endpoints.json.", "committedDate": "2020-07-07T18:25:28Z", "type": "commit"}, {"oid": "82cddd52a37573b6fd27f0a1111e2ad1c9a9e087", "url": "https://github.com/aws/aws-sdk-java-v2/commit/82cddd52a37573b6fd27f0a1111e2ad1c9a9e087", "message": "Release 2.13.52. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-07T18:26:03Z", "type": "commit"}, {"oid": "f4a96b62d63feb34a8869f50e5d6ba942392e68d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f4a96b62d63feb34a8869f50e5d6ba942392e68d", "message": "Merge pull request #896 from aws/staging/5b2086bc-ab52-45d4-bf64-a220fd04e190\n\nPull request: release <- staging/5b2086bc-ab52-45d4-bf64-a220fd04e190", "committedDate": "2020-07-07T18:26:19Z", "type": "commit"}, {"oid": "f2a35593a8979b4ef93b62d02ef33579303f5209", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f2a35593a8979b4ef93b62d02ef33579303f5209", "message": "Update to next snapshot version: 2.13.53-SNAPSHOT", "committedDate": "2020-07-07T19:03:09Z", "type": "commit"}, {"oid": "7463960cbc1b91d30955436e5bbf836efd4ac726", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7463960cbc1b91d30955436e5bbf836efd4ac726", "message": "Amazon Forecast Service Update: With this release, Amazon Forecast now supports the ability to add a tag to any resource via the launch of three new APIs: TagResouce, UntagResource and ListTagsForResource. A tag is a simple label consisting of a customer-defined key and an optional value allowing for easier resource management.", "committedDate": "2020-07-08T18:04:44Z", "type": "commit"}, {"oid": "7b39cbdc3c81e372dbdf20ddf4c8fdfa49cd1f3a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7b39cbdc3c81e372dbdf20ddf4c8fdfa49cd1f3a", "message": "AWS Cost Explorer Service Update: Customers can now see Instance Name alongside each rightsizing recommendation.", "committedDate": "2020-07-08T18:04:49Z", "type": "commit"}, {"oid": "b2d2b0f7cd3b33593b0c105f409461c9d1a0d1e3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b2d2b0f7cd3b33593b0c105f409461c9d1a0d1e3", "message": "Amazon Elastic Compute Cloud Update: EC2 Spot now enables customers to tag their Spot Instances Requests on creation.", "committedDate": "2020-07-08T18:04:56Z", "type": "commit"}, {"oid": "d952ef33becaf30b743e00788061f338bcce96b0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d952ef33becaf30b743e00788061f338bcce96b0", "message": "AWS Organizations Update: AI services opt out policies enable you to control what AI service data is collected and stored for the accounts in your organization. By default, AWS artificial intelligence (AI) services collect and store data as part of operating and supporting the continuous improvement life cycle for each service. You can use these policies to opt out of this process for all of your AWS accounts to ensure that your data is not persisted within AWS AI service data stores or used for service improvements.", "committedDate": "2020-07-08T18:05:01Z", "type": "commit"}, {"oid": "1d8fab6d1ca8f9b0621146940b12c372c7d58734", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1d8fab6d1ca8f9b0621146940b12c372c7d58734", "message": "Updated endpoints.json.", "committedDate": "2020-07-08T18:05:56Z", "type": "commit"}, {"oid": "8cb780fc29a9e5710115b990885dfe1d0c65e00f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8cb780fc29a9e5710115b990885dfe1d0c65e00f", "message": "Release 2.13.53. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-08T18:06:28Z", "type": "commit"}, {"oid": "15921acd7e8b8df96f6dee079c970d61bfdaa540", "url": "https://github.com/aws/aws-sdk-java-v2/commit/15921acd7e8b8df96f6dee079c970d61bfdaa540", "message": "Merge pull request #897 from aws/staging/71b210d4-dc00-4eaf-bb89-f8a5564ac639\n\nPull request: release <- staging/71b210d4-dc00-4eaf-bb89-f8a5564ac639", "committedDate": "2020-07-08T18:06:45Z", "type": "commit"}, {"oid": "28465dcecca9c1c868edf99882c2c6ff9ec36d02", "url": "https://github.com/aws/aws-sdk-java-v2/commit/28465dcecca9c1c868edf99882c2c6ff9ec36d02", "message": "Introduce \"EndpointDiscoveryFailedException\", which is thrown when an operation requires endpoint discovery, but endpoint discovery fails.", "committedDate": "2020-07-08T18:29:34Z", "type": "commit"}, {"oid": "0e2051144cf550c4a82f5283581db2bb10b052b7", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0e2051144cf550c4a82f5283581db2bb10b052b7", "message": "Merge remote-tracking branch 'public/release'", "committedDate": "2020-07-08T18:32:38Z", "type": "commit"}, {"oid": "226ac9ee6539cf928872e5c59dc9d195deff70f4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/226ac9ee6539cf928872e5c59dc9d195deff70f4", "message": "Update to next snapshot version: 2.13.54-SNAPSHOT", "committedDate": "2020-07-08T18:32:58Z", "type": "commit"}, {"oid": "cd8c93af79877065b6f3027499f7b061e3ac125c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/cd8c93af79877065b6f3027499f7b061e3ac125c", "message": "Updated DynamoDBEnhancedClient to support '0' and '1' as valid boolean values.\n\nThe 1.11.x DynamoDB mapper persisted booleans as 0s and 1s (in the 'number' type). For backwards-compatibility, we should be able to read these values. The values will be converted to boolean types if they are written back to DynamoDB.\n\nFixes #1912", "committedDate": "2020-07-08T20:37:36Z", "type": "commit"}, {"oid": "5b66e5713a26a681a162ed9953a70b19fc5ab24b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5b66e5713a26a681a162ed9953a70b19fc5ab24b", "message": "Update metrics docs", "committedDate": "2020-07-08T21:22:31Z", "type": "commit"}, {"oid": "9007043ebf8ebbb4f0805ee6a64495004df00385", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9007043ebf8ebbb4f0805ee6a64495004df00385", "message": "Update changelog for release", "committedDate": "2020-07-09T00:23:15Z", "type": "commit"}, {"oid": "274e21975999b3cb58adb1be0e8b465c0f1b12ac", "url": "https://github.com/aws/aws-sdk-java-v2/commit/274e21975999b3cb58adb1be0e8b465c0f1b12ac", "message": "Amazon CloudWatch Events Update: Amazon CloudWatch Events/EventBridge adds support for API Gateway as a target.", "committedDate": "2020-07-09T18:06:18Z", "type": "commit"}, {"oid": "f814299f74983d2972141c5dd23114670422d8a2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f814299f74983d2972141c5dd23114670422d8a2", "message": "AWS Amplify Update: Documentation update to the introduction text to specify that this is the Amplify Console API.", "committedDate": "2020-07-09T18:06:22Z", "type": "commit"}, {"oid": "c5c775b935cdacfca667f63f5980f73d68dec46e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c5c775b935cdacfca667f63f5980f73d68dec46e", "message": "AWS CloudHSM V2 Update: Documentation updates for cloudhsmv2", "committedDate": "2020-07-09T18:06:27Z", "type": "commit"}, {"oid": "1c04deea7622beb62938ecec76a10095b0f59674", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1c04deea7622beb62938ecec76a10095b0f59674", "message": "Amazon Comprehend Update: AWS Comprehend now supports Real-time Analysis with Custom Entity Recognition.", "committedDate": "2020-07-09T18:06:32Z", "type": "commit"}, {"oid": "0c9c597636b91d92ef19b53f6f87d219ad6efda0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0c9c597636b91d92ef19b53f6f87d219ad6efda0", "message": "Alexa For Business Update: Added support for registering an AVS device directly to a room using RegisterAVSDevice with a room ARN", "committedDate": "2020-07-09T18:06:37Z", "type": "commit"}, {"oid": "292cc8763005a8c2c32ebe34513cd8b14a7164ca", "url": "https://github.com/aws/aws-sdk-java-v2/commit/292cc8763005a8c2c32ebe34513cd8b14a7164ca", "message": "AWS Secrets Manager Update: Adds support for filters on the ListSecrets API to allow filtering results by name, tag key, tag value, or description. Adds support for the BlockPublicPolicy option on the PutResourcePolicy API to block resource policies which grant a wide range of IAM principals access to secrets. Adds support for the ValidateResourcePolicy API to validate resource policies for syntax and prevent lockout error scenarios and wide access to secrets.", "committedDate": "2020-07-09T18:06:41Z", "type": "commit"}, {"oid": "eabe0fad4241b8f4b6a6e80ae54bbcee5629fd1c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/eabe0fad4241b8f4b6a6e80ae54bbcee5629fd1c", "message": "AWS WAFV2 Update: Added the option to use IP addresses from an HTTP header that you specify, instead of using the web request origin. Available for IP set matching, geo matching, and rate-based rule count aggregation.", "committedDate": "2020-07-09T18:06:46Z", "type": "commit"}, {"oid": "cc9899399d99bdb7fba5ec6d828bf861b6139c0e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/cc9899399d99bdb7fba5ec6d828bf861b6139c0e", "message": "Amazon Elastic Block Store Update: This release introduces the following set of actions for the EBS direct APIs: 1. StartSnapshot, which creates a new Amazon EBS snapshot. 2. PutSnapshotBlock, which writes a block of data to a snapshot. 3. CompleteSnapshot, which seals and completes a snapshot after blocks of data have been written to it.", "committedDate": "2020-07-09T18:06:51Z", "type": "commit"}, {"oid": "3eed2386d2e4feb4eeaf5ef546c2eadcd46b4a6e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3eed2386d2e4feb4eeaf5ef546c2eadcd46b4a6e", "message": "Amazon SageMaker Service Update: This release adds the DeleteHumanTaskUi API to Amazon Augmented AI", "committedDate": "2020-07-09T18:06:55Z", "type": "commit"}, {"oid": "91834455639ae433bc0b99823904dc79255d73a3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/91834455639ae433bc0b99823904dc79255d73a3", "message": "AWS App Mesh Update: AppMesh now supports Ingress which allows resources outside a mesh to communicate to resources that are inside the mesh. See https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html", "committedDate": "2020-07-09T18:07:01Z", "type": "commit"}, {"oid": "c498503a49ee7b1fdc7d6661c5eddf6f41382530", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c498503a49ee7b1fdc7d6661c5eddf6f41382530", "message": "Amazon EventBridge Update: Amazon EventBridge adds support for API Gateway as a target.", "committedDate": "2020-07-09T18:07:05Z", "type": "commit"}, {"oid": "8c46500c4f096a8db013dc785874e3428ce7891b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8c46500c4f096a8db013dc785874e3428ce7891b", "message": "Amazon Simple Notification Service Update: This release adds support for SMS origination number as an attribute in the MessageAttributes parameter for the SNS Publish API.", "committedDate": "2020-07-09T18:07:09Z", "type": "commit"}, {"oid": "a5d6a09d0c7100409b1fa216fe181487984ada3c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a5d6a09d0c7100409b1fa216fe181487984ada3c", "message": "Updated endpoints.json.", "committedDate": "2020-07-09T18:08:06Z", "type": "commit"}, {"oid": "988a9d796b1005823d3c30c5b6a2044a51ad5b62", "url": "https://github.com/aws/aws-sdk-java-v2/commit/988a9d796b1005823d3c30c5b6a2044a51ad5b62", "message": "Release 2.13.54. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-09T18:08:40Z", "type": "commit"}, {"oid": "0150b8b8eea1c58dc12e3076010588bdb5dbcb9f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0150b8b8eea1c58dc12e3076010588bdb5dbcb9f", "message": "Merge pull request #899 from aws/staging/eaca728f-2dab-47fb-b1fd-7da8d5e9232b\n\nPull request: release <- staging/eaca728f-2dab-47fb-b1fd-7da8d5e9232b", "committedDate": "2020-07-09T18:08:55Z", "type": "commit"}, {"oid": "17dbe2ee26d3ee5506c72d0aeab772677c076de9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/17dbe2ee26d3ee5506c72d0aeab772677c076de9", "message": "Update to next snapshot version: 2.13.55-SNAPSHOT", "committedDate": "2020-07-09T18:34:28Z", "type": "commit"}, {"oid": "a093ba168bba7d022f6cb69e11ae068075537212", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a093ba168bba7d022f6cb69e11ae068075537212", "message": "Fix metrics tests\n\n - Init test clients with mock credentials provider\n - Account for asynchrony for local stream window size", "committedDate": "2020-07-09T22:51:46Z", "type": "commit"}, {"oid": "2ecd729a92a03127b1838a7721db36e6bc956b6a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2ecd729a92a03127b1838a7721db36e6bc956b6a", "message": "Return post metric publish stage\n\nReturn whenComplete's result, so that it's easier to say that \"when the execute\nfuture completes, metrics have been published\".", "committedDate": "2020-07-14T19:37:47Z", "type": "commit"}, {"oid": "d1d4dbe331e07513f7596ba21cbe424073eeca9e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d1d4dbe331e07513f7596ba21cbe424073eeca9e", "message": "Remove unsupported exception from No op collector", "committedDate": "2020-07-14T20:41:12Z", "type": "commit"}, {"oid": "af0dffdd088505f05eabc3b459ffb98fa8a0f6b1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/af0dffdd088505f05eabc3b459ffb98fa8a0f6b1", "message": "Minor metrics fixes\n\nRemove SdkMetric#convertValue, and various formatting fixes javadoc fixes", "committedDate": "2020-07-14T22:31:27Z", "type": "commit"}, {"oid": "e1662b78b5a415daebde377ce93e3d3f5bee5c2b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e1662b78b5a415daebde377ce93e3d3f5bee5c2b", "message": "Amazon Interactive Video Service Update: Introducing Amazon Interactive Video Service - a managed live streaming solution that is quick and easy to set up, and ideal for creating interactive video experiences.", "committedDate": "2020-07-15T18:11:05Z", "type": "commit"}, {"oid": "9199924ff4d69452c641e8b1915650652fda0b14", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9199924ff4d69452c641e8b1915650652fda0b14", "message": "Updated endpoints.json.", "committedDate": "2020-07-15T18:11:57Z", "type": "commit"}, {"oid": "11a7aed7a7f3f3b6f0f1fc573d6214aca996c1a7", "url": "https://github.com/aws/aws-sdk-java-v2/commit/11a7aed7a7f3f3b6f0f1fc573d6214aca996c1a7", "message": "Release 2.13.55. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-15T18:12:28Z", "type": "commit"}, {"oid": "fc1a12675b278e9c70bd36eca24f94d2a698b26d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fc1a12675b278e9c70bd36eca24f94d2a698b26d", "message": "Merge pull request #901 from aws/staging/2651492b-f0d6-4f13-9b2b-0af9bccdaa6a\n\nPull request: release <- staging/2651492b-f0d6-4f13-9b2b-0af9bccdaa6a", "committedDate": "2020-07-15T18:12:41Z", "type": "commit"}, {"oid": "39fe33d665c10a4faa00175d042585087536715d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/39fe33d665c10a4faa00175d042585087536715d", "message": "Update to next snapshot version: 2.13.56-SNAPSHOT", "committedDate": "2020-07-15T18:36:43Z", "type": "commit"}, {"oid": "f7e5408fd6bddd81ac80dcc5b62c82cd2647a756", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f7e5408fd6bddd81ac80dcc5b62c82cd2647a756", "message": "Merge remote-tracking branch 'upstream/master' into aws-crt-dev-preview", "committedDate": "2020-07-15T19:56:06Z", "type": "commit"}, {"oid": "31437dc58b515fb3c0db74ebe03de4e0413dc57e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/31437dc58b515fb3c0db74ebe03de4e0413dc57e", "message": "Update crt version", "committedDate": "2020-07-15T20:10:21Z", "type": "commit"}, {"oid": "989e02e3c51d04ffa633f4f5828255e53ebe7f82", "url": "https://github.com/aws/aws-sdk-java-v2/commit/989e02e3c51d04ffa633f4f5828255e53ebe7f82", "message": "Fixups", "committedDate": "2020-07-15T20:45:47Z", "type": "commit"}, {"oid": "6f6be670c387a5b82a1abdeb6f94ed9c47135a6d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6f6be670c387a5b82a1abdeb6f94ed9c47135a6d", "message": "Findbugs fixups", "committedDate": "2020-07-15T21:06:58Z", "type": "commit"}, {"oid": "f7b9605b25e7044b9bfa9bd2815570acbbb66d0a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f7b9605b25e7044b9bfa9bd2815570acbbb66d0a", "message": "Checkstyle", "committedDate": "2020-07-15T21:15:37Z", "type": "commit"}, {"oid": "320b132ef44ed9b72ff7280e0578393e2da010a5", "url": "https://github.com/aws/aws-sdk-java-v2/commit/320b132ef44ed9b72ff7280e0578393e2da010a5", "message": "Doing things correctly is hard", "committedDate": "2020-07-15T21:32:27Z", "type": "commit"}, {"oid": "8415cfcb67342a629260964ce339d93439ac59f0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8415cfcb67342a629260964ce339d93439ac59f0", "message": "Missing dependency", "committedDate": "2020-07-15T23:56:42Z", "type": "commit"}, {"oid": "6ad9cb77ff6bbfe10023f02cf967be3c76462bce", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6ad9cb77ff6bbfe10023f02cf967be3c76462bce", "message": "Amazon Elastic MapReduce Update: Adding support for MaximumCoreCapacityUnits parameter for EMR Managed Scaling. It allows users to control how many units/nodes are added to the CORE group/fleet. Remaining units/nodes are added to the TASK groups/fleet in the cluster.", "committedDate": "2020-06-22T18:08:48Z", "type": "commit"}, {"oid": "d19299270369b86d18f7f81a577003cb7694e169", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d19299270369b86d18f7f81a577003cb7694e169", "message": "Amazon Rekognition Update: This update adds the ability to detect black frames, end credits, shots, and color bars in stored videos", "committedDate": "2020-06-22T18:08:53Z", "type": "commit"}, {"oid": "abec169de171f109f25ad6174ca6d7cc31d1616e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/abec169de171f109f25ad6174ca6d7cc31d1616e", "message": "Amazon Elastic Compute Cloud Update: This release adds Tag On Create feature support for the ImportImage, ImportSnapshot, ExportImage and CreateInstanceExportTask APIs.", "committedDate": "2020-06-22T18:08:58Z", "type": "commit"}, {"oid": "8558e7aa3c9b1039c08f1fbc0401182b74805c98", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8558e7aa3c9b1039c08f1fbc0401182b74805c98", "message": "Amazon Simple Queue Service Update: AWS SQS adds pagination support for ListQueues and ListDeadLetterSourceQueues APIs", "committedDate": "2020-06-22T18:09:04Z", "type": "commit"}, {"oid": "87a1903d88ee86d784e87ed4cbb110b787312986", "url": "https://github.com/aws/aws-sdk-java-v2/commit/87a1903d88ee86d784e87ed4cbb110b787312986", "message": "Release 2.13.42. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-22T18:10:24Z", "type": "commit"}, {"oid": "449fd0b7122b1dacacae3a57146eb0bb3e3afc76", "url": "https://github.com/aws/aws-sdk-java-v2/commit/449fd0b7122b1dacacae3a57146eb0bb3e3afc76", "message": "Merge pull request #885 from aws/staging/851f7a0b-acf0-443d-9760-b6f781e6d032\n\nPull request: release <- staging/851f7a0b-acf0-443d-9760-b6f781e6d032", "committedDate": "2020-06-22T18:10:38Z", "type": "commit"}, {"oid": "fc38805f4b8e57ee4a77f8f14ebc43c7ca86e3a4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fc38805f4b8e57ee4a77f8f14ebc43c7ca86e3a4", "message": "Update to next snapshot version: 2.13.43-SNAPSHOT", "committedDate": "2020-06-22T18:35:30Z", "type": "commit"}, {"oid": "312d49a0e05c0b431cb0ded45e5245c442259052", "url": "https://github.com/aws/aws-sdk-java-v2/commit/312d49a0e05c0b431cb0ded45e5245c442259052", "message": "Add CloudWatchMetricPublisher, a MetricPublisher implementation that uploads metric data to CloudWatch.", "committedDate": "2020-06-22T20:09:15Z", "type": "commit"}, {"oid": "83d46ca59c168684d9b53fbec22821053f667d4f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/83d46ca59c168684d9b53fbec22821053f667d4f", "message": "Fixed a cloudwatch-metric-publisher issue where very small values would result in a failure calling cloudwatch.", "committedDate": "2020-06-22T21:24:10Z", "type": "commit"}, {"oid": "9908e2253ebc6c2a211be16382c1e1a348db0523", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9908e2253ebc6c2a211be16382c1e1a348db0523", "message": "Merged mainline to metrics development branch", "committedDate": "2020-06-23T04:54:04Z", "type": "commit"}, {"oid": "3d57c583a56c11def229349b01f6c3b2d9fe919a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3d57c583a56c11def229349b01f6c3b2d9fe919a", "message": "Add HttpClient collector to HTTP request", "committedDate": "2020-06-23T17:46:03Z", "type": "commit"}, {"oid": "3239d25eee226d3181351dc6b1eed5e459d570f3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3239d25eee226d3181351dc6b1eed5e459d570f3", "message": "AWS Organizations Update: Added a new error message to support the requirement for a Business License on AWS accounts in China to create an organization.", "committedDate": "2020-06-23T18:37:52Z", "type": "commit"}, {"oid": "4e9a8bcdf13571f120adf83e4321c16b4c1d3f25", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4e9a8bcdf13571f120adf83e4321c16b4c1d3f25", "message": "AWS MediaTailor Update: AWS Elemental MediaTailor SDK now allows configuration of Bumper.", "committedDate": "2020-06-23T18:37:58Z", "type": "commit"}, {"oid": "f03a4ca61a94ff2d02b561ee76c30799d2b3c5c0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f03a4ca61a94ff2d02b561ee76c30799d2b3c5c0", "message": "Updated endpoints.json.", "committedDate": "2020-06-23T18:38:52Z", "type": "commit"}, {"oid": "6aa5f97278448875cf9e21906c71bf8e29333243", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6aa5f97278448875cf9e21906c71bf8e29333243", "message": "Release 2.13.43. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-23T18:39:22Z", "type": "commit"}, {"oid": "71f74d5efa425207726581aa8f6d3ffad0959b9d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/71f74d5efa425207726581aa8f6d3ffad0959b9d", "message": "Merge pull request #886 from aws/staging/9c2a3afc-db98-47cd-af24-c7b0fb272147\n\nPull request: release <- staging/9c2a3afc-db98-47cd-af24-c7b0fb272147", "committedDate": "2020-06-23T18:39:37Z", "type": "commit"}, {"oid": "cb623de2b7bf84aadf55f2e83837c580b1cbf243", "url": "https://github.com/aws/aws-sdk-java-v2/commit/cb623de2b7bf84aadf55f2e83837c580b1cbf243", "message": "Update to next snapshot version: 2.13.44-SNAPSHOT", "committedDate": "2020-06-23T19:08:24Z", "type": "commit"}, {"oid": "203af1cb2d4d8fd24c95f77a4316a735fe6155d2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/203af1cb2d4d8fd24c95f77a4316a735fe6155d2", "message": "Merge pull request #1923 from Quanzzzz/sdk-metrics-development-2\n\nMerge mainline to metrics development branch", "committedDate": "2020-06-23T20:25:48Z", "type": "commit"}, {"oid": "b9c21c69f798a29e0cf2b068e411ce44fb5fd558", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b9c21c69f798a29e0cf2b068e411ce44fb5fd558", "message": "AWS Backup Update: Customers can now manage and monitor their backups in a policied manner across their AWS accounts, via an integration between AWS Backup and AWS Organizations", "committedDate": "2020-06-24T18:04:17Z", "type": "commit"}, {"oid": "c63cc1f851eb1ca477276711f47ae4191a847440", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c63cc1f851eb1ca477276711f47ae4191a847440", "message": "AWS Amplify Update: This release of AWS Amplify Console introduces support for automatically creating custom subdomains for branches based on user-defined glob patterns, as well as automatically cleaning up Amplify branches when their corresponding git branches are deleted.", "committedDate": "2020-06-24T18:04:22Z", "type": "commit"}, {"oid": "4872197e34e7b148f614e11d0dbe07501e49e030", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4872197e34e7b148f614e11d0dbe07501e49e030", "message": "AWS Identity and Access Management Update: Documentation updates for iam", "committedDate": "2020-06-24T18:04:27Z", "type": "commit"}, {"oid": "868238796b2645d925050cc71874bda0caff077f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/868238796b2645d925050cc71874bda0caff077f", "message": "AWS Organizations Update: This release adds support for a new backup policy type for AWS Organizations.", "committedDate": "2020-06-24T18:04:32Z", "type": "commit"}, {"oid": "5d5ea4cdd051ea717a5b92d936eb6978c10ada93", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5d5ea4cdd051ea717a5b92d936eb6978c10ada93", "message": "AWS CodeCommit Update: This release introduces support for reactions to CodeCommit comments. Users will be able to select from a pre-defined list of emojis to express their reaction to any comments.", "committedDate": "2020-06-24T18:04:38Z", "type": "commit"}, {"oid": "653730446d35de222a2c015bec8e750397742238", "url": "https://github.com/aws/aws-sdk-java-v2/commit/653730446d35de222a2c015bec8e750397742238", "message": "Amazon Honeycode Update: Introducing Amazon Honeycode - a fully managed service that allows you to quickly build mobile and web apps for teams without programming.", "committedDate": "2020-06-24T18:04:42Z", "type": "commit"}, {"oid": "15eb5e2ee3a5e138509275514d4902cb90872dbc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/15eb5e2ee3a5e138509275514d4902cb90872dbc", "message": "Amazon FSx Update: This release adds the capability to take highly-durable, incremental backups of your FSx for Lustre persistent file systems. This capability makes it easy to further protect your file system data and to meet business and regulatory compliance requirements.", "committedDate": "2020-06-24T18:04:47Z", "type": "commit"}, {"oid": "63ce9f18d3e0a9f42861909869ad11746dff9f4d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/63ce9f18d3e0a9f42861909869ad11746dff9f4d", "message": "Amazon Elastic MapReduce Update: Amazon EMR customers can now set allocation strategies for On-Demand and Spot instances in their EMR clusters with instance fleets. These allocation strategies use real-time capacity insights to provision clusters faster and make the most efficient use of available spare capacity to allocate Spot instances to reduce interruptions.", "committedDate": "2020-06-24T18:04:52Z", "type": "commit"}, {"oid": "f0f775bacfabd0e5eb737e7b5d19d4c8aedc17f7", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f0f775bacfabd0e5eb737e7b5d19d4c8aedc17f7", "message": "Auto Scaling Update: Documentation updates for Amazon EC2 Auto Scaling.", "committedDate": "2020-06-24T18:04:56Z", "type": "commit"}, {"oid": "4fc5b53399d02f930bac498b77a6d95d5e9b0347", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4fc5b53399d02f930bac498b77a6d95d5e9b0347", "message": "Updated endpoints.json.", "committedDate": "2020-06-24T18:05:52Z", "type": "commit"}, {"oid": "c33a9ab27fd0fc54a640123b57f7992f3408080d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c33a9ab27fd0fc54a640123b57f7992f3408080d", "message": "Release 2.13.44. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-24T18:06:22Z", "type": "commit"}, {"oid": "e5b358a63159d68709a0b508c497a687f677d199", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e5b358a63159d68709a0b508c497a687f677d199", "message": "Merge pull request #887 from aws/staging/1f73039a-83b2-4214-8ca0-ed7aaee67c13\n\nPull request: release <- staging/1f73039a-83b2-4214-8ca0-ed7aaee67c13", "committedDate": "2020-06-24T18:06:34Z", "type": "commit"}, {"oid": "535c24fc418d0427f19e1da5fb8a98e5254b88b8", "url": "https://github.com/aws/aws-sdk-java-v2/commit/535c24fc418d0427f19e1da5fb8a98e5254b88b8", "message": "Update to next snapshot version: 2.13.45-SNAPSHOT", "committedDate": "2020-06-24T18:31:56Z", "type": "commit"}, {"oid": "b5148ee1df12e97e96cfb35c2c700d8bcc66f6c6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b5148ee1df12e97e96cfb35c2c700d8bcc66f6c6", "message": "DDB-Enhanced: Fixed NPE in DeleteItemOperation when ConditionExpression has null attributeNames or attributeValues", "committedDate": "2020-06-24T19:21:36Z", "type": "commit"}, {"oid": "7f3adef4e7061b2080706cb03484a7442cf361c4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7f3adef4e7061b2080706cb03484a7442cf361c4", "message": "Amazon Elastic Compute Cloud Update: Added support for tag-on-create for Host Reservations in Dedicated Hosts. You can now specify tags when you create a Host Reservation for a Dedicated Host. For more information about tagging, see AWS Tagging Strategies.", "committedDate": "2020-06-25T18:38:24Z", "type": "commit"}, {"oid": "b4e4431ab3d4d6b5ffecdf7dfbbd7c34c1c67348", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b4e4431ab3d4d6b5ffecdf7dfbbd7c34c1c67348", "message": "AWS Glue Update: This release adds new APIs to support column level statistics in AWS Glue Data Catalog", "committedDate": "2020-06-25T18:38:37Z", "type": "commit"}, {"oid": "e22e7e696ca57f98f759d438794fe2ef93c8beb4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e22e7e696ca57f98f759d438794fe2ef93c8beb4", "message": "Updated endpoints.json.", "committedDate": "2020-06-25T18:39:34Z", "type": "commit"}, {"oid": "fd5d42b8f5eb5c1ddb0e67455236ff0abad39d18", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fd5d42b8f5eb5c1ddb0e67455236ff0abad39d18", "message": "Release 2.13.45. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-25T18:40:07Z", "type": "commit"}, {"oid": "e0faaf4ea7faf740684da229874e29f693e3a745", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e0faaf4ea7faf740684da229874e29f693e3a745", "message": "Merge pull request #888 from aws/staging/c10ded41-6dfe-4667-9e99-5c5dcb995ecc\n\nPull request: release <- staging/c10ded41-6dfe-4667-9e99-5c5dcb995ecc", "committedDate": "2020-06-25T18:40:21Z", "type": "commit"}, {"oid": "bd48860c4ca4a362c78da2f5ac2038276634b553", "url": "https://github.com/aws/aws-sdk-java-v2/commit/bd48860c4ca4a362c78da2f5ac2038276634b553", "message": "Update to next snapshot version: 2.13.46-SNAPSHOT", "committedDate": "2020-06-25T19:07:54Z", "type": "commit"}, {"oid": "60b6815f060e65ad7bdeeee83a4329d8cd268227", "url": "https://github.com/aws/aws-sdk-java-v2/commit/60b6815f060e65ad7bdeeee83a4329d8cd268227", "message": "AWS Database Migration Service Update: This release contains miscellaneous API documentation updates for AWS DMS in response to several customer reported issues.", "committedDate": "2020-06-26T18:13:22Z", "type": "commit"}, {"oid": "3de224296091c6f11f40ce6a2d8417fc7ffe1932", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3de224296091c6f11f40ce6a2d8417fc7ffe1932", "message": "Amazon Cognito Identity Provider Update: Don't require Authorization for InitiateAuth and RespondToAuthChallenge.", "committedDate": "2020-06-26T18:13:29Z", "type": "commit"}, {"oid": "4dea3edc87ebd3b924ea32f3fa5281c68066f3fd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4dea3edc87ebd3b924ea32f3fa5281c68066f3fd", "message": "AWS CloudFormation Update: ListStackInstances and DescribeStackInstance now return a new `StackInstanceStatus` object that contains `DetailedStatus` values: a disambiguation of the more generic `Status` value. ListStackInstances output can now be filtered on `DetailedStatus` using the new `Filters` parameter.", "committedDate": "2020-06-26T18:13:34Z", "type": "commit"}, {"oid": "3f297ab255242fe762143757bcf2e30067df2f98", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3f297ab255242fe762143757bcf2e30067df2f98", "message": "Amazon SageMaker Service Update: The new 'ModelClientConfig' parameter being added for CreateTransformJob and DescribeTransformJob api actions enable customers to configure model invocation related parameters such as timeout and retry.", "committedDate": "2020-06-26T18:13:39Z", "type": "commit"}, {"oid": "d74958fe10532b4e8f4e65a1a58268d8786fe1b0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d74958fe10532b4e8f4e65a1a58268d8786fe1b0", "message": "Amazon QuickSight Update: Added support for cross-region DataSource credentials copying.", "committedDate": "2020-06-26T18:13:45Z", "type": "commit"}, {"oid": "729b698877e6108f24ac61ebe6fc69cef7ada5ec", "url": "https://github.com/aws/aws-sdk-java-v2/commit/729b698877e6108f24ac61ebe6fc69cef7ada5ec", "message": "Updated endpoints.json.", "committedDate": "2020-06-26T18:14:38Z", "type": "commit"}, {"oid": "63a08329823299eb21b16fa269d2b631e860a8de", "url": "https://github.com/aws/aws-sdk-java-v2/commit/63a08329823299eb21b16fa269d2b631e860a8de", "message": "Release 2.13.46. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-26T18:15:07Z", "type": "commit"}, {"oid": "e13ebcba2ae02b46c9c54127c817139e10920ad6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e13ebcba2ae02b46c9c54127c817139e10920ad6", "message": "Merge pull request #889 from aws/staging/714c3d82-5b47-4d28-90e2-36dbd4769e5b\n\nPull request: release <- staging/714c3d82-5b47-4d28-90e2-36dbd4769e5b", "committedDate": "2020-06-26T18:15:21Z", "type": "commit"}, {"oid": "5f3c84ce0b6a28b42ee4c0a272fa49f687e6c860", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5f3c84ce0b6a28b42ee4c0a272fa49f687e6c860", "message": "Update to next snapshot version: 2.13.47-SNAPSHOT", "committedDate": "2020-06-26T18:40:19Z", "type": "commit"}, {"oid": "049f6ff704cd2f4fe8404ce2a57b455f09928309", "url": "https://github.com/aws/aws-sdk-java-v2/commit/049f6ff704cd2f4fe8404ce2a57b455f09928309", "message": "AWS CodeStar connections Update: Updated and new APIs in support of hosts for connections to installed provider types. New integration with the GitHub Enterprise Server provider type.", "committedDate": "2020-06-29T18:07:45Z", "type": "commit"}, {"oid": "aa6eb971f7b50fd1bef88b77bb802856dc0a28ef", "url": "https://github.com/aws/aws-sdk-java-v2/commit/aa6eb971f7b50fd1bef88b77bb802856dc0a28ef", "message": "Amazon CodeGuru Profiler Update: Amazon CodeGuru Profiler is now generally available. The Profiler helps developers to optimize their software, troubleshoot issues in production, and identify their most expensive lines of code. As part of general availability, we are launching: Profiling of AWS Lambda functions, Anomaly detection in CPU profiles, Color My Code on flame graphs, Expanding presence to 10 AWS regions.", "committedDate": "2020-06-29T18:07:51Z", "type": "commit"}, {"oid": "dc214837d6bcb7c9acab3c207a91eee72294fa0a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/dc214837d6bcb7c9acab3c207a91eee72294fa0a", "message": "Amazon Elastic Compute Cloud Update: Virtual Private Cloud (VPC) customers can now create and manage their own Prefix Lists to simplify VPC configurations.", "committedDate": "2020-06-29T18:07:56Z", "type": "commit"}, {"oid": "3355b82a91215ad9ac570f03cf553f6d7e14ca64", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3355b82a91215ad9ac570f03cf553f6d7e14ca64", "message": "Auto Scaling Update: Documentation updates for Amazon EC2 Auto Scaling.", "committedDate": "2020-06-29T18:08:01Z", "type": "commit"}, {"oid": "d1c35caf8434c4af79d8af241831f86ec2e8dcda", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d1c35caf8434c4af79d8af241831f86ec2e8dcda", "message": "Updated endpoints.json.", "committedDate": "2020-06-29T18:08:56Z", "type": "commit"}, {"oid": "6e5ea5f93d7c4f5542dbf12ebd992e1abbad632f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6e5ea5f93d7c4f5542dbf12ebd992e1abbad632f", "message": "Release 2.13.47. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-29T18:09:26Z", "type": "commit"}, {"oid": "6bb2811ea1e73758aeb4337efb06a57578c22374", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6bb2811ea1e73758aeb4337efb06a57578c22374", "message": "Merge pull request #890 from aws/staging/3f71acfe-db17-48d9-a5ae-56790eab3829\n\nPull request: release <- staging/3f71acfe-db17-48d9-a5ae-56790eab3829", "committedDate": "2020-06-29T18:09:38Z", "type": "commit"}, {"oid": "49bd2be323a22aa9b03da3bbfe83bd07b2138b99", "url": "https://github.com/aws/aws-sdk-java-v2/commit/49bd2be323a22aa9b03da3bbfe83bd07b2138b99", "message": "Update to next snapshot version: 2.13.48-SNAPSHOT", "committedDate": "2020-06-29T18:36:14Z", "type": "commit"}, {"oid": "022970eb0947f39d876b13227a0d49974079c25d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/022970eb0947f39d876b13227a0d49974079c25d", "message": "Fix event marshaller binding for input event streams.\n\nThis is another case of SDK code generation failing when the event's structure name and the structure member name are not identical.", "committedDate": "2020-06-30T00:15:11Z", "type": "commit"}, {"oid": "08833212836f6958364e0c0bb8abd1d0e6440c8c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08833212836f6958364e0c0bb8abd1d0e6440c8c", "message": "Add support for : in profile names", "committedDate": "2020-06-30T17:34:54Z", "type": "commit"}, {"oid": "5a8b390f02bcfdd1ca4dc71d2b04148b3647cb9e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5a8b390f02bcfdd1ca4dc71d2b04148b3647cb9e", "message": "Amazon Elastic Compute Cloud Update: Added support for tag-on-create for CreateVpc, CreateEgressOnlyInternetGateway, CreateSecurityGroup, CreateSubnet, CreateNetworkInterface, CreateNetworkAcl, CreateDhcpOptions and CreateInternetGateway. You can now specify tags when creating any of these resources. For more information about tagging, see AWS Tagging Strategies.", "committedDate": "2020-06-30T18:06:57Z", "type": "commit"}, {"oid": "cc7080cc2b288f15e5f2de58e2ed484e212906fd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/cc7080cc2b288f15e5f2de58e2ed484e212906fd", "message": "Amazon CodeGuru Reviewer Update: Release GitHub Enterprise Server source provider integration", "committedDate": "2020-06-30T18:07:03Z", "type": "commit"}, {"oid": "afa7ae7927f9ae09fc53be5f79681c2530ba4ef2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/afa7ae7927f9ae09fc53be5f79681c2530ba4ef2", "message": "Amazon Relational Database Service Update: Documentation updates for rds", "committedDate": "2020-06-30T18:07:08Z", "type": "commit"}, {"oid": "a93befd8d1f5e173f79522a2dc468be0db97e478", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a93befd8d1f5e173f79522a2dc468be0db97e478", "message": "Amazon EC2 Container Registry Update: Add a new parameter (ImageDigest) and a new exception (ImageDigestDoesNotMatchException) to PutImage API to support pushing image by digest.", "committedDate": "2020-06-30T18:07:13Z", "type": "commit"}, {"oid": "e9a8f683f231f95e2480785c5986fa7460e0ad6d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e9a8f683f231f95e2480785c5986fa7460e0ad6d", "message": "AWS Comprehend Medical Update: This release adds the relationships between MedicalCondition and Anatomy in DetectEntitiesV2 API.", "committedDate": "2020-06-30T18:07:18Z", "type": "commit"}, {"oid": "2106ff5a3e8e5dcf923c89ebacdff44b1827fffa", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2106ff5a3e8e5dcf923c89ebacdff44b1827fffa", "message": "Release 2.13.48. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-30T18:08:38Z", "type": "commit"}, {"oid": "fee8018bc29455c59e73a5744605e07ac3d49a8f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fee8018bc29455c59e73a5744605e07ac3d49a8f", "message": "Merge pull request #891 from aws/staging/6182acd1-5d01-42b1-b91d-831477b0625c\n\nPull request: release <- staging/6182acd1-5d01-42b1-b91d-831477b0625c", "committedDate": "2020-06-30T18:08:53Z", "type": "commit"}, {"oid": "4e423005aad4f01185028a1feea6fea5fb585ce2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4e423005aad4f01185028a1feea6fea5fb585ce2", "message": "Update to next snapshot version: 2.13.49-SNAPSHOT", "committedDate": "2020-06-30T18:33:28Z", "type": "commit"}, {"oid": "c4346d2cc8d0f02ca60c36088b17e213ec859e1b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c4346d2cc8d0f02ca60c36088b17e213ec859e1b", "message": "Mutiple metrics fixes\n\n - Allow lists of publishers to be set.\n\n   Allow setting of metric pubishers to be set on the client of request override\n   rather than a single publisher, making using multiple MetricPublishers per\n   client or request easier.\n\n - Remove any non-core usage of MetricUtils.\n\n - Fix metrics test in TranscribeStreamIntegrationTest.\n\n - Fix Async API call metric stage to add the duration in a separate\n   CompletionStage.", "committedDate": "2020-06-30T20:40:43Z", "type": "commit"}, {"oid": "972e7371a29cc6aef48371f0e34468858fafb6be", "url": "https://github.com/aws/aws-sdk-java-v2/commit/972e7371a29cc6aef48371f0e34468858fafb6be", "message": "Add design doc for waiters", "committedDate": "2020-06-30T20:48:23Z", "type": "commit"}, {"oid": "12f3afd431249634bef451928e0e2ee2233d6066", "url": "https://github.com/aws/aws-sdk-java-v2/commit/12f3afd431249634bef451928e0e2ee2233d6066", "message": "Updated the metrics design to include details on how metrics can be enabled at the request level, client level and global level.", "committedDate": "2020-06-30T23:42:34Z", "type": "commit"}, {"oid": "50c43fb7cdccd698fbfa523b441e7f8b0184d377", "url": "https://github.com/aws/aws-sdk-java-v2/commit/50c43fb7cdccd698fbfa523b441e7f8b0184d377", "message": "Added decision log for metrics.", "committedDate": "2020-06-30T23:45:20Z", "type": "commit"}, {"oid": "33b3138d20d8cda02fe947235a773dccbe29ad69", "url": "https://github.com/aws/aws-sdk-java-v2/commit/33b3138d20d8cda02fe947235a773dccbe29ad69", "message": "Updated metric publishing to address internal review comments.\n\nAlso fixed an issue where multiple parts of the SDK were ignoring the \"alternate\" request ID.", "committedDate": "2020-06-30T23:45:57Z", "type": "commit"}, {"oid": "7be9b77af7874d0b6999fee19c0e3c104953095a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7be9b77af7874d0b6999fee19c0e3c104953095a", "message": "Amazon Relational Database Service Update: This release adds the exceptions KMSKeyNotAccessibleFault and InvalidDBClusterStateFault to the Amazon RDS ModifyDBInstance API.", "committedDate": "2020-07-01T18:10:39Z", "type": "commit"}, {"oid": "ebaa54ab6d61301360d631db556fea192be565d9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/ebaa54ab6d61301360d631db556fea192be565d9", "message": "EC2 Image Builder Update: EC2 Image Builder adds support for encrypted AMI distribution.", "committedDate": "2020-07-01T18:10:45Z", "type": "commit"}, {"oid": "9dfb7341dcd6edefbc03e18cb1dde02cd184ce9f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9dfb7341dcd6edefbc03e18cb1dde02cd184ce9f", "message": "Amazon Chime Update: This release supports third party emergency call routing configuration for Amazon Chime Voice Connectors.", "committedDate": "2020-07-01T18:10:50Z", "type": "commit"}, {"oid": "6ee0b5d489d11d6517119e7f83bdaaf20d0b1bc3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6ee0b5d489d11d6517119e7f83bdaaf20d0b1bc3", "message": "AWS SecurityHub Update: This release adds additional details for findings. There are now finding details for auto scaling groups, EC2 volumes, and EC2 VPCs. You can identify detected vulnerabilities and provide related network paths.", "committedDate": "2020-07-01T18:10:55Z", "type": "commit"}, {"oid": "04df662bb4764b41c00b60ad4f2434edab9db011", "url": "https://github.com/aws/aws-sdk-java-v2/commit/04df662bb4764b41c00b60ad4f2434edab9db011", "message": "AWS CodeBuild Update: Support build status config in project source", "committedDate": "2020-07-01T18:11:00Z", "type": "commit"}, {"oid": "849f085b1f927821e3333f4e88309674b6601328", "url": "https://github.com/aws/aws-sdk-java-v2/commit/849f085b1f927821e3333f4e88309674b6601328", "message": "AWS AppSync Update: AWS AppSync supports new 12xlarge instance for server-side API caching", "committedDate": "2020-07-01T18:11:05Z", "type": "commit"}, {"oid": "fb2fe37f34cc86d620efefff9766230d35c1ee0c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fb2fe37f34cc86d620efefff9766230d35c1ee0c", "message": "Release 2.13.49. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-01T18:12:27Z", "type": "commit"}, {"oid": "06c6c61f3a6a5ab0f44b6ce021ab76e43421ba7f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/06c6c61f3a6a5ab0f44b6ce021ab76e43421ba7f", "message": "Merge pull request #892 from aws/staging/db0a5396-19da-4d7f-8e39-661a62e884d7\n\nPull request: release <- staging/db0a5396-19da-4d7f-8e39-661a62e884d7", "committedDate": "2020-07-01T18:12:41Z", "type": "commit"}, {"oid": "fdfd432942abe194e7a985cbf141271916649bdd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fdfd432942abe194e7a985cbf141271916649bdd", "message": "Update to next snapshot version: 2.13.50-SNAPSHOT", "committedDate": "2020-07-01T18:36:44Z", "type": "commit"}, {"oid": "43513308e653458b4a8d423a74e6839bd51339f0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/43513308e653458b4a8d423a74e6839bd51339f0", "message": "Add Preview annotations for metrics related classes/methods", "committedDate": "2020-07-01T22:03:01Z", "type": "commit"}, {"oid": "b9c37a9f1048cd6c0c7e5b8b9543cadd15dc5623", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b9c37a9f1048cd6c0c7e5b8b9543cadd15dc5623", "message": "Amazon Connect Service Update: Documentation updates for Amazon Connect.", "committedDate": "2020-07-02T18:05:15Z", "type": "commit"}, {"oid": "ccb610840704434d1b3014e743e715973852b17f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/ccb610840704434d1b3014e743e715973852b17f", "message": "Amazon ElastiCache Update: Documentation updates for elasticache", "committedDate": "2020-07-02T18:05:30Z", "type": "commit"}, {"oid": "3f8fe426aba0bbc977e1115ca1d4728343a25045", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3f8fe426aba0bbc977e1115ca1d4728343a25045", "message": "Updated endpoints.json.", "committedDate": "2020-07-02T18:06:27Z", "type": "commit"}, {"oid": "194a13a5f8120c5401b8d830a32d72976cb525a9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/194a13a5f8120c5401b8d830a32d72976cb525a9", "message": "Release 2.13.50. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-02T18:07:04Z", "type": "commit"}, {"oid": "3ef04655d2cc9479df8684cd9a7c4d4b3a2c0b98", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3ef04655d2cc9479df8684cd9a7c4d4b3a2c0b98", "message": "Merge pull request #894 from aws/staging/ea42435b-a8e3-4e91-9069-f3a2b43f1aff\n\nPull request: release <- staging/ea42435b-a8e3-4e91-9069-f3a2b43f1aff", "committedDate": "2020-07-02T18:07:17Z", "type": "commit"}, {"oid": "8a088f506b754c6e45fbde738a7b379e4873c0fa", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8a088f506b754c6e45fbde738a7b379e4873c0fa", "message": "Update to next snapshot version: 2.13.51-SNAPSHOT", "committedDate": "2020-07-02T18:31:46Z", "type": "commit"}, {"oid": "d3e149e1bcf44f7de999e525d8a49fb3fb8dac9d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d3e149e1bcf44f7de999e525d8a49fb3fb8dac9d", "message": "Update CW Publisher to PREVIEW", "committedDate": "2020-07-02T20:40:05Z", "type": "commit"}, {"oid": "9307eefb9d319feaca989da54a4a560cd4a9a9f1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9307eefb9d319feaca989da54a4a560cd4a9a9f1", "message": "Merge remote-tracking branch 'origin/master' into sdk-metrics-preview", "committedDate": "2020-07-02T21:33:30Z", "type": "commit"}, {"oid": "bac7d6f06bac3f985ded5a0c507143d8a84f4bd0", "url": "https://github.com/aws/aws-sdk-java-v2/commit/bac7d6f06bac3f985ded5a0c507143d8a84f4bd0", "message": "Update metrics module versions", "committedDate": "2020-07-02T21:33:52Z", "type": "commit"}, {"oid": "aabda4de01e88b0f30d019ee7a5f412e4fd29bb3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/aabda4de01e88b0f30d019ee7a5f412e4fd29bb3", "message": "AWS IoT SiteWise Update: This release supports optional start date and end date parameters for the GetAssetPropertyValueHistory API.", "committedDate": "2020-07-06T18:05:12Z", "type": "commit"}, {"oid": "d9408e0c76cda9c67212237794b5ad038fdf446f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d9408e0c76cda9c67212237794b5ad038fdf446f", "message": "Amazon QuickSight Update: Add Theme APIs and update Dashboard APIs to support theme overrides.", "committedDate": "2020-07-06T18:05:19Z", "type": "commit"}, {"oid": "08f89a9a42709cd173d2b3f28ce18aa4d7aa31aa", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08f89a9a42709cd173d2b3f28ce18aa4d7aa31aa", "message": "Amazon Relational Database Service Update: Adds support for Amazon RDS on AWS Outposts.", "committedDate": "2020-07-06T18:05:24Z", "type": "commit"}, {"oid": "fedf10491b83bd6e1cdc1a23cf8d178161091ea3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fedf10491b83bd6e1cdc1a23cf8d178161091ea3", "message": "Release 2.13.51. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-07-06T18:06:49Z", "type": "commit"}, {"oid": "45d0c53d9951ebdcc8bd3b50efc0f953e3c64d2b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/45d0c53d9951ebdcc8bd3b50efc0f953e3c64d2b", "message": "Merge pull request #895 from aws/staging/1092758c-ca98-4f71-868e-b0bf0b3a544e\n\nPull request: release <- staging/1092758c-ca98-4f71-868e-b0bf0b3a544e", "committedDate": "2020-07-06T18:07:05Z", "type": "commit"}, {"oid": "1f327f6e26e351a128691164762b59a031139324", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1f327f6e26e351a128691164762b59a031139324", "message": "Update to next snapshot version: 2.13.52-SNAPSHOT", "committedDate": "2020-07-06T18:31:17Z", "type": "commit"}, {"oid": "47da2eec26151650b968335e200f5896328035ce", "url": "https://github.com/aws/aws-sdk-java-v2/commit/47da2eec26151650b968335e200f5896328035ce", "message": "Merge remote-tracking branch 'origin/master' into sdk-metrics-preview", "committedDate": "2020-07-06T21:13:13Z", "type": "commit"}, {"oid": "9faee7d440bf49c1dff8a3f0872a70e0eb47b672", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9faee7d440bf49c1dff8a3f0872a70e0eb47b672", "message": "Update versions to match latest SNAPSHOT in master", "committedDate": "2020-07-06T22:19:57Z", "type": "commit"}, {"oid": "843adfc95201f0baa3a4524cb0793acb9fdcff1d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/843adfc95201f0baa3a4524cb0793acb9fdcff1d", "message": "Add announcement blog post", "committedDate": "2020-07-06T22:54:25Z", "type": "commit"}, {"oid": "0c9d384b2900180c6424c91739c78a06261f9a9b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0c9d384b2900180c6424c91739c78a06261f9a9b", "message": "Merge pull request #1938 from aws/sdk-metrics-preview\n\nSdk metrics preview", "committedDate": "2020-07-07T00:04:29Z", "type": "commit"}, {"oid": "49e5ca9c034beb003ac9a167f4185401334f309d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/49e5ca9c034beb003ac9a167f4185401334f309d", "message": "Amazon Elastic File System Update: This release adds support for automatic backups of Amazon EFS file systems to further simplify backup management.", "committedDate": "2020-07-07T18:24:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODk2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411738968", "bodyText": "nit, we have Content-Length in https://github.com/aws/aws-sdk-java-v2/blob/master/http-client-spi/src/main/java/software/amazon/awssdk/http/Header.java\nCan we add all the common headers to Header class?", "author": "zoewangg", "createdAt": "2020-04-20T22:39:26Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MDY0Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411740643", "bodyText": "This can be confused with h2 intialWindowSize.", "author": "zoewangg", "createdAt": "2020-04-20T22:43:17Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyNTkwOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417625908", "bodyText": "I'm updating the comment here to better reflect this setting, which actually corresponds to what's described for h1, but will correspond to h2 initialWindowSize for h2 connections.  It's not clear what changes will need to be made to fold h2 into the crt client, so for now I'd prefer to leave this be and readdress it (two params? one param with additional per-version comments?) as h2 gets brought in.", "author": "bretambrose", "createdAt": "2020-04-29T21:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MDY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0OTQxMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411749410", "bodyText": "Can we break up this block a bit?\nMaybe extracting line 108 - line 128 to resolveProxyOptions?", "author": "zoewangg", "createdAt": "2020-04-20T23:04:04Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjE4MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411752181", "bodyText": "errorCode -> statusCode?", "author": "zoewangg", "createdAt": "2020-04-20T23:11:06Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzMwOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417633309", "bodyText": "In this case it's not a status code, it's an internal error integer from C-land.", "author": "bretambrose", "createdAt": "2020-04-29T21:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411752687", "bodyText": "Should we do a try-catch here in case exceptions are thrown from the error response handler?", "author": "zoewangg", "createdAt": "2020-04-20T23:12:30Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n+            log.debug(() -> \"Response Completed Successfully\");\n+            respBodyPublisher.setQueueComplete();\n+            respBodyPublisher.publishToSubscribers();\n+        } else {\n+            HttpException error = new HttpException(errorCode);\n+            log.error(() -> \"Response Encountered an Error.\", error);\n+\n+            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n+            sdkRequest.responseHandler().onError(error);\n+\n+            // Invoke Error Callback on any Subscriber's of the Response Body\n+            respBodyPublisher.setError(error);\n+            respBodyPublisher.publishToSubscribers();", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNDUwNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417634504", "bodyText": "Makes sense but I'm not sure what scope it should cover and if it should do anything in the catch?", "author": "bretambrose", "createdAt": "2020-04-29T21:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MTIxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418261218", "bodyText": "In Netty client, we always log the error and complete the future exceptionally for such case. https://github.com/aws/aws-sdk-java-v2/blob/master/http-clients/netty-nio-client/src/main/java/software/amazon/awssdk/http/nio/netty/internal/ResponseHandler.java#L302-L307", "author": "zoewangg", "createdAt": "2020-04-30T20:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2NjcxNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411766715", "bodyText": "How about registerOwnedResource?", "author": "zoewangg", "createdAt": "2020-04-20T23:44:39Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2NzYyOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411767629", "bodyText": "Don't think this is necessary as uri is already validated on line 195", "author": "zoewangg", "createdAt": "2020-04-20T23:46:57Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3OTUyNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411779524", "bodyText": "This is confusing to me. From reading the code of HttpClientConnectionManager#close, it seems what close really does is to decrement the reference instead of closing the pool. Can we add a comment above to clarify that? because when I first read this, I thought it would close the connection pool for every request.", "author": "zoewangg", "createdAt": "2020-04-21T00:20:23Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412375005", "bodyText": "Are there any plans to expose http configs supported in other http clients such as connectionMaxIdleTime or connectionTimeout?", "author": "zoewangg", "createdAt": "2020-04-21T18:02:20Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n+    }\n+\n+    /**\n+     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n+     * configure and construct an immutable instance of the factory.\n+     */\n+    private static final class DefaultBuilder implements Builder {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODcyMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417638723", "bodyText": "Yes, but I don't think we're ready yet.  Our http connection monitoring is a bit different than existing timeouts.", "author": "bretambrose", "createdAt": "2020-04-29T22:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzM2OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377369", "bodyText": "Monitoring configuration has been merged in.", "author": "bretambrose", "createdAt": "2020-06-07T16:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3Njg0Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412376846", "bodyText": "Seems like configuring maxConnection is supported; should we expose maxConnection here?", "author": "zoewangg", "createdAt": "2020-04-21T18:05:03Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NDkyMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412384923", "bodyText": "Should we try-catch here in case onError throws the exception, resulting in an uncompletable future?\nWe can have something similar to https://github.com/aws/aws-sdk-java-v2/blob/master/http-clients/netty-nio-client/src/main/java/software/amazon/awssdk/http/nio/netty/internal/ResponseHandler.java#L177", "author": "zoewangg", "createdAt": "2020-04-21T18:16:42Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxOTE3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412419170", "bodyText": "nit:\nHow about the following?\n            connectionPools.values().forEach(pool -> IoUtils.closeQuietly(pool, log.logger()));\n            ownedSubResources.forEach(r -> IoUtils.closeQuietly(r, log.logger()));", "author": "zoewangg", "createdAt": "2020-04-21T19:08:19Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NTIzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412485233", "bodyText": "nit: Validate.notNull actually returns the value, so we can do:\nthis.connection = Validate.notNull(connection, \"HttpConnection must not be null\");", "author": "zoewangg", "createdAt": "2020-04-21T20:56:03Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\ndeleted file mode 100644\nindex 559936da81..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\n+++ /dev/null\n\n@@ -1,298 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.Optional;\n-import java.util.Queue;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.LongUnaryOperator;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n- */\n-@SdkInternalApi\n-public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n-    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n-    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n-\n-    private final HttpClientConnection connection;\n-    private final HttpStream stream;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AtomicLong outstandingRequests = new AtomicLong(0);\n-    private final int windowSize;\n-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n-    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n-    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n-    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n-    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n-    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n-    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n-    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n-    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n-\n-    /**\n-     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n-     * @param stream The AWS CRT Http Stream for this Response\n-     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n-     *                   never exceed this value.\n-     */\n-    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n-                                       CompletableFuture<Void> responseComplete, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection must not be null\");\n-        Validate.notNull(stream, \"Stream must not be null\");\n-        Validate.notNull(responseComplete, \"Stream must not be null\");\n-        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n-        this.connection = connection;\n-        this.stream = stream;\n-        this.responseComplete = responseComplete;\n-        this.windowSize = windowSize;\n-    }\n-\n-    /**\n-     * Method for the users consuming the Http Response Body to register a subscriber.\n-     * @param subscriber The Subscriber to register.\n-     */\n-    @Override\n-    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n-        Validate.notNull(subscriber, \"Subscriber must not be null\");\n-\n-        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n-\n-        if (!wasFirstSubscriber) {\n-            log.error(() -> \"Only one subscriber allowed\");\n-\n-            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-\n-                @Override\n-                public void cancel() {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-            });\n-            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n-        } else {\n-            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));\n-        }\n-    }\n-\n-    /**\n-     * Adds a Buffer to the Queue to be published to any Subscribers\n-     * @param buffer The Buffer to be queued.\n-     */\n-    public void queueBuffer(byte[] buffer) {\n-        Validate.notNull(buffer, \"ByteBuffer must not be null\");\n-\n-        if (isCancelled.get()) {\n-            // Immediately open HttpStream's IO window so it doesn't see any IO Back-pressure.\n-            // AFAIK there's no way to abort an in-progress HttpStream, only free it's memory by calling close()\n-            stream.incrementWindow(buffer.length);\n-            return;\n-        }\n-\n-        queuedBuffers.add(buffer);\n-        int totalBytesQueued = queuedBytes.addAndGet(buffer.length);\n-\n-        if (totalBytesQueued > windowSize) {\n-            throw new IllegalStateException(\"Queued more than Window Size: queued=\" + totalBytesQueued\n-                                            + \", window=\" + windowSize);\n-        }\n-    }\n-\n-    /**\n-     * Function called by Response Body Subscribers to request more Response Body buffers.\n-     * @param n The number of buffers requested.\n-     */\n-    protected void request(long n) {\n-        Validate.inclusiveBetween(1, Long.MAX_VALUE, n, \"request\");\n-\n-        // Check for overflow of outstanding Requests, and clamp to LONG_MAX.\n-        long outstandingReqs;\n-        if (n > (Long.MAX_VALUE - outstandingRequests.get())) {\n-            outstandingRequests.set(Long.MAX_VALUE);\n-            outstandingReqs = Long.MAX_VALUE;\n-        } else {\n-            outstandingReqs = outstandingRequests.addAndGet(n);\n-        }\n-\n-        /*\n-         * Since we buffer, in the case where the subscriber came in after the publication has already begun,\n-         * go ahead and flush what we have.\n-         */\n-        publishToSubscribers();\n-\n-        log.trace(() -> \"Subscriber Requested more Buffers. Outstanding Requests: \" + outstandingReqs);\n-    }\n-\n-    public void setError(Throwable t) {\n-        log.error(() -> \"Error processing Response Body\", t);\n-        error.compareAndSet(null, t);\n-    }\n-\n-    protected void setCancelled() {\n-        isCancelled.set(true);\n-        /**\n-         * subscriberRef must set to null due to ReactiveStream Spec stating references to Subscribers must be deleted\n-         * when onCancel() is called.\n-         */\n-        subscriberRef.set(null);\n-    }\n-\n-    private synchronized void releaseNativeResources() {\n-        boolean alreadyReleased = areNativeResourcesReleased.getAndSet(true);\n-\n-        if (!alreadyReleased) {\n-            stream.close();\n-            connection.close();\n-        }\n-    }\n-\n-    /**\n-     * Called when the final Buffer has been queued and no more data is expected.\n-     */\n-    public void setQueueComplete() {\n-        log.trace(() -> \"Response Body Publisher queue marked as completed.\");\n-        queueComplete.set(true);\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-    }\n-\n-    /**\n-     * Completes the Subscription by calling either the .onError() or .onComplete() callbacks exactly once.\n-     */\n-    protected void completeSubscriptionExactlyOnce() {\n-        boolean alreadyComplete = isSubscriptionComplete.getAndSet(true);\n-\n-        if (alreadyComplete) {\n-            return;\n-        }\n-\n-        // Subscriber may have cancelled their subscription, in which case this may be null.\n-        Optional<Subscriber<? super ByteBuffer>> subscriber = Optional.ofNullable(subscriberRef.getAndSet(null));\n-\n-        Throwable throwable = error.get();\n-\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-\n-        // Complete the Futures\n-        if (throwable != null) {\n-            log.error(() -> \"Error before ResponseBodyPublisher could complete: \" + throwable.getMessage());\n-            subscriber.ifPresent(s -> s.onError(throwable));\n-            responseComplete.completeExceptionally(throwable);\n-        } else {\n-            log.debug(() -> \"ResponseBodyPublisher Completed Successfully\");\n-            subscriber.ifPresent(s -> s.onComplete());\n-            responseComplete.complete(null);\n-        }\n-    }\n-\n-    /**\n-     * Publishes any queued data to any Subscribers if there is data queued and there is an outstanding Subscriber\n-     * request for more data. Will also call onError() or onComplete() callbacks if needed.\n-     *\n-     * This method MUST be synchronized since it can be called simultaneously from both the Native EventLoop Thread and\n-     * the User Thread. If this method wasn't synchronized, it'd be possible for each thread to dequeue a buffer by\n-     * calling queuedBuffers.poll(), but then have the 2nd thread call subscriber.onNext(buffer) first, resulting in the\n-     * subscriber seeing out-of-order data. To avoid this race condition, this method must be synchronized.\n-     */\n-    protected synchronized void publishToSubscribers() {\n-        if (error.get() != null) {\n-            completeSubscriptionExactlyOnce();\n-            return;\n-        }\n-\n-        if (isSubscriptionComplete.get() || isCancelled.get()) {\n-            log.warn(() -> \"Subscription already completed or cancelled, can't publish updates to Subscribers.\");\n-            return;\n-        }\n-\n-        if (mutualRecursionDepth.get() > 0) {\n-            /**\n-             * If our depth is > 0, then we already made a call to publishToSubscribers() further up the stack that\n-             * will continue publishing to subscribers, and this call should return without completing work to avoid\n-             * infinite recursive loop between: \"subscription.request() -> subscriber.onNext() -> subscription.request()\"\n-             */\n-            return;\n-        }\n-\n-        int totalAmountTransferred = 0;\n-\n-        while (outstandingRequests.get() > 0 && !queuedBuffers.isEmpty()) {\n-            byte[] buffer = queuedBuffers.poll();\n-            outstandingRequests.getAndUpdate(DECREMENT_IF_GREATER_THAN_ZERO);\n-            int amount = buffer.length;\n-            publishWithoutMutualRecursion(subscriberRef.get(), ByteBuffer.wrap(buffer));\n-            totalAmountTransferred += amount;\n-        }\n-\n-        if (totalAmountTransferred > 0) {\n-            queuedBytes.addAndGet(-totalAmountTransferred);\n-\n-            // We may have released the Native HttpConnection and HttpStream if they completed before the Subscriber\n-            // has finished reading the data.\n-            if (!areNativeResourcesReleased.get()) {\n-                // Open HttpStream's IO window so HttpStream can keep track of IO back-pressure\n-                stream.incrementWindow(totalAmountTransferred);\n-            }\n-        }\n-\n-        // Check if Complete, consider no subscriber as a completion.\n-        if (queueComplete.get() && queuedBuffers.isEmpty()) {\n-            completeSubscriptionExactlyOnce();\n-        }\n-    }\n-\n-    /**\n-     * This method is used to avoid a StackOverflow due to the potential infinite loop between\n-     * \"subscription.request() -> subscriber.onNext() -> subscription.request()\" calls. We only call subscriber.onNext()\n-     * if the recursion depth is zero, otherwise we return up to the stack frame with depth zero and continue publishing\n-     * from there.\n-     * @param subscriber The Subscriber to publish to.\n-     * @param buffer The buffer to publish to the subscriber.\n-     */\n-    private synchronized void publishWithoutMutualRecursion(Subscriber<? super ByteBuffer> subscriber, ByteBuffer buffer) {\n-        try {\n-            /**\n-             * Need to keep track of recursion depth between .onNext() -> .request() calls\n-             */\n-            int depth = mutualRecursionDepth.getAndIncrement();\n-            if (depth == 0) {\n-                subscriber.onNext(buffer);\n-            }\n-        } finally {\n-            mutualRecursionDepth.decrementAndGet();\n-        }\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412531528", "bodyText": "Seems like AwsCrtResponseBodySubscription and AwsCrtResponseBodyPublisher have circular dependency. Can we move the publisher methods that subscription class invokes to the subscription class?", "author": "zoewangg", "createdAt": "2020-04-21T22:21:07Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;\n+    }\n+\n+    /**\n+     * Method for the users consuming the Http Response Body to register a subscriber.\n+     * @param subscriber The Subscriber to register.\n+     */\n+    @Override\n+    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+        Validate.notNull(subscriber, \"Subscriber must not be null\");\n+\n+        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n+\n+        if (!wasFirstSubscriber) {\n+            log.error(() -> \"Only one subscriber allowed\");\n+\n+            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n+            subscriber.onSubscribe(new Subscription() {\n+                @Override\n+                public void request(long n) {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+            });\n+            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n+        } else {\n+            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyMTcxMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420321710", "bodyText": "I don't quite follow the change here.  moving request() and publishToSubscribers() and their downstreams would be a really big refactor.  What about folding the logic of Subscription's request() into a single method on the publisher (rather than call 4 methods on the publisher)?", "author": "bretambrose", "createdAt": "2020-05-05T18:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MzAxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420383011", "bodyText": "Yeah, ideally I'd expect most of the logic to be in Subscription class rather than Publisher class. How about making AwsCrtResponseBodySubscription an internal class of AwsCrtResponseBodyPublisher? Seems cleaner that way to me.", "author": "zoewangg", "createdAt": "2020-05-05T20:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\ndeleted file mode 100644\nindex 559936da81..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\n+++ /dev/null\n\n@@ -1,298 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.Optional;\n-import java.util.Queue;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.LongUnaryOperator;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n- */\n-@SdkInternalApi\n-public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n-    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n-    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n-\n-    private final HttpClientConnection connection;\n-    private final HttpStream stream;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AtomicLong outstandingRequests = new AtomicLong(0);\n-    private final int windowSize;\n-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n-    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n-    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n-    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n-    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n-    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n-    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n-    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n-    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n-\n-    /**\n-     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n-     * @param stream The AWS CRT Http Stream for this Response\n-     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n-     *                   never exceed this value.\n-     */\n-    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n-                                       CompletableFuture<Void> responseComplete, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection must not be null\");\n-        Validate.notNull(stream, \"Stream must not be null\");\n-        Validate.notNull(responseComplete, \"Stream must not be null\");\n-        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n-        this.connection = connection;\n-        this.stream = stream;\n-        this.responseComplete = responseComplete;\n-        this.windowSize = windowSize;\n-    }\n-\n-    /**\n-     * Method for the users consuming the Http Response Body to register a subscriber.\n-     * @param subscriber The Subscriber to register.\n-     */\n-    @Override\n-    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n-        Validate.notNull(subscriber, \"Subscriber must not be null\");\n-\n-        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n-\n-        if (!wasFirstSubscriber) {\n-            log.error(() -> \"Only one subscriber allowed\");\n-\n-            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-\n-                @Override\n-                public void cancel() {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-            });\n-            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n-        } else {\n-            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));\n-        }\n-    }\n-\n-    /**\n-     * Adds a Buffer to the Queue to be published to any Subscribers\n-     * @param buffer The Buffer to be queued.\n-     */\n-    public void queueBuffer(byte[] buffer) {\n-        Validate.notNull(buffer, \"ByteBuffer must not be null\");\n-\n-        if (isCancelled.get()) {\n-            // Immediately open HttpStream's IO window so it doesn't see any IO Back-pressure.\n-            // AFAIK there's no way to abort an in-progress HttpStream, only free it's memory by calling close()\n-            stream.incrementWindow(buffer.length);\n-            return;\n-        }\n-\n-        queuedBuffers.add(buffer);\n-        int totalBytesQueued = queuedBytes.addAndGet(buffer.length);\n-\n-        if (totalBytesQueued > windowSize) {\n-            throw new IllegalStateException(\"Queued more than Window Size: queued=\" + totalBytesQueued\n-                                            + \", window=\" + windowSize);\n-        }\n-    }\n-\n-    /**\n-     * Function called by Response Body Subscribers to request more Response Body buffers.\n-     * @param n The number of buffers requested.\n-     */\n-    protected void request(long n) {\n-        Validate.inclusiveBetween(1, Long.MAX_VALUE, n, \"request\");\n-\n-        // Check for overflow of outstanding Requests, and clamp to LONG_MAX.\n-        long outstandingReqs;\n-        if (n > (Long.MAX_VALUE - outstandingRequests.get())) {\n-            outstandingRequests.set(Long.MAX_VALUE);\n-            outstandingReqs = Long.MAX_VALUE;\n-        } else {\n-            outstandingReqs = outstandingRequests.addAndGet(n);\n-        }\n-\n-        /*\n-         * Since we buffer, in the case where the subscriber came in after the publication has already begun,\n-         * go ahead and flush what we have.\n-         */\n-        publishToSubscribers();\n-\n-        log.trace(() -> \"Subscriber Requested more Buffers. Outstanding Requests: \" + outstandingReqs);\n-    }\n-\n-    public void setError(Throwable t) {\n-        log.error(() -> \"Error processing Response Body\", t);\n-        error.compareAndSet(null, t);\n-    }\n-\n-    protected void setCancelled() {\n-        isCancelled.set(true);\n-        /**\n-         * subscriberRef must set to null due to ReactiveStream Spec stating references to Subscribers must be deleted\n-         * when onCancel() is called.\n-         */\n-        subscriberRef.set(null);\n-    }\n-\n-    private synchronized void releaseNativeResources() {\n-        boolean alreadyReleased = areNativeResourcesReleased.getAndSet(true);\n-\n-        if (!alreadyReleased) {\n-            stream.close();\n-            connection.close();\n-        }\n-    }\n-\n-    /**\n-     * Called when the final Buffer has been queued and no more data is expected.\n-     */\n-    public void setQueueComplete() {\n-        log.trace(() -> \"Response Body Publisher queue marked as completed.\");\n-        queueComplete.set(true);\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-    }\n-\n-    /**\n-     * Completes the Subscription by calling either the .onError() or .onComplete() callbacks exactly once.\n-     */\n-    protected void completeSubscriptionExactlyOnce() {\n-        boolean alreadyComplete = isSubscriptionComplete.getAndSet(true);\n-\n-        if (alreadyComplete) {\n-            return;\n-        }\n-\n-        // Subscriber may have cancelled their subscription, in which case this may be null.\n-        Optional<Subscriber<? super ByteBuffer>> subscriber = Optional.ofNullable(subscriberRef.getAndSet(null));\n-\n-        Throwable throwable = error.get();\n-\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-\n-        // Complete the Futures\n-        if (throwable != null) {\n-            log.error(() -> \"Error before ResponseBodyPublisher could complete: \" + throwable.getMessage());\n-            subscriber.ifPresent(s -> s.onError(throwable));\n-            responseComplete.completeExceptionally(throwable);\n-        } else {\n-            log.debug(() -> \"ResponseBodyPublisher Completed Successfully\");\n-            subscriber.ifPresent(s -> s.onComplete());\n-            responseComplete.complete(null);\n-        }\n-    }\n-\n-    /**\n-     * Publishes any queued data to any Subscribers if there is data queued and there is an outstanding Subscriber\n-     * request for more data. Will also call onError() or onComplete() callbacks if needed.\n-     *\n-     * This method MUST be synchronized since it can be called simultaneously from both the Native EventLoop Thread and\n-     * the User Thread. If this method wasn't synchronized, it'd be possible for each thread to dequeue a buffer by\n-     * calling queuedBuffers.poll(), but then have the 2nd thread call subscriber.onNext(buffer) first, resulting in the\n-     * subscriber seeing out-of-order data. To avoid this race condition, this method must be synchronized.\n-     */\n-    protected synchronized void publishToSubscribers() {\n-        if (error.get() != null) {\n-            completeSubscriptionExactlyOnce();\n-            return;\n-        }\n-\n-        if (isSubscriptionComplete.get() || isCancelled.get()) {\n-            log.warn(() -> \"Subscription already completed or cancelled, can't publish updates to Subscribers.\");\n-            return;\n-        }\n-\n-        if (mutualRecursionDepth.get() > 0) {\n-            /**\n-             * If our depth is > 0, then we already made a call to publishToSubscribers() further up the stack that\n-             * will continue publishing to subscribers, and this call should return without completing work to avoid\n-             * infinite recursive loop between: \"subscription.request() -> subscriber.onNext() -> subscription.request()\"\n-             */\n-            return;\n-        }\n-\n-        int totalAmountTransferred = 0;\n-\n-        while (outstandingRequests.get() > 0 && !queuedBuffers.isEmpty()) {\n-            byte[] buffer = queuedBuffers.poll();\n-            outstandingRequests.getAndUpdate(DECREMENT_IF_GREATER_THAN_ZERO);\n-            int amount = buffer.length;\n-            publishWithoutMutualRecursion(subscriberRef.get(), ByteBuffer.wrap(buffer));\n-            totalAmountTransferred += amount;\n-        }\n-\n-        if (totalAmountTransferred > 0) {\n-            queuedBytes.addAndGet(-totalAmountTransferred);\n-\n-            // We may have released the Native HttpConnection and HttpStream if they completed before the Subscriber\n-            // has finished reading the data.\n-            if (!areNativeResourcesReleased.get()) {\n-                // Open HttpStream's IO window so HttpStream can keep track of IO back-pressure\n-                stream.incrementWindow(totalAmountTransferred);\n-            }\n-        }\n-\n-        // Check if Complete, consider no subscriber as a completion.\n-        if (queueComplete.get() && queuedBuffers.isEmpty()) {\n-            completeSubscriptionExactlyOnce();\n-        }\n-    }\n-\n-    /**\n-     * This method is used to avoid a StackOverflow due to the potential infinite loop between\n-     * \"subscription.request() -> subscriber.onNext() -> subscription.request()\" calls. We only call subscriber.onNext()\n-     * if the recursion depth is zero, otherwise we return up to the stack frame with depth zero and continue publishing\n-     * from there.\n-     * @param subscriber The Subscriber to publish to.\n-     * @param buffer The buffer to publish to the subscriber.\n-     */\n-    private synchronized void publishWithoutMutualRecursion(Subscriber<? super ByteBuffer> subscriber, ByteBuffer buffer) {\n-        try {\n-            /**\n-             * Need to keep track of recursion depth between .onNext() -> .request() calls\n-             */\n-            int depth = mutualRecursionDepth.getAndIncrement();\n-            if (depth == 0) {\n-                subscriber.onNext(buffer);\n-            }\n-        } finally {\n-            mutualRecursionDepth.decrementAndGet();\n-        }\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzMyMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412537320", "bodyText": "Is this necessary since we already set the statusCode on line 74?", "author": "zoewangg", "createdAt": "2020-04-21T22:33:59Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzcxNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412537717", "bodyText": "Just curious, why do we need to invoke initRespBodyPublisherIfNeeded in every method?", "author": "zoewangg", "createdAt": "2020-04-21T22:35:00Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1MDk1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418150957", "bodyText": "No clue!  We might be able to remove some (onResponseHeaders at least), but am not sure beyond that.  I can ping Alex on this.", "author": "bretambrose", "createdAt": "2020-04-30T16:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412539941", "bodyText": "Is return 0 intentional?  The javadoc of onResponseBody states that Repeatedly returning zero will eventually cause the sliding window to fill up and data to stop flowing until the user slides the window back open", "author": "zoewangg", "createdAt": "2020-04-21T22:40:00Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNjg0NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420316845", "bodyText": "I have a query out to Alex about this.", "author": "bretambrose", "createdAt": "2020-05-05T18:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNDg5Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421734893", "bodyText": "Edit: 0 is intentional.  I've added comments at this point and the point where we do the window update manually.", "author": "bretambrose", "createdAt": "2020-05-07T19:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NDM1NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412544354", "bodyText": "nit: this.connection = Validate.notNull(connection, \"HttpConnection is null\");", "author": "zoewangg", "createdAt": "2020-04-21T22:49:38Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NjIwMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412546200", "bodyText": "Seems like this is unnecessary because respBodyPublisher should be initialized if it's null on line 92.", "author": "zoewangg", "createdAt": "2020-04-21T22:53:56Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412548499", "bodyText": "What happens if the status code is 5xx level? Would the underlying crt client close the connection after the response is complete? If not, should we mark it \"close to new request\" so that the next retry attempt would establish a new connection?", "author": "zoewangg", "createdAt": "2020-04-21T22:59:16Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzYxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412573611", "bodyText": "Another question, sometimes services will put connection:close in the response header to indicate the connection is to be closed on the service side, would the underlying crt client close such connections after they are released to the pool?", "author": "zoewangg", "createdAt": "2020-04-22T00:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY1MzkwMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418653901", "bodyText": "The connection will get closed before returning to the pool and the pool will check status and toss it, so it won't be vended again to the next requester", "author": "bretambrose", "createdAt": "2020-05-01T17:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyMjQzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420322433", "bodyText": "I'm going to go ahead and add a closed check on acquire as well, but it may arrive after the fact.", "author": "bretambrose", "createdAt": "2020-05-05T18:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4ODIxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420388211", "bodyText": "Update: this wasn't necessary; the instant a connection enters the closed state, if it's in the pool, it gets removed.", "author": "bretambrose", "createdAt": "2020-05-05T20:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5MjAxMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420392013", "bodyText": "To the original question, the crt does not make any interpretations on status code.  Behavioral changes would need to be driven by the SDK.  If we need to make this kind of a change, it will require a little more work, since we don't directly a close on the connection.", "author": "bretambrose", "createdAt": "2020-05-05T20:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjQ2NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420402465", "bodyText": "I see. For sync http clients, the SDK core module has access to the underlying connection, so it is able to close connections that generated a 5xx error. For async http clients, since core module doesn't have access to the connection, individual client would need to close such connections afterwards. This is how we implemented in netty for reference #1768", "author": "zoewangg", "createdAt": "2020-05-05T20:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzQxNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377416", "bodyText": "Updated, with test", "author": "bretambrose", "createdAt": "2020-06-07T16:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzE1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412553157", "bodyText": "It'd be nice to have a consumer builder overload here as well.\nBuilder proxyConfiguration(Consumer<ProxyConfiguration.Builder> proxyConfiguration);", "author": "zoewangg", "createdAt": "2020-04-21T23:10:38Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MDE1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412560157", "bodyText": "How does it handle requests with Expect: 100-continue header?", "author": "zoewangg", "createdAt": "2020-04-21T23:27:16Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY1NTE0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418655144", "bodyText": "Those come in as a different block type (informational) which actually was causing an issue in the initial draft of the s3 stability tests, but it was straightforward to fix.", "author": "bretambrose", "createdAt": "2020-05-01T17:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MDE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\ndeleted file mode 100644\nindex 730a85413a..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java\n+++ /dev/null\n\n@@ -1,130 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.CRT;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpException;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n-import software.amazon.awssdk.http.SdkHttpResponse;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n- */\n-@SdkInternalApi\n-public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n-\n-    private final HttpClientConnection connection;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AsyncExecuteRequest sdkRequest;\n-    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n-    private final int windowSize;\n-    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n-    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n-\n-    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n-                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n-        Validate.notNull(connection, \"HttpConnection is null\");\n-        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n-        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n-        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n-\n-        this.connection = connection;\n-        this.responseComplete = responseComplete;\n-        this.sdkRequest = sdkRequest;\n-        this.windowSize = windowSize;\n-        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n-\n-        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n-    }\n-\n-    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n-        if (respBodyPublisher == null) {\n-            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(responseStatusCode);\n-\n-        for (HttpHeader h : nextHeaders) {\n-            respBuilder.appendHeader(h.getName(), h.getValue());\n-        }\n-    }\n-\n-    @Override\n-    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        respBuilder.statusCode(stream.getResponseStatusCode());\n-        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n-        sdkRequest.responseHandler().onStream(respBodyPublisher);\n-    }\n-\n-    @Override\n-    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (respBodyPublisher == null) {\n-            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n-            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n-        }\n-\n-        respBodyPublisher.queueBuffer(bodyBytesIn);\n-        respBodyPublisher.publishToSubscribers();\n-\n-        return 0;\n-    }\n-\n-    @Override\n-    public void onResponseComplete(HttpStream stream, int errorCode) {\n-        initRespBodyPublisherIfNeeded(stream);\n-\n-        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n-            log.debug(() -> \"Response Completed Successfully\");\n-            respBodyPublisher.setQueueComplete();\n-            respBodyPublisher.publishToSubscribers();\n-        } else {\n-            HttpException error = new HttpException(errorCode);\n-            log.error(() -> \"Response Encountered an Error.\", error);\n-\n-            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n-            sdkRequest.responseHandler().onError(error);\n-\n-            // Invoke Error Callback on any Subscriber's of the Response Body\n-            respBodyPublisher.setError(error);\n-            respBodyPublisher.publishToSubscribers();\n-        }\n-    }\n-\n-    @Override\n-    public boolean sendRequestBody(ByteBuffer bodyBytesOut) {\n-        return requestBodySubscriber.transferRequestBody(bodyBytesOut);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412564466", "bodyText": "Is there anyway to check if the connection is still active here? In our experience with netty, there could be a race condition where a connection gets closed on the service side at the same time it gets picked up for a new request, so we had to implement a health check mechanism when acquiring a new connection for netty client.", "author": "zoewangg", "createdAt": "2020-04-21T23:38:36Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2NTMxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418665318", "bodyText": "We check on release-to-pool but it does not appear that we check on acquire; I can look into that change, but the C connection manager is a delicate beast.", "author": "bretambrose", "createdAt": "2020-05-01T18:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5Njc1Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420396753", "bodyText": "As noted above, closed connections are removed from the pool as soon as the status is registered.", "author": "bretambrose", "createdAt": "2020-05-05T20:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDkwMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412564901", "bodyText": "What type of exception could it throw? If it's not a subtype of IOException, should we wrap it with IOException so that it can be retried?", "author": "zoewangg", "createdAt": "2020-04-21T23:39:40Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NDM0OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420944348", "bodyText": "Looking at the subclasses of IoException and the ways this could fail I think wrapping this in an IoException is reasonable.  The most common problems would be socket in nature.", "author": "bretambrose", "createdAt": "2020-05-06T16:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412566611", "bodyText": "Same comment, we might want to wrap the exception with IOException so that it can be retried by the SDK.", "author": "zoewangg", "createdAt": "2020-04-21T23:44:08Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "originalCommit": "92af360089fb70c7bc5d1d55dfe8661576b019f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1NDIzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420954230", "bodyText": "Would it make more sense to remove the invokeSafely and just add a try that wraps anything in IoException?", "author": "bretambrose", "createdAt": "2020-05-06T17:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjgzMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420962831", "bodyText": "Looking at the code of HttpClientConnection#makeRequest, it can throw IllegalStateException and CrtRunTimeException, are they both retryable?", "author": "zoewangg", "createdAt": "2020-05-06T17:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0NDQ0Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421644447", "bodyText": "Looks like all should be retryable; there are some unknowns on the IllegalState situation whether or not you might end up with the same connection, but that case should not be possible in this particular situation.", "author": "bretambrose", "createdAt": "2020-05-07T16:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTcyNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421649724", "bodyText": "Will the sdk dig inside a RuntimeException to find an IoException cause and consider that to be retryable?", "author": "bretambrose", "createdAt": "2020-05-07T16:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NzQ2MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421667460", "bodyText": "The SDK will only check one level down of the exception chain, so if it'll retry if the exception thrown is an instance of IOException or its direct cause is IOException.\n\n  \n    \n      aws-sdk-java-v2/core/sdk-core/src/main/java/software/amazon/awssdk/core/retry/conditions/RetryOnExceptionsCondition.java\n    \n    \n        Lines 56 to 62\n      in\n      16b866a\n    \n    \n    \n    \n\n        \n          \n           Predicate<Class<? extends Exception>> isRetryableException = \n        \n\n        \n          \n               ex -> ex.isAssignableFrom(exception.getClass()); \n        \n\n        \n          \n            \n        \n\n        \n          \n           Predicate<Class<? extends Exception>> hasRetrableCause = \n        \n\n        \n          \n               ex -> exception.getCause() != null && ex.isAssignableFrom(exception.getCause().getClass()); \n        \n\n        \n          \n            \n        \n\n        \n          \n           return exceptionsToRetryOn.stream().anyMatch(isRetryableException.or(hasRetrableCause));", "author": "zoewangg", "createdAt": "2020-05-07T17:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex f9ae7f6816..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,441 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-    private static final String HOST_HEADER = \"Host\";\n-    private static final String CONTENT_LENGTH = \"Content-Length\";\n-    private static final String CONNECTION = \"Connection\";\n-    private static final String KEEP_ALIVE = \"keep-alive\";\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = own(clientBootstrap);\n-            this.socketOptions = own(clientSocketOptions);\n-            this.tlsContext = own(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-\n-            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n-            if (builderProxyConfig != null) {\n-                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-                clientProxyOptions.setHost(builderProxyConfig.host());\n-                clientProxyOptions.setPort(builderProxyConfig.port());\n-                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n-                    clientProxyOptions.setTlsContext(tlsContext);\n-                }\n-\n-                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n-                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n-                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-                } else {\n-                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-                }\n-\n-                this.proxyOptions = clientProxyOptions;\n-            } else {\n-                this.proxyOptions = null;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T own(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n-            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            asyncRequest.responseHandler().onError(throwable);\n-                            requestFuture.completeExceptionally(throwable);\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n-                IoUtils.closeQuietly(connPool, log.logger());\n-            }\n-\n-            while (!ownedSubResources.isEmpty()) {\n-                CrtResource r = ownedSubResources.pop();\n-                IoUtils.closeQuietly(r, log.logger());\n-            }\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n-         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n-         * the Subscriber to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NDM1OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436054358", "bodyText": "Should we put a warning log here? same as line 218", "author": "zoewangg", "createdAt": "2020-06-05T17:14:31Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -204,11 +204,19 @@ protected void completeSubscriptionExactlyOnce() {\n         // Complete the Futures\n         if (throwable != null) {\n             log.error(() -> \"Error before ResponseBodyPublisher could complete: \" + throwable.getMessage());\n-            subscriber.ifPresent(s -> s.onError(throwable));\n+            try {\n+                subscriber.ifPresent(s -> s.onError(throwable));\n+            } catch (Exception e) {\n+                ;", "originalCommit": "5affa636c9ee0a219d88a7b158750ec64dab0617", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\ndeleted file mode 100644\nindex df7a82a6c4..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java\n+++ /dev/null\n\n@@ -1,333 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt.internal;\n-\n-import java.nio.ByteBuffer;\n-import java.util.Optional;\n-import java.util.Queue;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.LongUnaryOperator;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import software.amazon.awssdk.annotations.SdkInternalApi;\n-import software.amazon.awssdk.crt.http.HttpClientConnection;\n-import software.amazon.awssdk.crt.http.HttpStream;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-\n-/**\n- * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n- */\n-@SdkInternalApi\n-public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n-    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n-    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n-\n-    private final HttpClientConnection connection;\n-    private final HttpStream stream;\n-    private final CompletableFuture<Void> responseComplete;\n-    private final AtomicLong outstandingRequests = new AtomicLong(0);\n-    private final int windowSize;\n-    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n-    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n-    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n-    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n-    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n-    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n-    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n-    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n-    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n-\n-    /**\n-     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n-     * @param stream The AWS CRT Http Stream for this Response\n-     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n-     *                   never exceed this value.\n-     */\n-    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n-                                       CompletableFuture<Void> responseComplete, int windowSize) {\n-        this.connection = Validate.notNull(connection, \"HttpConnection must not be null\");\n-        this.stream = Validate.notNull(stream, \"Stream must not be null\");\n-        this.responseComplete = Validate.notNull(responseComplete, \"ResponseComplete future must not be null\");\n-        this.windowSize = Validate.isPositive(windowSize, \"windowSize must be > 0\");\n-    }\n-\n-    /**\n-     * Method for the users consuming the Http Response Body to register a subscriber.\n-     * @param subscriber The Subscriber to register.\n-     */\n-    @Override\n-    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n-        Validate.notNull(subscriber, \"Subscriber must not be null\");\n-\n-        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n-\n-        if (!wasFirstSubscriber) {\n-            log.error(() -> \"Only one subscriber allowed\");\n-\n-            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-\n-                @Override\n-                public void cancel() {\n-                    // This is a dummy implementation to allow the onError call\n-                }\n-            });\n-            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n-        } else {\n-            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));\n-        }\n-    }\n-\n-    /**\n-     * Adds a Buffer to the Queue to be published to any Subscribers\n-     * @param buffer The Buffer to be queued.\n-     */\n-    public void queueBuffer(byte[] buffer) {\n-        Validate.notNull(buffer, \"ByteBuffer must not be null\");\n-\n-        if (isCancelled.get()) {\n-            // Immediately open HttpStream's IO window so it doesn't see any IO Back-pressure.\n-            // AFAIK there's no way to abort an in-progress HttpStream, only free it's memory by calling close()\n-            stream.incrementWindow(buffer.length);\n-            return;\n-        }\n-\n-        queuedBuffers.add(buffer);\n-        int totalBytesQueued = queuedBytes.addAndGet(buffer.length);\n-\n-        if (totalBytesQueued > windowSize) {\n-            throw new IllegalStateException(\"Queued more than Window Size: queued=\" + totalBytesQueued\n-                                            + \", window=\" + windowSize);\n-        }\n-    }\n-\n-    /**\n-     * Function called by Response Body Subscribers to request more Response Body buffers.\n-     * @param n The number of buffers requested.\n-     */\n-    protected void request(long n) {\n-        Validate.inclusiveBetween(1, Long.MAX_VALUE, n, \"request\");\n-\n-        // Check for overflow of outstanding Requests, and clamp to LONG_MAX.\n-        long outstandingReqs;\n-        if (n > (Long.MAX_VALUE - outstandingRequests.get())) {\n-            outstandingRequests.set(Long.MAX_VALUE);\n-            outstandingReqs = Long.MAX_VALUE;\n-        } else {\n-            outstandingReqs = outstandingRequests.addAndGet(n);\n-        }\n-\n-        /*\n-         * Since we buffer, in the case where the subscriber came in after the publication has already begun,\n-         * go ahead and flush what we have.\n-         */\n-        publishToSubscribers();\n-\n-        log.trace(() -> \"Subscriber Requested more Buffers. Outstanding Requests: \" + outstandingReqs);\n-    }\n-\n-    public void setError(Throwable t) {\n-        log.error(() -> \"Error processing Response Body\", t);\n-        error.compareAndSet(null, t);\n-    }\n-\n-    protected void setCancelled() {\n-        isCancelled.set(true);\n-        /**\n-         * subscriberRef must set to null due to ReactiveStream Spec stating references to Subscribers must be deleted\n-         * when onCancel() is called.\n-         */\n-        subscriberRef.set(null);\n-    }\n-\n-    private synchronized void releaseNativeResources() {\n-        boolean alreadyReleased = areNativeResourcesReleased.getAndSet(true);\n-\n-        if (!alreadyReleased) {\n-            stream.close();\n-            connection.close();\n-        }\n-    }\n-\n-    /**\n-     * Called when the final Buffer has been queued and no more data is expected.\n-     */\n-    public void setQueueComplete() {\n-        log.trace(() -> \"Response Body Publisher queue marked as completed.\");\n-        queueComplete.set(true);\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-    }\n-\n-    /**\n-     * Completes the Subscription by calling either the .onError() or .onComplete() callbacks exactly once.\n-     */\n-    protected void completeSubscriptionExactlyOnce() {\n-        boolean alreadyComplete = isSubscriptionComplete.getAndSet(true);\n-\n-        if (alreadyComplete) {\n-            return;\n-        }\n-\n-        // Subscriber may have cancelled their subscription, in which case this may be null.\n-        Optional<Subscriber<? super ByteBuffer>> subscriber = Optional.ofNullable(subscriberRef.getAndSet(null));\n-\n-        Throwable throwable = error.get();\n-\n-        // We're done with the Native Resources, release them so they can be used by another request.\n-        releaseNativeResources();\n-\n-        // Complete the Futures\n-        if (throwable != null) {\n-            log.error(() -> \"Error before ResponseBodyPublisher could complete: \" + throwable.getMessage());\n-            try {\n-                subscriber.ifPresent(s -> s.onError(throwable));\n-            } catch (Exception e) {\n-                ;\n-            }\n-            responseComplete.completeExceptionally(throwable);\n-        } else {\n-            log.debug(() -> \"ResponseBodyPublisher Completed Successfully\");\n-            try {\n-                subscriber.ifPresent(s -> s.onComplete());\n-            } catch (Exception e) {\n-                ;\n-            }\n-            responseComplete.complete(null);\n-        }\n-    }\n-\n-    /**\n-     * Publishes any queued data to any Subscribers if there is data queued and there is an outstanding Subscriber\n-     * request for more data. Will also call onError() or onComplete() callbacks if needed.\n-     *\n-     * This method MUST be synchronized since it can be called simultaneously from both the Native EventLoop Thread and\n-     * the User Thread. If this method wasn't synchronized, it'd be possible for each thread to dequeue a buffer by\n-     * calling queuedBuffers.poll(), but then have the 2nd thread call subscriber.onNext(buffer) first, resulting in the\n-     * subscriber seeing out-of-order data. To avoid this race condition, this method must be synchronized.\n-     */\n-    protected void publishToSubscribers() {\n-        boolean shouldComplete = true;\n-        synchronized (this) {\n-            if (error.get() == null) {\n-                if (isSubscriptionComplete.get() || isCancelled.get()) {\n-                    log.debug(() -> \"Subscription already completed or cancelled, can't publish updates to Subscribers.\");\n-                    return;\n-                }\n-\n-                if (mutualRecursionDepth.get() > 0) {\n-                    /**\n-                     * If our depth is > 0, then we already made a call to publishToSubscribers() further up the stack that\n-                     * will continue publishing to subscribers, and this call should return without completing work to avoid\n-                     * infinite recursive loop between: \"subscription.request() -> subscriber.onNext() -> subscription.request()\"\n-                     */\n-                    return;\n-                }\n-\n-                int totalAmountTransferred = 0;\n-\n-                while (outstandingRequests.get() > 0 && !queuedBuffers.isEmpty()) {\n-                    byte[] buffer = queuedBuffers.poll();\n-                    outstandingRequests.getAndUpdate(DECREMENT_IF_GREATER_THAN_ZERO);\n-                    int amount = buffer.length;\n-                    publishWithoutMutualRecursion(subscriberRef.get(), ByteBuffer.wrap(buffer));\n-                    totalAmountTransferred += amount;\n-                }\n-\n-                if (totalAmountTransferred > 0) {\n-                    queuedBytes.addAndGet(-totalAmountTransferred);\n-\n-                    // We may have released the Native HttpConnection and HttpStream if they completed before the Subscriber\n-                    // has finished reading the data.\n-                    if (!areNativeResourcesReleased.get()) {\n-                        // Open HttpStream's IO window so HttpStream can keep track of IO back-pressure\n-                        // This is why it is correct to return 0 from AwsCrtAsyncHttpStreamAdapter::onResponseBody\n-                        stream.incrementWindow(totalAmountTransferred);\n-                    }\n-                }\n-\n-                shouldComplete = queueComplete.get() && queuedBuffers.isEmpty();\n-            } else {\n-                shouldComplete = true;\n-            }\n-        }\n-\n-        // Check if Complete, consider no subscriber as a completion.\n-        if (shouldComplete) {\n-            completeSubscriptionExactlyOnce();\n-        }\n-    }\n-\n-    /**\n-     * This method is used to avoid a StackOverflow due to the potential infinite loop between\n-     * \"subscription.request() -> subscriber.onNext() -> subscription.request()\" calls. We only call subscriber.onNext()\n-     * if the recursion depth is zero, otherwise we return up to the stack frame with depth zero and continue publishing\n-     * from there.\n-     * @param subscriber The Subscriber to publish to.\n-     * @param buffer The buffer to publish to the subscriber.\n-     */\n-    private synchronized void publishWithoutMutualRecursion(Subscriber<? super ByteBuffer> subscriber, ByteBuffer buffer) {\n-        try {\n-            /**\n-             * Need to keep track of recursion depth between .onNext() -> .request() calls\n-             */\n-            int depth = mutualRecursionDepth.getAndIncrement();\n-            if (depth == 0) {\n-                subscriber.onNext(buffer);\n-            }\n-        } finally {\n-            mutualRecursionDepth.decrementAndGet();\n-        }\n-    }\n-\n-    static class AwsCrtResponseBodySubscription implements Subscription {\n-        private final AwsCrtResponseBodyPublisher publisher;\n-\n-        AwsCrtResponseBodySubscription(AwsCrtResponseBodyPublisher publisher) {\n-            this.publisher = publisher;\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Reactive Stream Spec requires us to call onError() callback instead of throwing Exception here.\n-                publisher.setError(new IllegalArgumentException(\"Request is for <= 0 elements: \" + n));\n-                publisher.publishToSubscribers();\n-                return;\n-            }\n-\n-            publisher.request(n);\n-            publisher.publishToSubscribers();\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            publisher.setCancelled();\n-        }\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ5NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436057495", "bodyText": "Nice, thank you for making it sharable for all http clients!!", "author": "zoewangg", "createdAt": "2020-06-05T17:20:49Z", "path": "test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.ssl.SslContextBuilder;\n+import io.netty.handler.ssl.util.SelfSignedCertificate;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.TEXT_PLAIN;\n+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;\n+\n+\n+/**\n+ * Testing the scenario where h1 server sends 5xx errors.\n+ */\n+public abstract class H1ServerErrorTestBase {", "originalCommit": "5affa636c9ee0a219d88a7b158750ec64dab0617", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java b/test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java\ndeleted file mode 100644\nindex 3109a6b9b4..0000000000\n--- a/test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java\n+++ /dev/null\n\n@@ -1,151 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http;\n-\n-import io.netty.bootstrap.ServerBootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.ChannelDuplexHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelInitializer;\n-import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.nio.NioEventLoopGroup;\n-import io.netty.channel.socket.ServerSocketChannel;\n-import io.netty.channel.socket.SocketChannel;\n-import io.netty.channel.socket.nio.NioServerSocketChannel;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.FullHttpResponse;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpServerCodec;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.logging.LogLevel;\n-import io.netty.handler.logging.LoggingHandler;\n-import io.netty.handler.ssl.SslContext;\n-import io.netty.handler.ssl.SslContextBuilder;\n-import io.netty.handler.ssl.util.SelfSignedCertificate;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\n-import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\n-import static io.netty.handler.codec.http.HttpHeaderValues.TEXT_PLAIN;\n-import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n-import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n-import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;\n-\n-\n-/**\n- * Testing the scenario where h1 server sends 5xx errors.\n- */\n-public abstract class H1ServerErrorTestBase {\n-    private Server server;\n-\n-    protected abstract SdkAsyncHttpClient getTestClient();\n-\n-    public void setup() throws Exception {\n-        server = new Server();\n-        server.init();\n-    }\n-\n-    public void teardown() throws InterruptedException {\n-        if (server != null) {\n-            server.shutdown();\n-        }\n-        server = null;\n-    }\n-\n-    public void connectionReceive500_shouldNotReuseConnection() throws Exception {\n-        server.return500OnFirstRequest = true;\n-\n-        TestUtils.sendGetRequest(server.port(), getTestClient()).join();\n-        TestUtils.sendGetRequest(server.port(), getTestClient()).join();\n-        assertThat(server.channels.size()).isEqualTo(2);\n-    }\n-\n-    public void connectionReceive200_shouldReuseConnection() {\n-        server.return500OnFirstRequest = false;\n-\n-        TestUtils.sendGetRequest(server.port(), getTestClient()).join();\n-        TestUtils.sendGetRequest(server.port(), getTestClient()).join();\n-        assertThat(server.channels.size()).isEqualTo(1);\n-    }\n-\n-    private static class Server extends ChannelInitializer<SocketChannel> {\n-        private static final byte[] CONTENT = \"helloworld\".getBytes();\n-        private ServerBootstrap bootstrap;\n-        private ServerSocketChannel serverSock;\n-        private List<SocketChannel> channels = new ArrayList<>();\n-        private final NioEventLoopGroup group = new NioEventLoopGroup();\n-        private SslContext sslCtx;\n-        private boolean return500OnFirstRequest;\n-\n-        public void init() throws Exception {\n-            SelfSignedCertificate ssc = new SelfSignedCertificate();\n-            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n-\n-            bootstrap = new ServerBootstrap()\n-                .channel(NioServerSocketChannel.class)\n-                .handler(new LoggingHandler(LogLevel.DEBUG))\n-                .group(group)\n-                .childHandler(this);\n-\n-            serverSock = (ServerSocketChannel) bootstrap.bind(0).sync().channel();\n-        }\n-\n-        @Override\n-        protected void initChannel(SocketChannel ch) throws Exception {\n-            channels.add(ch);\n-            ChannelPipeline pipeline = ch.pipeline();\n-            pipeline.addLast(sslCtx.newHandler(ch.alloc()));\n-            pipeline.addLast(new HttpServerCodec());\n-            pipeline.addLast(new MightReturn500ChannelHandler());\n-        }\n-\n-        public void shutdown() throws InterruptedException {\n-            group.shutdownGracefully().await();\n-        }\n-\n-        public int port() {\n-            return serverSock.localAddress().getPort();\n-        }\n-\n-        private class MightReturn500ChannelHandler extends ChannelDuplexHandler {\n-\n-            @Override\n-            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n-                if (msg instanceof HttpRequest) {\n-                    HttpResponseStatus status;\n-                    if (ctx.channel().equals(channels.get(0)) && return500OnFirstRequest) {\n-                        status = INTERNAL_SERVER_ERROR;\n-                    } else {\n-                        status = OK;\n-                    }\n-\n-                    FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status,\n-                                                                            Unpooled.wrappedBuffer(CONTENT));\n-\n-                    response.headers()\n-                            .set(CONTENT_TYPE, TEXT_PLAIN)\n-                            .setInt(CONTENT_LENGTH, response.content().readableBytes());\n-                    ctx.writeAndFlush(response);\n-                }\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1ODMzNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436058337", "bodyText": "Is there any reason lowering the total runs and increasing concurrency?", "author": "zoewangg", "createdAt": "2020-06-05T17:22:31Z", "path": "test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java", "diffHunk": "@@ -15,44 +15,39 @@\n \n package software.amazon.awssdk.stability.tests.s3;\n \n+import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Path;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.core.retry.RetryPolicy;\n+import java.util.function.IntFunction;\n+\n+import org.apache.commons.lang3.RandomStringUtils;\n+import software.amazon.awssdk.core.async.AsyncRequestBody;\n+import software.amazon.awssdk.core.async.AsyncResponseTransformer;\n import software.amazon.awssdk.core.sync.RequestBody;\n import software.amazon.awssdk.http.apache.ApacheHttpClient;\n-import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n import software.amazon.awssdk.services.s3.S3Client;\n import software.amazon.awssdk.services.s3.model.DeleteBucketRequest;\n import software.amazon.awssdk.services.s3.model.NoSuchBucketException;\n import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.stability.tests.utils.StabilityTestRunner;\n import software.amazon.awssdk.testutils.RandomTempFile;\n import software.amazon.awssdk.testutils.service.AwsTestBase;\n import software.amazon.awssdk.utils.Logger;\n \n public abstract class S3BaseStabilityTest extends AwsTestBase {\n     private static final Logger log = Logger.loggerFor(S3BaseStabilityTest.class);\n-    protected static final int CONCURRENCY = 100;\n-    protected static final int TOTAL_RUNS = 50;\n+    protected static final int CONCURRENCY = 500;", "originalCommit": "5affa636c9ee0a219d88a7b158750ec64dab0617", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzQ5NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377494", "bodyText": "I think that's me forgetting what the original settings were after we finished debugging.", "author": "bretambrose", "createdAt": "2020-06-07T16:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1ODMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java b/test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java\nindex 80dadcafae..178f8394c2 100644\n--- a/test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java\n+++ b/test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java\n\n@@ -15,39 +15,44 @@\n \n package software.amazon.awssdk.stability.tests.s3;\n \n-import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Path;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import java.util.function.IntFunction;\n-\n-import org.apache.commons.lang3.RandomStringUtils;\n-import software.amazon.awssdk.core.async.AsyncRequestBody;\n-import software.amazon.awssdk.core.async.AsyncResponseTransformer;\n+import software.amazon.awssdk.core.retry.RetryPolicy;\n import software.amazon.awssdk.core.sync.RequestBody;\n import software.amazon.awssdk.http.apache.ApacheHttpClient;\n+import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n import software.amazon.awssdk.services.s3.S3Client;\n import software.amazon.awssdk.services.s3.model.DeleteBucketRequest;\n import software.amazon.awssdk.services.s3.model.NoSuchBucketException;\n import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n-import software.amazon.awssdk.stability.tests.utils.StabilityTestRunner;\n import software.amazon.awssdk.testutils.RandomTempFile;\n import software.amazon.awssdk.testutils.service.AwsTestBase;\n import software.amazon.awssdk.utils.Logger;\n \n public abstract class S3BaseStabilityTest extends AwsTestBase {\n     private static final Logger log = Logger.loggerFor(S3BaseStabilityTest.class);\n-    protected static final int CONCURRENCY = 500;\n-    protected static final int TOTAL_RUNS = 10;\n+    protected static final int CONCURRENCY = 100;\n+    protected static final int TOTAL_RUNS = 50;\n     protected static final String LARGE_KEY_NAME = \"2GB\";\n \n+    protected static S3AsyncClient s3NettyClient;\n     protected static S3Client s3ApacheClient;\n \n     static {\n+        s3NettyClient = S3AsyncClient.builder()\n+                                     .httpClientBuilder(NettyNioAsyncHttpClient.builder()\n+                                                                               .maxConcurrency(CONCURRENCY))\n+                                     .credentialsProvider(CREDENTIALS_PROVIDER_CHAIN)\n+                                     .overrideConfiguration(b -> b.apiCallTimeout(Duration.ofMinutes(10))\n+                                                                  // Retry at test level\n+                                                                  .retryPolicy(RetryPolicy.none()))\n+                                     .build();\n+\n+\n         s3ApacheClient = S3Client.builder()\n                                  .httpClientBuilder(ApacheHttpClient.builder()\n                                                                     .maxConnections(CONCURRENCY))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4MzU0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436083544", "bodyText": "Minor: I don't think we need to create a default connectionMaxIdleTime here since the default value will be merged in when we merge SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS in the build method.\n        @Override\n        public SdkAsyncHttpClient build() {\n            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n        }", "author": "zoewangg", "createdAt": "2020-06-05T18:09:54Z", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -417,6 +437,10 @@ public void close() {\n         private EventLoopGroup eventLoopGroup;\n         private HostResolver hostResolver;\n         private ProxyConfiguration proxyConfiguration;\n+        private HttpMonitoringOptions monitoringOptions;\n+\n+        // default reaping interval matches Apache client\n+        private Duration connectionMaxIdleTime = Duration.ofSeconds(60);", "originalCommit": "5affa636c9ee0a219d88a7b158750ec64dab0617", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "511f2de51f36c5b40d7a72d50f2b6d7ca70704ae", "chunk": "diff --git a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java b/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\ndeleted file mode 100644\nindex fb278459de..0000000000\n--- a/http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java\n+++ /dev/null\n\n@@ -1,527 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.http.crt;\n-\n-import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n-import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.crt.CrtResource;\n-import software.amazon.awssdk.crt.CrtRuntimeException;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n-import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n-import software.amazon.awssdk.crt.http.HttpHeader;\n-import software.amazon.awssdk.crt.http.HttpProxyOptions;\n-import software.amazon.awssdk.crt.http.HttpRequest;\n-import software.amazon.awssdk.crt.http.HttpMonitoringOptions;\n-import software.amazon.awssdk.crt.io.ClientBootstrap;\n-import software.amazon.awssdk.crt.io.EventLoopGroup;\n-import software.amazon.awssdk.crt.io.HostResolver;\n-import software.amazon.awssdk.crt.io.SocketOptions;\n-import software.amazon.awssdk.crt.io.TlsCipherPreference;\n-import software.amazon.awssdk.crt.io.TlsContext;\n-import software.amazon.awssdk.crt.io.TlsContextOptions;\n-import software.amazon.awssdk.http.Header;\n-import software.amazon.awssdk.http.SdkHttpClient;\n-import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n-import software.amazon.awssdk.http.SdkHttpRequest;\n-import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n-import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n-import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n-import software.amazon.awssdk.utils.AttributeMap;\n-import software.amazon.awssdk.utils.IoUtils;\n-import software.amazon.awssdk.utils.Logger;\n-import software.amazon.awssdk.utils.Validate;\n-import software.amazon.awssdk.utils.http.SdkHttpUtils;\n-\n-/**\n- * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n- * Http Web Services. This client is asynchronous and uses non-blocking IO.\n- *\n- * <p>This can be created via {@link #builder()}</p>\n- */\n-@SdkPublicApi\n-public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n-    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n-\n-    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n-    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n-    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n-    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n-\n-    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n-    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n-    private final ClientBootstrap bootstrap;\n-    private final SocketOptions socketOptions;\n-    private final TlsContext tlsContext;\n-    private final HttpProxyOptions proxyOptions;\n-    private final HttpMonitoringOptions monitoringOptions;\n-    private final long maxConnectionIdleInMilliseconds;\n-    private final int initialWindowSize;\n-    private final int maxConnectionsPerEndpoint;\n-    private final boolean manualWindowManagement;\n-    private boolean isClosed = false;\n-\n-    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n-        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n-\n-        Validate.isPositive(maxConns, \"maxConns\");\n-        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n-        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n-        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n-        Validate.notNull(builder.hostResolver, \"hostResolver\");\n-\n-        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n-             SocketOptions clientSocketOptions = new SocketOptions();\n-             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n-                     .withCipherPreference(builder.cipherPreference)\n-                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n-             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n-\n-            this.bootstrap = registerOwnedResource(clientBootstrap);\n-            this.socketOptions = registerOwnedResource(clientSocketOptions);\n-            this.tlsContext = registerOwnedResource(clientTlsContext);\n-\n-            this.initialWindowSize = builder.initialWindowSize;\n-            this.maxConnectionsPerEndpoint = maxConns;\n-            this.manualWindowManagement = builder.manualWindowManagement;\n-            this.monitoringOptions = builder.monitoringOptions;\n-            this.maxConnectionIdleInMilliseconds = (builder.connectionMaxIdleTime != null) ? builder.connectionMaxIdleTime.toMillis() : 0;\n-\n-            this.proxyOptions = buildProxyOptions(builder.proxyConfiguration);\n-        }\n-    }\n-\n-    private HttpProxyOptions buildProxyOptions(ProxyConfiguration proxyConfiguration) {\n-        if (proxyConfiguration != null) {\n-            HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n-\n-            clientProxyOptions.setHost(proxyConfiguration.host());\n-            clientProxyOptions.setPort(proxyConfiguration.port());\n-            if (proxyConfiguration.scheme() != null && proxyConfiguration.scheme().equalsIgnoreCase(\"https\")) {\n-                clientProxyOptions.setTlsContext(tlsContext);\n-            }\n-\n-            if (proxyConfiguration.username() != null && proxyConfiguration.password() != null) {\n-                clientProxyOptions.setAuthorizationUsername(proxyConfiguration.username());\n-                clientProxyOptions.setAuthorizationPassword(proxyConfiguration.password());\n-                clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n-            } else {\n-                clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n-            }\n-\n-            return clientProxyOptions;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Marks a Native CrtResource as owned by the current Java Object.\n-     *\n-     * @param subresource The Resource to own.\n-     * @param <T> The CrtResource Type\n-     * @return The CrtResource passed in\n-     */\n-    private <T extends CrtResource> T registerOwnedResource(T subresource) {\n-        if (subresource != null) {\n-            subresource.addRef();\n-            ownedSubResources.push(subresource);\n-        }\n-        return subresource;\n-    }\n-\n-    private static URI toUri(SdkHttpRequest sdkRequest) {\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n-                null, null, null));\n-    }\n-\n-    public static Builder builder() {\n-        return new DefaultBuilder();\n-    }\n-\n-    @Override\n-    public String clientName() {\n-        return AWS_COMMON_RUNTIME;\n-    }\n-\n-    private HttpClientConnectionManager createConnectionPool(URI uri) {\n-        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n-\n-        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n-                .withClientBootstrap(bootstrap)\n-                .withSocketOptions(socketOptions)\n-                .withTlsContext(tlsContext)\n-                .withUri(uri)\n-                .withWindowSize(initialWindowSize)\n-                .withMaxConnections(maxConnectionsPerEndpoint)\n-                .withManualWindowManagement(manualWindowManagement)\n-                .withProxyOptions(proxyOptions)\n-                .withMonitoringOptions(monitoringOptions)\n-                .withMaxConnectionIdleInMilliseconds(maxConnectionIdleInMilliseconds);\n-\n-        return HttpClientConnectionManager.create(options);\n-    }\n-\n-    /*\n-     * Callers of this function MUST account for the addRef() on the pool before returning.\n-     * Every execution path consuming the return value must guarantee an associated close().\n-     * Currently this function is only used by execute(), which guarantees a matching close\n-     * via the try-with-resources block.\n-     *\n-     * This guarantees that a returned pool will not get closed (by closing the http client) during\n-     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n-     * be properly failed if the http client is closed before the acquisition completes.\n-     *\n-     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n-     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n-     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n-     * pool implementation.\n-     */\n-    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        synchronized (this) {\n-            if (isClosed) {\n-                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n-            }\n-\n-            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, this::createConnectionPool);\n-            connPool.addRef();\n-            return connPool;\n-        }\n-    }\n-\n-    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        // worst case we may add 3 more headers here\n-        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n-\n-        // Set Host Header if needed\n-        if (isNullOrEmpty(sdkRequest.headers().get(Header.HOST))) {\n-            crtHeaderList.add(new HttpHeader(Header.HOST, uri.getHost()));\n-        }\n-\n-        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n-        if (isNullOrEmpty(sdkRequest.headers().get(Header.CONNECTION))) {\n-            crtHeaderList.add(new HttpHeader(Header.CONNECTION, Header.KEEP_ALIVE_VALUE));\n-        }\n-\n-        // Set Content-Length if needed\n-        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n-        if (isNullOrEmpty(sdkRequest.headers().get(Header.CONTENT_LENGTH)) && contentLength.isPresent()) {\n-            crtHeaderList.add(new HttpHeader(Header.CONTENT_LENGTH, Long.toString(contentLength.get())));\n-        }\n-\n-        // Add the rest of the Headers\n-        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n-            for (String val: headerList.getValue()) {\n-                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n-                crtHeaderList.add(h);\n-            }\n-        }\n-\n-        return crtHeaderList;\n-    }\n-\n-    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n-        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n-    }\n-\n-    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n-        SdkHttpRequest sdkRequest = asyncRequest.request();\n-        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n-        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n-\n-        String method = sdkRequest.method().name();\n-        String encodedPath = sdkRequest.encodedPath();\n-        if (encodedPath == null || encodedPath.length() == 0) {\n-            encodedPath = \"/\";\n-        }\n-\n-        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n-                .map(value -> \"?\" + value)\n-                .orElse(\"\");\n-\n-        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n-\n-        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n-\n-        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n-        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n-        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n-        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n-\n-        URI uri = toUri(asyncRequest.request());\n-\n-        /*\n-         * See the note on getOrCreateConnectionPool()\n-         *\n-         * In particular, this returns a ref-counted object and calling getOrCreateConnectionPool\n-         * increments the ref count by one.  We add a try-with-resources to release our ref\n-         * once we have successfully submitted a request.  In this way, we avoid a race condition\n-         * when close/shutdown is called from another thread while this function is executing (ie.\n-         * we have a pool and no one can destroy it underneath us until we've finished submitting the\n-         * request)\n-         */\n-        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n-            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n-\n-            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n-            crtConnPool.acquireConnection()\n-                    .whenComplete((crtConn, throwable) -> {\n-                        // If we didn't get a connection for some reason, fail the request\n-                        if (throwable != null) {\n-                            try {\n-                                asyncRequest.responseHandler().onError(throwable);\n-                            } catch (Exception e) {\n-                                log.error(() -> String.format(\"Exception while handling error: %s\", e.toString()));\n-                            }\n-                            requestFuture.completeExceptionally(new IOException(\n-                                    \"Crt exception while acquiring connection\", throwable));\n-                            return;\n-                        }\n-\n-                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n-                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n-                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n-\n-                        // Submit the Request on this Connection\n-                        invokeSafely(() -> {\n-                            try {\n-                                crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate();\n-                            } catch (IllegalStateException | CrtRuntimeException e) {\n-                                throw new IOException(\"Exception throw while submitting request to CRT http connection\", e);\n-                            }\n-                        });\n-                    });\n-\n-            return requestFuture;\n-        }\n-    }\n-\n-    @Override\n-    public void close() {\n-        synchronized (this) {\n-\n-            if (isClosed) {\n-                return;\n-            }\n-\n-            connectionPools.values().forEach(pool -> IoUtils.closeQuietly(pool, log.logger()));\n-            ownedSubResources.forEach(r -> IoUtils.closeQuietly(r, log.logger()));\n-            ownedSubResources.clear();\n-\n-            isClosed = true;\n-        }\n-    }\n-\n-    /**\n-     * Builder that allows configuration of the AWS CRT HTTP implementation.\n-     */\n-    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n-\n-        /**\n-         * The maximum number of connections allowed per distinct endpoint\n-         * @param maxConnections maximum connections per endpoint\n-         * @return The builder of the method chaining.\n-         */\n-        Builder maxConnections(int maxConnections);\n-\n-        /**\n-         * The AWS CRT TlsCipherPreference to use for this Client\n-         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n-         * @return The builder of the method chaining.\n-         */\n-        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n-\n-        /**\n-         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n-         * is responsible for calling incrementWindow on the stream object.\n-         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder manualWindowManagement(boolean manualWindowManagement);\n-\n-        /**\n-         * The AWS CRT WindowSize to use for this HttpClient.\n-         *\n-         * For an http/1.1 connection, this represents  the number of unread bytes that can be buffered in the\n-         * ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for the Subscriber\n-         * to read more data.\n-         *\n-         * @param initialWindowSize The AWS Common Runtime WindowSize\n-         * @return The builder of the method chaining.\n-         */\n-        Builder initialWindowSize(int initialWindowSize);\n-\n-        /**\n-         * The AWS CRT EventLoopGroup to use for this Client.\n-         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n-\n-        /**\n-         * The AWS CRT HostResolver to use for this Client.\n-         * @param hostResolver The AWS CRT HostResolver to use for this client.\n-         * @return The builder of the method chaining.\n-         */\n-        Builder hostResolver(HostResolver hostResolver);\n-\n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         * @param proxyConfiguration The http proxy configuration to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n-\n-        /**\n-         * Sets the http monitoring options for all connections established by this client.\n-         * @param monitoringOptions The http monitoring options to use\n-         * @return The builder of the method chaining.\n-         */\n-        Builder monitoringOptions(HttpMonitoringOptions monitoringOptions);\n-\n-        /**\n-         * Configure the maximum amount of time that a connection should be allowed to remain open while idle.\n-         */\n-        Builder connectionMaxIdleTime(Duration connectionMaxIdleTime);\n-      \n-        /**\n-         * Sets the http proxy configuration to use for this client.\n-         *\n-         * @param proxyConfigurationBuilderConsumer The consumer of the proxy configuration builder object.\n-         * @return the builder for method chaining.\n-         */\n-        Builder proxyConfiguration(Consumer<ProxyConfiguration.Builder> proxyConfigurationBuilderConsumer);\n-    }\n-\n-    /**\n-     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n-     * configure and construct an immutable instance of the factory.\n-     */\n-    private static final class DefaultBuilder implements Builder {\n-        private final AttributeMap.Builder standardOptions = AttributeMap.builder();\n-        private TlsCipherPreference cipherPreference = TlsCipherPreference.TLS_CIPHER_SYSTEM_DEFAULT;\n-        private int initialWindowSize = DEFAULT_STREAM_WINDOW_SIZE;\n-        private boolean manualWindowManagement;\n-        private EventLoopGroup eventLoopGroup;\n-        private HostResolver hostResolver;\n-        private ProxyConfiguration proxyConfiguration;\n-        private HttpMonitoringOptions monitoringOptions;\n-\n-        // default reaping interval matches Apache client\n-        private Duration connectionMaxIdleTime = Duration.ofSeconds(60);\n-\n-        private DefaultBuilder() {\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient build() {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public SdkAsyncHttpClient buildWithDefaults(AttributeMap serviceDefaults) {\n-            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n-                                                           .merge(serviceDefaults)\n-                                                           .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n-        }\n-\n-        @Override\n-        public Builder maxConnections(int maxConnections) {\n-            Validate.isPositive(maxConnections, \"maxConnections\");\n-            standardOptions.put(SdkHttpConfigurationOption.MAX_CONNECTIONS, maxConnections);\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference) {\n-            Validate.notNull(tlsCipherPreference, \"cipherPreference\");\n-            Validate.isTrue(TlsContextOptions.isCipherPreferenceSupported(tlsCipherPreference),\n-                            \"TlsCipherPreference not supported on current Platform\");\n-            this.cipherPreference = tlsCipherPreference;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder manualWindowManagement(boolean manualWindowManagement) {\n-            this.manualWindowManagement = manualWindowManagement;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder initialWindowSize(int initialWindowSize) {\n-            Validate.isPositive(initialWindowSize, \"initialWindowSize\");\n-            this.initialWindowSize = initialWindowSize;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder eventLoopGroup(EventLoopGroup eventLoopGroup) {\n-            this.eventLoopGroup = eventLoopGroup;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder hostResolver(HostResolver hostResolver) {\n-            this.hostResolver = hostResolver;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(ProxyConfiguration proxyConfiguration) {\n-            this.proxyConfiguration = proxyConfiguration;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder monitoringOptions(HttpMonitoringOptions monitoringOptions) {\n-            this.monitoringOptions = monitoringOptions;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder connectionMaxIdleTime(Duration connectionMaxIdleTime) {\n-            this.connectionMaxIdleTime = connectionMaxIdleTime;\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder proxyConfiguration(Consumer<ProxyConfiguration.Builder> proxyConfigurationBuilderConsumer) {\n-            ProxyConfiguration.Builder builder = ProxyConfiguration.builder();\n-            proxyConfigurationBuilderConsumer.accept(builder);\n-            return proxyConfiguration(builder.build());\n-        }\n-    }\n-}\n"}}, {"oid": "a4a53465ac5333bae22ad6f9a6da7c5c0ee98fd5", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a4a53465ac5333bae22ad6f9a6da7c5c0ee98fd5", "message": "Merge pull request #872 from aws/staging/0b5e2565-d52d-44b6-aea6-e618c8e1dfce\n\nPull request: release <- staging/0b5e2565-d52d-44b6-aea6-e618c8e1dfce", "committedDate": "2020-06-09T18:06:34Z", "type": "commit"}, {"oid": "0cd2c1a46590af052713a19a537ae01e7e2fc7fa", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0cd2c1a46590af052713a19a537ae01e7e2fc7fa", "message": "Update to next snapshot version: 2.13.34-SNAPSHOT", "committedDate": "2020-06-09T18:31:27Z", "type": "commit"}, {"oid": "c882aaa0be323bd5cff55a5689347f4a1b9e13ff", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c882aaa0be323bd5cff55a5689347f4a1b9e13ff", "message": "Add metrics codegen changes for async clients", "committedDate": "2020-06-10T17:08:23Z", "type": "commit"}, {"oid": "b2328bd7868ba19fd54a4edda9e0d4ee2551cd59", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b2328bd7868ba19fd54a4edda9e0d4ee2551cd59", "message": "AWS Service Catalog Update: Service Catalog Documentation Update for Integration with AWS Organizations Delegated Administrator feature", "committedDate": "2020-06-10T18:04:47Z", "type": "commit"}, {"oid": "7e661dd78284c743ab79e6dad56bf1d2cf92ae70", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7e661dd78284c743ab79e6dad56bf1d2cf92ae70", "message": "AWS Shield Update: Corrections to the supported format for contact phone numbers and to the description for the create subscription action.", "committedDate": "2020-06-10T18:04:53Z", "type": "commit"}, {"oid": "2467c2f57d60148b5976285ae813f6f89991f446", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2467c2f57d60148b5976285ae813f6f89991f446", "message": "Amazon Macie 2 Update: This release of the Amazon Macie API removes support for the ArchiveFindings and UnarchiveFindings operations. This release also adds UNKNOWN as an encryption type for S3 bucket metadata.", "committedDate": "2020-06-10T18:04:57Z", "type": "commit"}, {"oid": "18528acbd76f3cd18b1bd7739ab9737936d4e4f9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/18528acbd76f3cd18b1bd7739ab9737936d4e4f9", "message": "CodeArtifact Update: Added support for AWS CodeArtifact.", "committedDate": "2020-06-10T18:05:03Z", "type": "commit"}, {"oid": "3735922bf5c6e362a8506bacdc2eb868ac10a8d6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3735922bf5c6e362a8506bacdc2eb868ac10a8d6", "message": "Amazon Lightsail Update: Documentation updates for lightsail", "committedDate": "2020-06-10T18:05:07Z", "type": "commit"}, {"oid": "5c800fdf6e0874c0b85fbdfa16f7cfc6708d4dcc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5c800fdf6e0874c0b85fbdfa16f7cfc6708d4dcc", "message": "Amazon Elastic Compute Cloud Update: New C6g instances powered by AWS Graviton2 processors and ideal for running advanced, compute-intensive workloads; New R6g instances powered by AWS Graviton2 processors and ideal for running memory-intensive workloads.", "committedDate": "2020-06-10T18:05:12Z", "type": "commit"}, {"oid": "8ca8d68414f17e4f4d18d6544da5547532116872", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8ca8d68414f17e4f4d18d6544da5547532116872", "message": "Amazon Data Lifecycle Manager Update: Reducing the schedule name of DLM Lifecycle policy from 500 to 120 characters.", "committedDate": "2020-06-10T18:05:17Z", "type": "commit"}, {"oid": "21bd248ad96c730ad66d00811c49edfa331e817b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/21bd248ad96c730ad66d00811c49edfa331e817b", "message": "AWS Compute Optimizer Update: Compute Optimizer supports exporting recommendations to Amazon S3.", "committedDate": "2020-06-10T18:05:22Z", "type": "commit"}, {"oid": "03e77363a0284b4f80556a8db942e1a5a8461fae", "url": "https://github.com/aws/aws-sdk-java-v2/commit/03e77363a0284b4f80556a8db942e1a5a8461fae", "message": "Amazon AppConfig Update: This release allows customers to choose from a list of predefined deployment strategies while starting deployments.", "committedDate": "2020-06-10T18:05:27Z", "type": "commit"}, {"oid": "023577f8e9a98afe5f64f2171cb4b2ed164b2f1e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/023577f8e9a98afe5f64f2171cb4b2ed164b2f1e", "message": "Release 2.13.34. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-10T18:06:44Z", "type": "commit"}, {"oid": "1c753673fe4def6a1a041fa3050ef15f62bee82e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1c753673fe4def6a1a041fa3050ef15f62bee82e", "message": "Merge pull request #873 from aws/staging/a7270fcf-c2b4-433a-bf5c-6a9e918952b9\n\nPull request: release <- staging/a7270fcf-c2b4-433a-bf5c-6a9e918952b9", "committedDate": "2020-06-10T18:07:01Z", "type": "commit"}, {"oid": "d155ac87545879ac03b9be50c963f382d3747f31", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d155ac87545879ac03b9be50c963f382d3747f31", "message": "Update to next snapshot version: 2.13.35-SNAPSHOT", "committedDate": "2020-06-10T18:31:44Z", "type": "commit"}, {"oid": "96e67ecb32cc15a63b2ce3d881e037d7ec9a9df9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/96e67ecb32cc15a63b2ce3d881e037d7ec9a9df9", "message": "Safely declare Netty AttributeKeys\n\nThis commit prevents the Netty client from throwing an exception in cases where\nit tries to declare an attribute key and the key already exists. This can happen\nwhen separate instances of the SDK are loaded by different classloaders, but the\nNetty classes loaded by a third and shared by the other classloaders.\n\nFixes #1886", "committedDate": "2020-06-10T20:44:35Z", "type": "commit"}, {"oid": "5c881b96063864af9f9c9d85a5f51000ec7dd05a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5c881b96063864af9f9c9d85a5f51000ec7dd05a", "message": "Remove unnecessary copy\n\nFixes #1877", "committedDate": "2020-06-10T22:53:14Z", "type": "commit"}, {"oid": "b67952429048d872ddd4455e1ec17faf07334e93", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b67952429048d872ddd4455e1ec17faf07334e93", "message": "Merge pull request #1887 from dagnir/gh1886\n\nSafely declare Netty AttributeKeys", "committedDate": "2020-06-10T23:17:17Z", "type": "commit"}, {"oid": "b5adbd9fa29dd995f5d485eb88025b6cfa17bc01", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b5adbd9fa29dd995f5d485eb88025b6cfa17bc01", "message": "Merge branch 'master' into 1877", "committedDate": "2020-06-10T23:17:32Z", "type": "commit"}, {"oid": "1ba3e7bf33cb71eb3a6b692c24f852fc664b10bf", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1ba3e7bf33cb71eb3a6b692c24f852fc664b10bf", "message": "Merge pull request #1888 from dagnir/1877\n\nRemove unnecessary copy", "committedDate": "2020-06-11T00:12:34Z", "type": "commit"}, {"oid": "9a2c97b83adffb514a08e523453b6d3b484b1431", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9a2c97b83adffb514a08e523453b6d3b484b1431", "message": "Amazon EC2 Container Service Update: This release adds support for deleting capacity providers.", "committedDate": "2020-06-11T18:20:48Z", "type": "commit"}, {"oid": "54a4ed4c011043b486ec92398d6cdf3cf41651b8", "url": "https://github.com/aws/aws-sdk-java-v2/commit/54a4ed4c011043b486ec92398d6cdf3cf41651b8", "message": "Amazon Lex Model Building Service Update: This change adds the built-in AMAZON.KendraSearchIntent that enables integration with Amazon Kendra.", "committedDate": "2020-06-11T18:20:55Z", "type": "commit"}, {"oid": "1b73eaa1d23913b21d2747572a2af52e8955124d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1b73eaa1d23913b21d2747572a2af52e8955124d", "message": "AWS IoT Data Plane Update: As part of this release, we are introducing a new feature called named shadow, which extends the capability of AWS IoT Device Shadow to support multiple shadows for a single IoT device. With this release, customers can store different device state data into different shadows, and as a result access only the required state data when needed and reduce individual shadow size.", "committedDate": "2020-06-11T18:21:00Z", "type": "commit"}, {"oid": "2e97fd66c7838c0c02dfc41cb11f4c7016275f25", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2e97fd66c7838c0c02dfc41cb11f4c7016275f25", "message": "EC2 Image Builder Update: EC2 Image Builder now supports specifying a custom working directory for your build and test workflows. In addition, Image Builder now supports defining tags that are applied to ephemeral resources created by EC2 Image Builder as part of the image creation workflow.", "committedDate": "2020-06-11T18:21:06Z", "type": "commit"}, {"oid": "4967e3c7aeb7ad5da168d5dbf31447803f15088f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4967e3c7aeb7ad5da168d5dbf31447803f15088f", "message": "Updated endpoints.json.", "committedDate": "2020-06-11T18:22:01Z", "type": "commit"}, {"oid": "64e8efef621a4fd3326a6e7c8fa253a2c4f651c4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/64e8efef621a4fd3326a6e7c8fa253a2c4f651c4", "message": "Release 2.13.35. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-11T18:22:31Z", "type": "commit"}, {"oid": "05d1a6a45bb725b771c9455fd1d5dda7c4502d97", "url": "https://github.com/aws/aws-sdk-java-v2/commit/05d1a6a45bb725b771c9455fd1d5dda7c4502d97", "message": "Merge pull request #878 from aws/staging/2e905f54-630b-4334-a3e3-235537ab9996\n\nPull request: release <- staging/2e905f54-630b-4334-a3e3-235537ab9996", "committedDate": "2020-06-11T18:22:44Z", "type": "commit"}, {"oid": "9032023c516b877958cd54d39a8f7bd4122bc9ac", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9032023c516b877958cd54d39a8f7bd4122bc9ac", "message": "Added support for HTTP/2 metrics to Netty.\n\nUpdated existing HTTP metrics to specify that they are \"concurrency\", not \"connections\". For HTTP/2, we can't calculate the maximum number of connections, and concurrency is more useful to customers anyway.\n\nFixed the AVAILABLE_CONCURRENCY in Netty to actually be the number of established but idle concurrency, not the difference between max concurrency and leased concurrency.", "committedDate": "2020-06-11T18:40:35Z", "type": "commit"}, {"oid": "9142b0bb0eb2620b6dec200fdd64e32ab461216f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9142b0bb0eb2620b6dec200fdd64e32ab461216f", "message": "Update to next snapshot version: 2.13.36-SNAPSHOT", "committedDate": "2020-06-11T18:48:11Z", "type": "commit"}, {"oid": "a3829d82a4a01af2971e1d5b2ee35a7bf09d54ce", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a3829d82a4a01af2971e1d5b2ee35a7bf09d54ce", "message": "Always use manual window management", "committedDate": "2020-06-11T22:37:49Z", "type": "commit"}, {"oid": "e868c531ce8a2d0b47c7e8b3ea9053d50303500b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e868c531ce8a2d0b47c7e8b3ea9053d50303500b", "message": "Added missing clientRequestToken to TransactWriteItemsEnhancedRequest", "committedDate": "2020-06-12T00:14:53Z", "type": "commit"}, {"oid": "117b2febbfb4e28c161feaf167cdb2c8f3d0bc3b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/117b2febbfb4e28c161feaf167cdb2c8f3d0bc3b", "message": "Resolved commments and added a changelog.", "committedDate": "2020-06-12T02:04:13Z", "type": "commit"}, {"oid": "1f53f9c0b09ef4849dff42a2fe255e02340dbd09", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1f53f9c0b09ef4849dff42a2fe255e02340dbd09", "message": "Support core metrics for async clients", "committedDate": "2020-06-12T03:34:36Z", "type": "commit"}, {"oid": "1c4be29d1a948e150bb7c693e2f5d26952eecba1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1c4be29d1a948e150bb7c693e2f5d26952eecba1", "message": "Build failure", "committedDate": "2020-06-12T15:56:05Z", "type": "commit"}, {"oid": "9f439e2f9904d60ec7437e5d4de23674e07a29b3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9f439e2f9904d60ec7437e5d4de23674e07a29b3", "message": "AWS CloudFormation Update: The following parameters now return the organization root ID or organizational unit (OU) IDs that you specified for DeploymentTargets: the OrganizationalUnitIds parameter on StackSet and the OrganizationalUnitId parameter on StackInstance, StackInstanceSummary, and StackSetOperationResultSummary", "committedDate": "2020-06-12T18:08:06Z", "type": "commit"}, {"oid": "5aa2cfc71151e9f3aa9e95620c84f2eb7a2c22a5", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5aa2cfc71151e9f3aa9e95620c84f2eb7a2c22a5", "message": "AWS Glue Update: You can now choose to crawl the entire table or just a sample of records in DynamoDB when using AWS Glue crawlers. Additionally, you can also specify a scanning rate for crawling DynamoDB tables.", "committedDate": "2020-06-12T18:08:11Z", "type": "commit"}, {"oid": "a57acec0abe702e350c4e213f04fc694ae8a090c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a57acec0abe702e350c4e213f04fc694ae8a090c", "message": "Amazon API Gateway Update: Documentation updates for Amazon API Gateway", "committedDate": "2020-06-12T18:08:15Z", "type": "commit"}, {"oid": "2d51b5533d23edccdd46603b6cbb795bd55a1aee", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2d51b5533d23edccdd46603b6cbb795bd55a1aee", "message": "AWS Storage Gateway Update: Display EndpointType in DescribeGatewayInformation", "committedDate": "2020-06-12T18:08:22Z", "type": "commit"}, {"oid": "15d728cab112982df1dc3a267723be78ed889194", "url": "https://github.com/aws/aws-sdk-java-v2/commit/15d728cab112982df1dc3a267723be78ed889194", "message": "Release 2.13.36. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-12T18:09:43Z", "type": "commit"}, {"oid": "c09f9899d18834a7d81683fcc154197fde697317", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c09f9899d18834a7d81683fcc154197fde697317", "message": "Merge pull request #879 from aws/staging/3205957c-a551-4048-a8f0-8f043bba7b6b\n\nPull request: release <- staging/3205957c-a551-4048-a8f0-8f043bba7b6b", "committedDate": "2020-06-12T18:09:58Z", "type": "commit"}, {"oid": "a9db020b7ec33840637cd8b13df340a0910170e7", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a9db020b7ec33840637cd8b13df340a0910170e7", "message": "Update to next snapshot version: 2.13.37-SNAPSHOT", "committedDate": "2020-06-12T18:34:28Z", "type": "commit"}, {"oid": "49d745e8966ee2f153ea69ad767aa21eaf13d1a6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/49d745e8966ee2f153ea69ad767aa21eaf13d1a6", "message": "Add functional and unit tests to verify async core metrics for event streaming operation", "committedDate": "2020-06-12T18:48:46Z", "type": "commit"}, {"oid": "88a0744c11e86b7d4ddfbfcf3dedcb1f8b0aab37", "url": "https://github.com/aws/aws-sdk-java-v2/commit/88a0744c11e86b7d4ddfbfcf3dedcb1f8b0aab37", "message": "Add javadoc for ClientRequestToken in TransactWriteItemsEnhancedRequest", "committedDate": "2020-06-12T19:52:57Z", "type": "commit"}, {"oid": "d1bf6f8ffafe3239bb173996dec6017fd0fe64ce", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d1bf6f8ffafe3239bb173996dec6017fd0fe64ce", "message": "Amazon AppConfig Update: This release adds a hosted configuration source provider. Customers can now store their application configurations directly in AppConfig, without the need for an external configuration source.", "committedDate": "2020-06-15T18:09:59Z", "type": "commit"}, {"oid": "2ad4d74137d07dded9f8af3646a8aa5cf423e426", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2ad4d74137d07dded9f8af3646a8aa5cf423e426", "message": "Amazon Cognito Identity Provider Update: Updated all AuthParameters to be sensitive.", "committedDate": "2020-06-15T18:10:06Z", "type": "commit"}, {"oid": "9e337a3a8e115ffcf4a6b697709b1175f300c171", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9e337a3a8e115ffcf4a6b697709b1175f300c171", "message": "AWS IoT Update: Added support for job executions rollout configuration, job abort configuration, and job executions timeout configuration for AWS IoT Over-the-Air (OTA) Update Feature.", "committedDate": "2020-06-15T18:10:11Z", "type": "commit"}, {"oid": "823dab5806a80469868694c5fede3ffe7d870ca3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/823dab5806a80469868694c5fede3ffe7d870ca3", "message": "Alexa For Business Update: Adding support for optional tags in CreateBusinessReportSchedule, CreateProfile and CreateSkillGroup APIs", "committedDate": "2020-06-15T18:10:16Z", "type": "commit"}, {"oid": "42c6cde76cb99d655dc365d51d6d7d9d1e260311", "url": "https://github.com/aws/aws-sdk-java-v2/commit/42c6cde76cb99d655dc365d51d6d7d9d1e260311", "message": "Amazon Chime Update: feature: Chime: This release introduces the ability to create an AWS Chime SDK meeting with attendees.", "committedDate": "2020-06-15T18:10:21Z", "type": "commit"}, {"oid": "0df15f8ba91087a7f4c2b92988b35efae8ec8611", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0df15f8ba91087a7f4c2b92988b35efae8ec8611", "message": "Release 2.13.37. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-15T18:11:42Z", "type": "commit"}, {"oid": "d695d402c1db712c34adad85c152025dd05ed4a6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d695d402c1db712c34adad85c152025dd05ed4a6", "message": "Merge pull request #880 from aws/staging/3b47cc16-c143-4d46-b40f-c3bfb0466176\n\nPull request: release <- staging/3b47cc16-c143-4d46-b40f-c3bfb0466176", "committedDate": "2020-06-15T18:11:56Z", "type": "commit"}, {"oid": "ced412dffc087735c573bfad55b13191ce777922", "url": "https://github.com/aws/aws-sdk-java-v2/commit/ced412dffc087735c573bfad55b13191ce777922", "message": "Update to next snapshot version: 2.13.38-SNAPSHOT", "committedDate": "2020-06-15T18:36:18Z", "type": "commit"}, {"oid": "2f20c92aab898945ee4e375921a30537fd376b38", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2f20c92aab898945ee4e375921a30537fd376b38", "message": "Fix NPE in OptionalAttributeValueConverter", "committedDate": "2020-06-15T22:25:21Z", "type": "commit"}, {"oid": "3b5f66df8461c78eefa629150370f350ae12c4c2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3b5f66df8461c78eefa629150370f350ae12c4c2", "message": "Merge pull request #1900 from dagnir/npe-fix\n\nFix NPE in OptionalAttributeValueConverter", "committedDate": "2020-06-15T22:42:58Z", "type": "commit"}, {"oid": "9772428b3dcbf7d3afb1a94ab2b983e4ba81de20", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9772428b3dcbf7d3afb1a94ab2b983e4ba81de20", "message": "Deleted wrongly pasted javadocs and fixed a minor bug", "committedDate": "2020-06-15T23:27:19Z", "type": "commit"}, {"oid": "46fa5617e12c9f9f795a5960962a93510ff03852", "url": "https://github.com/aws/aws-sdk-java-v2/commit/46fa5617e12c9f9f795a5960962a93510ff03852", "message": "Amazon QLDB Update: Documentation updates for Amazon QLDB", "committedDate": "2020-06-16T18:22:03Z", "type": "commit"}, {"oid": "cf54eb4103a0fe3e362b52eb302185f6125167d4", "url": "https://github.com/aws/aws-sdk-java-v2/commit/cf54eb4103a0fe3e362b52eb302185f6125167d4", "message": "Amazon CloudFront Update: Documentation updates for CloudFront", "committedDate": "2020-06-16T18:22:08Z", "type": "commit"}, {"oid": "3ce4fa35f3ddd05cfaf3ecfe8dec56b714fe337c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3ce4fa35f3ddd05cfaf3ecfe8dec56b714fe337c", "message": "AWS Data Exchange Update: This release fixes a bug in the AWS Data Exchange Python and NodeJS SDKs. The 'KmsKeyArn' field in the create-job API was configured to be required instead of optional. We updated this field to be optional in this release.", "committedDate": "2020-06-16T18:22:14Z", "type": "commit"}, {"oid": "74959ee9d2663d09b36ab69dc4b1b8eafc2252f1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/74959ee9d2663d09b36ab69dc4b1b8eafc2252f1", "message": "Amazon Polly Update: Amazon Polly adds new US English child voice - Kevin. Kevin is available as Neural voice only.", "committedDate": "2020-06-16T18:22:18Z", "type": "commit"}, {"oid": "590e6db45832a67092ae5b1eb63f7f883a2712bc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/590e6db45832a67092ae5b1eb63f7f883a2712bc", "message": "AWS Lambda Update: Adds support for using Amazon Elastic File System (persistent storage) with AWS Lambda. This enables customers to share data across function invocations, read large reference data files, and write function output to a persistent and shared store.", "committedDate": "2020-06-16T18:22:24Z", "type": "commit"}, {"oid": "a429fefb79b7f4c81bc0701eb691d0b0a4c912bf", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a429fefb79b7f4c81bc0701eb691d0b0a4c912bf", "message": "Auto Scaling Update: Introducing instance refresh, a feature that helps you update all instances in an Auto Scaling group in a rolling fashion (for example, to apply a new AMI or instance type). You can control the pace of the refresh by defining the percentage of the group that must remain running/healthy during the replacement process and the time for new instances to warm up between replacements.", "committedDate": "2020-06-16T18:22:30Z", "type": "commit"}, {"oid": "e82963c7d5fd7f902dda21bd19be45ba49215889", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e82963c7d5fd7f902dda21bd19be45ba49215889", "message": "Release 2.13.38. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-16T18:23:48Z", "type": "commit"}, {"oid": "4af611776e1e728dd32573baeca1e9acf3916f10", "url": "https://github.com/aws/aws-sdk-java-v2/commit/4af611776e1e728dd32573baeca1e9acf3916f10", "message": "Merge pull request #881 from aws/staging/abbfeb43-717f-4a4c-a09f-33e2e3344cf2\n\nPull request: release <- staging/abbfeb43-717f-4a4c-a09f-33e2e3344cf2", "committedDate": "2020-06-16T18:24:04Z", "type": "commit"}, {"oid": "d0e6099e03e360d654986663437faea25c3c8940", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d0e6099e03e360d654986663437faea25c3c8940", "message": "Update to next snapshot version: 2.13.39-SNAPSHOT", "committedDate": "2020-06-16T18:49:22Z", "type": "commit"}, {"oid": "2ad3b0baede9ab61bb05f0d52ab3a00c3ad39dcc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2ad3b0baede9ab61bb05f0d52ab3a00c3ad39dcc", "message": "Amazon Import/Export Snowball Update: AWS Snowcone is a portable, rugged and secure device for edge computing and data transfer. You can use Snowcone to collect, process, and move data to AWS, either offline by shipping the device to AWS or online by using AWS DataSync. With 2 CPUs and 4 GB RAM of compute and 8 TB of storage, Snowcone can run edge computing workloads and store data securely. Snowcone's small size (8.94\" x 5.85\" x 3.25\" / 227 mm x 148.6 mm x 82.65 mm) allows you to set it next to machinery in a factory. Snowcone weighs about 4.5 lbs. (2 kg), so you can carry one in a backpack, use it with battery-based operation, and use the Wi-Fi interface to gather sensor data. Snowcone supports a file interface with NFS support.", "committedDate": "2020-06-17T18:11:32Z", "type": "commit"}, {"oid": "9a2ec5524c032b004dde98f27a4b63a29d7f52e3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9a2ec5524c032b004dde98f27a4b63a29d7f52e3", "message": "AWS App Mesh Update: Adds support for route and virtual node listener timeouts.", "committedDate": "2020-06-17T18:11:38Z", "type": "commit"}, {"oid": "b7b1bdee13f0bc6cef6a1f7c4700023a4391c7a7", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b7b1bdee13f0bc6cef6a1f7c4700023a4391c7a7", "message": "Amazon Macie 2 Update: This is a documentation-only update to the Amazon Macie API. This update contains miscellaneous editorial improvements to various API descriptions.", "committedDate": "2020-06-17T18:11:42Z", "type": "commit"}, {"oid": "e7db055ed0f472076012d2bc3cccc084f5504aab", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e7db055ed0f472076012d2bc3cccc084f5504aab", "message": "Amazon Route 53 Update: Add PriorRequestNotComplete exception to AssociateVPCWithHostedZone API", "committedDate": "2020-06-17T18:11:46Z", "type": "commit"}, {"oid": "2d99c909966d5a2158091494d2b60d5dd7c3f7fb", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2d99c909966d5a2158091494d2b60d5dd7c3f7fb", "message": "Amazon Elastic Compute Cloud Update: nvmeSupport added to DescribeInstanceTypes API", "committedDate": "2020-06-17T18:11:51Z", "type": "commit"}, {"oid": "65d00fb3624d889c4b85a17650959db3bdd4be85", "url": "https://github.com/aws/aws-sdk-java-v2/commit/65d00fb3624d889c4b85a17650959db3bdd4be85", "message": "Updated endpoints.json.", "committedDate": "2020-06-17T18:12:47Z", "type": "commit"}, {"oid": "a57263925e1fac7c5a05b4983c6e1738a60e107e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a57263925e1fac7c5a05b4983c6e1738a60e107e", "message": "Release 2.13.39. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-17T18:13:19Z", "type": "commit"}, {"oid": "c7f5cadafb96909b7119b9474644c3de515d31b3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c7f5cadafb96909b7119b9474644c3de515d31b3", "message": "Merge pull request #882 from aws/staging/168e1f5a-f593-4fc8-9f6d-4a16b16eb690\n\nPull request: release <- staging/168e1f5a-f593-4fc8-9f6d-4a16b16eb690", "committedDate": "2020-06-17T18:13:32Z", "type": "commit"}, {"oid": "c6cf35e6230c0cac5475ae0580f5f1604d2263db", "url": "https://github.com/aws/aws-sdk-java-v2/commit/c6cf35e6230c0cac5475ae0580f5f1604d2263db", "message": "Update to next snapshot version: 2.13.40-SNAPSHOT", "committedDate": "2020-06-17T18:39:02Z", "type": "commit"}, {"oid": "b9b7faabb0ecd823a5ce0f7cc99a6530d5f7a82c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b9b7faabb0ecd823a5ce0f7cc99a6530d5f7a82c", "message": "Add tests for MetricUtils\n\nFollow-up on review comment on #1882", "committedDate": "2020-06-18T15:19:38Z", "type": "commit"}, {"oid": "27fbcfd88a4f5170a9a982563ca6263a8b890ffc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/27fbcfd88a4f5170a9a982563ca6263a8b890ffc", "message": "Merge pull request #1906 from dagnir/metric-utils-test\n\nMetric utils test", "committedDate": "2020-06-18T16:39:44Z", "type": "commit"}, {"oid": "6c888404d3d80e327cad33f7193473ea8018757a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6c888404d3d80e327cad33f7193473ea8018757a", "message": "Minor metrics fixes\n\n - move ServiceId and OperationName reporting into try block\n - ServiceName -> ServiceId\n - Fix typo in test", "committedDate": "2020-06-18T17:38:10Z", "type": "commit"}, {"oid": "87a7d1fd3f313f4beaec4f2144ad605ef2d8f6e3", "url": "https://github.com/aws/aws-sdk-java-v2/commit/87a7d1fd3f313f4beaec4f2144ad605ef2d8f6e3", "message": "AWS Elemental MediaConvert Update: AWS Elemental MediaConvert SDK has added support for NexGuard FileMarker SDK, which allows NexGuard partners to watermark proprietary content in mezzanine and OTT streaming contexts.", "committedDate": "2020-06-18T18:08:34Z", "type": "commit"}, {"oid": "3781e72cd921074ec86f7600880fdb3f561fa114", "url": "https://github.com/aws/aws-sdk-java-v2/commit/3781e72cd921074ec86f7600880fdb3f561fa114", "message": "Amazon Relational Database Service Update: Adding support for global write forwarding on secondary clusters in an Aurora global database.", "committedDate": "2020-06-18T18:08:39Z", "type": "commit"}, {"oid": "d32548c433b5f37d7dcfcbace9d4de441303de0d", "url": "https://github.com/aws/aws-sdk-java-v2/commit/d32548c433b5f37d7dcfcbace9d4de441303de0d", "message": "AWSMarketplace Metering Update: Documentation updates for meteringmarketplace", "committedDate": "2020-06-18T18:08:43Z", "type": "commit"}, {"oid": "8a233181d0b000599c5d60c43b85af457d530f0e", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8a233181d0b000599c5d60c43b85af457d530f0e", "message": "Amazon Route 53 Update: Added a new ListHostedZonesByVPC API for customers to list all the private hosted zones that a specified VPC is associated with.", "committedDate": "2020-06-18T18:08:48Z", "type": "commit"}, {"oid": "abbcef5a619e5f37849d212f4508c8770390019f", "url": "https://github.com/aws/aws-sdk-java-v2/commit/abbcef5a619e5f37849d212f4508c8770390019f", "message": "Amazon Simple Systems Manager (SSM) Update: Added offset support for specifying the number of days to wait after the date and time specified by a CRON expression before running the maintenance window.", "committedDate": "2020-06-18T18:08:53Z", "type": "commit"}, {"oid": "43f40f1065c4ae33c1583d5488fc74645a110724", "url": "https://github.com/aws/aws-sdk-java-v2/commit/43f40f1065c4ae33c1583d5488fc74645a110724", "message": "AWS Support Update: Documentation updates for support", "committedDate": "2020-06-18T18:08:58Z", "type": "commit"}, {"oid": "2ab3aa8903eeb075cefe8daf666ce4f863ad1af9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/2ab3aa8903eeb075cefe8daf666ce4f863ad1af9", "message": "Amazon Simple Email Service Update: You can now configure Amazon SES to send event notifications when the delivery of an email is delayed because of a temporary issue. For example, you can receive a notification if the recipient's inbox is full, or if there's a temporary problem with the receiving email server.", "committedDate": "2020-06-18T18:09:03Z", "type": "commit"}, {"oid": "6505dcb8b7385b9013ad2c28ca407cc624e2a4ad", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6505dcb8b7385b9013ad2c28ca407cc624e2a4ad", "message": "Updated endpoints.json.", "committedDate": "2020-06-18T18:09:54Z", "type": "commit"}, {"oid": "b95eed75eeed088ca779106b1d5aca033960c749", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b95eed75eeed088ca779106b1d5aca033960c749", "message": "Release 2.13.40. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-18T18:10:25Z", "type": "commit"}, {"oid": "b21260b6626af4ae93cfe3a47aca0d0367e4e192", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b21260b6626af4ae93cfe3a47aca0d0367e4e192", "message": "Merge pull request #883 from aws/staging/147ef832-4a45-465d-9a5e-80bdf1d9b1c3\n\nPull request: release <- staging/147ef832-4a45-465d-9a5e-80bdf1d9b1c3", "committedDate": "2020-06-18T18:10:42Z", "type": "commit"}, {"oid": "8c192e3b04892987bf0872f76ba4f65167f3a872", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8c192e3b04892987bf0872f76ba4f65167f3a872", "message": "Additional tests for IOException for core metrics", "committedDate": "2020-06-18T18:21:54Z", "type": "commit"}, {"oid": "5cb4fe24cdef0f1ef540a991281326442e132f31", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5cb4fe24cdef0f1ef540a991281326442e132f31", "message": "Update to next snapshot version: 2.13.41-SNAPSHOT", "committedDate": "2020-06-18T18:35:49Z", "type": "commit"}, {"oid": "7ad50b23010aafab035c1eb46b23eee9c3c34162", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7ad50b23010aafab035c1eb46b23eee9c3c34162", "message": "AWS Elemental MediaLive Update: AWS Elemental MediaLive now supports Input Prepare schedule actions. This feature improves existing input switching by allowing users to prepare an input prior to switching to it.", "committedDate": "2020-06-19T18:12:48Z", "type": "commit"}, {"oid": "a0eb951831d568ac8b5f8e242c180ecb051c9cfc", "url": "https://github.com/aws/aws-sdk-java-v2/commit/a0eb951831d568ac8b5f8e242c180ecb051c9cfc", "message": "AWS OpsWorks CM Update: Documentation updates for AWS OpsWorks CM.", "committedDate": "2020-06-19T18:12:54Z", "type": "commit"}, {"oid": "bc19e9cbc313a612d3abaf7df0b69bc6edd7efa5", "url": "https://github.com/aws/aws-sdk-java-v2/commit/bc19e9cbc313a612d3abaf7df0b69bc6edd7efa5", "message": "Amazon ElastiCache Update: Documentation updates for elasticache", "committedDate": "2020-06-19T18:13:00Z", "type": "commit"}, {"oid": "47f823de9bdc306a0c5c0d4e851a49f4afb5c790", "url": "https://github.com/aws/aws-sdk-java-v2/commit/47f823de9bdc306a0c5c0d4e851a49f4afb5c790", "message": "Amazon Elastic Compute Cloud Update: Adds support to tag elastic-gpu on the RunInstances api", "committedDate": "2020-06-19T18:13:05Z", "type": "commit"}, {"oid": "7e1fde9a1be9f919bd85f232d75bdfa61e571cfa", "url": "https://github.com/aws/aws-sdk-java-v2/commit/7e1fde9a1be9f919bd85f232d75bdfa61e571cfa", "message": "Updated endpoints.json.", "committedDate": "2020-06-19T18:13:54Z", "type": "commit"}, {"oid": "8347049cb78bc137032d71f881256165d393fd7a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/8347049cb78bc137032d71f881256165d393fd7a", "message": "Release 2.13.41. Updated CHANGELOG.md, README.md and all pom.xml.", "committedDate": "2020-06-19T18:14:25Z", "type": "commit"}, {"oid": "5418aa6707c7a5f8cdb9ab725df1df422444e208", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5418aa6707c7a5f8cdb9ab725df1df422444e208", "message": "Merge pull request #884 from aws/staging/3a1ce293-b1b5-4c61-a023-ae65fbf2ca30\n\nPull request: release <- staging/3a1ce293-b1b5-4c61-a023-ae65fbf2ca30", "committedDate": "2020-06-19T18:14:40Z", "type": "commit"}, {"oid": "b58330a5fbd9fe131fc8d4b7d0e0d7a768c18829", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b58330a5fbd9fe131fc8d4b7d0e0d7a768c18829", "message": "Update to next snapshot version: 2.13.42-SNAPSHOT", "committedDate": "2020-06-19T18:39:54Z", "type": "commit"}, {"oid": "b8279d02acd2949ecd5ab499b3f0a45b7ab51d88", "url": "https://github.com/aws/aws-sdk-java-v2/commit/b8279d02acd2949ecd5ab499b3f0a45b7ab51d88", "message": "Amazon Relational Database Service Update: Added paginators for various APIs.", "committedDate": "2020-06-22T18:08:29Z", "type": "commit"}]}