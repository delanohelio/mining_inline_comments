{"pr_number": 2012, "pr_title": "Immutables support in DynamoDb Enhanced Client", "pr_createdAt": "2020-08-30T20:54:27Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/2012", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzNTM5Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480335396", "bodyText": "I see I missed some javadocs for these new interface methods. Will add those shortly.", "author": "bmaizels", "createdAt": "2020-08-31T19:13:33Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,18 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    Collection<Index> indices();", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\nindex 4586af093a..a8beb61ed6 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n\n@@ -79,10 +79,24 @@ public interface TableMetadata {\n     @Deprecated\n     Collection<String> allKeys();\n \n+    /**\n+     * Returns all the indices known for this table.\n+     * @return A collection of {@link Index} containing information about the indices.\n+     */\n     Collection<Index> indices();\n \n+    /**\n+     * Returns all custom metadata for this table. These entries are used by extensions to the library, therefore the\n+     * value of each metadata object stored in the map is not known and is provided as {@link Object}.\n+     * @return A map of all the custom metadata for this table.\n+     */\n     Map<String, Object> customMetadata();\n \n+    /**\n+     * Returns metadata about all the known 'key' attributes for this table, such as primary and secondary index keys,\n+     * or any other attribute that forms part of the structure of the table.\n+     * @return A collection of {@link Key} containing information about the keys.\n+     */\n     Collection<Key> keyAttributes();\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzNTkzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480335930", "bodyText": "I see a typo in 'delcared'. Will fix.", "author": "bmaizels", "createdAt": "2020-08-31T19:14:06Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java", "diffHunk": "@@ -43,6 +47,21 @@\n         return StaticTableSchema.builder(itemClass);\n     }\n \n+    /**\n+     * Returns a builder for the {@link StaticImmutableTableSchema} implementation of this interface which allows all\n+     * attributes, tags and table structure to be directly delcared in the builder.", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\nindex d06ddc711a..fcc98b6baf 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\n\n@@ -49,7 +49,7 @@ public interface TableSchema<T> {\n \n     /**\n      * Returns a builder for the {@link StaticImmutableTableSchema} implementation of this interface which allows all\n-     * attributes, tags and table structure to be directly delcared in the builder.\n+     * attributes, tags and table structure to be directly declared in the builder.\n      * @param immutableItemClass The class of the immutable item this {@link TableSchema} will map records to.\n      * @param immutableBuilderClass The class that can be used to construct immutable items this {@link TableSchema}\n      *                              maps records to.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzODY2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480338668", "bodyText": "I am thinking I should add 'implements TableSchema' here because WrappedTableSchema is an internal class and I want the TableSchema interface to be part of the public contract of this class.", "author": "bmaizels", "createdAt": "2020-08-31T19:16:58Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java", "diffHunk": "@@ -41,72 +40,61 @@\n import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;\n import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n-import software.amazon.awssdk.enhanced.dynamodb.TableMetadata;\n import software.amazon.awssdk.enhanced.dynamodb.TableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeGetter;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSetter;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbConvertedBy;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n-import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n \n /**\n  * Implementation of {@link TableSchema} that builds a table schema based on properties and annotations of a bean\n  * class. Example:\n  * <pre>\n  * <code>\n  * {@literal @}DynamoDbBean\n- * public class CustomerAccount {\n- *     private String unencryptedBillingKey;\n+ * public class Customer {\n+ *     private String accountId;\n+ *     private int subId;            // primitive types are supported\n+ *     private String name;\n+ *     private Instant createdDate;\n  *\n  *     {@literal @}DynamoDbPartitionKey\n- *     {@literal @}DynamoDbSecondarySortKey(indexName = \"accounts_by_customer\")\n- *     public String accountId;\n+ *     public String getAccountId() { return this.accountId; }\n+ *     public void setAccountId(String accountId) { this.accountId = accountId; }\n  *\n  *     {@literal @}DynamoDbSortKey\n- *     {@literal @}DynamoDbSecondaryPartitionKey(indexName = \"accounts_by_customer\")\n- *     public String customerId;\n- *\n- *     {@literal @}DynamoDbAttribute(\"account_status\")\n- *     public CustomerAccountStatus status;\n- *\n- *     {@literal @}DynamoDbFlatten(dynamoDbBeanClass = Customer.class)\n- *     public Customer customer;\n- *\n- *     public Instant createdOn;\n+ *     public int getSubId() { return this.subId; }\n+ *     public void setSubId(int subId) { this.subId = subId; }\n  *\n- *     // All public fields must be opted out to not participate in mapping\n- *     {@literal @}DynamoDbIgnore\n- *     public String internalKey;\n+ *     // Defines a GSI (customers_by_name) with a partition key of 'name'\n+ *     {@literal @}DynamoDbSecondaryPartitionKey(indexNames = \"customers_by_name\")\n+ *     public String getName() { return this.name; }\n+ *     public void setName(String name) { this.name = name; }\n  *\n- *     public enum CustomerAccountStatus {\n- *         ACTIVE,\n- *         CLOSED\n- *     }\n+ *     // Defines an LSI (customers_by_date) with a sort key of 'createdDate' and also declares the\n+ *     // same attribute as a sort key for the GSI named 'customers_by_name'\n+ *     {@literal @}DynamoDbSecondarySortKey(indexNames = {\"customers_by_date\", \"customers_by_name\"})\n+ *     public Instant getCreatedDate() { return this.createdDate; }\n+ *     public void setCreatedDate(Instant createdDate) { this.createdDate = createdDate; }\n  * }\n- * </code>\n- * {@literal @}DynamoDbBean\n- * public class Customer {\n- *     public String name;\n  *\n- *     {@literal public List<String> address;}\n- * }\n- * }\n  * </pre>\n+ *\n  * @param <T> The type of object that this {@link TableSchema} maps to.\n  */\n @SdkPublicApi\n-public final class BeanTableSchema<T> implements TableSchema<T> {\n+public final class BeanTableSchema<T> extends WrappedTableSchema<T, StaticTableSchema<T>> {", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java\nindex 336fa1fc21..f342bd9ab5 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/BeanTableSchema.java\n\n@@ -44,7 +44,6 @@ import software.amazon.awssdk.enhanced.dynamodb.TableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeGetter;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSetter;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzOTM2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480339368", "bodyText": "I am thinking I should add 'implements TableSchema' here because WrappedTableSchema is an internal class and I want the TableSchema interface to be part of the public contract of this class.", "author": "bmaizels", "createdAt": "2020-08-31T19:17:42Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.mapper;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n+import software.amazon.awssdk.enhanced.dynamodb.TableSchema;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutableInfo;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutableIntrospector;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.immutable.ImmutablePropertyDescriptor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeGetter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSetter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectGetterMethod;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.StaticGetterMethod;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbConvertedBy;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbFlatten;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+/**\n+ * Implementation of {@link TableSchema} that builds a table schema based on properties and annotations of an immutable\n+ * class with an associated builder class. Example:\n+ * <pre>\n+ * <code>\n+ * {@literal @}DynamoDbImmutable(builder = Customer.Builder.class)\n+ * public class Customer {\n+ *     {@literal @}DynamoDbPartitionKey\n+ *     public String accountId() { ... }\n+ *\n+ *     {@literal @}DynamoDbSortKey\n+ *     public int subId() { ... }\n+ *\n+ *     // Defines a GSI (customers_by_name) with a partition key of 'name'\n+ *     {@literal @}DynamoDbSecondaryPartitionKey(indexNames = \"customers_by_name\")\n+ *     public String name() { ... }\n+ *\n+ *     // Defines an LSI (customers_by_date) with a sort key of 'createdDate' and also declares the\n+ *     // same attribute as a sort key for the GSI named 'customers_by_name'\n+ *     {@literal @}DynamoDbSecondarySortKey(indexNames = {\"customers_by_date\", \"customers_by_name\"})\n+ *     public Instant createdDate() { ... }\n+ *\n+ *     // Not required to be an inner-class, but builders often are\n+ *     public static final class Builder {\n+ *         public Builder accountId(String accountId) { ... };\n+ *         public Builder subId(int subId) { ... };\n+ *         public Builder name(String name) { ... };\n+ *         public Builder createdDate(Instant createdDate) { ... };\n+ *\n+ *         public Customer build() { ... };\n+ *     }\n+ * }\n+ *\n+ * </pre>\n+ * @param <T> The type of object that this {@link TableSchema} maps to.\n+ */\n+@SdkPublicApi\n+public final class ImmutableTableSchema<T> extends WrappedTableSchema<T, StaticImmutableTableSchema<T, ?>> {", "originalCommit": "09d6fa660d2853d4239a5add3e0fce75328085d9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java\nindex bb24e107c2..8b8a5f1402 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/ImmutableTableSchema.java\n\n@@ -44,7 +44,6 @@ import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.BeanAttributeSet\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectConstructor;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.ObjectGetterMethod;\n import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.StaticGetterMethod;\n-import software.amazon.awssdk.enhanced.dynamodb.internal.mapper.WrappedTableSchema;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.BeanTableSchemaAttributeTag;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbAttribute;\n import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean;\n"}}, {"oid": "efffc864d0cddee3fc785c48804ac617c1aa25fd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/efffc864d0cddee3fc785c48804ac617c1aa25fd", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-08-31T22:48:20Z", "type": "forcePushed"}, {"oid": "1d08b9f31ecae9a8d757d50e51bc5a1f8cd91227", "url": "https://github.com/aws/aws-sdk-java-v2/commit/1d08b9f31ecae9a8d757d50e51bc5a1f8cd91227", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T01:18:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3ODUxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480478518", "bodyText": "What does 'if a class is used as a document within .. ' mean?", "author": "cenedhryn", "createdAt": "2020-08-31T23:52:11Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.mapper.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.DefaultAttributeConverterProvider;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;\n+\n+/**\n+ * Class level annotation that identifies this class as being a DynamoDb mappable entity. Any class used to initialize\n+ * a {@link ImmutableTableSchema} must have this annotation. If a class is used as a document within another annotated", "originalCommit": "0e74c847f8447ea426c5146374feaf57e08f7a7f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java\nindex 1fda12a2ac..7dc79af6fa 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/mapper/annotations/DynamoDbImmutable.java\n\n@@ -27,8 +27,9 @@ import software.amazon.awssdk.enhanced.dynamodb.mapper.ImmutableTableSchema;\n \n /**\n  * Class level annotation that identifies this class as being a DynamoDb mappable entity. Any class used to initialize\n- * a {@link ImmutableTableSchema} must have this annotation. If a class is used as a document within another annotated\n- * DynamoDb class, it will also require this annotation.\n+ * a {@link ImmutableTableSchema} must have this annotation. If a class is used as an attribute type within another\n+ * annotated DynamoDb class, either as a document or flattened with the {@link DynamoDbFlatten} annotation, it will also\n+ * require this annotation to work automatically without an explicit {@link AttributeConverter}.\n  * <p>\n  * <b>Attribute Converter Providers</b><br>\n  * Using {@link AttributeConverterProvider}s is optional and, if used, the supplied provider supersedes the default\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDUxOTkxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r480519918", "bodyText": "Why is this commented out?", "author": "cenedhryn", "createdAt": "2020-09-01T00:58:04Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java", "diffHunk": "@@ -204,26 +204,25 @@ public void build_addAttributeConverter() {\n         assertThat(attributeConverterR).isEqualTo(attributeConverter);\n     }\n \n-    @Test\n-    public void resolve_uses_customConverter() {\n-        when(attributeConverter.transformFrom(any())).thenReturn(AttributeValue.builder().s(\"test-string-custom\").build());\n-\n-        StaticAttribute<SimpleItem, String> staticAttribute = StaticAttribute.builder(SimpleItem.class, String.class)\n-                                                                         .name(\"test-attribute\")\n-                                                                         .getter(SimpleItem::getAString)\n-                                                                         .setter(SimpleItem::setAString)\n-                                                                         .attributeConverter(attributeConverter)\n-                                                                         .build();\n-\n-        ResolvedStaticAttribute<SimpleItem> resolvedAttribute =\n-            staticAttribute.resolve(AttributeConverterProvider.defaultProvider());\n-\n-        Function<SimpleItem, AttributeValue> attributeValueFunction = resolvedAttribute.attributeGetterMethod();\n-\n-        SimpleItem item = new SimpleItem(\"test-string\");\n-        AttributeValue resultAttributeValue = attributeValueFunction.apply(item);\n-\n-        assertThat(resultAttributeValue.s()).isEqualTo(\"test-string-custom\");\n-    }\n-\n+//    @Test", "originalCommit": "0e74c847f8447ea426c5146374feaf57e08f7a7f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java b/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java\nindex e1a40f94f4..2cb25f45d4 100644\n--- a/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java\n+++ b/services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/mapper/StaticAttributeTest.java\n\n@@ -203,26 +161,4 @@ public class StaticAttributeTest {\n         AttributeConverter<String> attributeConverterR = staticAttribute.attributeConverter();\n         assertThat(attributeConverterR).isEqualTo(attributeConverter);\n     }\n-\n-//    @Test\n-//    public void resolve_uses_customConverter() {\n-//        when(attributeConverter.transformFrom(any())).thenReturn(AttributeValue.builder().s(\"test-string-custom\").build());\n-//\n-//        StaticAttribute<SimpleItem, String> staticAttribute = StaticAttribute.builder(SimpleItem.class, String.class)\n-//                                                                         .name(\"test-attribute\")\n-//                                                                         .getter(SimpleItem::getAString)\n-//                                                                         .setter(SimpleItem::setAString)\n-//                                                                         .attributeConverter(attributeConverter)\n-//                                                                         .build();\n-//\n-//        ResolvedStaticAttribute<SimpleItem> resolvedAttribute =\n-//            staticAttribute.resolve(AttributeConverterProvider.defaultProvider());\n-//\n-//        Function<SimpleItem, AttributeValue> attributeValueFunction = resolvedAttribute.attributeGetterMethod();\n-//\n-//        SimpleItem item = new SimpleItem(\"test-string\");\n-//        AttributeValue resultAttributeValue = attributeValueFunction.apply(item);\n-//\n-//        assertThat(resultAttributeValue.s()).isEqualTo(\"test-string-custom\");\n-//    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI3NjQwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481276405", "bodyText": "Nit: 'known indices'", "author": "cenedhryn", "createdAt": "2020-09-01T16:26:08Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,36 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    /**\n+     * Returns all the indices known for this table.", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\nindex b18dd10399..40d5ffce02 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n\n@@ -80,10 +80,10 @@ public interface TableMetadata {\n     Collection<String> allKeys();\n \n     /**\n-     * Returns all the indices known for this table.\n-     * @return A collection of {@link Index} containing information about the indices.\n+     * Returns metadata about all the known indices for this table.\n+     * @return A collection of {@link IndexMetadata} containing information about the indices.\n      */\n-    Collection<Index> indices();\n+    Collection<IndexMetadata> indices();\n \n     /**\n      * Returns all custom metadata for this table. These entries are used by extensions to the library, therefore the\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI4NDM3OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481284378", "bodyText": "It may be confusing to users that there is an Index interface that they can't use as an index but instead contains metadata.\nIndex is a nested interface but StaticIndex is a top level class\n\nHave you considered alternative code organization such as top level interface IndexMetadata, for consistency? Naming with metadata would also alleviate mixups with customers trying to use Index and Key for actual queries, which would seem logical to me if I was a user.", "author": "cenedhryn", "createdAt": "2020-09-01T16:39:49Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -124,4 +152,39 @@ static String primaryIndexName() {\n         // actions of a client, so it should not be altered unless absolutely necessary.\n         return \"$PRIMARY_INDEX\";\n     }\n+\n+    /**\n+     * A metadata class that stores information about an index\n+     */\n+    interface Index {", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\nindex b18dd10399..40d5ffce02 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n\n@@ -152,39 +152,4 @@ public interface TableMetadata {\n         // actions of a client, so it should not be altered unless absolutely necessary.\n         return \"$PRIMARY_INDEX\";\n     }\n-\n-    /**\n-     * A metadata class that stores information about an index\n-     */\n-    interface Index {\n-        /**\n-         * The name of the index\n-         */\n-        String name();\n-\n-        /**\n-         * The partition key for the index; if there is one.\n-         */\n-        Optional<Key> partitionKey();\n-\n-        /**\n-         * The sort key for the index; if there is one.\n-         */\n-        Optional<Key> sortKey();\n-    }\n-\n-    /**\n-     * A metadata class that stores information about a key attribute\n-     */\n-    interface Key {\n-        /**\n-         * The name of the key attribute\n-         */\n-        String name();\n-\n-        /**\n-         * The DynamoDB type of the key attribute\n-         */\n-        AttributeValueType attributeValueType();\n-    }\n }\n"}}, {"oid": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/9ce7a3f59bb19b87c20381efb9da33f05522798c", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T18:58:45Z", "type": "forcePushed"}, {"oid": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6f1405f00d6bb4880739a17e544db8d881d6d24a", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T19:11:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjI2Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481372267", "bodyText": "nit, <p> \ud83d\ude1b", "author": "zoewangg", "createdAt": "2020-09-01T19:11:33Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java", "diffHunk": "@@ -72,9 +73,36 @@\n      * attribute when using the versioned record extension.\n      *\n      * @return A collection of all key attribute names for the table.\n+     *\n+     * @deprecated Use {@link #keyAttributes()} instead.\n      */\n+    @Deprecated\n     Collection<String> allKeys();\n \n+    /**\n+     * Returns metadata about all the known indices for this table.\n+     * @return A collection of {@link IndexMetadata} containing information about the indices.\n+     */\n+    Collection<IndexMetadata> indices();\n+\n+    /**\n+     * Returns all custom metadata for this table. These entries are used by extensions to the library, therefore the\n+     * value type of each metadata object stored in the map is not known and is provided as {@link Object}.\n+     *", "originalCommit": "9ce7a3f59bb19b87c20381efb9da33f05522798c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjc0Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402746", "bodyText": "Will fix.", "author": "bmaizels", "createdAt": "2020-09-01T20:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3MjI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "08945b911393841c37d72bfb38524fef1ba391b1", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\nindex 40d5ffce02..a7249a5a7b 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableMetadata.java\n\n@@ -88,7 +88,7 @@ public interface TableMetadata {\n     /**\n      * Returns all custom metadata for this table. These entries are used by extensions to the library, therefore the\n      * value type of each metadata object stored in the map is not known and is provided as {@link Object}.\n-     *\n+     * <p>\n      * This method should not be used to inspect individual custom metadata objects, instead use\n      * {@link TableMetadata#customMetadataObject(String, Class)} ()} as that will perform a type-safety check on the\n      * retrieved object.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDAzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481374030", "bodyText": "Can we add more javadocs to explain the definition of abstract here since abstract is an overloaded term?", "author": "zoewangg", "createdAt": "2020-09-01T19:14:57Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java", "diffHunk": "@@ -115,4 +172,17 @@\n      * @return The {@link EnhancedType} of the modelled item this TableSchema maps to.\n      */\n     EnhancedType<T> itemType();\n+\n+    /**\n+     * Returns a complete list of attribute names that are mapped by this {@link TableSchema}\n+     */\n+    List<String> attributeNames();\n+\n+    /**\n+     * A boolean value that represents whether this {@link TableSchema} is abstract.\n+     *\n+     * @return true if it is abstract, and therefore cannot be used directly to create records but can be referred to\n+     * by other schemata, and false if it is concrete and may be used to map records directly.\n+     */\n+    boolean isAbstract();", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjgyMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402820", "bodyText": "Okay. +1", "author": "bmaizels", "createdAt": "2020-09-01T20:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NDAzMA=="}], "type": "inlineReview", "revised_code": {"commit": "08945b911393841c37d72bfb38524fef1ba391b1", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\nindex fcc98b6baf..82a133eb3b 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/TableSchema.java\n\n@@ -179,7 +179,9 @@ public interface TableSchema<T> {\n     List<String> attributeNames();\n \n     /**\n-     * A boolean value that represents whether this {@link TableSchema} is abstract.\n+     * A boolean value that represents whether this {@link TableSchema} is abstract which means that it cannot be used\n+     * to directly create records as it is lacking required structural elements to map to a table, such as a primary\n+     * key, but can be referred to and embedded by other schemata.\n      *\n      * @return true if it is abstract, and therefore cannot be used directly to create records but can be referred to\n      * by other schemata, and false if it is concrete and may be used to map records directly.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTQ1Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481375452", "bodyText": "Can we break up the if statement a bit, like creating variables with meaningful names? seems a bit hard to read with so many predicates.", "author": "zoewangg", "createdAt": "2020-09-01T19:17:47Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));\n+\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        return INSTANCE.introspect(immutableClass);\n+    }\n+\n+    private static boolean isMappableMethod(Method method) {\n+        return method.getDeclaringClass() != Object.class\n+            && method.getAnnotation(DynamoDbIgnore.class) == null\n+            && !method.isSynthetic()\n+            && !method.isBridge()\n+            && !Modifier.isStatic(method.getModifiers())\n+            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    }\n+\n+    private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n+        Class<?> builderClass = validateAndGetBuilderClass(immutableClass);\n+        Optional<Method> staticBuilderMethod = findStaticBuilderMethod(immutableClass, builderClass);\n+        List<Method> getters = filterAndCollectGetterMethods(immutableClass.getMethods());\n+        Map<String, Method> indexedBuilderMethods = filterAndIndexBuilderMethods(builderClass.getMethods());\n+        Method buildMethod = extractBuildMethod(indexedBuilderMethods, immutableClass)\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\n+                    \"An immutable builder class must have a public method named 'build()' that takes no arguments \" +\n+                        \"and returns an instance of the immutable class it builds\"));\n+\n+        List<ImmutablePropertyDescriptor> propertyDescriptors =\n+            getters.stream()\n+                   .map(getter -> {\n+                       validateGetter(getter);\n+                       String propertyName = normalizeGetterName(getter);\n+\n+                       Method setter = extractSetterMethod(propertyName, indexedBuilderMethods, getter, builderClass)\n+                           .orElseThrow(\n+                               () -> generateExceptionForMethod(\n+                                   getter,\n+                                   \"A method was found on the immutable class that does not appear to have a \" +\n+                                       \"matching setter on the builder class.\"));\n+\n+                       return ImmutablePropertyDescriptor.create(propertyName, getter, setter);\n+                   }).collect(Collectors.toList());\n+\n+        if (!indexedBuilderMethods.isEmpty()) {\n+            throw generateExceptionForMethod(indexedBuilderMethods.values().iterator().next(),\n+                                             \"A method was found on the immutable class builder that does not appear \" +\n+                                                 \"to have a matching getter on the immutable class.\");\n+        }\n+\n+        return ImmutableInfo.builder(immutableClass)\n+                            .builderClass(builderClass)\n+                            .staticBuilderMethod(staticBuilderMethod.orElse(null))\n+                            .buildMethod(buildMethod)\n+                            .propertyDescriptors(propertyDescriptors)\n+                            .build();\n+    }\n+\n+    private Optional<Method> findStaticBuilderMethod(Class<?> immutableClass, Class<?> builderClass) {\n+        try {\n+            Method method = immutableClass.getMethod(BUILDER_METHOD);\n+\n+            if (Modifier.isStatic(method.getModifiers()) && method.getReturnType().isAssignableFrom(builderClass)) {\n+                return Optional.of(method);\n+            }\n+        } catch (NoSuchMethodException ignored) {\n+            // no-op\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private IllegalArgumentException generateExceptionForMethod(Method getter, String message) {\n+        return new IllegalArgumentException(\n+            message + \" Use the @DynamoDbIgnore annotation on the method if you do not want it to be included in the \" +\n+                \"TableSchema introspection. [Method = \\\"\" + getter + \"\\\"]\");\n+    }\n+\n+    private Class<?> validateAndGetBuilderClass(Class<?> immutableClass) {\n+        DynamoDbImmutable dynamoDbImmutable = immutableClass.getAnnotation(DynamoDbImmutable.class);\n+\n+        if (dynamoDbImmutable == null) {\n+            throw new IllegalArgumentException(\"A DynamoDb immutable class must be annotated with @DynamoDbImmutable\");\n+        }\n+\n+        return dynamoDbImmutable.builder();\n+    }\n+\n+    private void validateGetter(Method getter) {\n+        if (getter.getReturnType() == void.class || getter.getReturnType() == Void.class) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to the return type being void.\");\n+        }\n+\n+        if (getter.getParameterCount() != 0) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to it having one or more parameters.\");\n+        }\n+    }\n+\n+    private List<Method> filterAndCollectGetterMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, Method> filterAndIndexBuilderMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toMap(this::normalizeSetterName, m -> m));\n+    }\n+\n+    private String normalizeSetterName(Method setter) {\n+        String setterName = setter.getName();\n+\n+        if (setterName.length() > 3\n+            && Character.isUpperCase(setterName.charAt(3))\n+            && setterName.startsWith(SET_PREFIX)) {\n+\n+            return Character.toLowerCase(setterName.charAt(3)) + setterName.substring(4);\n+        }\n+\n+        return setterName;\n+    }\n+\n+    private String normalizeGetterName(Method getter) {\n+        String getterName = getter.getName();\n+\n+        if (getterName.length() > 2\n+            && Character.isUpperCase(getterName.charAt(2))\n+            && getterName.startsWith(IS_PREFIX)\n+            && isMethodBoolean(getter)) {\n+\n+            return Character.toLowerCase(getterName.charAt(2)) + getterName.substring(3);\n+        }\n+\n+        if (getterName.length() > 3\n+            && Character.isUpperCase(getterName.charAt(3))\n+            && getterName.startsWith(GET_PREFIX)) {\n+\n+            return Character.toLowerCase(getterName.charAt(3)) + getterName.substring(4);\n+        }\n+\n+        return getterName;\n+    }\n+\n+    private boolean isMethodBoolean(Method method) {\n+        return method.getReturnType() == boolean.class || method.getReturnType() == Boolean.class;\n+    }\n+\n+    private Optional<Method> extractBuildMethod(Map<String, Method> indexedBuilderMethods, Class<?> immutableClass) {\n+        Method buildMethod = indexedBuilderMethods.get(BUILD_METHOD);\n+\n+        if (buildMethod == null\n+            || buildMethod.getParameterCount() != 0\n+            || !immutableClass.equals(buildMethod.getReturnType())) {\n+\n+            return Optional.empty();\n+        }\n+\n+        indexedBuilderMethods.remove(BUILD_METHOD);\n+        return Optional.of(buildMethod);\n+    }\n+\n+    private Optional<Method> extractSetterMethod(String propertyName,\n+                                                 Map<String, Method> indexedBuilderMethods,\n+                                                 Method getterMethod,\n+                                                 Class<?> builderClass) {\n+        Method setterMethod = indexedBuilderMethods.get(propertyName);\n+\n+        if (setterMethod == null", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjkwNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481402907", "bodyText": "Okay. +1", "author": "bmaizels", "createdAt": "2020-09-01T20:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTQ1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "08945b911393841c37d72bfb38524fef1ba391b1", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\nindex d930179640..af70594692 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n\n@@ -30,31 +30,34 @@ import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmut\n \n @SdkInternalApi\n public class ImmutableIntrospector {\n-    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n     private static final String BUILD_METHOD = \"build\";\n     private static final String BUILDER_METHOD = \"builder\";\n     private static final String GET_PREFIX = \"get\";\n     private static final String IS_PREFIX = \"is\";\n     private static final String SET_PREFIX = \"set\";\n \n+    private static volatile ImmutableIntrospector INSTANCE = null;\n+\n     // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n     // that matches a method defined on Object.\n-    private static final Set<String> NAMES_TO_EXCLUDE =\n-        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n-                                          .map(Method::getName)\n-                                          .collect(Collectors.toSet()));\n+    private final Set<String> namesToExclude;\n \n-    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n-        return INSTANCE.introspect(immutableClass);\n+    private ImmutableIntrospector() {\n+        this.namesToExclude = Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                                                .map(Method::getName)\n+                                                                .collect(Collectors.toSet()));\n     }\n \n-    private static boolean isMappableMethod(Method method) {\n-        return method.getDeclaringClass() != Object.class\n-            && method.getAnnotation(DynamoDbIgnore.class) == null\n-            && !method.isSynthetic()\n-            && !method.isBridge()\n-            && !Modifier.isStatic(method.getModifiers())\n-            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        if (INSTANCE == null) {\n+            synchronized (ImmutableIntrospector.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = new ImmutableIntrospector();\n+                }\n+            }\n+        }\n+\n+        return INSTANCE.introspect(immutableClass);\n     }\n \n     private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481329211", "bodyText": "Can we do this in a constructor and make the singleton lazily-initialized so that we only do this if getImmutableInfo is invoked? That also has the slight advantage of using the classloader that invokes getImmutableInfo (the first time), not the one that statically initializes the class... not that I expect the methods on Object to change much between classloaders.", "author": "millems", "createdAt": "2020-09-01T17:56:52Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));", "originalCommit": "a41407c5c9d5dad51484306b3eec42425a4e80e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzgyNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481403824", "bodyText": "I was trying not to synchronize as the static class loader path is guaranteed to be thread synchronized. Do you think it would be preferable to do a synchronized double-null-check type lazy initialization here?", "author": "bmaizels", "createdAt": "2020-09-01T20:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTE5Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481405197", "bodyText": "Since it's not a big deal if we double-initialize, doing a synchronized double-null-check lazy initialization wouldn't even need to be on a volatile variable. It would probably be the best of both worlds.", "author": "millems", "createdAt": "2020-09-01T20:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MjMzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481472333", "bodyText": "Okay, will do that and make it non-volatile.", "author": "bmaizels", "createdAt": "2020-09-01T22:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4ODkwOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481488909", "bodyText": "As discussed offline and due to spotbug's protests we'll make this volatile after all.", "author": "bmaizels", "createdAt": "2020-09-01T23:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyOTIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "08945b911393841c37d72bfb38524fef1ba391b1", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\nindex d930179640..af70594692 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n\n@@ -30,31 +30,34 @@ import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmut\n \n @SdkInternalApi\n public class ImmutableIntrospector {\n-    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n     private static final String BUILD_METHOD = \"build\";\n     private static final String BUILDER_METHOD = \"builder\";\n     private static final String GET_PREFIX = \"get\";\n     private static final String IS_PREFIX = \"is\";\n     private static final String SET_PREFIX = \"set\";\n \n+    private static volatile ImmutableIntrospector INSTANCE = null;\n+\n     // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n     // that matches a method defined on Object.\n-    private static final Set<String> NAMES_TO_EXCLUDE =\n-        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n-                                          .map(Method::getName)\n-                                          .collect(Collectors.toSet()));\n+    private final Set<String> namesToExclude;\n \n-    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n-        return INSTANCE.introspect(immutableClass);\n+    private ImmutableIntrospector() {\n+        this.namesToExclude = Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                                                .map(Method::getName)\n+                                                                .collect(Collectors.toSet()));\n     }\n \n-    private static boolean isMappableMethod(Method method) {\n-        return method.getDeclaringClass() != Object.class\n-            && method.getAnnotation(DynamoDbIgnore.class) == null\n-            && !method.isSynthetic()\n-            && !method.isBridge()\n-            && !Modifier.isStatic(method.getModifiers())\n-            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        if (INSTANCE == null) {\n+            synchronized (ImmutableIntrospector.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = new ImmutableIntrospector();\n+                }\n+            }\n+        }\n+\n+        return INSTANCE.introspect(immutableClass);\n     }\n \n     private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481394108", "bodyText": "Should we make \"is bean style\" an annotation setting, instead of trying to guess by looking at the method names? I'm worried about an attribute starting with \"Set\" being magically messed up because we're trying to be too clever.\nE.g. A customer probably wants a \"setOfStuff\" attribute to be stored as \"setOfStuff\", not \"ofStuff\".", "author": "millems", "createdAt": "2020-09-01T19:54:05Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.enhanced.dynamodb.internal.immutable;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbIgnore;\n+import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmutable;\n+\n+@SdkInternalApi\n+public class ImmutableIntrospector {\n+    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n+    private static final String BUILD_METHOD = \"build\";\n+    private static final String BUILDER_METHOD = \"builder\";\n+    private static final String GET_PREFIX = \"get\";\n+    private static final String IS_PREFIX = \"is\";\n+    private static final String SET_PREFIX = \"set\";\n+\n+    // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n+    // that matches a method defined on Object.\n+    private static final Set<String> NAMES_TO_EXCLUDE =\n+        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                          .map(Method::getName)\n+                                          .collect(Collectors.toSet()));\n+\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        return INSTANCE.introspect(immutableClass);\n+    }\n+\n+    private static boolean isMappableMethod(Method method) {\n+        return method.getDeclaringClass() != Object.class\n+            && method.getAnnotation(DynamoDbIgnore.class) == null\n+            && !method.isSynthetic()\n+            && !method.isBridge()\n+            && !Modifier.isStatic(method.getModifiers())\n+            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    }\n+\n+    private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n+        Class<?> builderClass = validateAndGetBuilderClass(immutableClass);\n+        Optional<Method> staticBuilderMethod = findStaticBuilderMethod(immutableClass, builderClass);\n+        List<Method> getters = filterAndCollectGetterMethods(immutableClass.getMethods());\n+        Map<String, Method> indexedBuilderMethods = filterAndIndexBuilderMethods(builderClass.getMethods());\n+        Method buildMethod = extractBuildMethod(indexedBuilderMethods, immutableClass)\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\n+                    \"An immutable builder class must have a public method named 'build()' that takes no arguments \" +\n+                        \"and returns an instance of the immutable class it builds\"));\n+\n+        List<ImmutablePropertyDescriptor> propertyDescriptors =\n+            getters.stream()\n+                   .map(getter -> {\n+                       validateGetter(getter);\n+                       String propertyName = normalizeGetterName(getter);\n+\n+                       Method setter = extractSetterMethod(propertyName, indexedBuilderMethods, getter, builderClass)\n+                           .orElseThrow(\n+                               () -> generateExceptionForMethod(\n+                                   getter,\n+                                   \"A method was found on the immutable class that does not appear to have a \" +\n+                                       \"matching setter on the builder class.\"));\n+\n+                       return ImmutablePropertyDescriptor.create(propertyName, getter, setter);\n+                   }).collect(Collectors.toList());\n+\n+        if (!indexedBuilderMethods.isEmpty()) {\n+            throw generateExceptionForMethod(indexedBuilderMethods.values().iterator().next(),\n+                                             \"A method was found on the immutable class builder that does not appear \" +\n+                                                 \"to have a matching getter on the immutable class.\");\n+        }\n+\n+        return ImmutableInfo.builder(immutableClass)\n+                            .builderClass(builderClass)\n+                            .staticBuilderMethod(staticBuilderMethod.orElse(null))\n+                            .buildMethod(buildMethod)\n+                            .propertyDescriptors(propertyDescriptors)\n+                            .build();\n+    }\n+\n+    private Optional<Method> findStaticBuilderMethod(Class<?> immutableClass, Class<?> builderClass) {\n+        try {\n+            Method method = immutableClass.getMethod(BUILDER_METHOD);\n+\n+            if (Modifier.isStatic(method.getModifiers()) && method.getReturnType().isAssignableFrom(builderClass)) {\n+                return Optional.of(method);\n+            }\n+        } catch (NoSuchMethodException ignored) {\n+            // no-op\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private IllegalArgumentException generateExceptionForMethod(Method getter, String message) {\n+        return new IllegalArgumentException(\n+            message + \" Use the @DynamoDbIgnore annotation on the method if you do not want it to be included in the \" +\n+                \"TableSchema introspection. [Method = \\\"\" + getter + \"\\\"]\");\n+    }\n+\n+    private Class<?> validateAndGetBuilderClass(Class<?> immutableClass) {\n+        DynamoDbImmutable dynamoDbImmutable = immutableClass.getAnnotation(DynamoDbImmutable.class);\n+\n+        if (dynamoDbImmutable == null) {\n+            throw new IllegalArgumentException(\"A DynamoDb immutable class must be annotated with @DynamoDbImmutable\");\n+        }\n+\n+        return dynamoDbImmutable.builder();\n+    }\n+\n+    private void validateGetter(Method getter) {\n+        if (getter.getReturnType() == void.class || getter.getReturnType() == Void.class) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to the return type being void.\");\n+        }\n+\n+        if (getter.getParameterCount() != 0) {\n+            throw generateExceptionForMethod(getter, \"A method was found on the immutable class that does not appear \" +\n+                \"to be a valid getter due to it having one or more parameters.\");\n+        }\n+    }\n+\n+    private List<Method> filterAndCollectGetterMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, Method> filterAndIndexBuilderMethods(Method[] rawMethods) {\n+        return Arrays.stream(rawMethods)\n+                     .filter(ImmutableIntrospector::isMappableMethod)\n+                     .collect(Collectors.toMap(this::normalizeSetterName, m -> m));\n+    }\n+\n+    private String normalizeSetterName(Method setter) {\n+        String setterName = setter.getName();\n+\n+        if (setterName.length() > 3\n+            && Character.isUpperCase(setterName.charAt(3))\n+            && setterName.startsWith(SET_PREFIX)) {\n+\n+            return Character.toLowerCase(setterName.charAt(3)) + setterName.substring(4);\n+        }\n+\n+        return setterName;\n+    }", "originalCommit": "6f1405f00d6bb4880739a17e544db8d881d6d24a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NzQ3OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481397479", "bodyText": "Some code generators will produce immutable implementations that have 'set'. I think it would be inconvenient to require an additional annotation for all of those. I feel it would be preferable to annotate the exceptions with @DynamoDbAttribute(\"setOfStuff\") (which is already supported)", "author": "bmaizels", "createdAt": "2020-09-01T20:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTkzNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481405936", "bodyText": "I was thinking a boolean on the class-level annotation, instead of one on every attribute. That seems less troublesome and prevents magic confusion (I feel like this is the opposite argument we usually have - you're usually the anti-magic one!)", "author": "millems", "createdAt": "2020-09-01T20:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4ODgyNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2012#discussion_r481488827", "bodyText": "As we discussed offline, we'll bias towards making it easy for customers using code generators such as Lombok and not require an additional opt-in flag for getter/setter prefixes.", "author": "bmaizels", "createdAt": "2020-09-01T23:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5NDEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "08945b911393841c37d72bfb38524fef1ba391b1", "chunk": "diff --git a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\nindex d930179640..af70594692 100644\n--- a/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n+++ b/services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/immutable/ImmutableIntrospector.java\n\n@@ -30,31 +30,34 @@ import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbImmut\n \n @SdkInternalApi\n public class ImmutableIntrospector {\n-    private static final ImmutableIntrospector INSTANCE = new ImmutableIntrospector();\n     private static final String BUILD_METHOD = \"build\";\n     private static final String BUILDER_METHOD = \"builder\";\n     private static final String GET_PREFIX = \"get\";\n     private static final String IS_PREFIX = \"is\";\n     private static final String SET_PREFIX = \"set\";\n \n+    private static volatile ImmutableIntrospector INSTANCE = null;\n+\n     // Methods from Object are commonly overridden and confuse the mapper, automatically exclude any method with a name\n     // that matches a method defined on Object.\n-    private static final Set<String> NAMES_TO_EXCLUDE =\n-        Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n-                                          .map(Method::getName)\n-                                          .collect(Collectors.toSet()));\n+    private final Set<String> namesToExclude;\n \n-    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n-        return INSTANCE.introspect(immutableClass);\n+    private ImmutableIntrospector() {\n+        this.namesToExclude = Collections.unmodifiableSet(Arrays.stream(Object.class.getMethods())\n+                                                                .map(Method::getName)\n+                                                                .collect(Collectors.toSet()));\n     }\n \n-    private static boolean isMappableMethod(Method method) {\n-        return method.getDeclaringClass() != Object.class\n-            && method.getAnnotation(DynamoDbIgnore.class) == null\n-            && !method.isSynthetic()\n-            && !method.isBridge()\n-            && !Modifier.isStatic(method.getModifiers())\n-            && !NAMES_TO_EXCLUDE.contains(method.getName());\n+    public static <T> ImmutableInfo<T> getImmutableInfo(Class<T> immutableClass) {\n+        if (INSTANCE == null) {\n+            synchronized (ImmutableIntrospector.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = new ImmutableIntrospector();\n+                }\n+            }\n+        }\n+\n+        return INSTANCE.introspect(immutableClass);\n     }\n \n     private <T> ImmutableInfo<T> introspect(Class<T> immutableClass) {\n"}}, {"oid": "08945b911393841c37d72bfb38524fef1ba391b1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08945b911393841c37d72bfb38524fef1ba391b1", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T23:34:26Z", "type": "commit"}, {"oid": "08945b911393841c37d72bfb38524fef1ba391b1", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08945b911393841c37d72bfb38524fef1ba391b1", "message": "DynamoDb Enhanced Client: Add support for immutables with StaticImmutableTableSchema and ImmutableTableSchema", "committedDate": "2020-09-01T23:34:26Z", "type": "forcePushed"}, {"oid": "0199b0a97b762957d22e6ed7257e9fe698409e33", "url": "https://github.com/aws/aws-sdk-java-v2/commit/0199b0a97b762957d22e6ed7257e9fe698409e33", "message": "Merge branch 'master' into bmaizels/ddbenhanced-immutables-poc", "committedDate": "2020-09-01T23:34:55Z", "type": "commit"}]}