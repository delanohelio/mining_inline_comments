{"pr_number": 311, "pr_title": "307 fix group areas", "pr_createdAt": "2020-09-26T20:49:49Z", "pr_url": "https://github.com/dedica-team/nivio/pull/311", "timeline": [{"oid": "ed3a47c0215bc6cf86a25c5ca93e16cce61de06a", "url": "https://github.com/dedica-team/nivio/commit/ed3a47c0215bc6cf86a25c5ca93e16cce61de06a", "message": "[#307] fill gaps by adding paths to closest group items", "committedDate": "2020-09-26T09:29:17Z", "type": "commit"}, {"oid": "a1c3bcfbbfc807ca4be7a923117e32f5b3c92239", "url": "https://github.com/dedica-team/nivio/commit/a1c3bcfbbfc807ca4be7a923117e32f5b3c92239", "message": "[#310] fix for glitches in large groups", "committedDate": "2020-09-26T18:10:33Z", "type": "commit"}, {"oid": "112150a8f0fb7b71fe9a0e9b530656456dfc0baf", "url": "https://github.com/dedica-team/nivio/commit/112150a8f0fb7b71fe9a0e9b530656456dfc0baf", "message": "added more items to common group", "committedDate": "2020-09-26T19:00:25Z", "type": "commit"}, {"oid": "e79fd751386c7085f44f2552a633fdf2712c5252", "url": "https://github.com/dedica-team/nivio/commit/e79fd751386c7085f44f2552a633fdf2712c5252", "message": "[#310] fixes", "committedDate": "2020-09-26T19:01:00Z", "type": "commit"}, {"oid": "797c5ba64623e7630d33a439b42e2c6332b379ba", "url": "https://github.com/dedica-team/nivio/commit/797c5ba64623e7630d33a439b42e2c6332b379ba", "message": "[#310] disabled debug mode", "committedDate": "2020-09-26T19:03:35Z", "type": "commit"}, {"oid": "bd6bee3fdd1ffa49665d6723ce66cbc5e7633274", "url": "https://github.com/dedica-team/nivio/commit/bd6bee3fdd1ffa49665d6723ce66cbc5e7633274", "message": "[#310] smoother outline", "committedDate": "2020-09-26T19:09:08Z", "type": "commit"}, {"oid": "211b1487ac615047ae6b0a1eff892145b57cdd74", "url": "https://github.com/dedica-team/nivio/commit/211b1487ac615047ae6b0a1eff892145b57cdd74", "message": "larger map icons", "committedDate": "2020-09-26T19:12:41Z", "type": "commit"}, {"oid": "69ff489152be4e0ec702acf332185d9a3e12663c", "url": "https://github.com/dedica-team/nivio/commit/69ff489152be4e0ec702acf332185d9a3e12663c", "message": "[#307] higher force constant within groups", "committedDate": "2020-09-26T19:18:00Z", "type": "commit"}, {"oid": "4f247425063e1de6f43cde01017ab41b8d8c87a0", "url": "https://github.com/dedica-team/nivio/commit/4f247425063e1de6f43cde01017ab41b8d8c87a0", "message": "larger icons, larger labels at right", "committedDate": "2020-09-26T19:37:40Z", "type": "commit"}, {"oid": "72d33ba340ae5bc51d6e776ec94560bd5706af89", "url": "https://github.com/dedica-team/nivio/commit/72d33ba340ae5bc51d6e776ec94560bd5706af89", "message": "larger group labels", "committedDate": "2020-09-26T19:42:47Z", "type": "commit"}, {"oid": "1d62299c1ce07d5788b2c3b4d4568198a3119baf", "url": "https://github.com/dedica-team/nivio/commit/1d62299c1ce07d5788b2c3b4d4568198a3119baf", "message": "hexes as background", "committedDate": "2020-09-26T20:37:55Z", "type": "commit"}, {"oid": "a3bf56cd559051abc193ce93a7cac7c956d48221", "url": "https://github.com/dedica-team/nivio/commit/a3bf56cd559051abc193ce93a7cac7c956d48221", "message": "test fixes", "committedDate": "2020-09-26T20:43:24Z", "type": "commit"}, {"oid": "1015de4567f1843d3acc6571cd994eb2e4015be7", "url": "https://github.com/dedica-team/nivio/commit/1015de4567f1843d3acc6571cd994eb2e4015be7", "message": "text anchor middle if shortname is used instead of icon", "committedDate": "2020-09-26T20:48:17Z", "type": "commit"}, {"oid": "d7b8306531b022b7158cd8fc45ead2a336686948", "url": "https://github.com/dedica-team/nivio/commit/d7b8306531b022b7158cd8fc45ead2a336686948", "message": "[#264] fix pathfinder not choosing best path", "committedDate": "2020-09-27T09:01:08Z", "type": "commit"}, {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "url": "https://github.com/dedica-team/nivio/commit/a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "message": "[#264] disable debug", "committedDate": "2020-09-27T09:02:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA2MA==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553060", "bodyText": "Why don't we care?", "author": "mfbieber", "createdAt": "2020-09-27T09:42:46Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here", "originalCommit": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NTM0OQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495555349", "bodyText": "I'll improve the comment", "author": "bonndan", "createdAt": "2020-09-27T10:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA2MA=="}], "type": "inlineReview", "revised_code": {"commit": "115890dc15a89906b64ebb06b0a83ee730e593c9", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\nindex b506fbe2..3a2935f0 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n\n@@ -46,7 +46,9 @@ public class GroupAreaFactory {\n             });\n \n             Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n-            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            // we dont care for occupied tiles here, since we just want the closest item within group, and non-group\n+            // items cannot be anywhere nearby (other types of obstacles do not exist yet)\n+            PathFinder pathFinder = new PathFinder(Set.of());\n             closestNeighbours.forEach(neighbour -> {\n                 HexPath path = pathFinder.getPath(hex, neighbour);\n                 Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA5OQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553099", "bodyText": "Can this be reflected by tests?", "author": "mfbieber", "createdAt": "2020-09-27T09:43:21Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue", "originalCommit": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NjIzMQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495556231", "bodyText": "I've added a test.", "author": "bonndan", "createdAt": "2020-09-27T10:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "115890dc15a89906b64ebb06b0a83ee730e593c9", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\nindex b506fbe2..3a2935f0 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n\n@@ -46,7 +46,9 @@ public class GroupAreaFactory {\n             });\n \n             Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n-            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            // we dont care for occupied tiles here, since we just want the closest item within group, and non-group\n+            // items cannot be anywhere nearby (other types of obstacles do not exist yet)\n+            PathFinder pathFinder = new PathFinder(Set.of());\n             closestNeighbours.forEach(neighbour -> {\n                 HexPath path = pathFinder.getPath(hex, neighbour);\n                 Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzE5Mw==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553193", "bodyText": "Is this logic tested by our tests?", "author": "mfbieber", "createdAt": "2020-09-27T09:44:35Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n+                path.getHexes().forEach(pathTile -> {\n+                    padded.add(pathTile);\n+                    padded.addAll(pathTile.neighbours());\n+                });\n+                padded.stream().filter(hex1 -> !occupied.contains(hex1)).forEach(inArea::add);\n+            });\n+\n         });\n \n         Set<Hex> bridges = getBridges(inArea);\n         inArea.addAll(bridges);\n \n-        //2nd pass fills gaps\n-        bridges = getBridges(inArea);\n-        inArea.addAll(bridges);\n-\n         return inArea;\n     }\n \n+    /**\n+     * Returns all neighbours in group which are the have same (minimum) distance.\n+     *\n+     * @param item           the current group item\n+     * @param items          all group items\n+     * @param allVertexHexes item hex mapping\n+     * @return the closest neighbours\n+     */\n+    private static Set<Hex> getClosestItemsHexes(Item item, Set<Item> items, Map<LandscapeItem, Hex> allVertexHexes) {\n+        Hex start = allVertexHexes.get(item);\n+        AtomicInteger minDist = new AtomicInteger(Integer.MAX_VALUE);\n+        final Set<Hex> min = new HashSet<>();\n+        items.stream()\n+                .filter(otherGroupItem -> !item.equals(otherGroupItem))\n+                .forEach(otherGroupItem -> {\n+                    Hex dest = allVertexHexes.get(otherGroupItem);\n+                    int distance = start.distance(dest);\n+                    if (distance > minDist.get()) {\n+                        return;\n+                    }\n+                    if (distance == minDist.get()) {\n+                        min.add(dest);\n+                        return;\n+                    }\n+                    if (distance < minDist.get()) {\n+                        minDist.set(distance);\n+                        min.clear();\n+                        min.add(dest);\n+                    }\n+                });\n+\n+        return min;\n+    }", "originalCommit": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NjE2OQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495556169", "bodyText": "I've added a test.", "author": "bonndan", "createdAt": "2020-09-27T10:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "115890dc15a89906b64ebb06b0a83ee730e593c9", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\nindex b506fbe2..3a2935f0 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java\n\n@@ -46,7 +46,9 @@ public class GroupAreaFactory {\n             });\n \n             Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n-            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            // we dont care for occupied tiles here, since we just want the closest item within group, and non-group\n+            // items cannot be anywhere nearby (other types of obstacles do not exist yet)\n+            PathFinder pathFinder = new PathFinder(Set.of());\n             closestNeighbours.forEach(neighbour -> {\n                 HexPath path = pathFinder.getPath(hex, neighbour);\n                 Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553407", "bodyText": "Where does this magic formula come from? :)", "author": "mfbieber", "createdAt": "2020-09-27T09:46:22Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "originalCommit": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NTgyOA==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495555828", "bodyText": "https://www.redblobgames.com/grids/hexagons/implementation.html\nTLDR: q and r and like x and y and sufficient to describe a hex position. s is a third axis orthogonal to q and r.", "author": "bonndan", "createdAt": "2020-09-27T10:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1ODk4Ng==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495558986", "bodyText": "I am trying to really understand this. So I understood that it comes from cube algorithms, and thus s would equal z in a cartesian coordinate system.\nThe comment helps to understand that the formula has something to do with a coordinate system, but it does not explain why z = (x + y) * (-1)\nIn general all these Hex and Layout classes are really hard to understand, without understanding the math and logic behind it.\nInitially we used the linked implementation as a library but then started to implement own logic on top of it, right?\nHaving own complex code, without (me) really understanding what it does makes it hard to review and grow it. Isn't there a possibility to use the library as it was and decorate (or maybe another pattern is better suited) with our own logic? That own logic can be well tested and understandable :)", "author": "mfbieber", "createdAt": "2020-09-27T10:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NTE3MQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495565171", "bodyText": "No, the hex stuff has never been in a library. That was the layouting (force based positioning stuff). Some time ago I investigated some Java hex libraries, but decided against them. If we find a suitable one, we can consider replacing some of our code.", "author": "bonndan", "createdAt": "2020-09-27T11:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NzQwOQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495567409", "bodyText": "Btw, I understood the \"s\" coordinate as an alternative coordinate, and not as \"z\". Think of a square with the two sides running parallel to x and y axes in a cartesian system: the sides can be described by offsetting the axes. A hex system has three axes, but you only need to know the offsets of two axes to construct a hex at a position.", "author": "bonndan", "createdAt": "2020-09-27T12:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java b/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\nindex 840190c0..f9477c98 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\n\n@@ -68,6 +71,13 @@ public class Hex {\n         this.s = s;\n     }\n \n+    /**\n+     * https://www.redblobgames.com/grids/hexagons/implementation.html\n+     *\n+     * TLDR: q and r and like x and y and sufficient to describe a hex position. s is a third axis orthogonal to q and r.\n+     * @param q coordinate\n+     * @param r coordinate\n+     */\n     public Hex(int q, int r) {\n         this(q, r, (r + q) * -1);\n     }\n"}}, {"oid": "115890dc15a89906b64ebb06b0a83ee730e593c9", "url": "https://github.com/dedica-team/nivio/commit/115890dc15a89906b64ebb06b0a83ee730e593c9", "message": "[#307] added test to ensure closest item path padding", "committedDate": "2020-09-27T10:14:50Z", "type": "commit"}, {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5", "url": "https://github.com/dedica-team/nivio/commit/2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5", "message": "[#307] added comment", "committedDate": "2020-09-27T10:17:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTAzOQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495559039", "bodyText": "Why is the distance the sum of all coordinates divided by 2?", "author": "mfbieber", "createdAt": "2020-09-27T10:45:15Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -103,11 +120,19 @@ public static Hex of(long x, long y, float scaling) {\n         return new Hex(qi, ri, si);\n     }\n \n-\n+    /**\n+     * Returns the distance to the target hex in number of tiles.\n+     *\n+     * @param target target hex\n+     * @return number of tiles\n+     */\n     public int distance(Hex target) {\n-        return lengths(this.subtract(target));\n+        Hex hex = this.subtract(target);\n+        double l = (Math.abs(hex.q) + Math.abs(hex.r) + Math.abs(hex.s)) / 2.0;", "originalCommit": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NTQ0OQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495565449", "bodyText": "https://www.redblobgames.com/grids/hexagons/#distances I will add this link as comment, too.", "author": "bonndan", "createdAt": "2020-09-27T11:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cebb6ca1495a8a7fd75deb4fb352ac3950d65ac0", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java b/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\nindex f9477c98..e394fdb1 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/Hex.java\n\n@@ -123,6 +123,8 @@ public class Hex {\n     /**\n      * Returns the distance to the target hex in number of tiles.\n      *\n+     * https://www.redblobgames.com/grids/hexagons/#distances\n+     *\n      * @param target target hex\n      * @return number of tiles\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495559159", "bodyText": "Why doesn't the Pathfinder return an Optional itself?", "author": "mfbieber", "createdAt": "2020-09-27T10:46:24Z", "path": "src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java", "diffHunk": "@@ -63,16 +63,7 @@ public Hex hexForItem(Item item) {\n      * @return a path if one could be found\n      */\n     public Optional<HexPath> getPath(Item start, Item target) {\n-        Optional<HexPath> optional = Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));\n-\n-        optional.ifPresent(hexPath -> {\n-            if (start.getGroup() != null && start.getGroup().equals(target.getGroup())) {\n-                hexPath.setGroup(start.getGroup());\n-            }\n-            paths.add(hexPath);\n-        });\n-\n-        return optional;\n+        return Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));", "originalCommit": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NDc0NQ==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495564745", "bodyText": "Because nobody refactored it yet \ud83d\ude04", "author": "bonndan", "createdAt": "2020-09-27T11:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NzgwMg==", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495567802", "bodyText": "I have refactored it to use Optional.", "author": "bonndan", "createdAt": "2020-09-27T12:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "36614dbd078e1b297756fc088a927b04c74e0c68", "chunk": "diff --git a/src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java b/src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java\nindex ca227069..04ff6766 100644\n--- a/src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java\n+++ b/src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java\n\n@@ -63,7 +63,7 @@ public class HexMap {\n      * @return a path if one could be found\n      */\n     public Optional<HexPath> getPath(Item start, Item target) {\n-        return Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));\n+        return pathFinder.getPath(hexForItem(start), hexForItem(target));\n     }\n \n     /**\n"}}, {"oid": "cebb6ca1495a8a7fd75deb4fb352ac3950d65ac0", "url": "https://github.com/dedica-team/nivio/commit/cebb6ca1495a8a7fd75deb4fb352ac3950d65ac0", "message": "[#307] added comment", "committedDate": "2020-09-27T11:59:02Z", "type": "commit"}, {"oid": "36614dbd078e1b297756fc088a927b04c74e0c68", "url": "https://github.com/dedica-team/nivio/commit/36614dbd078e1b297756fc088a927b04c74e0c68", "message": "[#307] pathfinder returns optional path", "committedDate": "2020-09-27T12:25:28Z", "type": "commit"}, {"oid": "367da6272ee09e2cbc92c5226892329a56415ea0", "url": "https://github.com/dedica-team/nivio/commit/367da6272ee09e2cbc92c5226892329a56415ea0", "message": "[#307] less and bigger markers for dataflow relations", "committedDate": "2020-09-30T14:22:05Z", "type": "commit"}, {"oid": "7dbf1948fb3a9840ab5a81d301b4ed53bea98548", "url": "https://github.com/dedica-team/nivio/commit/7dbf1948fb3a9840ab5a81d301b4ed53bea98548", "message": "[#307] hexes background drawn first", "committedDate": "2020-09-30T14:23:17Z", "type": "commit"}, {"oid": "428cc0990b1f3187ff358d1496acd921c49cec1e", "url": "https://github.com/dedica-team/nivio/commit/428cc0990b1f3187ff358d1496acd921c49cec1e", "message": "[#307] more space between items (higher initial temp)", "committedDate": "2020-09-30T14:25:59Z", "type": "commit"}, {"oid": "1c02408f0e9f3b26c47caafc1c52263ac6bcf9d5", "url": "https://github.com/dedica-team/nivio/commit/1c02408f0e9f3b26c47caafc1c52263ac6bcf9d5", "message": "[#307] added internal worflows as nivio landscape", "committedDate": "2020-09-30T14:26:47Z", "type": "commit"}, {"oid": "713d4f67263581b352fd99cbef5024a4693244ae", "url": "https://github.com/dedica-team/nivio/commit/713d4f67263581b352fd99cbef5024a4693244ae", "message": "[#307] not showing contact/owner on items if not present", "committedDate": "2020-09-30T14:48:16Z", "type": "commit"}, {"oid": "07243d182c2eaee1ecd49fcd6855d97bb7ffe6fd", "url": "https://github.com/dedica-team/nivio/commit/07243d182c2eaee1ecd49fcd6855d97bb7ffe6fd", "message": "[#307] updated internals.yml", "committedDate": "2020-10-01T04:56:37Z", "type": "commit"}]}