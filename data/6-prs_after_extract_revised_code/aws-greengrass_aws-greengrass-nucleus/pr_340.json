{"pr_number": 340, "pr_title": "Add initial AuthZ pub/sub integration", "pr_createdAt": "2020-07-30T19:21:52Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMTQ2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463221463", "bodyText": "you don't use this method. Get rid of it.", "author": "MikeDombo", "createdAt": "2020-07-30T19:27:40Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -17,4 +17,27 @@\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        public boolean equalsName(String otherName) {", "originalCommit": "f0ee2bf1b709f14d23d1a48ee24df3084ba83018", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyNDgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463224820", "bodyText": "ok", "author": "avipinku", "createdAt": "2020-07-30T19:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMTQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\nindex 0f8211f7ca..8657472886 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n\n@@ -31,10 +31,6 @@ public class AuthorizationPolicy {\n             name = s;\n         }\n \n-        public boolean equalsName(String otherName) {\n-            return name.equals(otherName);\n-        }\n-\n         @Override\n         public String toString() {\n             return this.name;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzODg3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463238876", "bodyText": "pretty sure @Value has this already.", "author": "MikeDombo", "createdAt": "2020-07-30T20:01:15Z", "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -4,11 +4,13 @@\n package com.aws.iot.evergreen.auth;\n \n import lombok.Builder;\n+import lombok.EqualsAndHashCode;\n import lombok.NonNull;\n import lombok.Value;\n \n @Builder\n @Value\n+@EqualsAndHashCode", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MDgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463250827", "bodyText": "will remove", "author": "avipinku", "createdAt": "2020-07-30T20:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzODg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/Permission.java b/src/main/java/com/aws/iot/evergreen/auth/Permission.java\nindex 25f9c19739..885336c6a6 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/Permission.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/Permission.java\n\n@@ -4,13 +4,11 @@\n package com.aws.iot.evergreen.auth;\n \n import lombok.Builder;\n-import lombok.EqualsAndHashCode;\n import lombok.NonNull;\n import lombok.Value;\n \n @Builder\n @Value\n-@EqualsAndHashCode\n public class Permission {\n     @NonNull String principal;\n     @NonNull String operation;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTM2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463239369", "bodyText": "no * imports. setup your IDE to not do this.", "author": "MikeDombo", "createdAt": "2020-07-30T20:02:17Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MDg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463250884", "bodyText": "ah my mistake", "author": "avipinku", "createdAt": "2020-07-30T20:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTM2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\nindex 10a28d1911..c60a8b146c 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n\n@@ -1,8 +1,11 @@\n package com.aws.iot.evergreen.auth;\n \n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n import com.fasterxml.jackson.jr.ob.JSON;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NjE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463356140", "bodyText": "I am not sure if we follow pascal case or camel case for the config fields? mostly it should be accessControl", "author": "prateek-y", "createdAt": "2020-07-31T01:19:28Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MzkxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463363919", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-07-31T01:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NjE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 5f50f9dc9e..8153f152bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,81 +5,137 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n \n     private AuthorizationUtils(){\n     }\n \n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n \n     /**\n-     * Given a Topics config object, construct and return a list of AuthorizationPolicy objects that may exist.\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n      * @param config Topics\n-     * @return List AuthorizationPolicy\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicy(Topics config) throws AuthorizationException {\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n \n-        Topics accessControlMap = config.findTopics(ACCESS_CONTROL_KEY);\n-        if (accessControlMap == null) {\n-            return null;\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);\n+        if (servicesConfig == null) {\n+            logger.atWarn(String.format(\"No services found in config.\"));\n+            return authorizationPolicyMap;\n         }\n \n-        ArrayList<AuthorizationPolicy> authorizationPolicyList = new ArrayList<>();\n-\n-        //Iterate through all policies\n-        for (Node policyObject : accessControlMap) {\n-\n-            //Initialize these components to null\n-            String policyDescription = null;\n-            Set<String> principals = null;\n-            Set<String> operations = null;\n-            Set<String> resources = null;\n-\n-            for (Node policyComponentNode : (Topics) policyObject) {\n-                //Iterate through the components of this policy\n-                Topic policyComponent = (Topic) policyComponentNode;\n-                PolicyComponentTypes policyComponentKey = toEnum(\n-                        PolicyComponentTypes.class,\n-                        policyComponentNode.getName(),\n-                        PolicyComponentTypes.INVALID_ENUM);\n-                switch (policyComponentKey) {\n-                    case POLICY_DESCRIPTION:\n-                        policyDescription = Coerce.toString(policyComponent);\n-                        break;\n-                    case PRINCIPALS:\n-                        principals = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    case OPERATIONS:\n-                        operations = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    case RESOURCES:\n-                        resources = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    default:\n-                        throw new AuthorizationException(\"Unknown policy component key.\");\n-                    }\n+        //For each component\n+        for (Node componentConfigNode : servicesConfig) {\n+            Topics componentConfigTopics = (Topics) componentConfigNode;\n+            String componentName = componentConfigTopics.getName();\n+\n+            //Get the Access Control List for this component\n+            Topics accessControlTopics = componentConfigTopics.findTopics(ACCESS_CONTROL_KEY);\n+            if (accessControlTopics == null) {\n+                logger.atWarn(String.format(\"Component %s has no valid accessControl component field.\", componentName));\n+                continue;\n             }\n+            //Iterate through each ACL type\n+            for (Node accessControlListNode : accessControlTopics) {\n+                Topic accessControlTopic = (Topic) accessControlListNode;\n+                String policyType = accessControlTopic.getName();\n+                List<AuthorizationPolicy> newAuthorizationPolicyList = parseAuthorizationPolicyList(\n+                        componentName, accessControlTopic);\n \n-            authorizationPolicyList.add(AuthorizationPolicy.builder()\n-                    .policyId(policyObject.getName())\n-                    .policyDescription(policyDescription)\n-                    .principals(principals)\n-                    .operations(operations)\n-                    .resources(resources)\n-                    .build());\n+                //If the policyType already exists in the map\n+                if (authorizationPolicyMap.containsKey(policyType)) {\n+                    authorizationPolicyMap.get(policyType).addAll(newAuthorizationPolicyList);\n+                } else {\n+                    authorizationPolicyMap.put(policyType, newAuthorizationPolicyList);\n+                }\n+            }\n         }\n \n-        return authorizationPolicyList;\n+        return authorizationPolicyMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1OTg5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463359890", "bodyText": "we would need to handle cases when some of the fields are not set by the customer.", "author": "prateek-y", "createdAt": "2020-07-31T01:34:26Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+\n+    /**\n+     * Given a Topics config object, construct and return a list of AuthorizationPolicy objects that may exist.\n+     * @param config Topics\n+     * @return List AuthorizationPolicy\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicy(Topics config) throws AuthorizationException {\n+\n+        Topics accessControlMap = config.findTopics(ACCESS_CONTROL_KEY);\n+        if (accessControlMap == null) {\n+            return null;\n+        }\n+\n+        ArrayList<AuthorizationPolicy> authorizationPolicyList = new ArrayList<>();\n+\n+        //Iterate through all policies\n+        for (Node policyObject : accessControlMap) {\n+\n+            //Initialize these components to null\n+            String policyDescription = null;\n+            Set<String> principals = null;\n+            Set<String> operations = null;\n+            Set<String> resources = null;\n+\n+            for (Node policyComponentNode : (Topics) policyObject) {\n+                //Iterate through the components of this policy\n+                Topic policyComponent = (Topic) policyComponentNode;\n+                PolicyComponentTypes policyComponentKey = toEnum(\n+                        PolicyComponentTypes.class,\n+                        policyComponentNode.getName(),\n+                        PolicyComponentTypes.INVALID_ENUM);\n+                switch (policyComponentKey) {\n+                    case POLICY_DESCRIPTION:\n+                        policyDescription = Coerce.toString(policyComponent);", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMzIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463413211", "bodyText": "added a test for this", "author": "avipinku", "createdAt": "2020-07-31T05:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1OTg5MA=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 5f50f9dc9e..8153f152bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,81 +5,137 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n \n     private AuthorizationUtils(){\n     }\n \n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n \n     /**\n-     * Given a Topics config object, construct and return a list of AuthorizationPolicy objects that may exist.\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n      * @param config Topics\n-     * @return List AuthorizationPolicy\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicy(Topics config) throws AuthorizationException {\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n \n-        Topics accessControlMap = config.findTopics(ACCESS_CONTROL_KEY);\n-        if (accessControlMap == null) {\n-            return null;\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);\n+        if (servicesConfig == null) {\n+            logger.atWarn(String.format(\"No services found in config.\"));\n+            return authorizationPolicyMap;\n         }\n \n-        ArrayList<AuthorizationPolicy> authorizationPolicyList = new ArrayList<>();\n-\n-        //Iterate through all policies\n-        for (Node policyObject : accessControlMap) {\n-\n-            //Initialize these components to null\n-            String policyDescription = null;\n-            Set<String> principals = null;\n-            Set<String> operations = null;\n-            Set<String> resources = null;\n-\n-            for (Node policyComponentNode : (Topics) policyObject) {\n-                //Iterate through the components of this policy\n-                Topic policyComponent = (Topic) policyComponentNode;\n-                PolicyComponentTypes policyComponentKey = toEnum(\n-                        PolicyComponentTypes.class,\n-                        policyComponentNode.getName(),\n-                        PolicyComponentTypes.INVALID_ENUM);\n-                switch (policyComponentKey) {\n-                    case POLICY_DESCRIPTION:\n-                        policyDescription = Coerce.toString(policyComponent);\n-                        break;\n-                    case PRINCIPALS:\n-                        principals = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    case OPERATIONS:\n-                        operations = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    case RESOURCES:\n-                        resources = new HashSet<>(Coerce.toStringList(policyComponent));\n-                        break;\n-                    default:\n-                        throw new AuthorizationException(\"Unknown policy component key.\");\n-                    }\n+        //For each component\n+        for (Node componentConfigNode : servicesConfig) {\n+            Topics componentConfigTopics = (Topics) componentConfigNode;\n+            String componentName = componentConfigTopics.getName();\n+\n+            //Get the Access Control List for this component\n+            Topics accessControlTopics = componentConfigTopics.findTopics(ACCESS_CONTROL_KEY);\n+            if (accessControlTopics == null) {\n+                logger.atWarn(String.format(\"Component %s has no valid accessControl component field.\", componentName));\n+                continue;\n             }\n+            //Iterate through each ACL type\n+            for (Node accessControlListNode : accessControlTopics) {\n+                Topic accessControlTopic = (Topic) accessControlListNode;\n+                String policyType = accessControlTopic.getName();\n+                List<AuthorizationPolicy> newAuthorizationPolicyList = parseAuthorizationPolicyList(\n+                        componentName, accessControlTopic);\n \n-            authorizationPolicyList.add(AuthorizationPolicy.builder()\n-                    .policyId(policyObject.getName())\n-                    .policyDescription(policyDescription)\n-                    .principals(principals)\n-                    .operations(operations)\n-                    .resources(resources)\n-                    .build());\n+                //If the policyType already exists in the map\n+                if (authorizationPolicyMap.containsKey(policyType)) {\n+                    authorizationPolicyMap.get(policyType).addAll(newAuthorizationPolicyList);\n+                } else {\n+                    authorizationPolicyMap.put(policyType, newAuthorizationPolicyList);\n+                }\n+            }\n         }\n \n-        return authorizationPolicyList;\n+        return authorizationPolicyMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360182", "bodyText": "I am not sure if this should be Camel case or pascal case??", "author": "prateek-y", "createdAt": "2020-07-31T01:35:19Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +26,29 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = \"pubsub\", autostart = true)", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360593", "bodyText": "rename to \"aws.greengrass.ipc.pubsub\", we're moving toward namespacing all our internal stuff like that.", "author": "MikeDombo", "createdAt": "2020-07-31T01:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDA2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364068", "bodyText": "ok", "author": "avipinku", "createdAt": "2020-07-31T01:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\nindex b58ce64686..0ad90e24cf 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n\n@@ -35,7 +33,7 @@ import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsub\", autostart = true)\n+@ImplementsService(name = \"aws.greengrass.ipc.pubsub\", autostart = true)\n public class PubSubIPCService extends EvergreenService {\n     private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n     private static final String DESTINATION_STRING = \"destination\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDUyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360524", "bodyText": "remove \"ipc\" from event type.", "author": "prateek-y", "createdAt": "2020-07-31T01:36:45Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +57,47 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+            //Initialize auth config\n+            updateAuthConfig(this.config);\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"ipc-initialize-pubsub-authorization-error\").setCause(e)\n+                    .addKeyValue(DESTINATION_STRING, destination.name())\n+                    .log(\"Failed to initialize the Pub/Sub service with the Authorization module.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.config.subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    try {\n+                        //If there is a change in a node, reload the entire config\n+                        updateAuthConfig(this.config);\n+                    } catch (AuthorizationException e) {\n+                        logger.atError().setEventType(\"ipc-load-authorization-config-error\").setCause(e)", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDc2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364767", "bodyText": "removed from all logging in this file", "author": "avipinku", "createdAt": "2020-07-31T01:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\nindex b58ce64686..0ad90e24cf 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n\n@@ -65,38 +63,19 @@ public class PubSubIPCService extends EvergreenService {\n                 .collect(Collectors.toList());\n         try {\n             authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n-            //Initialize auth config\n-            updateAuthConfig(this.config);\n         } catch (AuthorizationException e) {\n-            logger.atError().setEventType(\"ipc-initialize-pubsub-authorization-error\").setCause(e)\n+            logger.atError().setEventType(\"initialize-pubsub-authorization-error\").setCause(e)\n                     .addKeyValue(DESTINATION_STRING, destination.name())\n                     .log(\"Failed to initialize the Pub/Sub service with the Authorization module.\");\n         }\n \n-        //Subscribe to future auth config updates\n-        this.config.subscribe(\n-                (why, newv) -> {\n-                    if (newv == null) {\n-                        return;\n-                    }\n-                    try {\n-                        //If there is a change in a node, reload the entire config\n-                        updateAuthConfig(this.config);\n-                    } catch (AuthorizationException e) {\n-                        logger.atError().setEventType(\"ipc-load-authorization-config-error\").setCause(e)\n-                                .addKeyValue(DESTINATION_STRING, destination.name())\n-                                .log(\"Failed to load the Pub/Sub Authorization config.\");\n-                    }\n-                });\n-\n-\n         try {\n             router.registerServiceCallback(destination.getValue(), this::handleMessage);\n-            logger.atInfo().setEventType(\"ipc-register-request-handler\")\n+            logger.atInfo().setEventType(\"register-request-handler\")\n                     .addKeyValue(DESTINATION_STRING, destination.name())\n                     .log();\n         } catch (IPCException e) {\n-            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+            logger.atError().setEventType(\"register-request-handler-error\").setCause(e)\n                     .addKeyValue(DESTINATION_STRING, destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTAzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361033", "bodyText": "Any reason you just set the code and not create a PubSubGenericResponse object?", "author": "prateek-y", "createdAt": "2020-07-31T01:39:00Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -101,6 +151,9 @@ public void postInject() {\n             try {\n                 PubSubGenericResponse response =\n                         new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2NDcyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463364722", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-07-31T01:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\nindex b58ce64686..0ad90e24cf 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n\n@@ -147,19 +126,20 @@ public class PubSubIPCService extends EvergreenService {\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n         } catch (Throwable e) {\n-            logger.atError().setEventType(\"pubsub-ipc-error\").setCause(e).log(\"Failed to handle message\");\n+            logger.atError().setEventType(\"pubsub-error\").setCause(e).log(\"Failed to handle message\");\n             try {\n-                PubSubGenericResponse response =\n-                        new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());\n+                PubSubGenericResponse response = null;\n                 if (e instanceof AuthorizationException) {\n-                    response.setStatus(PubSubResponseStatus.Unauthorized);\n+                    response = new PubSubGenericResponse(PubSubResponseStatus.Unauthorized, e.getMessage());\n+                } else {\n+                    response = new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());\n                 }\n                 ApplicationMessage responseMessage =\n                         ApplicationMessage.builder().version(applicationMessage.getVersion())\n                                 .payload(CBOR_MAPPER.writeValueAsBytes(response)).build();\n                 fut.complete(new Message(responseMessage.toByteArray()));\n             } catch (IOException ex) {\n-                logger.atError(\"pubsub-ipc-error\", ex).log(\"Failed to send error response\");\n+                logger.atError(\"pubsub-error\", ex).log(\"Failed to send error response\");\n             }\n         }\n         if (!fut.isDone()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTI2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361260", "bodyText": "We need to distinguish between the cases when policy is absent and its malformed, and atleast log informative error if its malformed.", "author": "prateek-y", "createdAt": "2020-07-31T01:39:53Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -114,4 +167,23 @@ public void postInject() {\n         }\n         return fut;\n     }\n+\n+    private void updateAuthConfig(Topics config) throws AuthorizationException {\n+        List<AuthorizationPolicy> authorizationPolicyList = AuthorizationUtils\n+                .parseAuthorizationPolicy(config);\n+        if (authorizationPolicyList != null) {", "originalCommit": "88f8c5593f83f7ffb423bff360a0e453d301cb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMzI2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463413265", "bodyText": "added tests for this as well as more logging", "author": "avipinku", "createdAt": "2020-07-31T05:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\nindex b58ce64686..0ad90e24cf 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n\n@@ -147,19 +126,20 @@ public class PubSubIPCService extends EvergreenService {\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n         } catch (Throwable e) {\n-            logger.atError().setEventType(\"pubsub-ipc-error\").setCause(e).log(\"Failed to handle message\");\n+            logger.atError().setEventType(\"pubsub-error\").setCause(e).log(\"Failed to handle message\");\n             try {\n-                PubSubGenericResponse response =\n-                        new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());\n+                PubSubGenericResponse response = null;\n                 if (e instanceof AuthorizationException) {\n-                    response.setStatus(PubSubResponseStatus.Unauthorized);\n+                    response = new PubSubGenericResponse(PubSubResponseStatus.Unauthorized, e.getMessage());\n+                } else {\n+                    response = new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());\n                 }\n                 ApplicationMessage responseMessage =\n                         ApplicationMessage.builder().version(applicationMessage.getVersion())\n                                 .payload(CBOR_MAPPER.writeValueAsBytes(response)).build();\n                 fut.complete(new Message(responseMessage.toByteArray()));\n             } catch (IOException ex) {\n-                logger.atError(\"pubsub-ipc-error\", ex).log(\"Failed to send error response\");\n+                logger.atError(\"pubsub-error\", ex).log(\"Failed to send error response\");\n             }\n         }\n         if (!fut.isDone()) {\n"}}, {"oid": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "message": "Final iteration of authZ pub/sub", "committedDate": "2020-08-04T03:30:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDYyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264626", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "author": "avipinku", "createdAt": "2020-08-04T19:01:54Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -185,19 +256,20 @@ private void validatePolicyId(List<AuthorizationPolicy> policies) throws Authori\n         }\n     }\n \n-    private void validateOperations(String componentName, AuthorizationPolicy policy) throws AuthorizationException {\n-        Set<String> operations = policy.getOperations();\n-        if (Utils.isEmpty(operations)) {\n-            throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n-                    + policy.getPolicyId());\n-        }\n-        Set<String> supportedOps = componentToOperationsMap.get(componentName);\n-        // check if operations are valid and registered.\n-        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n-            throw new AuthorizationException(\n-                    String.format(\"Operation not registered with component %s\", componentName));\n+        private void validateOperations(String componentName, AuthorizationPolicy policy)\n+        throws AuthorizationException {\n+            Set<String> operations = policy.getOperations();\n+            if (Utils.isEmpty(operations)) {\n+                throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n+                        + policy.getPolicyId());\n+            }\n+            //Set<String> supportedOps = componentToOperationsMap.get(componentName);", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzg5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467273894", "bodyText": "TODO SIM has been created and commented here. Resolving this conversation.", "author": "avipinku", "createdAt": "2020-08-07T21:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDYyNg=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex fee056f0e3..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -256,20 +266,21 @@ public class AuthorizationHandler {\n         }\n     }\n \n-        private void validateOperations(String componentName, AuthorizationPolicy policy)\n-        throws AuthorizationException {\n-            Set<String> operations = policy.getOperations();\n-            if (Utils.isEmpty(operations)) {\n-                throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n-                        + policy.getPolicyId());\n-            }\n-            //Set<String> supportedOps = componentToOperationsMap.get(componentName);\n-            // check if operations are valid and registered.\n-            //if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n-            //throw new AuthorizationException(\n-            //String.format(\"Operation not registered with component %s\", componentName));\n-            //}\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void validateOperations(String componentName, AuthorizationPolicy policy) throws AuthorizationException {\n+        Set<String> operations = policy.getOperations();\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n+                    + policy.getPolicyId());\n         }\n+        //TODO: solve the issue where the authhandler starts up and loads policies before services are registered\n+        //Set<String> supportedOps = componentToOperationsMap.get(componentName);\n+        // check if operations are valid and registered.\n+        //if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n+        //throw new AuthorizationException(\n+        //String.format(\"Operation not registered with component %s\", componentName));\n+        //}\n+    }\n \n     private void validatePrincipals(AuthorizationPolicy policy) throws AuthorizationException {\n         Set<String> principals = policy.getPrincipals();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264670", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "author": "avipinku", "createdAt": "2020-08-04T19:02:00Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,46 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {\n+            validatePrincipals(policy);\n+            validateOperations(componentName, policy);\n+        }\n+\n+        authModule.clearComponentPermissions(componentName);\n+        // now start adding the policies as permissions\n+        for (AuthorizationPolicy policy: policies) {\n+            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        }\n+        this.componentToAuthZConfig.replace(componentName, policies);\n+    }\n+\n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n         if (Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Component name is not specified: \" + componentName);\n         }\n-        if (!componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component not registered: \" + componentName);\n-        }\n+        //if (!componentToOperationsMap.containsKey(componentName)) {\n+        //throw new AuthorizationException(\"Component not registered: \" + componentName);", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5ODc4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465998789", "bodyText": "Is there a way to start authhandler in the end, and let all other components start up and register themselves first?", "author": "prateek-y", "createdAt": "2020-08-05T20:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466585579", "bodyText": "Michael confirmed that there is no way to do this, and that this should be dynamic. I'd like to get this initial implementation merged in first and then loop back around to this.", "author": "avipinku", "createdAt": "2020-08-06T17:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5OTc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467199777", "bodyText": "lets create a backlog task so that we dont miss it.", "author": "prateek-y", "createdAt": "2020-08-07T18:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex fee056f0e3..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -182,25 +189,27 @@ public class AuthorizationHandler {\n         isComponentRegistered(componentName);\n         validatePolicyId(policies);\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             validatePrincipals(policy);\n             validateOperations(componentName, policy);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n         }\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Update authZ policies for a single component. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n     public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTEyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269123", "bodyText": "use https://github.com/aws/aws-greengrass-kernel/blob/1972ecb1e01f0ca1fc39b0228c9495b5a3381ccd/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java#L140 instead", "author": "MikeDombo", "createdAt": "2020-08-04T19:10:25Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = updatedTopic.parent.parent.getName();", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431887", "bodyText": "perfect, thanks", "author": "avipinku", "createdAt": "2020-08-05T02:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex fee056f0e3..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -42,6 +45,7 @@ public class AuthorizationHandler {\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTIxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269211", "bodyText": "make a const for this string", "author": "MikeDombo", "createdAt": "2020-08-04T19:10:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {", "originalCommit": "30bf0cd8c636d624816f83064b7bdbfbd4a20377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431882", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex fee056f0e3..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -42,6 +45,7 @@ public class AuthorizationHandler {\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269685", "bodyText": "reformat.", "author": "MikeDombo", "createdAt": "2020-08-04T19:11:27Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,48 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431875", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex a90cd66f85..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -182,12 +189,12 @@ public class AuthorizationHandler {\n         isComponentRegistered(componentName);\n         validatePolicyId(policies);\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             validatePrincipals(policy);\n             validateOperations(componentName, policy);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n         }\n         this.componentToAuthZConfig.put(componentName, policies);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MDgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465270809", "bodyText": "don't make your own const. We already have these as consts", "author": "MikeDombo", "createdAt": "2020-08-04T19:13:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431865", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MDgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271306", "bodyText": "this isn't needed. Do for (Map.Entry policyEntry : allPoliciesMap.entrySet())", "author": "MikeDombo", "createdAt": "2020-08-04T19:14:26Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431858", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271428", "bodyText": "again here", "author": "MikeDombo", "createdAt": "2020-08-04T19:14:41Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431852", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTc0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271746", "bodyText": "this cast might fail, make sure that you are handling ClassCastException appropriately somewhere", "author": "MikeDombo", "createdAt": "2020-08-04T19:15:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTg0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431845", "bodyText": "added checks in multiple cast locations", "author": "avipinku", "createdAt": "2020-08-05T02:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTc0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTk4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271985", "bodyText": "do a static import for Collections.singleton", "author": "MikeDombo", "createdAt": "2020-08-04T19:15:44Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431836", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTk4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Mjk0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465272945", "bodyText": "This log is completely wrong. All logging needs to end with .log() the message needs to go in the .log(). Putting a string in the atWarn is the event type and not the message. Do not use string.format, use .log(\"{}\", value)", "author": "MikeDombo", "createdAt": "2020-08-04T19:17:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);\n+        if (servicesConfig == null) {\n+            logger.atWarn(String.format(\"No services found in config.\"));\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each component\n+        for (Node componentConfigNode : servicesConfig) {\n+            Topics componentConfigTopics = (Topics) componentConfigNode;\n+            String componentName = componentConfigTopics.getName();\n+\n+            //Get the Access Control List for this component\n+            Topics accessControlTopics = componentConfigTopics.findTopics(ACCESS_CONTROL_KEY);\n+            if (accessControlTopics == null) {\n+                logger.atWarn(String.format(\"Component %s has no valid accessControl component field.\", componentName));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431833", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Mjk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjE1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276150", "bodyText": "I don't like this idea because it is dependent on the config layout. Use kernel.orderedDependencies() to get the list of all services, then use service.getConfig() to get their config.", "author": "MikeDombo", "createdAt": "2020-08-04T19:24:06Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431827", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276803", "bodyText": "this log line can be shortened using our convenience overrides you can do atError(<event type>, <exception>).kv(key, value).log(<stuff>). kv == addKeyValue", "author": "MikeDombo", "createdAt": "2020-08-04T19:25:04Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +55,28 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"initialize-pubsub-authorization-error\").setCause(e)", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431822", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\nindex 0ad90e24cf..64355b9084 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java\n\n@@ -64,19 +65,19 @@ public class PubSubIPCService extends EvergreenService {\n         try {\n             authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n         } catch (AuthorizationException e) {\n-            logger.atError().setEventType(\"initialize-pubsub-authorization-error\").setCause(e)\n-                    .addKeyValue(DESTINATION_STRING, destination.name())\n+            logger.atError(\"initialize-pubsub-authorization-error\", e)\n+                    .kv(DESTINATION_STRING, destination.name())\n                     .log(\"Failed to initialize the Pub/Sub service with the Authorization module.\");\n         }\n \n         try {\n             router.registerServiceCallback(destination.getValue(), this::handleMessage);\n-            logger.atInfo().setEventType(\"register-request-handler\")\n-                    .addKeyValue(DESTINATION_STRING, destination.name())\n+            logger.atInfo(\"register-request-handler\")\n+                    .kv(DESTINATION_STRING, destination.name())\n                     .log();\n         } catch (IPCException e) {\n-            logger.atError().setEventType(\"register-request-handler-error\").setCause(e)\n-                    .addKeyValue(DESTINATION_STRING, destination.name())\n+            logger.atError(\"register-request-handler-error\", e)\n+                    .kv(DESTINATION_STRING, destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzc0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465277740", "bodyText": "shutdown the context in the afterEach otherwise you're leaving a thread running forever.", "author": "MikeDombo", "createdAt": "2020-08-04T19:26:11Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java", "diffHunk": "@@ -124,12 +127,18 @@ private AuthorizationPolicy getAuthZPolicyWithEmptyPolicyId() {\n                 .build();\n     }\n \n+    @BeforeEach\n+    void beforeEach() {\n+        when(mockKernel.getConfig()).thenReturn(new Configuration(new Context()));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431818", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java\nindex d1bbbbda01..e569000385 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java\n\n@@ -131,6 +133,10 @@ public class AuthorizationHandlerTest {\n     void beforeEach() {\n         when(mockKernel.getConfig()).thenReturn(new Configuration(new Context()));\n     }\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        mockKernel.getConfig().context.close();\n+    }\n \n \n     @ParameterizedTest\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3OTkxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465279917", "bodyText": "flip these assertions, the actual value should be first and the expected value second.\n\"Expected  to equal \"", "author": "MikeDombo", "createdAt": "2020-08-04T19:28:51Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431812", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3OTkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\nindex c60a8b146c..54639f8ec7 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n\n@@ -2,8 +2,9 @@ package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Configuration;\n-import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MDI1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465280251", "bodyText": "create a constant for the service name and use that here and in the annotation", "author": "MikeDombo", "createdAt": "2020-08-04T19:29:14Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431803", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T02:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MDI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\nindex c60a8b146c..54639f8ec7 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n\n@@ -2,8 +2,9 @@ package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Configuration;\n-import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MTc5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465281792", "bodyText": "We shouldn't be throwing nulls. Handle the exception properly when parsing.", "author": "MikeDombo", "createdAt": "2020-08-04T19:30:59Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+            assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+            assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+            assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+            assertThat(policy2.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy2.getResources(), Matchers.nullValue());\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_invalid_pubsub_yaml_file_without_operations_WHEN_auth_parsing_THEN_fail() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_invalid_no_operations.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                assertThrows(NullPointerException.class, () -> AuthorizationUtils", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431799", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\nindex c60a8b146c..54639f8ec7 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java\n\n@@ -2,8 +2,9 @@ package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Configuration;\n-import com.aws.iot.evergreen.config.Topics;\n import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzgyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465367829", "bodyText": "These policies can be for any module other than pubsub as well. So we need to make it general. Currently it assumes policies are for pubsub right? This policy is for pubsub where is that captured?", "author": "abanthiy", "createdAt": "2020-08-04T22:34:35Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431789", "bodyText": "This should be usable for any generic policy", "author": "avipinku", "createdAt": "2020-08-05T02:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 8153f152bb..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -5,56 +5,74 @@ import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationUtils {\n \n-    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n-    private static final String SERVICES_KEY = \"services\";\n-\n-    private AuthorizationUtils(){\n+    private AuthorizationUtils() {\n     }\n \n     /**\n      * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n-     * @param componentName String\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n      * @param accessControlTopic Topic\n+     * @param logger             Logger\n      * @return {@List} of {@AuthorizationPolicy}'s\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n             throws AuthorizationException {\n \n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-\n-        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n \n         //Iterate through each policy\n-        for (Map allPoliciesMap : accessControlList) {\n-            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n-                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n \n                 //Initialize these components to null\n                 String policyDescription = null;\n                 Set<String> operations = null;\n                 Set<String> resources = null;\n \n-                //Retrieve the actual policy specifications\n-                Map policyMap = (Map) policyEntry.getValue();\n+                Map<String, Object> policyMap;\n \n-                for (Object policyComponentObject : policyMap.entrySet()) {\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n                     //Iterate through the components of this policy\n-                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n                     PolicyComponentTypes policyComponentKey = toEnum(\n                             PolicyComponentTypes.class,\n                             Coerce.toString(policyComponent.getKey()),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2ODgyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465368826", "bodyText": "This should be generic message than being specific to pubsub", "author": "abanthiy", "createdAt": "2020-08-04T22:37:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");", "originalCommit": "02d6fd5499d4556da0502dffa27280ac5092042a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzMTc1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465431752", "bodyText": "good catch, fixed", "author": "avipinku", "createdAt": "2020-08-05T02:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2ODgyNg=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex a90cd66f85..3c520243d8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -42,6 +45,7 @@ public class AuthorizationHandler {\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDY0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466000646", "bodyText": "Lets log all the variables so that its easy for customers to debug.", "author": "prateek-y", "createdAt": "2020-08-05T21:00:11Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                HashSet<String> principals = new HashSet<>(java.util.Collections.singleton(componentName));\n+\n+                if (policyId == null || operations == null || principals.isEmpty()) {\n+                    String errorMessage = \"Policy component is missing or invalid\";", "originalCommit": "1c88aad1e9b4accc516cb2cd4b2f2ca84ae60d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NTMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466065306", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-05T23:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nindex 5fe3d31692..956916d53e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n\n@@ -94,11 +94,16 @@ public final class AuthorizationUtils {\n                 }\n \n                 String policyId = Coerce.toString(policyEntry.getKey());\n-                HashSet<String> principals = new HashSet<>(java.util.Collections.singleton(componentName));\n \n-                if (policyId == null || operations == null || principals.isEmpty()) {\n-                    String errorMessage = \"Policy component is missing or invalid\";\n-                    logger.atError(\"missing-policy-component\")\n+                if (policyId == null) {\n+                    String errorMessage = \"Policy ID is missing or invalid\";\n+                    logger.atError(\"missing-policy-component-policyId\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }\n+                if (operations == null || operations.isEmpty()) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"missing-policy-component-operations\")\n                             .log(errorMessage);\n                     throw new AuthorizationException(errorMessage);\n                 }\n"}}, {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5055bcbee2e9eb715770b7c9a1431c6809318746", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-05T23:36:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466056519", "bodyText": "Change the name to indicate what the mapping is. componentNameToPolicies maybe", "author": "abanthiy", "createdAt": "2020-08-05T23:20:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;", "originalCommit": "224689b3cbb8b8ae27a1729e19e315bef85abdf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODE2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466578163", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-06T17:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 3c520243d8..6b4d9ea4bc 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -53,12 +53,12 @@ public class AuthorizationHandler {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n \n-        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n         try {\n-            mappedPolicies = AuthorizationUtils\n+            componentNameToPolicies = AuthorizationUtils\n                     .parseAllAuthorizationPolicies(kernel, logger);\n \n-            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n                 this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n             }\n         } catch (AuthorizationException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODAyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466078024", "bodyText": "Does this need to be exposed to customer/first party components (not running in same JVM as kernel) by Re:invent 2020? For example to Stream manager over IPC?", "author": "abanthiy", "createdAt": "2020-08-06T00:33:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,8 +149,9 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)", "originalCommit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3Nzk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466577975", "bodyText": "SM and any other components will be making a request to the IPC which will be handled by a separate service. That separate service will then use this method to register SM.", "author": "avipinku", "createdAt": "2020-08-06T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 3c520243d8..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -159,80 +149,94 @@ public class AuthorizationHandler {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n      *\n      * @param componentName Destination component which intents to supply auth policies\n      * @param policies      policies which has list of policies. All policies are treated as separate\n      *                      and no merging or joins happen. Duplicated policies would result in duplicated\n      *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n-        // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n-        }\n-        // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n         }\n-        this.componentToAuthZConfig.put(componentName, policies);\n-    }\n \n-    /**\n-     * Update authZ policies for a single component. The policies should not have confidential\n-     * values. This method assumes that the component names for principal and destination,\n-     * the operations and resources must not be secret and can be logged or shared if required.\n-     * This method clears the existing policies for a component before refreshing with the updated list.\n-     *\n-     * @param componentName Destination component which intents to supply auth policies\n-     * @param policies      policies which has list of policies. All policies are treated as separate\n-     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n-     *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n-     */\n-    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n-        if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+\n         // First validate if all principals and operations are valid\n         for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n-\n-        authModule.clearComponentPermissions(componentName);\n         // now start adding the policies as permissions\n         for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);\n         }\n-        this.componentToAuthZConfig.replace(componentName, policies);\n     }\n \n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTQ4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466085481", "bodyText": "Any reason to choose this path as name?", "author": "abanthiy", "createdAt": "2020-08-06T01:02:09Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +24,30 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = PubSubIPCService.PUB_SUB_SERVICE_NAME, autostart = true)\n public class PubSubIPCService extends EvergreenService {\n     private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+    private static final String DESTINATION_STRING = \"destination\";\n+    public static final String PUB_SUB_SERVICE_NAME = \"aws.greengrass.ipc.pubsub\";", "originalCommit": "5055bcbee2e9eb715770b7c9a1431c6809318746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3Nzk5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466577995", "bodyText": "I was told that this is the naming schema we're propagating throughout the kernel", "author": "avipinku", "createdAt": "2020-08-06T17:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTQ4MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/39ee9af6b4fad604d39653cf8b3b8de019da9800", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-06T17:46:20Z", "type": "forcePushed"}, {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/97c1930a83fdcab29960d7c26689c5f0ce8e1033", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-06T18:06:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NDQ5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466594491", "bodyText": "What's ServiceName? Why is it a hardcoded string? It should be passed in as a parameter so this method can be used by other tests as well.", "author": "fengwang666", "createdAt": "2020-08-06T18:07:20Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+\n+        // ensure awaitIpcServiceLatch starts\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {", "originalCommit": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833266", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NDQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\nindex 44f69f2aa2..6109b92e30 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n\n@@ -1,36 +1,51 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n+import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.util.Coerce;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class IPCTestUtils {\n \n+    public static String TEST_SERVICE_NAME = \"ServiceName\";\n+\n     private IPCTestUtils() {\n \n     }\n \n-    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, Kernel kernel) throws ServiceLoadException, URISyntaxException {\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = null;\n+        serverUri = new URI((String) kernelUri.getOnce());\n+\n+        int port = serverUri.getPort();\n+        String address = serverUri.getHost();\n+\n         return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n-                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n-                        .getOnce()).build();\n+                .token(Coerce.toString(kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce())).build();\n     }\n \n-    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+    public static Kernel prepareKernelFromConfigFile(String configFile, String serviceName, Class testClass) throws InterruptedException {\n         Kernel kernel = new Kernel();\n-        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+        kernel.parseArgs(\"-i\", testClass.getResource(configFile).toString());\n \n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(serviceName) && newState.equals(State.RUNNING)) {\n                 awaitIpcServiceLatch.countDown();\n             }\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NjMwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466596307", "bodyText": "Use Coerce.toString()", "author": "fengwang666", "createdAt": "2020-08-06T18:10:38Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833275", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NjMwNw=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\nindex 44f69f2aa2..6109b92e30 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n\n@@ -1,36 +1,51 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n+import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.util.Coerce;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class IPCTestUtils {\n \n+    public static String TEST_SERVICE_NAME = \"ServiceName\";\n+\n     private IPCTestUtils() {\n \n     }\n \n-    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, Kernel kernel) throws ServiceLoadException, URISyntaxException {\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = null;\n+        serverUri = new URI((String) kernelUri.getOnce());\n+\n+        int port = serverUri.getPort();\n+        String address = serverUri.getHost();\n+\n         return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n-                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n-                        .getOnce()).build();\n+                .token(Coerce.toString(kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce())).build();\n     }\n \n-    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+    public static Kernel prepareKernelFromConfigFile(String configFile, String serviceName, Class testClass) throws InterruptedException {\n         Kernel kernel = new Kernel();\n-        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+        kernel.parseArgs(\"-i\", testClass.getResource(configFile).toString());\n \n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(serviceName) && newState.equals(State.RUNNING)) {\n                 awaitIpcServiceLatch.countDown();\n             }\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NzEzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466597138", "bodyText": "Instead of using IPCPubSubTest.class, can you make this a method parameter so it can be used by other tests as well?", "author": "fengwang666", "createdAt": "2020-08-06T18:12:11Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833281", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NzEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\nindex 44f69f2aa2..6109b92e30 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n\n@@ -1,36 +1,51 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n+import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.util.Coerce;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class IPCTestUtils {\n \n+    public static String TEST_SERVICE_NAME = \"ServiceName\";\n+\n     private IPCTestUtils() {\n \n     }\n \n-    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, Kernel kernel) throws ServiceLoadException, URISyntaxException {\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = null;\n+        serverUri = new URI((String) kernelUri.getOnce());\n+\n+        int port = serverUri.getPort();\n+        String address = serverUri.getHost();\n+\n         return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n-                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n-                        .getOnce()).build();\n+                .token(Coerce.toString(kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce())).build();\n     }\n \n-    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+    public static Kernel prepareKernelFromConfigFile(String configFile, String serviceName, Class testClass) throws InterruptedException {\n         Kernel kernel = new Kernel();\n-        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+        kernel.parseArgs(\"-i\", testClass.getResource(configFile).toString());\n \n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(serviceName) && newState.equals(State.RUNNING)) {\n                 awaitIpcServiceLatch.countDown();\n             }\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466599617", "bodyText": "This is duplicated across multiple test cases, consider extracting them to a private method.", "author": "fengwang666", "createdAt": "2020-08-06T18:16:45Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzI5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833291", "bodyText": "refactored and consolidated this logic", "author": "avipinku", "createdAt": "2020-08-07T05:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\nindex 6920e0864b..24cea11280 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n\n@@ -4,7 +4,6 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n-import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.ipc.IPCClient;\n import com.aws.iot.evergreen.ipc.IPCClientImpl;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466603872", "bodyText": "Extract ServiceName to a constant.", "author": "fengwang666", "createdAt": "2020-08-06T18:24:40Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833306", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzg3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\nindex 6920e0864b..24cea11280 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n\n@@ -4,7 +4,6 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n-import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.ipc.IPCClient;\n import com.aws.iot.evergreen.ipc.IPCClientImpl;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466611928", "bodyText": "Isn't this counter-intuitive? Why would we want to prevent unsubscribe? What would be the use case that a component is allowed to subscribe bu cannot unsubscribe?", "author": "fengwang666", "createdAt": "2020-08-06T18:39:49Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+        IPCClientImpl client2 = new IPCClientImpl(config);\n+        try {\n+            PubSub c2 = new PubSubImpl(client2);\n+\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c.subscribeToTopic(\"a\", cb.getRight());\n+            c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+            // Now unsubscribe and make sure that we only got the first message in the first client\n+            c.unsubscribeFromTopic(\"a\");\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb2 = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"second message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c2.subscribeToTopic(\"a\", cb2.getRight());\n+            c2.publishToTopic(\"a\", \"second message\".getBytes(StandardCharsets.UTF_8));\n+            cb2.getLeft().get(2, TimeUnit.SECONDS);\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+        } finally {\n+            client2.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        //Reload the kernel with the correct authorization policy\n+        kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n+        Thread.sleep(500);\n+        c.subscribeToTopic(\"a\", cb.getRight()); //now this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+    }\n+\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+\n+        //TODO: change PubSubImpl L124 to handle PubSubExceptions better by switching on AuthorizationExceptions\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_publish_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_publish.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_unsubscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833316", "bodyText": "Prateek and I are still discussing this. As we talked about offline, we may need to have a whitelist for certain operations that should not require authorization.", "author": "avipinku", "createdAt": "2020-08-07T05:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMDk4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467200988", "bodyText": "Wait. We dont need anything special, its up to the module owner to decide what operations they want to register. This is exactly why we have registerComponent. This is more for pub sub to decide as module owner. If we want to skip Unsubscribe,  pub sub module wont register it. Simple.", "author": "prateek-y", "createdAt": "2020-08-07T18:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjY5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467216692", "bodyText": "I think, same as v1, we should only allow customers to add policies for publish and subscribe. In the future, we can extend it to unsubscribe and add a default policy for all to unsubscribe.", "author": "prateek-y", "createdAt": "2020-08-07T18:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NDAyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467274025", "bodyText": "Added a SIM and TODO for this.", "author": "avipinku", "createdAt": "2020-08-07T21:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\nindex 6920e0864b..24cea11280 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java\n\n@@ -4,7 +4,6 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n-import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.ipc.IPCClient;\n import com.aws.iot.evergreen.ipc.IPCClientImpl;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMzE5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466613191", "bodyText": "Would it be simpler to change this method's parameters to take in only the service name and kernel object? Both the port and address are derived from the kernel object.", "author": "fengwang666", "createdAt": "2020-08-06T18:42:13Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzMyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833328", "bodyText": "refactored and consolidated this logic", "author": "avipinku", "createdAt": "2020-08-07T05:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMzE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\nindex 44f69f2aa2..6109b92e30 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java\n\n@@ -1,36 +1,51 @@\n package com.aws.iot.evergreen.integrationtests.ipc;\n \n+import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.util.Coerce;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class IPCTestUtils {\n \n+    public static String TEST_SERVICE_NAME = \"ServiceName\";\n+\n     private IPCTestUtils() {\n \n     }\n \n-    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, Kernel kernel) throws ServiceLoadException, URISyntaxException {\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = null;\n+        serverUri = new URI((String) kernelUri.getOnce());\n+\n+        int port = serverUri.getPort();\n+        String address = serverUri.getHost();\n+\n         return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n-                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n-                        .getOnce()).build();\n+                .token(Coerce.toString(kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce())).build();\n     }\n \n-    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+    public static Kernel prepareKernelFromConfigFile(String configFile, String serviceName, Class testClass) throws InterruptedException {\n         Kernel kernel = new Kernel();\n-        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+        kernel.parseArgs(\"-i\", testClass.getResource(configFile).toString());\n \n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(serviceName) && newState.equals(State.RUNNING)) {\n                 awaitIpcServiceLatch.countDown();\n             }\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466614896", "bodyText": "Do you need a null check on the get method?", "author": "fengwang666", "createdAt": "2020-08-06T18:45:32Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java", "diffHunk": "@@ -38,6 +38,10 @@ public void addPermission(final String destination, Permission permission) throw\n         permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n     }\n \n+    public void clearComponentPermissions(String destination) {\n+        permissions.get(destination).clear();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzA5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466617092", "bodyText": "Also the List<Permission> need to be thread-safe? It seems multiple threads can access it concurrently.", "author": "fengwang666", "createdAt": "2020-08-06T18:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzAzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623031", "bodyText": "Line66 in the isPresent method also requires a null check on the permissionForDest?", "author": "fengwang666", "createdAt": "2020-08-06T19:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833343", "bodyText": "Added a null check for the get method.\nI don't think permissions will ever be null, since it is initialized in the declaration.\nI've changed the List<Permission> to be a CopyOnWriteArrayList.\nAlso added a null check for permissionsForDest.", "author": "avipinku", "createdAt": "2020-08-07T05:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTEzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467201136", "bodyText": "Thanks for adding these guards.", "author": "prateek-y", "createdAt": "2020-08-07T18:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java\nindex 02da1314de..7b66aea395 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java\n\n@@ -35,11 +36,17 @@ public class AuthorizationModule {\n         if (resource != null && Utils.isEmpty(resource)) {\n             throw new AuthorizationException(\"Resource cannot be empty\");\n         }\n-        permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n+        permissions.computeIfAbsent(destination, a -> new CopyOnWriteArrayList<>()).add(permission);\n     }\n \n+    /**\n+     * Clear the permission list for a given destination. This is used when updating policies for a component.\n+     * @param destination destination value\n+     */\n     public void clearComponentPermissions(String destination) {\n-        permissions.get(destination).clear();\n+        if (permissions.containsKey(destination) && !Utils.isEmpty(permissions.get(destination))) {\n+            permissions.get(destination).clear();\n+        }\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzQ1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623455", "bodyText": "Just initialize it when you declare it.", "author": "fengwang666", "createdAt": "2020-08-06T19:01:15Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833355", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -37,7 +37,8 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDMzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466624334", "bodyText": "Why not just:\ntry {\n    Map<String, List<AuthorizationPolicy>> componentNameToPolicies = AuthorizationUtils.parseAllAuthorizationPolicies(kernel, logger);", "author": "fengwang666", "createdAt": "2020-08-06T19:02:55Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833365", "bodyText": "good point, fixed", "author": "avipinku", "createdAt": "2020-08-07T05:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -37,7 +37,8 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNjUzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466626537", "bodyText": "I would make this a class like AuthorizationPolicyParser and pass it in as a dependency of AuthorizationHandler. That way is more object-oriented. Utils is a bit too generic. Also don't mark the methods as static.", "author": "fengwang666", "createdAt": "2020-08-06T19:07:18Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833375", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNjUzNw=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nsimilarity index 79%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 7d2d0650e2..328a83b4bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -9,6 +9,7 @@ import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466691916", "bodyText": "I saw this method both called here and in the TES. Shouldn't parseAllAuthorizationPolicies() already include TES policy?", "author": "fengwang666", "createdAt": "2020-08-06T21:18:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -128,13 +172,14 @@ public void registerComponent(String componentName, Set<String> operations)\n      * Loads authZ policies for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MzY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466693674", "bodyText": "Line 187, why not just return? Do you need to throw an exception? Is policies empty expected or unexpected? If it's expected, then the code can handle it gracefully by just return at that point. If it's not expected, then it's a programming error we should make sure it doesn't happen using testing.", "author": "fengwang666", "createdAt": "2020-08-06T21:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5Nzc3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466697771", "bodyText": "I would revisit every line of the code that throws the AuthorizationException and think again whether that is the desired behavior. We don't want to just fail. For scenarios that we can recover (e.g. empty list), we should just handle it and move on.", "author": "fengwang666", "createdAt": "2020-08-06T21:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833400", "bodyText": "You're right, it shouldn't be necessary to have TES load it in; this should be centralized. Removed it.\nYes, you're right; policies will never be null but it could be empty in the edge case where there are no ACLs specified; i.e.\naccessControl:\n      aws.greengrass.ipc.pubsub:\n\nI've changed this method to not throw and added much more verbose logging instead in order to recover and continue.", "author": "avipinku", "createdAt": "2020-08-07T05:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNTUzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467205531", "bodyText": "Initially the idea was that each component will have its own policies. Now, we are moving to source based policies, in this case, policies for TES are not specified at TES level, but at other components. TES today allows any component to access it, a default would mean to generate allow for all components, or introduce a new global flag at TES level. This is why source is complicated, and it does not prevent us from multi group overrides anyway because TES config is again gonna get overridden and we are back to the same problem. For now, we should have default policy generator which merges with loaded policies.", "author": "prateek-y", "createdAt": "2020-08-07T18:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -159,80 +149,94 @@ public class AuthorizationHandler {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n      *\n      * @param componentName Destination component which intents to supply auth policies\n      * @param policies      policies which has list of policies. All policies are treated as separate\n      *                      and no merging or joins happen. Duplicated policies would result in duplicated\n      *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n-        // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n-        }\n-        // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n         }\n-        this.componentToAuthZConfig.put(componentName, policies);\n-    }\n \n-    /**\n-     * Update authZ policies for a single component. The policies should not have confidential\n-     * values. This method assumes that the component names for principal and destination,\n-     * the operations and resources must not be secret and can be logged or shared if required.\n-     * This method clears the existing policies for a component before refreshing with the updated list.\n-     *\n-     * @param componentName Destination component which intents to supply auth policies\n-     * @param policies      policies which has list of policies. All policies are treated as separate\n-     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n-     *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n-     */\n-    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n-        if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+\n         // First validate if all principals and operations are valid\n         for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n-\n-        authModule.clearComponentPermissions(componentName);\n         // now start adding the policies as permissions\n         for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);\n         }\n-        this.componentToAuthZConfig.replace(componentName, policies);\n     }\n \n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466698286", "bodyText": "This handling is interesting. So if some code throws AuthorizationException, we just stop loading the rest and move on? is that desirable?", "author": "fengwang666", "createdAt": "2020-08-06T21:33:24Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833417", "bodyText": "refactored to do  best-effort parsing and loading, and improve logging at each stage", "author": "avipinku", "createdAt": "2020-08-07T05:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -37,7 +37,8 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNzU2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466707567", "bodyText": "Shouldn't you do null check on the componentName before parse the policy?", "author": "fengwang666", "createdAt": "2020-08-06T21:55:41Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = findServiceForNode(updatedTopic);", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833427", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNzU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -37,7 +37,8 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466708360", "bodyText": "Is this expected or not? If it's expected, the code can just return.", "author": "fengwang666", "createdAt": "2020-08-06T21:57:50Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -144,24 +189,60 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         isComponentRegistered(componentName);\n         validatePolicyId(policies);\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             validatePrincipals(policy);\n             validateOperations(componentName, policy);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n         }\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     *\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833452", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6b4d9ea4bc..2c3bf6ac34 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -159,80 +149,94 @@ public class AuthorizationHandler {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n      *\n      * @param componentName Destination component which intents to supply auth policies\n      * @param policies      policies which has list of policies. All policies are treated as separate\n      *                      and no merging or joins happen. Duplicated policies would result in duplicated\n      *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n-        // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n-        }\n-        // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n         }\n-        this.componentToAuthZConfig.put(componentName, policies);\n-    }\n \n-    /**\n-     * Update authZ policies for a single component. The policies should not have confidential\n-     * values. This method assumes that the component names for principal and destination,\n-     * the operations and resources must not be secret and can be logged or shared if required.\n-     * This method clears the existing policies for a component before refreshing with the updated list.\n-     *\n-     * @param componentName Destination component which intents to supply auth policies\n-     * @param policies      policies which has list of policies. All policies are treated as separate\n-     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n-     *                      permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n-     */\n-    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n-        if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+\n         // First validate if all principals and operations are valid\n         for (AuthorizationPolicy policy : policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n-\n-        authModule.clearComponentPermissions(componentName);\n         // now start adding the policies as permissions\n         for (AuthorizationPolicy policy : policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);\n         }\n-        this.componentToAuthZConfig.replace(componentName, policies);\n     }\n \n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMjMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466712308", "bodyText": "Can this ever happen?", "author": "fengwang666", "createdAt": "2020-08-06T22:08:05Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833465", "bodyText": "If the customer specifies the ACL as a map instead of a list or makes a similar formatting error, this will happen", "author": "avipinku", "createdAt": "2020-08-07T05:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMjMwOA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nsimilarity index 79%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 7d2d0650e2..328a83b4bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -9,6 +9,7 @@ import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzAzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713038", "bodyText": "Why not just log and ignore? throw an exception up to the stack is very intrusive. How would the call handle it better?", "author": "fengwang666", "createdAt": "2020-08-06T22:10:08Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833477", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-07T05:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nsimilarity index 79%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 7d2d0650e2..328a83b4bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -9,6 +9,7 @@ import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzY2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713665", "bodyText": "Same comment. Is throwing an exception up the best way to handle the error?", "author": "fengwang666", "createdAt": "2020-08-06T22:11:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+\n+                if (policyId == null) {\n+                    String errorMessage = \"Policy ID is missing or invalid\";\n+                    logger.atError(\"missing-policy-component-policyId\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }\n+                if (operations == null || operations.isEmpty()) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }", "originalCommit": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzMzQ5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466833494", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-07T05:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nsimilarity index 79%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 7d2d0650e2..328a83b4bb 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -9,6 +9,7 @@ import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "message": "Rename AuthorizationUtilsTest to AuthorizationPolicyParserTest", "committedDate": "2020-08-07T17:17:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467295446", "bodyText": "this cast is unsafe. Use instanceof to make sure it actually is a topic.", "author": "MikeDombo", "createdAt": "2020-08-07T21:49:59Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +37,57 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+\n+                    Topic updatedTopic = (Topic) newv;", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344824", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -68,7 +67,11 @@ public class AuthorizationHandler {\n                     if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n                         return;\n                     }\n-\n+                    if (!(newv instanceof Topic)) {\n+                        logger.atError(\"update-authorization-formatting-error\")\n+                                .log(\"Incorrect formatting while updating the authorization ACL.\");\n+                        return;\n+                    }\n                     Topic updatedTopic = (Topic) newv;\n                     String componentName = findServiceForNode(updatedTopic);\n                     //If there is a change in a node, reload that one component's ACL\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296527", "bodyText": "use compute otherwise this isn't threadsafe.", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:21Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDgyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344828", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -150,21 +153,12 @@ public class AuthorizationHandler {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n         operations.add(ANY_REGEX);\n-        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        componentToOperationsMap.computeIfAbsent(componentName, k -> new HashSet<>()).addAll(operations);\n \n-        //Check if the component was previously registered\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n-            if (!Utils.isEmpty(existingOperations)) {\n-                existingOperations.addAll(operationsCopy);\n-            }\n-        } else {\n-            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n-        }\n     }\n \n     /**\n-     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n      * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjcwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296706", "bodyText": "extra space in single component.", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:34Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344842", "bodyText": "fixed", "author": "avipinku", "createdAt": "2020-08-08T01:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjcwNg=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -150,21 +153,12 @@ public class AuthorizationHandler {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n         operations.add(ANY_REGEX);\n-        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        componentToOperationsMap.computeIfAbsent(componentName, k -> new HashSet<>()).addAll(operations);\n \n-        //Check if the component was previously registered\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n-            if (!Utils.isEmpty(existingOperations)) {\n-                existingOperations.addAll(operationsCopy);\n-            }\n-        } else {\n-            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n-        }\n     }\n \n     /**\n-     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n      * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296991", "bodyText": "Why is this a warning, that's not a problem is it?", "author": "MikeDombo", "createdAt": "2020-08-07T21:51:56Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344857", "bodyText": "if this is empty, this means that an ACL was likely malformed or failed to load, since the AuthorizationPolicyParser would have registered an empty ACL list to a componentName that has the \"accessControl\" field.", "author": "avipinku", "createdAt": "2020-08-08T01:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyOTg0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468129842", "bodyText": "But why is that a problem for the acl list to be empty? That is definitely possible to happen, right?", "author": "MikeDombo", "createdAt": "2020-08-10T19:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODIxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468158212", "bodyText": "Yeah, you're right. I've changed this to a debug-level log.", "author": "avipinku", "createdAt": "2020-08-10T20:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -150,21 +153,12 @@ public class AuthorizationHandler {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n         operations.add(ANY_REGEX);\n-        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        componentToOperationsMap.computeIfAbsent(componentName, k -> new HashSet<>()).addAll(operations);\n \n-        //Check if the component was previously registered\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n-            if (!Utils.isEmpty(existingOperations)) {\n-                existingOperations.addAll(operationsCopy);\n-            }\n-        } else {\n-            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n-        }\n     }\n \n     /**\n-     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n      * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467297639", "bodyText": "why does it need to be registered first? Why not just handle the registration here?", "author": "MikeDombo", "createdAt": "2020-08-07T21:52:47Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTA1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345050", "bodyText": "I think we want each component to register itself on startup, instead of during policy loading. If we registered components here, customers would be able to register all sorts of services just by passing in the config, which seems like a bad idea.", "author": "avipinku", "createdAt": "2020-08-08T01:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjE0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468132146", "bodyText": "Not sure I follow this logic. Can you explain more? How does registration work, and why can't it be done on-demand instead of during startup? Also, it can't just be during startup because things need to be dynamic.", "author": "MikeDombo", "createdAt": "2020-08-10T19:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0ODIzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468148238", "bodyText": "Registration lets the Auth module know about the operations a component wishes to register for auth. Without such a method, its not possible to validate whether an ACL is valid with a defined operation. What is your suggestion on how to implement such a mechanism.", "author": "prateek-y", "createdAt": "2020-08-10T20:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0OTY3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468149670", "bodyText": "My suggestion is that you don't. The version of a resource server could change at any time which would then make the ACL valid or invalid. We should allow this.", "author": "MikeDombo", "createdAt": "2020-08-10T20:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1NDEzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468154134", "bodyText": "Lets remove the isRegistered part for now. This still has benefit that when a customer specifies an ACL, it is possible to know immediately whether it will work correctly in the future. If we do not have validateOperation then customers will only know that ACL was malformed, when they actually send requests for auth which gets rejected and it will be annoying experience.", "author": "prateek-y", "createdAt": "2020-08-10T20:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MTM5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468191399", "bodyText": "isComponentRegistered actually already doesn't check registration due to the issue we had earlier with the AuthHandler starting before components are registered. I commented out the registration check in isComponentRegistered and added a TODO with SIM link to revisit this.\nI'm leaving the isComponentRegistered check in here for now though, since we have a unit test that tests if the componentName is null.", "author": "avipinku", "createdAt": "2020-08-10T21:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -150,21 +153,12 @@ public class AuthorizationHandler {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n         operations.add(ANY_REGEX);\n-        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        componentToOperationsMap.computeIfAbsent(componentName, k -> new HashSet<>()).addAll(operations);\n \n-        //Check if the component was previously registered\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n-            if (!Utils.isEmpty(existingOperations)) {\n-                existingOperations.addAll(operationsCopy);\n-            }\n-        } else {\n-            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n-        }\n     }\n \n     /**\n-     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n      * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODUyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467298521", "bodyText": "just use put.", "author": "MikeDombo", "createdAt": "2020-08-07T21:53:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n+        }\n+\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n+        }\n+\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344873", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 2c3bf6ac34..6a9d4798dd 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -150,21 +153,12 @@ public class AuthorizationHandler {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n         operations.add(ANY_REGEX);\n-        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        componentToOperationsMap.computeIfAbsent(componentName, k -> new HashSet<>()).addAll(operations);\n \n-        //Check if the component was previously registered\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n-            if (!Utils.isEmpty(existingOperations)) {\n-                existingOperations.addAll(operationsCopy);\n-            }\n-        } else {\n-            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n-        }\n     }\n \n     /**\n-     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n      * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299429", "bodyText": "why do you need this?", "author": "MikeDombo", "createdAt": "2020-08-07T21:55:11Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.name;\n+        }\n+    }\n+\n+    @Override\n+    public int compareTo(AuthorizationPolicy other) {\n+        return this.policyId.compareTo(other.policyId);\n+    }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344875", "bodyText": "parseAllAuthorizationPolicies() returns an unsorted HashMap, which can cause unit tests to fail between test runs due to differences in policy ordering. I can probably change it to use a TreeMap instead and get rid of this", "author": "avipinku", "createdAt": "2020-08-08T01:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTA5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345096", "bodyText": "You also could change the tests to use the hamcrest matcher containsInAnyOrder, depending on what exactly you're testing", "author": "MikeDombo", "createdAt": "2020-08-08T01:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTM4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345385", "bodyText": "I'd rather not use containsInAnyOrder since I'm checking that each field in the policy matches the expected value.\nI think it may actually be useful to keep this compareTo because otherwise we have no way of comparing policies against each other...", "author": "avipinku", "createdAt": "2020-08-08T01:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTUzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345537", "bodyText": "why would order matter?", "author": "MikeDombo", "createdAt": "2020-08-08T01:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NTkxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467345914", "bodyText": "Not specifically just for ordering but if we need to compare policies at some point down the road...it doesn't matter too much either way I suppose.", "author": "avipinku", "createdAt": "2020-08-08T01:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\nindex 2d64309392..9be6eb86e1 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n\n@@ -23,7 +23,7 @@ public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n         PRINCIPALS(\"principals\"),\n         OPERATIONS(\"operations\"),\n         RESOURCES(\"resources\"),\n-        INVALID_ENUM(\"invalid_enum\");\n+        UNKNOWN(\"unknown\");\n \n         private final String name;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTc4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299785", "bodyText": "instead of catching you can just use instanceof to make sure the cast is safe.", "author": "MikeDombo", "createdAt": "2020-08-07T21:55:39Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344880", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 328a83b4bb..bb488fe36a 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -35,18 +35,21 @@ public final class AuthorizationPolicyParser {\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n     public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                         Logger logger) {\n+                                                                  Logger logger) {\n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-        List<Map<String, Object>> accessControlList;\n \n-        try {\n-            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n-        } catch (ClassCastException e) {\n-            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\")\n                     .log(\"Error while retrieving the Access Control List\");\n             return newAuthorizationPolicyList;\n         }\n \n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n         //Iterate through each policy\n         for (Map<String, Object> allPoliciesMap : accessControlList) {\n             for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300519", "bodyText": "the key can't be null anyway, so I don't think this check is needed", "author": "MikeDombo", "createdAt": "2020-08-07T21:56:38Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344884", "bodyText": "removed", "author": "avipinku", "createdAt": "2020-08-08T01:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 328a83b4bb..bb488fe36a 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -35,18 +35,21 @@ public final class AuthorizationPolicyParser {\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n     public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                         Logger logger) {\n+                                                                  Logger logger) {\n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-        List<Map<String, Object>> accessControlList;\n \n-        try {\n-            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n-        } catch (ClassCastException e) {\n-            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\")\n                     .log(\"Error while retrieving the Access Control List\");\n             return newAuthorizationPolicyList;\n         }\n \n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n         //Iterate through each policy\n         for (Map<String, Object> allPoliciesMap : accessControlList) {\n             for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300938", "bodyText": "replace \"service\" with \"component\" everywhere.", "author": "MikeDombo", "createdAt": "2020-08-07T21:57:09Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                if (policyId == null) {\n+                    logger.atError(\"load-authorization-missing-policy-component-policyId\")\n+                            .log(\"Policy ID is missing or invalid\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            logger.atError(\"load-authorization-config-unknown policy key\")\n+                                    .log(\"Component {} has an invalid policy key in policy {}\", componentName,\n+                                            policyId);\n+                            continue;\n+                    }\n+                }\n+\n+                if (Utils.isEmpty(operations)) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"load-authorization-missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    continue;\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(policyId)\n+                        .policyDescription(policyDescription)\n+                        .principals(java.util.Collections.singleton(componentName))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-service-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());", "originalCommit": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0NDg5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467344892", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-08T01:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDkzOA=="}], "type": "inlineReview", "revised_code": {"commit": "68a368746998c94522d4c36d57bf7fa3507330cc", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 328a83b4bb..bb488fe36a 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -35,18 +35,21 @@ public final class AuthorizationPolicyParser {\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n     public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                         Logger logger) {\n+                                                                  Logger logger) {\n         List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n-        List<Map<String, Object>> accessControlList;\n \n-        try {\n-            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n-        } catch (ClassCastException e) {\n-            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\")\n                     .log(\"Error while retrieving the Access Control List\");\n             return newAuthorizationPolicyList;\n         }\n \n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n         //Iterate through each policy\n         for (Map<String, Object> allPoliciesMap : accessControlList) {\n             for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n"}}, {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68a368746998c94522d4c36d57bf7fa3507330cc", "message": "Revised according to feedback", "committedDate": "2020-08-10T17:53:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468125717", "bodyText": "[nit]\nInject these for easier testing.", "author": "MikeDombo", "createdAt": "2020-08-10T19:23:19Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODAzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468158036", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T20:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6a9d4798dd..09626b477b 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -33,24 +37,28 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule = new AuthorizationModule();\n-    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+    \n     /**\n      * Constructor for AuthZ.\n      *\n      * @param kernel kernel module for getting component information\n+     * @param authModule authorization module to store the authorization state\n+     * @param policyParser for parsing a given policy ACL\n      */\n     @Inject\n-    public AuthorizationHandler(Kernel kernel) {\n+    public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n+                                AuthorizationPolicyParser policyParser) {\n         this.kernel = kernel;\n+        this.authModule = authModule;\n \n         Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n                 kernel, logger);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNjMxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468126318", "bodyText": "[nit]\nAdd a k-v for the Node's full name", "author": "MikeDombo", "createdAt": "2020-08-10T19:24:16Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    if (!(newv instanceof Topic)) {\n+                        logger.atError(\"update-authorization-formatting-error\")", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1Nzk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468157993", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T20:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNjMxOA=="}], "type": "inlineReview", "revised_code": {"commit": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 6a9d4798dd..09626b477b 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -33,24 +37,28 @@ import static com.aws.iot.evergreen.kernel.Kernel.findServiceForNode;\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule = new AuthorizationModule();\n-    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+    \n     /**\n      * Constructor for AuthZ.\n      *\n      * @param kernel kernel module for getting component information\n+     * @param authModule authorization module to store the authorization state\n+     * @param policyParser for parsing a given policy ACL\n      */\n     @Inject\n-    public AuthorizationHandler(Kernel kernel) {\n+    public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n+                                AuthorizationPolicyParser policyParser) {\n         this.kernel = kernel;\n+        this.authModule = authModule;\n \n         Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n                 kernel, logger);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMzQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468133482", "bodyText": "the enum isn't invalid, the value is invalid. Change this to \"UNKNOWN\" or \"INVALID_VALUE\"", "author": "MikeDombo", "createdAt": "2020-08-10T19:30:50Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");", "originalCommit": "68a368746998c94522d4c36d57bf7fa3507330cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1NzkzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468157932", "bodyText": "changed to UNKNOWN", "author": "avipinku", "createdAt": "2020-08-10T20:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMzQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\nindex 2d64309392..9be6eb86e1 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n\n@@ -23,7 +23,7 @@ public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n         PRINCIPALS(\"principals\"),\n         OPERATIONS(\"operations\"),\n         RESOURCES(\"resources\"),\n-        INVALID_ENUM(\"invalid_enum\");\n+        UNKNOWN(\"unknown\");\n \n         private final String name;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzEyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468233122", "bodyText": "If you're using constructor injection, move this into the constructor instead. Unless there's a reason not to.", "author": "MikeDombo", "createdAt": "2020-08-10T23:05:00Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +38,81 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler implements InjectionActions {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+\n+    private final AuthorizationPolicyParser policyParser;\n+\n+    @Override\n+    public void postInject() {", "originalCommit": "94ef07ebab1e8b1bc05374de9caadfa6575119ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzQxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468237412", "bodyText": "Yeah, this is a relic of when I was using field injection. Removed.", "author": "avipinku", "createdAt": "2020-08-10T23:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 5ff2e80a96..09626b477b 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -38,7 +37,7 @@ import static com.aws.iot.evergreen.tes.TokenExchangeService.TOKEN_EXCHANGE_SERV\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler implements InjectionActions {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDkyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468234923", "bodyText": "again, you could use instanceof instead of catching the exception.", "author": "MikeDombo", "createdAt": "2020-08-10T23:10:58Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                  Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n+                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {", "originalCommit": "94ef07ebab1e8b1bc05374de9caadfa6575119ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MTI1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468241259", "bodyText": "done", "author": "avipinku", "createdAt": "2020-08-10T23:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "5d01e679683db12e548169c3380e42f1f1b57bc7", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\nindex 97925036c8..d1bd687b16 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java\n\n@@ -61,15 +61,13 @@ public final class AuthorizationPolicyParser {\n \n                 Map<String, Object> policyMap;\n \n-                try {\n-                    //Retrieve the actual policy specifications\n-                    policyMap = (Map<String, Object>) policyEntry.getValue();\n-                } catch (ClassCastException e) {\n-                    logger.atWarn(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n-                            .log(\"Error while retrieving an Access Control List policy\");\n+                //Retrieve the actual policy specifications\n+                if (!(policyEntry.getValue() instanceof Map)) {\n+                    logger.atWarn(\"load-authorization-access-control-list-policy-retrieval-error\")\n+                        .log(\"Error while retrieving an Access Control List policy\");\n                     continue;\n                 }\n-\n+                policyMap = (Map<String, Object>) policyEntry.getValue();\n                 String policyId = Coerce.toString(policyEntry.getKey());\n \n                 for (Map.Entry policyComponent : policyMap.entrySet()) {\n"}}, {"oid": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "message": "Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:11:44Z", "type": "forcePushed"}, {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "message": " Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:27:06Z", "type": "commit"}, {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "message": " Initial AuthZ Pub/Sub Integration", "committedDate": "2020-08-10T23:27:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NTc2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468275761", "bodyText": "Why are we loading tes here? Can tes load itself?", "author": "MikeDombo", "createdAt": "2020-08-11T01:32:23Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +37,73 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+    \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n+     * @param authModule authorization module to store the authorization state\n+     * @param policyParser for parsing a given policy ACL\n      */\n     @Inject\n-    public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n+    public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n+                                AuthorizationPolicyParser policyParser) {\n         this.kernel = kernel;\n+        this.authModule = authModule;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Load default policy for TES\n+        this.loadAuthorizationPolicies(TOKEN_EXCHANGE_SERVICE_TOPICS,", "originalCommit": "5d01e679683db12e548169c3380e42f1f1b57bc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3OTcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468279723", "bodyText": "We would need this consolidated now, as in the future, components might declare exclusive access to TES. So tes would have to subscribe for auth changes as well. Earlier the plan was that a component would only manage its own auth, so it made sense. Going forward we need to think about default policies in general.", "author": "prateek-y", "createdAt": "2020-08-11T01:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NTc2MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b6f79ca3724dda9bde072197472dee8d3865140e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6f79ca3724dda9bde072197472dee8d3865140e", "message": "Merge branch 'master' into authZ_pubsub", "committedDate": "2020-08-11T02:26:33Z", "type": "commit"}]}