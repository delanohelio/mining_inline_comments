{"pr_number": 422, "pr_title": "Make S3 integrity check mandatory, perform download only if necessary", "pr_createdAt": "2020-09-09T19:11:26Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485856862", "bodyText": "what if the algorithm and digest aren't specified?", "author": "MikeDombo", "createdAt": "2020-09-09T19:23:06Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -3,16 +3,89 @@\n \n package com.aws.iot.evergreen.packagemanager.plugins;\n \n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.ArtifactChecksumMismatchException;\n import com.aws.iot.evergreen.packagemanager.exceptions.InvalidArtifactUriException;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n import com.aws.iot.evergreen.packagemanager.models.ComponentArtifact;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n \n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n \n-public interface ArtifactDownloader {\n-    File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifact artifact, Path saveToPath)\n+public abstract class ArtifactDownloader {\n+    static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n+            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+\n+    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n+                                             PackageIdentifier packageIdentifier, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());", "originalCommit": "3756df0382d908dc6e4da3325702ad2cadfab728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NDY1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485864650", "bodyText": "That's handled in respective implementations, end goal is both types of artifacts must have algorithm and digest and device fails deployment if it's not present. But right now, cloud sets the artifacts and digest for private components but their public component publish workflow isn't ready yet so greengrass: type artifacts don't have the information in recipe as of today so had to temporarily make it optional for greengras: while it's mandatory for s3: type", "author": "shaguptashaikh", "createdAt": "2020-09-09T19:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NjgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485866809", "bodyText": "So, if I'm just trying things out locally, I still need a digest? That seems super annoying. Why would we want that limitation? If cloud puts in the digest for all S3 automatically, then there's no reason to force it on the device", "author": "MikeDombo", "createdAt": "2020-09-09T19:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2OTYxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485869618", "bodyText": "Local deployment doesn't have the downloader in the code path right? this should just get bypassed for local deployment, no?", "author": "shaguptashaikh", "createdAt": "2020-09-09T19:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MDU4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485870582", "bodyText": "There's no separate codepath", "author": "MikeDombo", "createdAt": "2020-09-09T19:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MDgxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485870810", "bodyText": "Of course it's not acceptable to require digest for local testing because customer shouldn't need to worry about it, so I'll change it if it affects local deployments", "author": "shaguptashaikh", "createdAt": "2020-09-09T19:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3MjA0Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485872047", "bodyText": "Thanks, yes it does affect it which is why there's the \"fallback\" comments and codepath where it finds it locally after failing to download from cloud. that's for the local deployment case", "author": "MikeDombo", "createdAt": "2020-09-09T19:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3Njg0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485876846", "bodyText": "Okay, I'll see how to account for that, but sounds erroneous to me that we first try to download from cloud and then fallback, because when customer is trying to test their artifact file locally all we need is that file to exist in the local path they give us and copy it to the store. If the same file name exists for that component version in cloud then looks like we'll end up using the cloud artifact even if customer has modified it locally. Not sure why this was done like this", "author": "shaguptashaikh", "createdAt": "2020-09-09T19:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3MjEwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485972103", "bodyText": "Okay, so based on the long offline discussion, I've made some changes to not require integrity check when digest doesn't exist in recipe. There's no deployment type check because the only case when there won't be digest in recipe is for local deployment, recipes downloaded from cloud will always have digest", "author": "shaguptashaikh", "createdAt": "2020-09-09T23:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1Njg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "29a4f5093b3a1ff7d09e8f2e055b4b58948fc43a", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\nindex 31234cbe..823b7148 100644\n--- a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n+++ b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n\n@@ -10,6 +10,7 @@ import com.aws.iot.evergreen.packagemanager.exceptions.InvalidArtifactUriExcepti\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n import com.aws.iot.evergreen.packagemanager.models.ComponentArtifact;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.io.File;\n import java.io.FileInputStream;\n"}}, {"oid": "29a4f5093b3a1ff7d09e8f2e055b4b58948fc43a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/29a4f5093b3a1ff7d09e8f2e055b4b58948fc43a", "message": "Make S3 integrity check mandatory, add optional integrity check for public artifacts, perform download only if necessary", "committedDate": "2020-09-09T23:08:24Z", "type": "forcePushed"}, {"oid": "ad0336dd7aa351eae8c15d62481afd6395e42096", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ad0336dd7aa351eae8c15d62481afd6395e42096", "message": "Make S3 integrity check mandatory, add optional integrity check for public artifacts, perform download only if necessary", "committedDate": "2020-09-09T23:21:42Z", "type": "forcePushed"}, {"oid": "8a557731e911f963069943c885aa6d9fef558cc6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8a557731e911f963069943c885aa6d9fef558cc6", "message": "Make S3 integrity check mandatory, add optional integrity check for public artifacts, perform download only if necessary", "committedDate": "2020-09-09T23:27:05Z", "type": "commit"}, {"oid": "8a557731e911f963069943c885aa6d9fef558cc6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8a557731e911f963069943c885aa6d9fef558cc6", "message": "Make S3 integrity check mandatory, add optional integrity check for public artifacts, perform download only if necessary", "committedDate": "2020-09-09T23:27:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5MjQyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485992429", "bodyText": "use try with resources to close the input stream?", "author": "MikeDombo", "createdAt": "2020-09-10T00:25:49Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -3,16 +3,109 @@\n \n package com.aws.iot.evergreen.packagemanager.plugins;\n \n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.ArtifactChecksumMismatchException;\n import com.aws.iot.evergreen.packagemanager.exceptions.InvalidArtifactUriException;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n import com.aws.iot.evergreen.packagemanager.models.ComponentArtifact;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n \n-public interface ArtifactDownloader {\n-    File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifact artifact, Path saveToPath)\n+public abstract class ArtifactDownloader {\n+    static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n+            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+\n+    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n+                                             PackageIdentifier packageIdentifier, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+            byte[] buffer = new byte[1024];\n+            int readBytes = artifactObject.read(buffer);\n+            while (readBytes > -1) {\n+                // Compute digest as well as write to the file path\n+                messageDigest.update(buffer, 0, readBytes);\n+                artifactFile.write(buffer, 0, readBytes);\n+                readBytes = artifactObject.read(buffer);\n+            }\n+            artifactObject.close();\n+            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+            if (!digest.equals(artifact.getChecksum())) {\n+                // Handle failure in integrity check, delete bad file then throw\n+                Files.deleteIfExists(saveToPath);\n+                throw new ArtifactChecksumMismatchException(\n+                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                                packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                                \"Integrity check for downloaded artifact failed\"));\n+            }\n+            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                            packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+    }\n+\n+    static boolean needsDownload(ComponentArtifact artifact, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        // Local recipes don't have digest or algorithm and that's expected, in such case, use the\n+        // locally present artifact. On the other hand, recipes downloaded from cloud will always\n+        // have digest and algorithm\n+        if (Files.exists(saveToPath) && !recipeHasDigest(artifact)) {\n+            return false;\n+        } else if (!Files.exists(saveToPath)) {\n+            if (recipeHasDigest(artifact)) {\n+                return true;\n+            } else {\n+                throw new PackageDownloadException(\n+                        \"No local artifact found and recipe does not have required digest information\");\n+            }\n+        }\n+\n+        // If the file already exists and has the right content, skip download\n+        InputStream existingArtifact = null;\n+        try {\n+            existingArtifact = Files.newInputStream(saveToPath);", "originalCommit": "8a557731e911f963069943c885aa6d9fef558cc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb4b450938d7e445cc45cc4fd1ef04c046369809", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\nindex ff1f4331..afcdbd0c 100644\n--- a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n+++ b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n\n@@ -40,7 +40,7 @@ public abstract class ArtifactDownloader {\n                 artifactFile.write(buffer, 0, readBytes);\n                 readBytes = artifactObject.read(buffer);\n             }\n-            artifactObject.close();\n+\n             String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n             if (!digest.equals(artifact.getChecksum())) {\n                 // Handle failure in integrity check, delete bad file then throw\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5MjYxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485992611", "bodyText": "why is this commented out? When would we uncomment it?", "author": "MikeDombo", "createdAt": "2020-09-10T00:26:35Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -61,7 +62,23 @@ public File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifac\n                     String filename = extractFilename(url, disposition);\n \n                     try (InputStream inputStream = httpConn.getInputStream()) {\n+\n+                        // TODO : Remove this and uncomment the code below once cloud implementation for public\n+                        //  component publish workflow is ready\n                         Files.copy(inputStream, saveToPath.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n+\n+                        /*", "originalCommit": "8a557731e911f963069943c885aa6d9fef558cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5ODcxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485998713", "bodyText": "We'll uncomment it when cloud has the public component publish workflow deployed to preprod and we start getting public component recipes with digest and algorithm, until then this stays as it has been so far, there's a TODO on line 66 above", "author": "shaguptashaikh", "createdAt": "2020-09-10T00:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5MjYxMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5MzM4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485993382", "bodyText": "does this method close the input stream? It will need to, or else close it in this method", "author": "MikeDombo", "createdAt": "2020-09-10T00:29:21Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/S3Downloader.java", "diffHunk": "@@ -68,25 +63,20 @@ public File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifac\n         String key = s3PathMatcher.group(2);\n \n         try {\n-            // Get artifact from S3\n-            // TODO : Calculating hash for integrity check needs the whole object in memory,\n-            //  However it could be an issue in the case of large files, need to evaluate if\n-            //  there's a way to get around this\n-            byte[] artifactObject = getObject(bucket, key, artifact, packageIdentifier);\n-\n-            // TODO : There is ongoing discussion on whether integrity check should be made mandatory\n-            //  and who should own calculating checksums i.e. customer vs greengrass cloud. Until\n-            //  that is resolved, integrity check here is made optional, it will be performed only if\n-            //  the downloaded recipe has checksum that can be used for validation\n-            // Perform integrity check\n-            if (!Utils.isEmpty(artifact.getChecksum()) && !Utils.isEmpty(artifact.getAlgorithm())) {\n-                performIntegrityCheck(artifactObject, artifact, packageIdentifier);\n+            Path filePath = saveToPath.resolve(extractFileName(key));\n+            // Skip download if not needed\n+            if (needsDownload(artifact, filePath)) {\n+                // Get artifact from S3\n+                InputStream artifactObject = getObject(bucket, key, artifact, packageIdentifier);\n+\n+                // Perform integrity check and save file to store\n+                checkIntegrityAndSaveToStore(artifactObject, artifact, packageIdentifier, filePath);", "originalCommit": "8a557731e911f963069943c885aa6d9fef558cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5ODg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485998865", "bodyText": "It did but I moved it to this method now since PMD was complaining", "author": "shaguptashaikh", "createdAt": "2020-09-10T00:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5MzM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "eb4b450938d7e445cc45cc4fd1ef04c046369809", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/S3Downloader.java b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/S3Downloader.java\nindex 7234b229..a3f0ec68 100644\n--- a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/S3Downloader.java\n+++ b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/S3Downloader.java\n\n@@ -62,15 +62,17 @@ public class S3Downloader extends ArtifactDownloader {\n         String bucket = s3PathMatcher.group(1);\n         String key = s3PathMatcher.group(2);\n \n+        InputStream artifactObject = null;\n         try {\n             Path filePath = saveToPath.resolve(extractFileName(key));\n             // Skip download if not needed\n             if (needsDownload(artifact, filePath)) {\n                 // Get artifact from S3\n-                InputStream artifactObject = getObject(bucket, key, artifact, packageIdentifier);\n+                artifactObject = getObject(bucket, key, artifact, packageIdentifier);\n \n                 // Perform integrity check and save file to store\n                 checkIntegrityAndSaveToStore(artifactObject, artifact, packageIdentifier, filePath);\n+\n             } else {\n                 logger.atDebug().addKeyValue(\"artifact\", artifact.getArtifactUri())\n                         .log(\"Artifact already exists, skipping download\");\n"}}, {"oid": "eb4b450938d7e445cc45cc4fd1ef04c046369809", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb4b450938d7e445cc45cc4fd1ef04c046369809", "message": "Address comments", "committedDate": "2020-09-10T00:40:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NTE4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485995181", "bodyText": "nit: add a constant for 4096 and above?", "author": "hui-yang", "createdAt": "2020-09-10T00:35:29Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -3,16 +3,109 @@\n \n package com.aws.iot.evergreen.packagemanager.plugins;\n \n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.ArtifactChecksumMismatchException;\n import com.aws.iot.evergreen.packagemanager.exceptions.InvalidArtifactUriException;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n import com.aws.iot.evergreen.packagemanager.models.ComponentArtifact;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n \n-public interface ArtifactDownloader {\n-    File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifact artifact, Path saveToPath)\n+public abstract class ArtifactDownloader {\n+    static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n+            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+\n+    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n+                                             PackageIdentifier packageIdentifier, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+            byte[] buffer = new byte[1024];\n+            int readBytes = artifactObject.read(buffer);\n+            while (readBytes > -1) {\n+                // Compute digest as well as write to the file path\n+                messageDigest.update(buffer, 0, readBytes);\n+                artifactFile.write(buffer, 0, readBytes);\n+                readBytes = artifactObject.read(buffer);\n+            }\n+            artifactObject.close();\n+            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+            if (!digest.equals(artifact.getChecksum())) {\n+                // Handle failure in integrity check, delete bad file then throw\n+                Files.deleteIfExists(saveToPath);\n+                throw new ArtifactChecksumMismatchException(\n+                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                                packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                                \"Integrity check for downloaded artifact failed\"));\n+            }\n+            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                            packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+    }\n+\n+    static boolean needsDownload(ComponentArtifact artifact, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        // Local recipes don't have digest or algorithm and that's expected, in such case, use the\n+        // locally present artifact. On the other hand, recipes downloaded from cloud will always\n+        // have digest and algorithm\n+        if (Files.exists(saveToPath) && !recipeHasDigest(artifact)) {\n+            return false;\n+        } else if (!Files.exists(saveToPath)) {\n+            if (recipeHasDigest(artifact)) {\n+                return true;\n+            } else {\n+                throw new PackageDownloadException(\n+                        \"No local artifact found and recipe does not have required digest information\");\n+            }\n+        }\n+\n+        // If the file already exists and has the right content, skip download\n+        InputStream existingArtifact = null;\n+        try {\n+            existingArtifact = Files.newInputStream(saveToPath);\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+            byte[] buffer = new byte[4096];", "originalCommit": "8a557731e911f963069943c885aa6d9fef558cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5OTA4OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485999088", "bodyText": "Done", "author": "shaguptashaikh", "createdAt": "2020-09-10T00:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NTE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb4b450938d7e445cc45cc4fd1ef04c046369809", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\nindex ff1f4331..afcdbd0c 100644\n--- a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n+++ b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n\n@@ -40,7 +40,7 @@ public abstract class ArtifactDownloader {\n                 artifactFile.write(buffer, 0, readBytes);\n                 readBytes = artifactObject.read(buffer);\n             }\n-            artifactObject.close();\n+\n             String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n             if (!digest.equals(artifact.getChecksum())) {\n                 // Handle failure in integrity check, delete bad file then throw\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NTIwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485995202", "bodyText": "return true?", "author": "hui-yang", "createdAt": "2020-09-10T00:35:36Z", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -3,16 +3,109 @@\n \n package com.aws.iot.evergreen.packagemanager.plugins;\n \n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.ArtifactChecksumMismatchException;\n import com.aws.iot.evergreen.packagemanager.exceptions.InvalidArtifactUriException;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n import com.aws.iot.evergreen.packagemanager.models.ComponentArtifact;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.util.Utils;\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n \n-public interface ArtifactDownloader {\n-    File downloadToPath(PackageIdentifier packageIdentifier, ComponentArtifact artifact, Path saveToPath)\n+public abstract class ArtifactDownloader {\n+    static final Logger logger = LogManager.getLogger(ArtifactDownloader.class);\n+    static final String ARTIFACT_DOWNLOAD_EXCEPTION_FMT =\n+            \"Failed to download artifact %s for component %s-%s, reason: %s\";\n+\n+    static void checkIntegrityAndSaveToStore(InputStream artifactObject, ComponentArtifact artifact,\n+                                             PackageIdentifier packageIdentifier, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        try (OutputStream artifactFile = Files.newOutputStream(saveToPath)) {\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+            byte[] buffer = new byte[1024];\n+            int readBytes = artifactObject.read(buffer);\n+            while (readBytes > -1) {\n+                // Compute digest as well as write to the file path\n+                messageDigest.update(buffer, 0, readBytes);\n+                artifactFile.write(buffer, 0, readBytes);\n+                readBytes = artifactObject.read(buffer);\n+            }\n+            artifactObject.close();\n+            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+            if (!digest.equals(artifact.getChecksum())) {\n+                // Handle failure in integrity check, delete bad file then throw\n+                Files.deleteIfExists(saveToPath);\n+                throw new ArtifactChecksumMismatchException(\n+                        String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                                packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                                \"Integrity check for downloaded artifact failed\"));\n+            }\n+            logger.atDebug().setEventType(\"download-artifact\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .addKeyValue(\"artifactUri\", artifact.getArtifactUri()).log(\"Passed integrity check\");\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ArtifactChecksumMismatchException(\n+                    String.format(ARTIFACT_DOWNLOAD_EXCEPTION_FMT, artifact.getArtifactUri(),\n+                            packageIdentifier.getName(), packageIdentifier.getVersion().toString(),\n+                            \"Algorithm requested for artifact checksum is not supported\"), e);\n+        }\n+    }\n+\n+    static boolean needsDownload(ComponentArtifact artifact, Path saveToPath)\n+            throws PackageDownloadException, IOException {\n+        // Local recipes don't have digest or algorithm and that's expected, in such case, use the\n+        // locally present artifact. On the other hand, recipes downloaded from cloud will always\n+        // have digest and algorithm\n+        if (Files.exists(saveToPath) && !recipeHasDigest(artifact)) {\n+            return false;\n+        } else if (!Files.exists(saveToPath)) {\n+            if (recipeHasDigest(artifact)) {\n+                return true;\n+            } else {\n+                throw new PackageDownloadException(\n+                        \"No local artifact found and recipe does not have required digest information\");\n+            }\n+        }\n+\n+        // If the file already exists and has the right content, skip download\n+        InputStream existingArtifact = null;\n+        try {\n+            existingArtifact = Files.newInputStream(saveToPath);\n+            MessageDigest messageDigest = MessageDigest.getInstance(artifact.getAlgorithm());\n+            byte[] buffer = new byte[4096];\n+            int readBytes = existingArtifact.read(buffer);\n+            while (readBytes > -1) {\n+                messageDigest.update(buffer, 0, readBytes);\n+                readBytes = existingArtifact.read(buffer);\n+            }\n+            String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n+            return !digest.equals(artifact.getChecksum());\n+\n+        } catch (IOException | NoSuchAlgorithmException e) {\n+            // If error in checking the existing content, attempt fresh download\n+            return false;", "originalCommit": "8a557731e911f963069943c885aa6d9fef558cc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5OTA2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/422#discussion_r485999065", "bodyText": "Yep, fixed", "author": "shaguptashaikh", "createdAt": "2020-09-10T00:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NTIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "eb4b450938d7e445cc45cc4fd1ef04c046369809", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\nindex ff1f4331..afcdbd0c 100644\n--- a/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n+++ b/src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java\n\n@@ -40,7 +40,7 @@ public abstract class ArtifactDownloader {\n                 artifactFile.write(buffer, 0, readBytes);\n                 readBytes = artifactObject.read(buffer);\n             }\n-            artifactObject.close();\n+\n             String digest = Base64.getEncoder().encodeToString(messageDigest.digest());\n             if (!digest.equals(artifact.getChecksum())) {\n                 // Handle failure in integrity check, delete bad file then throw\n"}}, {"oid": "583281208b872d7be9d226b77d879db3e8ad43b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/583281208b872d7be9d226b77d879db3e8ad43b5", "message": "Address comments", "committedDate": "2020-09-10T00:45:16Z", "type": "commit"}, {"oid": "583281208b872d7be9d226b77d879db3e8ad43b5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/583281208b872d7be9d226b77d879db3e8ad43b5", "message": "Address comments", "committedDate": "2020-09-10T00:45:16Z", "type": "forcePushed"}]}