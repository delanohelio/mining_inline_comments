{"pr_number": 339, "pr_title": "Set up Kernel alts and deployments directories", "pr_createdAt": "2020-07-30T05:41:33Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339", "timeline": [{"oid": "7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "message": "Kernel can detect and resume persisted deployment on launch", "committedDate": "2020-07-30T18:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMzA4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463233086", "bodyText": "Do you need to move kernel state out of BOOTSTRAP? otherwise it will keep restarting kernel", "author": "ShirleyZheng92", "createdAt": "2020-07-30T19:50:12Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,8 +162,34 @@ public Kernel launch() {\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                BootstrapManager bootstrapManager = context.get(BootstrapManager.class);\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                        kernelAlts.prepareActivation();", "originalCommit": "7a62a1eb58ea8f1743d3906e55ddc5f6d22d82da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI0MDMzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463240333", "bodyText": "kernelAlts.prepareActivation() should update the directory layout which indicates the state", "author": "hui-yang", "createdAt": "2020-07-30T20:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzMzA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "52d911ec07fa590e778c66ff6200b4f60ebcb97f", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java b/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\nindex 5be3c765..11ada5cd 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\n\n@@ -196,7 +196,9 @@ public class Kernel {\n                 logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n                 LinkedBlockingQueue<Deployment> deploymentsQueue = new LinkedBlockingQueue();\n                 context.put(DEPLOYMENTS_QUEUE, deploymentsQueue);\n-                deploymentsQueue.add(kernelAlts.loadPersistedDeployment());\n+                Deployment deployment = kernelAlts.loadPersistedDeployment();\n+                deployment.setDeploymentStage(stage);\n+                deploymentsQueue.add(deployment);\n                 // fall through to launch kernel\n             default:\n                 kernelLifecycle.launch();\n"}}, {"oid": "52d911ec07fa590e778c66ff6200b4f60ebcb97f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/52d911ec07fa590e778c66ff6200b4f60ebcb97f", "message": "Kernel can detect and resume persisted deployment on launch", "committedDate": "2020-07-30T21:51:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NTg2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463865860", "bodyText": "NIT: I feel we can have currentDeployment as a field of the DeploymentDirectoryManager, so that we don't need to pass Deployment around in Activator", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:03:45Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4OTAxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466089019", "bodyText": "Discussed offline. Will not make this change for now. Open for refactor later", "author": "hui-yang", "createdAt": "2020-08-06T01:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NTg2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex fb043e69..9a04d7e3 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -56,33 +56,33 @@ public class DeploymentDirectoryManager {\n     /**\n      * Persist the directory for the last failed deployment and clean up earlier deployments.\n      *\n-     * @param deploymentId the last deployment ID\n+     * @param fleetConfigArn\n+     *the last deployment ID\n      */\n-    public void persistPreviousDeploymentFailure(String deploymentId) {\n-        persistPreviousDeployment(previousFailureDir, deploymentId);\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n     }\n \n     /**\n      * Persist the directory for the last successful deployment and clean up earlier deployments.\n      *\n-     * @param deploymentId the last deployment ID\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n      */\n-    public void persistPreviousDeploymentSuccess(String deploymentId) {\n-        persistPreviousDeployment(previousSuccessDir, deploymentId);\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n     }\n \n-    private void persistPreviousDeployment(Path symlink, String deploymentId) {\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n         try {\n-            Path deploymentPath = getDeploymentDirectoryPath(deploymentId);\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n             if (Files.isSymbolicLink(symlink)) {\n                 Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n             }\n             Utils.deleteFileRecursively(symlink.toFile());\n             Files.createSymbolicLink(symlink, deploymentPath);\n-\n-            Utils.deleteFileRecursively(ongoingDir.toFile());\n+            Files.delete(ongoingDir);\n         } catch (IOException e) {\n-            logger.atWarn().kv(\"deploymentId\", deploymentId).log(\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n                     \"Unable to preserve artifacts from the last deployment\");\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg2NjM3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463866379", "bodyText": "I'd prefer rename to persistDeploymentFailureInPrevious()", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:05:37Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param deploymentId the last deployment ID\n+     */\n+    public void persistPreviousDeploymentFailure(String deploymentId) {", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex fb043e69..9a04d7e3 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -56,33 +56,33 @@ public class DeploymentDirectoryManager {\n     /**\n      * Persist the directory for the last failed deployment and clean up earlier deployments.\n      *\n-     * @param deploymentId the last deployment ID\n+     * @param fleetConfigArn\n+     *the last deployment ID\n      */\n-    public void persistPreviousDeploymentFailure(String deploymentId) {\n-        persistPreviousDeployment(previousFailureDir, deploymentId);\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n     }\n \n     /**\n      * Persist the directory for the last successful deployment and clean up earlier deployments.\n      *\n-     * @param deploymentId the last deployment ID\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n      */\n-    public void persistPreviousDeploymentSuccess(String deploymentId) {\n-        persistPreviousDeployment(previousSuccessDir, deploymentId);\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n     }\n \n-    private void persistPreviousDeployment(Path symlink, String deploymentId) {\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n         try {\n-            Path deploymentPath = getDeploymentDirectoryPath(deploymentId);\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n             if (Files.isSymbolicLink(symlink)) {\n                 Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n             }\n             Utils.deleteFileRecursively(symlink.toFile());\n             Files.createSymbolicLink(symlink, deploymentPath);\n-\n-            Utils.deleteFileRecursively(ongoingDir.toFile());\n+            Files.delete(ongoingDir);\n         } catch (IOException e) {\n-            logger.atWarn().kv(\"deploymentId\", deploymentId).log(\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n                     \"Unable to preserve artifacts from the last deployment\");\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MTUxNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463871515", "bodyText": "Can we put deploymentDirManager in deploymentStatusKeeper?", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:25:04Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -229,20 +232,20 @@ private void finishCurrentDeployment() throws InterruptedException {\n                         }\n                     });\n                     deploymentGroupTopics.replaceAndWait(deploymentGroupToRootPackages);\n-                    deploymentStatusKeeper\n-                            .persistAndPublishDeploymentStatus(currentDeploymentTaskMetadata.getDeploymentId(),\n-                                    currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n-                                    statusDetails);\n+                    deploymentStatusKeeper.persistAndPublishDeploymentStatus(deploymentId,\n+                            currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n+                            statusDetails);\n+                    deploymentDirectoryManager.persistPreviousDeploymentSuccess(deploymentId);\n                 } else {\n                     if (result.getFailureCause() != null) {\n                         statusDetails.put(\"deployment-failure-cause\", result.getFailureCause().toString());\n                     }\n                     //TODO: Update the groupToRootPackages mapping in config for the case where there is no rollback\n                     // and now the packages deployed for the current group are not the same as before starting\n                     // deployment\n-                    deploymentStatusKeeper\n-                            .persistAndPublishDeploymentStatus(currentDeploymentTaskMetadata.getDeploymentId(),\n-                                    currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.FAILED, statusDetails);\n+                    deploymentStatusKeeper.persistAndPublishDeploymentStatus(deploymentId,\n+                            currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.FAILED, statusDetails);\n+                    deploymentDirectoryManager.persistPreviousDeploymentFailure(deploymentId);", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4OTExOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466089118", "bodyText": "Discussed offline. Will not make this change for now. Open for refactor later", "author": "hui-yang", "createdAt": "2020-08-06T01:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3MTUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\nindex 4cca4087..cb79e07b 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\n\n@@ -232,10 +229,10 @@ public class DeploymentService extends EvergreenService {\n                         }\n                     });\n                     deploymentGroupTopics.replaceAndWait(deploymentGroupToRootPackages);\n-                    deploymentStatusKeeper.persistAndPublishDeploymentStatus(deploymentId,\n-                            currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n-                            statusDetails);\n-                    deploymentDirectoryManager.persistPreviousDeploymentSuccess(deploymentId);\n+                    deploymentStatusKeeper\n+                            .persistAndPublishDeploymentStatus(currentDeploymentTaskMetadata.getDeploymentId(),\n+                                    currentDeploymentTaskMetadata.getDeploymentType(), JobStatus.SUCCEEDED,\n+                                    statusDetails);\n                 } else {\n                     if (result.getFailureCause() != null) {\n                         statusDetails.put(\"deployment-failure-cause\", result.getFailureCause().toString());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3NDg3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r463874870", "bodyText": "Maybe have deploymentId as a parameter? In this case you don't need to have the null check on path", "author": "ShirleyZheng92", "createdAt": "2020-07-31T22:39:19Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -5,121 +5,97 @@\n \n package com.aws.iot.evergreen.deployment.activator;\n \n-import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelAlternatives;\n import com.aws.iot.evergreen.kernel.KernelLifecycle;\n \n import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n import javax.inject.Inject;\n \n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n \n /**\n  * Activation and rollback of Kernel update deployments.\n  */\n public class KernelUpdateActivator extends DeploymentActivator {\n     private final BootstrapManager bootstrapManager;\n+    private final KernelAlternatives kernelAlternatives;\n \n     @Inject\n     protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n         super(kernel);\n         this.bootstrapManager = bootstrapManager;\n+        this.kernelAlternatives = kernel.getContext().get(KernelAlternatives.class);\n     }\n \n     @Override\n     public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n-                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture, Deployment deployment) {\n         String deploymentId = deploymentDocument.getDeploymentId();\n         if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n             return;\n         }\n \n         // Wait for all services to close\n-        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(30);\n         kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n         try {\n-            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n-            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n-                    deploymentId.replace(':', '.').replace('/', '+')));\n-            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+            deploymentDirectoryManager.takeSnapshot(deploymentDirectoryManager.getTargetConfigFilePath(deploymentId));\n+            bootstrapManager.setPersistedTaskFilePath(\n+                    deploymentDirectoryManager.getBootstrapTaskFilePath(deploymentId));\n+            bootstrapManager.persistBootstrapTaskList();", "originalCommit": "6056551123418e05f348a41234370f0484ad3e14", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java b/src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java\nindex cc38354e..9403d612 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java\n\n@@ -5,97 +5,121 @@\n \n package com.aws.iot.evergreen.deployment.activator;\n \n+import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n-import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n-import com.aws.iot.evergreen.kernel.KernelAlternatives;\n import com.aws.iot.evergreen.kernel.KernelLifecycle;\n \n import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n import javax.inject.Inject;\n \n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n-import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n \n /**\n  * Activation and rollback of Kernel update deployments.\n  */\n public class KernelUpdateActivator extends DeploymentActivator {\n     private final BootstrapManager bootstrapManager;\n-    private final KernelAlternatives kernelAlternatives;\n \n     @Inject\n     protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n         super(kernel);\n         this.bootstrapManager = bootstrapManager;\n-        this.kernelAlternatives = kernel.getContext().get(KernelAlternatives.class);\n     }\n \n     @Override\n     public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n-                         CompletableFuture<DeploymentResult> totallyCompleteFuture, Deployment deployment) {\n+                         CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n         String deploymentId = deploymentDocument.getDeploymentId();\n         if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n             return;\n         }\n \n         // Wait for all services to close\n-        kernel.getContext().get(KernelLifecycle.class).stopAllServices(30);\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n         kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n         try {\n-            deploymentDirectoryManager.takeSnapshot(deploymentDirectoryManager.getTargetConfigFilePath(deploymentId));\n-            bootstrapManager.setPersistedTaskFilePath(\n-                    deploymentDirectoryManager.getBootstrapTaskFilePath(deploymentId));\n-            bootstrapManager.persistBootstrapTaskList();\n-\n-            kernelAlternatives.prepareBootstrap(deploymentId);\n+            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n+            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n+                    deploymentId.replace(':', '.').replace('/', '+')));\n+            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n         } catch (IOException e) {\n-            rollback(deploymentDocument, deployment, e);\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n             return;\n         }\n+        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n+        bootstrapManager.persistBootstrapTaskList();\n+        // TODO: KernelAlts prepare bootstrap\n \n         try {\n             int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n             if (!bootstrapManager.hasNext()) {\n+                // TODO: flip symlinks, new to current\n                 logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n             }\n             // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n             // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n-            logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n+            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")\n                     + \" requested to complete bootstrap task\");\n+            // TODO: Kernel shutdown supports exit code\n+            // System.exit(exitCode == 101 ? 101 : 100);\n \n-            kernel.shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n-        } catch (ServiceUpdateException | IOException e) {\n-            rollback(deploymentDocument, deployment, e);\n+        } catch (ServiceUpdateException e) {\n+            rollback(deploymentDocument, totallyCompleteFuture, e);\n             return;\n         }\n     }\n \n-    void rollback(DeploymentDocument deploymentDocument, Deployment deployment,\n+    void rollback(DeploymentDocument deploymentDocument, CompletableFuture<DeploymentResult> totallyCompleteFuture,\n                   Throwable failureCause) {\n-        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentDocument.getDeploymentId())\n+        String deploymentId = deploymentDocument.getDeploymentId();\n+        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                 .log(\"Rolling back failed deployment\");\n-        deployment.setStageDetails(failureCause.getMessage());\n-        deployment.setDeploymentStage(Deployment.DeploymentStage.KERNEL_ROLLBACK);\n \n-        try {\n-            deploymentDirectoryManager.writeDeploymentMetadata(deployment);\n-        } catch (IOException ioException) {\n-            logger.atError().setCause(ioException).log(\"Failed to persist deployment details\");\n-        }\n-        try {\n-            kernelAlternatives.prepareRollback();\n-        } catch (IOException e) {\n-            logger.atError().setCause(e).log(\"Failed to set up rollback directory\");\n+        // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+        long mergeTime = rollbackConfig(deploymentId, totallyCompleteFuture, failureCause);\n+        if (mergeTime == -1) {\n+            return;\n         }\n-        // Restart Kernel regardless and rely on loader orchestration\n-        kernel.shutdown(30, REQUEST_RESTART);\n+\n+        kernel.getContext().get(ExecutorService.class).execute(() -> {\n+            // TODO: Add timeout\n+            try {\n+                kernel.getContext().get(KernelLifecycle.class).startupAllServices();\n+\n+                Collection<EvergreenService> servicesToTrackForRollback = kernel.orderedDependencies();\n+\n+                waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n+\n+                logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"All services rolled back\");\n+\n+                ConfigSnapshotUtils.cleanUpSnapshot(\n+                        ConfigSnapshotUtils.getSnapshotFilePath(kernel, deploymentId), logger);\n+\n+                totallyCompleteFuture.complete(new DeploymentResult(\n+                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n+            } catch (InterruptedException | ServiceUpdateException e) {\n+                // Rollback execution failed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                        .log(\"Failed to rollback deployment\");\n+                // TODO : Run user provided script to reach user defined safe state and\n+                //  set deployment status based on the success of the script run\n+                totallyCompleteFuture.complete(new DeploymentResult(\n+                        DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n+            }\n+        });\n     }\n }\n\\ No newline at end of file\n"}}, {"oid": "f514b89021436f7a8d5fe90092ae1bd5864cdab4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f514b89021436f7a8d5fe90092ae1bd5864cdab4", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T01:20:51Z", "type": "forcePushed"}, {"oid": "3b8741f936f219916cf14cb46fcc915506e4f881", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b8741f936f219916cf14cb46fcc915506e4f881", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T01:33:32Z", "type": "forcePushed"}, {"oid": "f131cdb878da07acfd3658f3c7952189f221869f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f131cdb878da07acfd3658f3c7952189f221869f", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-06T19:23:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MzQyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466673421", "bodyText": "The function just follow the symlink delete the path recursively, and it's not referring to kernelAltPath. I'd prefer remove this function and have the logic in invoker.", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:39:58Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -111,36 +130,39 @@ public void prepareRollback() throws IOException {\n      */\n     public void rollbackCompletes() throws IOException {\n         cleanupAltDir(previousFailureDir);\n-        Files.move(brokenDir, previousFailureDir, ATOMIC_MOVE);\n+        Files.createSymbolicLink(previousFailureDir, Files.readSymbolicLink(brokenDir).toAbsolutePath());\n+        Files.deleteIfExists(brokenDir);\n     }\n \n     /**\n      * Set up files and directories in order to run bootstrap steps before activating new Kernel configuration.\n      *\n+     * @param deploymentId deployment ID which associates with the bootstrap task list\n      * @throws IOException if file or directory changes fail\n      */\n-    public void prepareBootstrap() throws IOException {\n-        Files.copy(currentDir, tmpDir);\n-        Files.move(tmpDir, newDir, ATOMIC_MOVE);\n+    public void prepareBootstrap(String deploymentId) throws IOException {\n+        logger.atInfo().log(\"Setting up launch directory for new Kernel\");\n+        Path newLaunchDir = altsDir.resolve(getSafeFileName(deploymentId)).toAbsolutePath();\n+        Path existingLaunchDir = Files.readSymbolicLink(currentDir).toAbsolutePath();\n+        copyFolderRecursively(existingLaunchDir, newLaunchDir, REPLACE_EXISTING, NOFOLLOW_LINKS, COPY_ATTRIBUTES);\n+        Files.deleteIfExists(oldDir);\n+        Files.createSymbolicLink(oldDir, existingLaunchDir);\n+        Files.deleteIfExists(currentDir);\n+        Files.createSymbolicLink(currentDir, newLaunchDir);\n+        logger.atInfo().log(\"Finish setup of launch directory for new Kernel\");\n     }\n \n     /**\n      * Clean up files and directories, and remove symlink references.\n      *\n      * @param path file path to cleanup\n+     * @throws IOException if unable to delete\n      */\n-    public void cleanupAltDir(Path path) {\n-        // TODO: delete files and symlinks and then remove dir\n-    }\n-\n-    /**\n-     * Load information of the deployment to resume.\n-     *\n-     * @return Deployment\n-     */\n-    public Deployment loadPersistedDeployment() {\n-        // TODO: read deployment directory\n-        // return new Deployment(DeploymentType deploymentType, String id, DeploymentStage stage)\n-        return null;\n+    public void cleanupAltDir(Path path) throws IOException {", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTQxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466689418", "bodyText": "I can update the method name and make it private. It still can be reused in a few places.", "author": "hui-yang", "createdAt": "2020-08-06T21:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MzQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex cfafda48..bcc717c6 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -129,9 +116,11 @@ public class KernelAlternatives {\n      * @throws IOException if file or directory changes fail\n      */\n     public void rollbackCompletes() throws IOException {\n-        cleanupAltDir(previousFailureDir);\n-        Files.createSymbolicLink(previousFailureDir, Files.readSymbolicLink(brokenDir).toAbsolutePath());\n-        Files.deleteIfExists(brokenDir);\n+        if (!Files.exists(brokenDir)) {\n+            return;\n+        }\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(brokenDir).toFile());\n+        Files.delete(brokenDir);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTMxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466675310", "bodyText": "Should previousSuccess be under deployments/ instead of alts/ dir ?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:43:55Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,51 +5,68 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n     private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n     private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n     @Getter\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n+    // Symlink to the old launch directory during kernel update\n     @Getter\n     private Path oldDir;\n+    // Symlink to the broken new launch directory during kernel update\n     @Getter\n     private Path brokenDir;\n-\n+    // Symlink to the previous working launch directory after kernel update\n     private final Path previousSuccessDir;\n+    // Symlink to the broken new launch directory after rollback from kernel update\n     private final Path previousFailureDir;\n \n+    private final BootstrapManager bootstrapManager;\n+    private final DeploymentDirectoryManager deploymentDirectoryManager;\n+\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n-    public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+    public KernelAlternatives(BootstrapManager bootstrapManager, DeploymentDirectoryManager deploymentDirectoryManager,\n+                              Path kernelAltsPath) {\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n+        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR).toAbsolutePath();", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4ODU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466688593", "bodyText": "right now I have a previous pointer in both directory. The points are slightly different in that previous deployment cover all types of deployments. previous launch dir only points to the last deployment with bootstraps", "author": "hui-yang", "createdAt": "2020-08-06T21:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTMxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex cfafda48..bcc717c6 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -11,6 +11,7 @@ import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4MjEyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466682125", "bodyText": "NIT: Add a log showing unable to roll back", "author": "ShirleyZheng92", "createdAt": "2020-08-06T20:57:28Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -96,12 +114,13 @@ public void activationSucceeds() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void prepareRollback() throws IOException {\n-        if (newDir.toFile().exists()) {\n-            Files.move(newDir, brokenDir, ATOMIC_MOVE);\n+        if (!Files.exists(oldDir)) {\n             return;", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex cfafda48..bcc717c6 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -115,6 +101,7 @@ public class KernelAlternatives {\n      */\n     public void prepareRollback() throws IOException {\n         if (!Files.exists(oldDir)) {\n+            logger.atWarn().log(\"Cannot find the old launch directory to rollback to.\");\n             return;\n         }\n         Files.deleteIfExists(brokenDir);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NDI5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466684297", "bodyText": "Is this trying to clean up the unpacked artifacts of previous kernel? If so this logic should be in DeploymentService", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:01:59Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -87,7 +104,8 @@ public void prepareActivation() throws IOException {\n     public void activationSucceeds() throws IOException {\n         cleanupAltDir(previousSuccessDir);", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTY3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466691679", "bodyText": "Replied above. Both deployments dir and alts dir have previous links. It might be confusing. I'm open to suggestions.", "author": "hui-yang", "createdAt": "2020-08-06T21:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NDI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex cfafda48..bcc717c6 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -102,9 +90,7 @@ public class KernelAlternatives {\n      * @throws IOException if file or directory changes fail\n      */\n     public void activationSucceeds() throws IOException {\n-        cleanupAltDir(previousSuccessDir);\n-        cleanupAltDir(previousFailureDir);\n-        Files.createSymbolicLink(previousSuccessDir, Files.readSymbolicLink(oldDir).toAbsolutePath());\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(oldDir).toFile());\n         Files.delete(oldDir);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466695439", "bodyText": "symlink is a single file, Are we trying to follow down the symlink and delete the actual files? If not maybe just use File.delete?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:26:42Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMjY5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466702694", "bodyText": "Yes. I want to use this chance to clean up the actual files, before we have other mechanisms for cleanup.", "author": "hui-yang", "createdAt": "2020-08-06T21:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2MzgwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466763808", "bodyText": "I didn't understand the question earlier. Yes, this is just a symlink and this delete will follow the link, which is same as File.delete", "author": "hui-yang", "createdAt": "2020-08-07T01:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NTQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex c27bab15..350eaf9c 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -11,6 +11,8 @@ import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466696396", "bodyText": "Will this follow the ongoingDir symlink and remove files in the symlink?", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:28:55Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n+                    \"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(String fleetConfigArn, Deployment deployment) throws IOException {\n+        Path filePath = getDeploymentMetadataFilePath(fleetConfigArn);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(Deployment deployment) throws IOException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    private void writeDeploymentMetadata(Path filePath, Deployment deployment) throws IOException {\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(filePath))) {\n+            out.writeObject(deployment);\n+        }\n+    }\n+\n+    /**\n+     * Read Deployment object from file.\n+     *\n+     * @return deployment object\n+     * @throws IOException on I/O error\n+     * @throws ClassNotFoundException when deserialization fails\n+     */\n+    public Deployment readDeploymentMetadata() throws IOException, ClassNotFoundException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(filePath))) {\n+            return (Deployment) in.readObject();\n+        }\n+    }\n+\n+    /**\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment.\n+     *\n+     * @param filepath File path to the config snapshot\n+     * @throws IOException if write fails\n+     */\n+    public void takeSnapshot(Path filepath) throws IOException {\n+        kernel.writeEffectiveConfigAsTransactionLog(filepath);\n+    }\n+\n+    /**\n+     * Resolve snapshot file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to snapshot file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getSnapshotFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(ROLLBACK_SNAPSHOT_FILE);\n+    }\n+\n+    /**\n+     * Resolve target config file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to target config file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getTargetConfigFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(TARGET_CONFIG_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list of an ongoing deployment.\n+     *\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath() throws IOException {\n+        return Files.readSymbolicLink(ongoingDir).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted deployment metadata.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getDeploymentMetadataFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(DEPLOYMENT_METADATA_FILE);\n+    }\n+\n+    private Path getDeploymentDirectoryPath(String fleetConfigArn) throws IOException {\n+        return createNewDeploymentDirectoryIfNotExists(fleetConfigArn);\n+    }\n+\n+    private Path createNewDeploymentDirectoryIfNotExists(String fleetConfigArn) throws IOException {\n+        Path path = deploymentsDir.resolve(getSafeFileName(fleetConfigArn));\n+        if (Files.exists(path) && Files.isDirectory(path)) {\n+            return path;\n+        }\n+        if (Files.isRegularFile(path)) {\n+            Files.delete(path);\n+        }\n+        Utils.createPaths(path);\n+        Utils.deleteFileRecursively(ongoingDir.toFile());", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMzE3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466703170", "bodyText": "Yes. If ongoing dir exists at this point, then something went wrong. Not sure what's the right thing to do.", "author": "hui-yang", "createdAt": "2020-08-06T21:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDAyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466764027", "bodyText": "regarding deleteFileRecursively on a symlink, same as above", "author": "hui-yang", "createdAt": "2020-08-07T01:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex c27bab15..350eaf9c 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -11,6 +11,8 @@ import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466700041", "bodyText": "This function always symlink the fleetConfigArn to 'ongoingDir' . It might be confusing. Eg: in persistLastSuccessfulDeployment(deploymentId) , the deployment is finished and the expected behavior is 'ongoingDir' will be deleted after a successful deployment. Also, in DefaultDeployment, this class is not used in creating/performing the deployment and thus the 'ongoingDir' is not created when the deployment is actually happening.\nI'd prefer separate out a function setCurrentDeploymentPath(deploymentId) , and have DeploymentService invoke that explicitly on construction.", "author": "ShirleyZheng92", "createdAt": "2020-08-06T21:37:34Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    private static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    private static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    private static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.json\";\n+    private static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.json\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    private final Path previousSuccessDir;\n+    private final Path previousFailureDir;\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the directory for the last failed deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn the last deployment ID\n+     */\n+    public void persistLastFailedDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousFailureDir, fleetConfigArn);\n+    }\n+\n+    /**\n+     * Persist the directory for the last successful deployment and clean up earlier deployments.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     */\n+    public void persistLastSuccessfulDeployment(String fleetConfigArn) {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir, fleetConfigArn);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink, String fleetConfigArn) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath(fleetConfigArn);\n+            if (Files.isSymbolicLink(symlink)) {\n+                Utils.deleteFileRecursively(Files.readSymbolicLink(symlink).toFile());\n+            }\n+            Utils.deleteFileRecursively(symlink.toFile());\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().kv(\"fleetConfigArn\", fleetConfigArn).log(\n+                    \"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(String fleetConfigArn, Deployment deployment) throws IOException {\n+        Path filePath = getDeploymentMetadataFilePath(fleetConfigArn);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    /**\n+     * Write Deployment object to file.\n+     *\n+     * @param deployment Deployment object\n+     * @throws IOException on I/O error\n+     */\n+    public void writeDeploymentMetadata(Deployment deployment) throws IOException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        writeDeploymentMetadata(filePath, deployment);\n+    }\n+\n+    private void writeDeploymentMetadata(Path filePath, Deployment deployment) throws IOException {\n+        try (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(filePath))) {\n+            out.writeObject(deployment);\n+        }\n+    }\n+\n+    /**\n+     * Read Deployment object from file.\n+     *\n+     * @return deployment object\n+     * @throws IOException on I/O error\n+     * @throws ClassNotFoundException when deserialization fails\n+     */\n+    public Deployment readDeploymentMetadata() throws IOException, ClassNotFoundException {\n+        if (!Files.isSymbolicLink(ongoingDir)) {\n+            throw new IOException(\"Deployment details can not be loaded from file \" + ongoingDir);\n+        }\n+\n+        Path filePath = Files.readSymbolicLink(ongoingDir).toAbsolutePath().resolve(DEPLOYMENT_METADATA_FILE);\n+        try (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(filePath))) {\n+            return (Deployment) in.readObject();\n+        }\n+    }\n+\n+    /**\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment.\n+     *\n+     * @param filepath File path to the config snapshot\n+     * @throws IOException if write fails\n+     */\n+    public void takeSnapshot(Path filepath) throws IOException {\n+        kernel.writeEffectiveConfigAsTransactionLog(filepath);\n+    }\n+\n+    /**\n+     * Resolve snapshot file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to snapshot file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getSnapshotFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(ROLLBACK_SNAPSHOT_FILE);\n+    }\n+\n+    /**\n+     * Resolve target config file path.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to target config file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getTargetConfigFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(TARGET_CONFIG_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted bootstrap task list of an ongoing deployment.\n+     *\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getBootstrapTaskFilePath() throws IOException {\n+        return Files.readSymbolicLink(ongoingDir).resolve(BOOTSTRAP_TASK_FILE);\n+    }\n+\n+    /**\n+     * Resolve file path to persisted deployment metadata.\n+     *\n+     * @param fleetConfigArn Deployment fleet configuration ARN\n+     * @return Path to file\n+     * @throws IOException on I/O errors\n+     */\n+    public Path getDeploymentMetadataFilePath(String fleetConfigArn) throws IOException {\n+        return getDeploymentDirectoryPath(fleetConfigArn).resolve(DEPLOYMENT_METADATA_FILE);\n+    }\n+\n+    private Path getDeploymentDirectoryPath(String fleetConfigArn) throws IOException {\n+        return createNewDeploymentDirectoryIfNotExists(fleetConfigArn);\n+    }\n+\n+    private Path createNewDeploymentDirectoryIfNotExists(String fleetConfigArn) throws IOException {\n+        Path path = deploymentsDir.resolve(getSafeFileName(fleetConfigArn));\n+        if (Files.exists(path) && Files.isDirectory(path)) {\n+            return path;\n+        }\n+        if (Files.isRegularFile(path)) {\n+            Files.delete(path);\n+        }\n+        Utils.createPaths(path);\n+        Utils.deleteFileRecursively(ongoingDir.toFile());\n+        Files.createSymbolicLink(ongoingDir, path);", "originalCommit": "f131cdb878da07acfd3658f3c7952189f221869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNDE5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r466704197", "bodyText": "Right now it's implicitly created when a deployment requires the rollback tlog. For those disabling rollback, this directory is not set up.\nDo you suggest always create a deployment dir in the beginning of the process? Just note, sometimes there can be nothing in the directory", "author": "hui-yang", "createdAt": "2020-08-06T21:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0348cb960fb896687d80c64149626a5ab454a276", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex c27bab15..350eaf9c 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -11,6 +11,8 @@ import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n"}}, {"oid": "0348cb960fb896687d80c64149626a5ab454a276", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0348cb960fb896687d80c64149626a5ab454a276", "message": "Add unit tests and address comments", "committedDate": "2020-08-07T02:19:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467257704", "bodyText": "Why need getter on these fields , they are already in context right?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:37:44Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java", "diffHunk": "@@ -39,6 +42,13 @@\n \n     private final Kernel kernel;\n \n+    @Getter(AccessLevel.PACKAGE)\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+    @Getter(AccessLevel.PACKAGE)\n+    private KernelAlternatives kernelAlternatives;\n+    @Getter(AccessLevel.PACKAGE)\n+    private BootstrapManager bootstrapManager;\n+", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MDI5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467260298", "bodyText": "Yeah. I'm using these to unit test kernel launch. It's possible to stub these out if they are fields here or in Kernel class", "author": "hui-yang", "createdAt": "2020-08-07T20:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java\nindex 53da7b45..c38b8827 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelCommandLine.java\n\n@@ -42,13 +39,6 @@ public class KernelCommandLine {\n \n     private final Kernel kernel;\n \n-    @Getter(AccessLevel.PACKAGE)\n-    private DeploymentDirectoryManager deploymentDirectoryManager;\n-    @Getter(AccessLevel.PACKAGE)\n-    private KernelAlternatives kernelAlternatives;\n-    @Getter(AccessLevel.PACKAGE)\n-    private BootstrapManager bootstrapManager;\n-\n     @Getter\n     private String providedConfigPathName;\n     private String[] args;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODM4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467258380", "bodyText": "NIT: use setupLinkToDirectory() ?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:39:20Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -110,37 +116,39 @@ public void prepareRollback() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void rollbackCompletes() throws IOException {\n-        cleanupAltDir(previousFailureDir);\n-        Files.move(brokenDir, previousFailureDir, ATOMIC_MOVE);\n+        if (!Files.exists(brokenDir)) {\n+            return;\n+        }\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(brokenDir).toFile());\n+        Files.delete(brokenDir);\n     }\n \n     /**\n      * Set up files and directories in order to run bootstrap steps before activating new Kernel configuration.\n      *\n+     * @param deploymentId deployment ID which associates with the bootstrap task list\n      * @throws IOException if file or directory changes fail\n      */\n-    public void prepareBootstrap() throws IOException {\n-        Files.copy(currentDir, tmpDir);\n-        Files.move(tmpDir, newDir, ATOMIC_MOVE);\n-    }\n-\n-    /**\n-     * Clean up files and directories, and remove symlink references.\n-     *\n-     * @param path file path to cleanup\n-     */\n-    public void cleanupAltDir(Path path) {\n-        // TODO: delete files and symlinks and then remove dir\n+    public void prepareBootstrap(String deploymentId) throws IOException {\n+        logger.atInfo().log(\"Setting up launch directory for new Kernel\");\n+        Path newLaunchDir = altsDir.resolve(getSafeFileName(deploymentId)).toAbsolutePath();\n+        Path existingLaunchDir = Files.readSymbolicLink(currentDir).toAbsolutePath();\n+        copyFolderRecursively(existingLaunchDir, newLaunchDir, REPLACE_EXISTING, NOFOLLOW_LINKS, COPY_ATTRIBUTES);\n+        Files.deleteIfExists(oldDir);\n+        Files.createSymbolicLink(oldDir, existingLaunchDir);", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64dbb767604430a84606b3d42a79e883c565d0ff", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex bcc717c6..aacfc539 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -134,8 +133,8 @@ public class KernelAlternatives {\n         Path newLaunchDir = altsDir.resolve(getSafeFileName(deploymentId)).toAbsolutePath();\n         Path existingLaunchDir = Files.readSymbolicLink(currentDir).toAbsolutePath();\n         copyFolderRecursively(existingLaunchDir, newLaunchDir, REPLACE_EXISTING, NOFOLLOW_LINKS, COPY_ATTRIBUTES);\n-        Files.deleteIfExists(oldDir);\n-        Files.createSymbolicLink(oldDir, existingLaunchDir);\n+\n+        setupLinkToDirectory(oldDir, existingLaunchDir);\n         setupLinkToDirectory(currentDir, newLaunchDir);\n         logger.atInfo().log(\"Finish setup of launch directory for new Kernel\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1ODU1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r467258551", "bodyText": "NIT: use setupLinkToDirectory()?", "author": "ShirleyZheng92", "createdAt": "2020-08-07T20:39:47Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -96,12 +100,14 @@ public void activationSucceeds() throws IOException {\n      * @throws IOException if file or directory changes fail\n      */\n     public void prepareRollback() throws IOException {\n-        if (newDir.toFile().exists()) {\n-            Files.move(newDir, brokenDir, ATOMIC_MOVE);\n+        if (!Files.exists(oldDir)) {\n+            logger.atWarn().log(\"Cannot find the old launch directory to rollback to.\");\n             return;\n         }\n-        Files.move(currentDir, brokenDir, ATOMIC_MOVE);\n-        Files.move(oldDir, currentDir, ATOMIC_MOVE);\n+        Files.deleteIfExists(brokenDir);\n+        Files.createSymbolicLink(brokenDir, Files.readSymbolicLink(currentDir).toAbsolutePath());", "originalCommit": "ab0a2124f94f8f8b19d7aae2c394615de315ca38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64dbb767604430a84606b3d42a79e883c565d0ff", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex bcc717c6..aacfc539 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -104,10 +104,9 @@ public class KernelAlternatives {\n             logger.atWarn().log(\"Cannot find the old launch directory to rollback to.\");\n             return;\n         }\n-        Files.deleteIfExists(brokenDir);\n-        Files.createSymbolicLink(brokenDir, Files.readSymbolicLink(currentDir).toAbsolutePath());\n-        Files.delete(currentDir);\n-        Files.createSymbolicLink(currentDir, Files.readSymbolicLink(oldDir).toAbsolutePath());\n+        setupLinkToDirectory(brokenDir, Files.readSymbolicLink(currentDir).toAbsolutePath());\n+        setupLinkToDirectory(currentDir, Files.readSymbolicLink(oldDir).toAbsolutePath());\n+        Files.delete(oldDir);\n     }\n \n     /**\n"}}, {"oid": "64dbb767604430a84606b3d42a79e883c565d0ff", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/64dbb767604430a84606b3d42a79e883c565d0ff", "message": "Address comments and rebase", "committedDate": "2020-08-07T20:53:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NDUzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468054536", "bodyText": "I still feel that deploymentService should handle the cleaning up of unused package artifacts", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:12:00Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n-    @Getter\n+    // Symlink to the old launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path oldDir;\n-    @Getter\n+    // Symlink to the broken new launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path brokenDir;\n \n-    private final Path previousSuccessDir;\n-    private final Path previousFailureDir;\n-\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n     public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n     }\n \n     /**\n      * Determine if Kernel is in update workflow from deployments and return deployment stage.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @return DeploymentStage\n      */\n-    public Deployment.DeploymentStage determineDeploymentStage() {\n+    public Deployment.DeploymentStage determineDeploymentStage(BootstrapManager bootstrapManager,\n+                                                               DeploymentDirectoryManager deploymentDirectoryManager) {\n         // TODO: validate if any directory is corrupted\n-        if (newDir.toFile().exists()) {\n-            return Deployment.DeploymentStage.BOOTSTRAP;\n-        } else if (oldDir.toFile().exists()) {\n+        if (oldDir.toFile().exists()) {\n+            try {\n+                Path persistedBootstrapTasks = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+                if (!persistedBootstrapTasks.toFile().exists()) {\n+                    return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n+                }\n+                bootstrapManager.loadBootstrapTaskList(persistedBootstrapTasks);\n+                if (bootstrapManager.hasNext()) {\n+                    return Deployment.DeploymentStage.BOOTSTRAP;\n+                }\n+            } catch (IOException | ClassNotFoundException e) {\n+                logger.atWarn().setCause(e).log(\"Bootstrap task list not found or unable to read the file\");\n+            }\n             return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n         } else if (brokenDir.toFile().exists()) {\n             return Deployment.DeploymentStage.KERNEL_ROLLBACK;\n         }\n         return Deployment.DeploymentStage.DEFAULT;\n     }\n \n-    /**\n-     * Set up files and directories in order to flip Kernel to a new instance with new configuration.\n-     *\n-     * @throws IOException if file or directory changes fail\n-     */\n-    public void prepareActivation() throws IOException {\n-        Files.move(currentDir, oldDir, ATOMIC_MOVE);\n-        Files.move(newDir, currentDir, ATOMIC_MOVE);\n-    }\n-\n     /**\n      * Clean up files and directories if Kernel update deployments succeeds.\n      *\n      * @throws IOException if file or directory changes fail\n      */\n     public void activationSucceeds() throws IOException {\n-        cleanupAltDir(previousSuccessDir);\n-        cleanupAltDir(previousFailureDir);\n-        Files.move(oldDir, previousSuccessDir, ATOMIC_MOVE);\n+        Utils.deleteFileRecursively(Files.readSymbolicLink(oldDir).toFile());", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2OTYyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468069621", "bodyText": "I believe this should be handled by some logic in local component store. In the kernel case, it might be ok to clean up here as long as we can make sure current does not point to the same artifacts. But we cannot do that for other components here.", "author": "hui-yang", "createdAt": "2020-08-10T17:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NDUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex aacfc539..cfafda48 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -11,7 +11,6 @@ import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NTQzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468055437", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:13:31Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)\n     private Path currentDir;\n-    @Getter\n-    private Path newDir;\n-    @Getter\n-    private Path tmpDir;\n-    @Getter\n+    // Symlink to the old launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path oldDir;\n-    @Getter\n+    // Symlink to the broken new launch directory during kernel update\n+    @Getter(AccessLevel.MODULE)\n     private Path brokenDir;\n \n-    private final Path previousSuccessDir;\n-    private final Path previousFailureDir;\n-\n     /**\n      * Constructor for KernelAlternatives, which manages the alternative launch directory of Kernel.\n      *\n      * @param kernelAltsPath alternative launch directory of Kernel\n      */\n     public KernelAlternatives(Path kernelAltsPath) {\n-        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR);\n-        this.newDir = kernelAltsPath.resolve(NEW_DIR);\n-        this.tmpDir = kernelAltsPath.resolve(TMP_DIR);\n-        this.oldDir = kernelAltsPath.resolve(OLD_DIR);\n-        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR);\n-        this.previousSuccessDir = kernelAltsPath.resolve(PREVIOUS_SUCCESS_DIR);\n-        this.previousFailureDir = kernelAltsPath.resolve(PREVIOUS_FAILURE_DIR);\n+        this.altsDir = kernelAltsPath.toAbsolutePath();\n+        this.currentDir = kernelAltsPath.resolve(CURRENT_DIR).toAbsolutePath();\n+        this.oldDir = kernelAltsPath.resolve(OLD_DIR).toAbsolutePath();\n+        this.brokenDir = kernelAltsPath.resolve(BROKEN_DIR).toAbsolutePath();\n     }\n \n     /**\n      * Determine if Kernel is in update workflow from deployments and return deployment stage.\n      *\n+     * @param bootstrapManager BootstrapManager instance to manage pending bootstrap tasks\n+     * @param deploymentDirectoryManager DeploymentDirectoryManager instance to manage persisted deployment information\n      * @return DeploymentStage\n      */\n-    public Deployment.DeploymentStage determineDeploymentStage() {\n+    public Deployment.DeploymentStage determineDeploymentStage(BootstrapManager bootstrapManager,\n+                                                               DeploymentDirectoryManager deploymentDirectoryManager) {\n         // TODO: validate if any directory is corrupted\n-        if (newDir.toFile().exists()) {\n-            return Deployment.DeploymentStage.BOOTSTRAP;\n-        } else if (oldDir.toFile().exists()) {\n+        if (oldDir.toFile().exists()) {\n+            try {\n+                Path persistedBootstrapTasks = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+                if (!persistedBootstrapTasks.toFile().exists()) {\n+                    return Deployment.DeploymentStage.KERNEL_ACTIVATION;\n+                }\n+                bootstrapManager.loadBootstrapTaskList(persistedBootstrapTasks);\n+                if (bootstrapManager.hasNext()) {\n+                    return Deployment.DeploymentStage.BOOTSTRAP;\n+                }\n+            } catch (IOException | ClassNotFoundException e) {\n+                logger.atWarn().setCause(e).log(\"Bootstrap task list not found or unable to read the file\");", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex aacfc539..cfafda48 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -11,7 +11,6 @@ import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NjIxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468056217", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:15:05Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -333,6 +339,12 @@ private void createNewDeployment(Deployment deployment) {\n         }\n         deploymentStatusKeeper.persistAndPublishDeploymentStatus(deployment.getId(), deployment.getDeploymentType(),\n                 JobStatus.IN_PROGRESS, new HashMap<>());\n+        try {\n+            deploymentDirectoryManager.createNewDeploymentDirectoryIfNotExists(\n+                    deployment.getDeploymentDocumentObj().getDeploymentId());\n+        } catch (IOException ioException) {\n+            logger.atWarn().log(\"Unable to create deployment directory\", ioException);", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\nindex 686b1e3f..ad9a9bfe 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java\n\n@@ -339,12 +339,6 @@ public class DeploymentService extends EvergreenService {\n         }\n         deploymentStatusKeeper.persistAndPublishDeploymentStatus(deployment.getId(), deployment.getDeploymentType(),\n                 JobStatus.IN_PROGRESS, new HashMap<>());\n-        try {\n-            deploymentDirectoryManager.createNewDeploymentDirectoryIfNotExists(\n-                    deployment.getDeploymentDocumentObj().getDeploymentId());\n-        } catch (IOException ioException) {\n-            logger.atWarn().log(\"Unable to create deployment directory\", ioException);\n-        }\n         Future<DeploymentResult> process = executorService.submit(deploymentTask);\n         logger.atInfo().kv(\"deployment\", deployment.getId()).log(\"Started deployment execution\");\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA1NzI4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468057287", "bodyText": "Log error?", "author": "ShirleyZheng92", "createdAt": "2020-08-10T17:16:59Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atWarn().log(\"Unable to preserve artifacts from the last deployment\");", "originalCommit": "64dbb767604430a84606b3d42a79e883c565d0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex 350eaf9c..c27bab15 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -11,8 +11,6 @@ import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n"}}, {"oid": "62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62fed6a801d59e67a7acc693a8e27fc9fd0051dd", "message": "Set up Kernel alts and deployments directories", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "5a9aa51ebb9ed6a29e351b433162c43310cc0e16", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5a9aa51ebb9ed6a29e351b433162c43310cc0e16", "message": "Add unit tests and address comments", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "18a78f0097b622d1275b99d5017afee7fd8f7d89", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18a78f0097b622d1275b99d5017afee7fd8f7d89", "message": "Address comments and rebase", "committedDate": "2020-08-10T17:40:46Z", "type": "commit"}, {"oid": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "message": "Rebase and address comments", "committedDate": "2020-08-10T17:42:24Z", "type": "commit"}, {"oid": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "message": "Rebase and address comments", "committedDate": "2020-08-10T17:42:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468178446", "bodyText": "why are you changing this? \"Find or create\" is important.", "author": "MikeDombo", "createdAt": "2020-08-10T20:51:14Z", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -172,7 +172,7 @@ public Topic find(String... path) {\n      * exist, then it will return the default value provided.\n      *\n      * @param defaultV default value if the Topic was not found\n-     * @param path     String[] of node names to traverse to find or create the Topic\n+     * @param path     String[] of node names to traverse to find the Topic", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NzM3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468187377", "bodyText": "lookup creates if missing. Find do not create if missing. Only the doc is being updated.", "author": "fahadmohammed01", "createdAt": "2020-08-10T21:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5MzY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468193648", "bodyText": "Yes. Only fixing the java doc here.", "author": "hui-yang", "createdAt": "2020-08-10T21:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODQ0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3ODgzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468178839", "bodyText": "we don't have modules (Java 9). Use package.", "author": "MikeDombo", "createdAt": "2020-08-10T20:52:03Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex 8b52ba35..bf8ec38a 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -10,13 +10,14 @@ import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n import com.aws.iot.evergreen.util.Utils;\n import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTA2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468179065", "bodyText": "log the exception", "author": "MikeDombo", "createdAt": "2020-08-10T20:52:31Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\nindex 8b52ba35..bf8ec38a 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java\n\n@@ -10,13 +10,14 @@ import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n import com.aws.iot.evergreen.util.Utils;\n import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTUzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468181530", "bodyText": "Why are we serializing using Java? Why not use jackson?", "author": "MikeDombo", "createdAt": "2020-08-10T20:57:17Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java", "diffHunk": "@@ -28,7 +29,8 @@\n @ToString\n @EqualsAndHashCode\n // TODO: pull this class to a library to share with cloud services. SIM: https://sim.amazon.com/issues/P33788350\n-public class DeploymentDocument {\n+public class DeploymentDocument implements Serializable {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTE4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468195187", "bodyText": "Will update", "author": "hui-yang", "createdAt": "2020-08-10T21:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java b/src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java\nindex 35c34d53..5a6e7ad8 100644\n--- a/src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java\n+++ b/src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentDocument.java\n\n@@ -29,8 +28,7 @@ import java.util.List;\n @ToString\n @EqualsAndHashCode\n // TODO: pull this class to a library to share with cloud services. SIM: https://sim.amazon.com/issues/P33788350\n-public class DeploymentDocument implements Serializable {\n-    private static final long serialVersionUID = 0L;\n+public class DeploymentDocument {\n \n     @JsonProperty(\"DeploymentId\")\n     private String deploymentId;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTcyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468181729", "bodyText": "must this be public? Can it be at least package-private?", "author": "MikeDombo", "createdAt": "2020-08-10T20:57:41Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -254,8 +254,8 @@ public boolean isErrored() {\n      * @throws InterruptedException when the execution is interrupted.\n      * @throws TimeoutException     when the command execution times out.\n      */\n-    public Integer bootstrap() throws InterruptedException, TimeoutException {\n-        return null;\n+    public int bootstrap() throws InterruptedException, TimeoutException {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTc3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468195770", "bodyText": "It's used in both Kernel.launch and deployment.bootstrap.BootstrapManager. Alternative is moving deployment.bootstrap.BootstrapManager to kernel pkg, if it's more appropriate.", "author": "hui-yang", "createdAt": "2020-08-10T21:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MTcyOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4MjgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468182819", "bodyText": "use PACKAGE", "author": "MikeDombo", "createdAt": "2020-08-10T20:59:54Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java", "diffHunk": "@@ -5,89 +5,93 @@\n \n package com.aws.iot.evergreen.kernel;\n \n+import com.aws.iot.evergreen.deployment.DeploymentDirectoryManager;\n+import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n import lombok.Getter;\n \n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n-import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.getSafeFileName;\n+import static com.aws.iot.evergreen.util.Utils.copyFolderRecursively;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n \n public class KernelAlternatives {\n+    private static final Logger logger = LogManager.getLogger(BootstrapManager.class);\n+\n     private static final String CURRENT_DIR = \"current\";\n-    private static final String NEW_DIR = \"new\";\n-    private static final String TMP_DIR = \"tmp\";\n     private static final String OLD_DIR = \"old\";\n     private static final String BROKEN_DIR = \"broken\";\n-    private static final String PREVIOUS_SUCCESS_DIR = \"previousSuccess\";\n-    private static final String PREVIOUS_FAILURE_DIR = \"previousFailure\";\n \n-    @Getter\n+    private final Path altsDir;\n+    // Symlink to the current launch directory\n+    @Getter(AccessLevel.MODULE)", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\nindex 603282b0..7a501b02 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/KernelAlternatives.java\n\n@@ -33,13 +33,13 @@ public class KernelAlternatives {\n \n     private final Path altsDir;\n     // Symlink to the current launch directory\n-    @Getter(AccessLevel.MODULE)\n+    @Getter(AccessLevel.PACKAGE)\n     private Path currentDir;\n     // Symlink to the old launch directory during kernel update\n-    @Getter(AccessLevel.MODULE)\n+    @Getter(AccessLevel.PACKAGE)\n     private Path oldDir;\n     // Symlink to the broken new launch directory during kernel update\n-    @Getter(AccessLevel.MODULE)\n+    @Getter(AccessLevel.PACKAGE)\n     private Path brokenDir;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4Mzc2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468183767", "bodyText": "you can use hamcrest anExistingFile, etc.", "author": "MikeDombo", "createdAt": "2020-08-10T21:01:51Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTSTRAP_TASK_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DeploymentDirectoryManagerTest {\n+    private static final String mockArn = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:1\";\n+    private static final String expectedDirectoryName =\n+            \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.1\";\n+    @TempDir\n+    Path deploymentsDir;\n+    @Mock\n+    private Kernel kernel;\n+\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        doReturn(deploymentsDir).when(kernel).getDeploymentsPath();\n+        deploymentDirectoryManager = new DeploymentDirectoryManager(kernel);\n+    }\n+\n+    @Test\n+    public Path WHEN_create_new_deployment_dir_THEN_setup_directory_and_symlink() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        assertTrue(Files.exists(actual));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName), actual);\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getOngoingDir()));\n+        return actual;\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_succeeds_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_fails_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousSuccessDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_previous_deployment_WHEN_new_deployment_finishes_THEN_cleanup_previous_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+\n+        String mockArn2 = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:2\";\n+        String expectedDirectoryName2 =\n+                \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.2\";\n+        Path actual2 = createNewDeploymentDir(mockArn2);\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+\n+        assertFalse(Files.exists(actual1));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java b/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\nindex 45907f19..eb23d4a2 100644\n--- a/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\n\n@@ -23,9 +23,12 @@ import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTST\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.hamcrest.io.FileMatchers.anExistingFileOrDirectory;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NDA5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468184091", "bodyText": "What do we do when the deployment changes schema between an upgrade?", "author": "MikeDombo", "createdAt": "2020-08-10T21:02:30Z", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTSTRAP_TASK_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n+import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DeploymentDirectoryManagerTest {\n+    private static final String mockArn = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:1\";\n+    private static final String expectedDirectoryName =\n+            \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.1\";\n+    @TempDir\n+    Path deploymentsDir;\n+    @Mock\n+    private Kernel kernel;\n+\n+    private DeploymentDirectoryManager deploymentDirectoryManager;\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        doReturn(deploymentsDir).when(kernel).getDeploymentsPath();\n+        deploymentDirectoryManager = new DeploymentDirectoryManager(kernel);\n+    }\n+\n+    @Test\n+    public Path WHEN_create_new_deployment_dir_THEN_setup_directory_and_symlink() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        assertTrue(Files.exists(actual));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName), actual);\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getOngoingDir()));\n+        return actual;\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_succeeds_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_ongoing_dir_WHEN_deployment_fails_THEN_persist_deployment_info() throws Exception {\n+        Path actual = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+        assertEquals(actual, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousSuccessDir()));\n+    }\n+\n+    @Test\n+    public void GIVEN_previous_deployment_WHEN_new_deployment_finishes_THEN_cleanup_previous_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        deploymentDirectoryManager.persistLastFailedDeployment();\n+\n+        String mockArn2 = \"arn:aws:greengrass:us-east-1:12345678910:configuration:thinggroup/group1:2\";\n+        String expectedDirectoryName2 =\n+                \"arn.aws.greengrass.us-east-1.12345678910.configuration.thinggroup+group1.2\";\n+        Path actual2 = createNewDeploymentDir(mockArn2);\n+        deploymentDirectoryManager.persistLastSuccessfulDeployment();\n+\n+        assertFalse(Files.exists(actual1));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getPreviousFailureDir()));\n+        assertFalse(Files.exists(deploymentDirectoryManager.getOngoingDir()));\n+        assertEquals(actual2, Files.readSymbolicLink(deploymentDirectoryManager.getPreviousSuccessDir()));\n+        assertEquals(deploymentsDir.resolve(expectedDirectoryName2), actual2);\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_WHEN_write_to_file_and_read_THEN_restore_deployment() throws Exception {\n+        Path actual1 = createNewDeploymentDir(mockArn);\n+        Deployment expected = new Deployment(\"mockDoc\", Deployment.DeploymentType.IOT_JOBS, \"mockId\");\n+        deploymentDirectoryManager.writeDeploymentMetadata(expected);\n+        assertTrue(Files.exists(actual1.resolve(DEPLOYMENT_METADATA_FILE)));\n+        Deployment actual = deploymentDirectoryManager.readDeploymentMetadata();\n+        assertEquals(expected, actual);", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwMTgxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468201816", "bodyText": "Not handled yet. Deployment should be backward compatible. Will add to the backlog for corner cases.", "author": "hui-yang", "createdAt": "2020-08-10T21:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4NDA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java b/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\nindex 45907f19..eb23d4a2 100644\n--- a/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManagerTest.java\n\n@@ -23,9 +23,12 @@ import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.BOOTST\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.DEPLOYMENT_METADATA_FILE;\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.ROLLBACK_SNAPSHOT_FILE;\n import static com.aws.iot.evergreen.deployment.DeploymentDirectoryManager.TARGET_CONFIG_FILE;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.hamcrest.io.FileMatchers.anExistingFileOrDirectory;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n"}}, {"oid": "17bae15e7276a8c2452f12b4743361d53a0b5b7c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17bae15e7276a8c2452f12b4743361d53a0b5b7c", "message": "Address comments and refactor serdes", "committedDate": "2020-08-10T22:47:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjg4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468232887", "bodyText": "name persistLastFailedDeployment is kind of misleading, the funtion is actually cleaning up state of last failed deployment right?", "author": "fahadmohammed01", "createdAt": "2020-08-10T23:04:21Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MjQ2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468242464", "bodyText": "It's cleaning up the earlier one, and mark the current (the one just finished) as lastFailed.", "author": "hui-yang", "createdAt": "2020-08-10T23:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjg4Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/339#discussion_r468233674", "bodyText": "cleanupSymLinkedDirectory maybe?", "author": "fahadmohammed01", "createdAt": "2020-08-10T23:06:49Z", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentDirectoryManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import javax.inject.Inject;\n+\n+/**\n+ * Deployment directory manager preserves deployment artifacts for configuration rollback workflow and troubleshooting.\n+ */\n+public class DeploymentDirectoryManager {\n+    static final String ROLLBACK_SNAPSHOT_FILE = \"rollback_snapshot.tlog\";\n+    static final String TARGET_CONFIG_FILE = \"target_config.tlog\";\n+    static final String BOOTSTRAP_TASK_FILE = \"bootstrap_task.ser\";\n+    static final String DEPLOYMENT_METADATA_FILE = \"deployment_metadata.ser\";\n+\n+    private static final String PREVIOUS_SUCCESS_LINK = \"previous-success\";\n+    private static final String PREVIOUS_FAILURE_LINK = \"previous-failure\";\n+    private static final String ONGOING_DEPLOYMENT_LINK = \"ongoing\";\n+    private static final Logger logger = LogManager.getLogger(DeploymentDirectoryManager.class);\n+    private final Kernel kernel;\n+\n+    private final Path deploymentsDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousSuccessDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path previousFailureDir;\n+    @Getter(AccessLevel.MODULE)\n+    private final Path ongoingDir;\n+\n+    /**\n+     * Constructor of deployment directory manager for kernel.\n+     *\n+     * @param kernel a kernel instance\n+     */\n+    @Inject\n+    public DeploymentDirectoryManager(Kernel kernel) {\n+        this.kernel = kernel;\n+        this.deploymentsDir = kernel.getDeploymentsPath();\n+        this.previousFailureDir = deploymentsDir.resolve(PREVIOUS_FAILURE_LINK);\n+        this.previousSuccessDir = deploymentsDir.resolve(PREVIOUS_SUCCESS_LINK);\n+        this.ongoingDir = deploymentsDir.resolve(ONGOING_DEPLOYMENT_LINK);\n+    }\n+\n+    /**\n+     * Persist the last failed deployment and clean up earlier deployments.\n+     */\n+    public void persistLastFailedDeployment() {\n+        persistPointerToLastFinishedDeployment(previousFailureDir);\n+    }\n+\n+    /**\n+     * Persist the last successful deployment and clean up earlier deployments.\n+     */\n+    public void persistLastSuccessfulDeployment() {\n+        persistPointerToLastFinishedDeployment(previousSuccessDir);\n+    }\n+\n+    private void persistPointerToLastFinishedDeployment(Path symlink) {\n+        try {\n+            Path deploymentPath = getDeploymentDirectoryPath();\n+            cleanupPreviousDeployments(previousSuccessDir);\n+            cleanupPreviousDeployments(previousFailureDir);\n+\n+            Files.createSymbolicLink(symlink, deploymentPath);\n+            Files.delete(ongoingDir);\n+        } catch (IOException e) {\n+            logger.atError().log(\"Unable to preserve artifacts from the last deployment\");\n+        }\n+    }\n+\n+    private void cleanupPreviousDeployments(Path symlink) {", "originalCommit": "4bd4f5faa13765e66ebb5c4bea4a7e6fad3d41e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}