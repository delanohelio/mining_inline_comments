{"pr_number": 54, "pr_title": "Add unit testing for IPC and update for Netty-based IPC Client", "pr_createdAt": "2020-02-05T22:33:59Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54", "timeline": [{"oid": "0b359a08d3490ca8935b821a68cadde900c93cb5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b359a08d3490ca8935b821a68cadde900c93cb5", "message": "Fix writing effective config and getting paths of CommitableFile", "committedDate": "2020-02-05T22:27:32Z", "type": "commit"}, {"oid": "6a5e2e32a5d5223808d82be8486da9f4b7632b83", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6a5e2e32a5d5223808d82be8486da9f4b7632b83", "message": "Add unit tests for IPC server", "committedDate": "2020-02-05T22:29:16Z", "type": "commit"}, {"oid": "478a27e9055bee747f5615f12c03f22236691aaf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/478a27e9055bee747f5615f12c03f22236691aaf", "message": "Update to match IPC client changes", "committedDate": "2020-02-05T22:33:40Z", "type": "commit"}, {"oid": "cbd28eac0d9844bd0a5fbef5ebb94738d75da002", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbd28eac0d9844bd0a5fbef5ebb94738d75da002", "message": "Merge branch 'master' into netty_client_changes", "committedDate": "2020-02-05T23:04:12Z", "type": "commit"}, {"oid": "0487faf174865d66ed37a559e017c7545ba50652", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0487faf174865d66ed37a559e017c7545ba50652", "message": "Merge branch 'master' into netty_client_changes", "committedDate": "2020-02-06T00:07:10Z", "type": "commit"}, {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/316542c6089da88a4b8a5107dae97e5dba39dfbf", "message": "Merge branch 'master' into netty_client_changes", "committedDate": "2020-02-06T00:27:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Mjk0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375582942", "bodyText": "Super clear! Helped a lot for reading tests.", "author": "leaf94", "createdAt": "2020-02-06T00:26:01Z", "path": "src/test/java/com/aws/iot/evergreen/ipc/IPCRouterTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class IPCRouterTest {\n+    @Mock\n+    Log log;\n+\n+    @Test\n+    public void GIVEN_function_WHEN_register_callback_THEN_callback_can_be_called() throws Throwable {\n+        IPCRouter router = new IPCRouter(log);\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        router.registerServiceCallback(\"dest\", (a, b) -> {\n+            cdl.countDown();\n+            return null;\n+        });\n+\n+        router.getCallbackForDestination(\"dest\").onMessage(null, null);\n+        assertTrue(cdl.await(100, TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void GIVEN_already_registered_function_WHEN_register_callback_THEN_exception_is_thrown() throws Throwable {", "originalCommit": "0487faf174865d66ed37a559e017c7545ba50652", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375584523", "bodyText": "I like AuthRequestType.Auth better. (plural -> singular)", "author": "leaf94", "createdAt": "2020-02-06T00:31:59Z", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "originalCommit": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Nzc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375587777", "bodyText": "There is only 1 type, yes, but it is an enum which could technically have differing types.", "author": "MikeDombo", "createdAt": "2020-02-06T00:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4ODY1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375588658", "bodyText": "Not because it just have 1 type for now... Since each enum is a Type so we use a singular name for most Enum types.", "author": "leaf94", "createdAt": "2020-02-06T00:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTE2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375589168", "bodyText": "The enum is describing the different types of requests that can happen.", "author": "MikeDombo", "createdAt": "2020-02-06T00:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java b/src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java\nindex 60a78bd45..6320887f7 100644\n--- a/src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java\n\n@@ -12,6 +12,7 @@ import com.aws.iot.evergreen.kernel.EvergreenService;\n import org.junit.jupiter.api.Test;\n \n import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.SERVICE_UNIQUE_ID_KEY;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTU1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375585556", "bodyText": "For long tests, maybe adding //GIVEN //WHEN //THEN will be helpful", "author": "leaf94", "createdAt": "2020-02-06T00:35:58Z", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {", "originalCommit": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\nindex 00ded9ee9..88adb3dfd 100644\n--- a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n\n@@ -20,6 +20,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NjIwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375586200", "bodyText": "times(1) can be removed. save as several occurrences below", "author": "leaf94", "createdAt": "2020-02-06T00:38:24Z", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));", "originalCommit": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\nindex 00ded9ee9..88adb3dfd 100644\n--- a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n\n@@ -20,6 +20,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NzEwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375587104", "bodyText": "Seems this could be moved to beforeEach. ArgumentCaptor could be an @Captor class field", "author": "leaf94", "createdAt": "2020-02-06T00:41:35Z", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Unauthorized\"));\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_any_request_THEN_server_forces_them_to_authenticate_first() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_unregistered_destination_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Destination handler not found\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_normal_return_THEN_respond_with_message() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+        // Setup handler for destination\n+        when(ipcRouter.getCallbackForDestination(anyString())).thenReturn((message, ctx) -> {\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            fut.complete(new FrameReader.Message(\"Success\".getBytes()));\n+            return fut;\n+        });\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertEquals(\"Success\", new String(responseFrame.message.getPayload()));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_exceptional_return_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);", "originalCommit": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\nindex 00ded9ee9..88adb3dfd 100644\n--- a/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java\n\n@@ -20,6 +20,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.junit.jupiter.MockitoExtension;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375592591", "bodyText": "Not related to this pull request, but can you change this to not use hardcoded string \"_UID\".", "author": "fengwang666", "createdAt": "2020-02-06T01:02:26Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "originalCommit": "4da926e04a410557c7a06f6b7dcc68315dc7304f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzEyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603128", "bodyText": "Also at line 33, what if the random generated authToken collides with an existing one? Right now it seems it would overwrite the existing one. Isn't that wrong?", "author": "fengwang666", "createdAt": "2020-02-06T01:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNTA5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375605098", "bodyText": "There shouldn't be a collision since there should be enough entropy, but yeah, it would just overwrite if that was the case.\nI'll pull out _UID to a const.", "author": "MikeDombo", "createdAt": "2020-02-06T01:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNzc5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375607799", "bodyText": "Changed it to check if it was previously set, and if so, it will retry registering an auth token, thus generating a new one.", "author": "MikeDombo", "createdAt": "2020-02-06T02:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\nindex 7df320130..74d143c5b 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n\n@@ -22,12 +22,13 @@ import javax.inject.Inject;\n @NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n+    public static final String SERVICE_UNIQUE_ID_KEY = \"_UID\";\n \n     @Inject\n     private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n-        Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);\n+        Topic uid = s.config.createLeafChild(SERVICE_UNIQUE_ID_KEY).setParentNeedsToKnow(false);\n         String authToken = Utils.generateRandomString(16).toUpperCase();\n         uid.setValue(authToken);\n         s.config.parent.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).setValue(s.getName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5ODAyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375598027", "bodyText": "Not related to this pull request, but I think it's cleaner to move this method into the GenericExternalService class. Not block this pull request though.", "author": "fengwang666", "createdAt": "2020-02-06T01:23:13Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {", "originalCommit": "4da926e04a410557c7a06f6b7dcc68315dc7304f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\nindex 7df320130..74d143c5b 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n\n@@ -22,12 +22,13 @@ import javax.inject.Inject;\n @NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n+    public static final String SERVICE_UNIQUE_ID_KEY = \"_UID\";\n \n     @Inject\n     private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n-        Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);\n+        Topic uid = s.config.createLeafChild(SERVICE_UNIQUE_ID_KEY).setParentNeedsToKnow(false);\n         String authToken = Utils.generateRandomString(16).toUpperCase();\n         uid.setValue(authToken);\n         s.config.parent.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).setValue(s.getName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375601875", "bodyText": "getOnce() is marked as deprecated. Is this a misuse?", "author": "fengwang666", "createdAt": "2020-02-06T01:39:23Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "originalCommit": "4da926e04a410557c7a06f6b7dcc68315dc7304f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzU0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603541", "bodyText": "line 59-60, can you change serviceName to be private and use constructor?", "author": "fengwang666", "createdAt": "2020-02-06T01:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNTMyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375605328", "bodyText": "getOnce shouldn't be deprecated. The \"deprecation\" is that we should be subscribing for updates and not using getOnce, but in this case we're just doing a static lookup and there's no need to be notified of a change.", "author": "MikeDombo", "createdAt": "2020-02-06T01:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\nindex 7df320130..74d143c5b 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java\n\n@@ -56,8 +57,6 @@ public class AuthHandler implements InjectionActions {\n             throw new IPCClientNotAuthorizedException(\"Auth token not found\");\n         }\n \n-        RequestContext context = new RequestContext();\n-        context.serviceName = serviceName;\n-        return context;\n+        return new RequestContext(serviceName);\n     }\n }\n"}}, {"oid": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "message": "Address PR comments", "committedDate": "2020-02-06T02:01:46Z", "type": "forcePushed"}, {"oid": "bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "message": "Address PR comments", "committedDate": "2020-02-06T02:05:37Z", "type": "forcePushed"}, {"oid": "cb9322e1c51882e9626a3f4f4a35e4d038174921", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb9322e1c51882e9626a3f4f4a35e4d038174921", "message": "Address PR comments", "committedDate": "2020-02-06T23:07:07Z", "type": "commit"}, {"oid": "cb9322e1c51882e9626a3f4f4a35e4d038174921", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb9322e1c51882e9626a3f4f4a35e4d038174921", "message": "Address PR comments", "committedDate": "2020-02-06T23:07:07Z", "type": "forcePushed"}]}