{"pr_number": 51, "pr_title": "Switch to using Netty for IPC server", "pr_createdAt": "2020-02-03T23:15:38Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51", "timeline": [{"oid": "14349de350f5fb287cb1c7fb9160f90652376d57", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14349de350f5fb287cb1c7fb9160f90652376d57", "message": "Switch to using Netty for IPC server", "committedDate": "2020-02-03T23:19:25Z", "type": "commit"}, {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14349de350f5fb287cb1c7fb9160f90652376d57", "message": "Switch to using Netty for IPC server", "committedDate": "2020-02-03T23:19:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471375", "bodyText": "Shouldn't it be logged at error level? Also log the exception?", "author": "fengwang666", "createdAt": "2020-02-04T04:40:41Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjQwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502403", "bodyText": "No need to log interrupted exception, it never has anything helpful, it will just say that they thread died.\nI can change the level though.", "author": "MikeDombo", "createdAt": "2020-02-04T07:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\nindex 9ecb25b10..076d4fe8c 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n\n@@ -80,7 +80,7 @@ public class IPCService extends EvergreenService {\n \n             super.startup();\n         } catch (InterruptedException e) {\n-            log.warn(\"Failed IPC server startup\");\n+            log.error(\"Failed IPC server startup\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471636", "bodyText": "Update comments", "author": "fengwang666", "createdAt": "2020-02-04T04:42:09Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");\n         }\n     }\n \n+    private int listen() throws InterruptedException {\n+        ServerBootstrap b = new ServerBootstrap();\n+\n+        b.group(bossGroup, workerGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    public void initChannel(SocketChannel ch) {\n+                        ChannelPipeline p = ch.pipeline();\n+\n+                        p.addLast(new MessageFrameDecoder());\n+                        p.addLast(new MessageFrameEncoder());\n+                        p.addLast(messageHandler);\n+                    }\n+                })\n+                .option(ChannelOption.SO_BACKLOG, MAX_SO_BACKLOG)\n+                .childOption(ChannelOption.SO_KEEPALIVE, true);\n+\n+        // Bind and start to accept incoming connections.\n+        ChannelFuture f = b.bind(InetAddress.getLoopbackAddress(), 0).sync();\n+        int port = ((InetSocketAddress) f.channel().localAddress()).getPort();\n+\n+        log.note(\"IPC ready to accept connections on port\", port);\n+        return port;\n+    }\n+\n     /**", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNDIwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374504200", "bodyText": "Sure thing.", "author": "MikeDombo", "createdAt": "2020-02-04T07:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\nindex 9ecb25b10..076d4fe8c 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n\n@@ -80,7 +80,7 @@ public class IPCService extends EvergreenService {\n \n             super.startup();\n         } catch (InterruptedException e) {\n-            log.warn(\"Failed IPC server startup\");\n+            log.error(\"Failed IPC server startup\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471753", "bodyText": "do you need this log?", "author": "fengwang666", "createdAt": "2020-02-04T04:42:46Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");\n         }\n     }\n \n+    private int listen() throws InterruptedException {\n+        ServerBootstrap b = new ServerBootstrap();\n+\n+        b.group(bossGroup, workerGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    public void initChannel(SocketChannel ch) {\n+                        ChannelPipeline p = ch.pipeline();\n+\n+                        p.addLast(new MessageFrameDecoder());\n+                        p.addLast(new MessageFrameEncoder());\n+                        p.addLast(messageHandler);\n+                    }\n+                })\n+                .option(ChannelOption.SO_BACKLOG, MAX_SO_BACKLOG)\n+                .childOption(ChannelOption.SO_KEEPALIVE, true);\n+\n+        // Bind and start to accept incoming connections.\n+        ChannelFuture f = b.bind(InetAddress.getLoopbackAddress(), 0).sync();\n+        int port = ((InetSocketAddress) f.channel().localAddress()).getPort();\n+\n+        log.note(\"IPC ready to accept connections on port\", port);\n+        return port;\n+    }\n+\n     /**\n      * Blocks indefinitely listening for new connection. If the server socket errors while listening, the exception\n      * is bubbled up and IPCService will transition to Errored state.\n      */\n     @Override\n     public void run() {\n         log.log(Level.Note, \"Run called for IPC service\");", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjU2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502564", "bodyText": "Right now, yes. It is actually used in the unit tests to know when it is safe to start the testing since the server has started up.", "author": "MikeDombo", "createdAt": "2020-02-04T07:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\nindex 9ecb25b10..076d4fe8c 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n\n@@ -80,7 +80,7 @@ public class IPCService extends EvergreenService {\n \n             super.startup();\n         } catch (InterruptedException e) {\n-            log.warn(\"Failed IPC server startup\");\n+            log.error(\"Failed IPC server startup\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDM0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374474345", "bodyText": "Why are you using RePlayingDecoder? Also can you add a comment describing the message frame? Similar to the style we have in stream manager", "author": "fengwang666", "createdAt": "2020-02-04T04:57:01Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjk1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502953", "bodyText": "This is needed because we don't have a length field which has the length of the full packet. I tried adding multiple LengthFieldBasedDecoders, but that does not work, so that's why I had to do it this way. If we change the packet format, then I can change this implementation.", "author": "MikeDombo", "createdAt": "2020-02-04T07:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\nindex 9fa912f06..c52ebbe74 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n\n@@ -15,12 +15,28 @@ import java.util.List;\n public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n     private static final int BYTE_MASK = 0xff;\n     private static final int IS_RESPONSE_MASK = 0x01;\n+    public static final int SEQ_NUM_AND_PAYLOAD_LENGTH_LENGTH = 6;\n+    public static final int VERSION_AND_DEST_LENGTH_LENGTH = 2;\n \n+    /**\n+     * Decode the input message.\n+     * Message format is\n+     *\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     * | Version + Type   |  Destination Length  |  Destination  |  Seq. Number  |  Payload Length  |  Payload   |\n+     * |     1 byte       |         1 byte       |    x bytes    |    4 bytes    |      2 bytes     |  y bytes   |\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     *\n+     * @param channelHandlerContext\n+     * @param byteBuf\n+     * @param list\n+     * @throws Exception\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n         byteBuf.markReaderIndex();\n \n-        if (actualReadableBytes() < 2) {\n+        if (actualReadableBytes() < VERSION_AND_DEST_LENGTH_LENGTH) {\n             byteBuf.resetReaderIndex();\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NTgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374475824", "bodyText": "What is \"2\"? Can you not use magic number here?", "author": "fengwang666", "createdAt": "2020-02-04T05:05:32Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNDEyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374504121", "bodyText": "2 for the first 2 bytes (version/type and destination name length). But of course I can extract the const.", "author": "MikeDombo", "createdAt": "2020-02-04T07:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NTgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\nindex 9fa912f06..c52ebbe74 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n\n@@ -15,12 +15,28 @@ import java.util.List;\n public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n     private static final int BYTE_MASK = 0xff;\n     private static final int IS_RESPONSE_MASK = 0x01;\n+    public static final int SEQ_NUM_AND_PAYLOAD_LENGTH_LENGTH = 6;\n+    public static final int VERSION_AND_DEST_LENGTH_LENGTH = 2;\n \n+    /**\n+     * Decode the input message.\n+     * Message format is\n+     *\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     * | Version + Type   |  Destination Length  |  Destination  |  Seq. Number  |  Payload Length  |  Payload   |\n+     * |     1 byte       |         1 byte       |    x bytes    |    4 bytes    |      2 bytes     |  y bytes   |\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     *\n+     * @param channelHandlerContext\n+     * @param byteBuf\n+     * @param list\n+     * @throws Exception\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n         byteBuf.markReaderIndex();\n \n-        if (actualReadableBytes() < 2) {\n+        if (actualReadableBytes() < VERSION_AND_DEST_LENGTH_LENGTH) {\n             byteBuf.resetReaderIndex();\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjI1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374476258", "bodyText": "Where is actualReadableBytes() method defined?", "author": "fengwang666", "createdAt": "2020-02-04T05:07:52Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        int firstByte = ((int) byteBuf.readByte()) & BYTE_MASK;\n+        int version = firstByte >> 1;\n+        FrameReader.FrameType type = FrameReader.FrameType.fromOrdinal(firstByte & IS_RESPONSE_MASK);\n+\n+        int destinationNameLength = byteBuf.readByte();\n+\n+        if (actualReadableBytes() < destinationNameLength) {", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzAzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503030", "bodyText": "In the super class, the replaying decoder.", "author": "MikeDombo", "createdAt": "2020-02-04T07:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\nindex 9fa912f06..c52ebbe74 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n\n@@ -15,12 +15,28 @@ import java.util.List;\n public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n     private static final int BYTE_MASK = 0xff;\n     private static final int IS_RESPONSE_MASK = 0x01;\n+    public static final int SEQ_NUM_AND_PAYLOAD_LENGTH_LENGTH = 6;\n+    public static final int VERSION_AND_DEST_LENGTH_LENGTH = 2;\n \n+    /**\n+     * Decode the input message.\n+     * Message format is\n+     *\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     * | Version + Type   |  Destination Length  |  Destination  |  Seq. Number  |  Payload Length  |  Payload   |\n+     * |     1 byte       |         1 byte       |    x bytes    |    4 bytes    |      2 bytes     |  y bytes   |\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     *\n+     * @param channelHandlerContext\n+     * @param byteBuf\n+     * @param list\n+     * @throws Exception\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n         byteBuf.markReaderIndex();\n \n-        if (actualReadableBytes() < 2) {\n+        if (actualReadableBytes() < VERSION_AND_DEST_LENGTH_LENGTH) {\n             byteBuf.resetReaderIndex();\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjkyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374476925", "bodyText": "If you decide to use ReplayingDecoder, you could use checkpoint() method to avoid rewinding to the beginning.", "author": "fengwang666", "createdAt": "2020-02-04T05:10:49Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        int firstByte = ((int) byteBuf.readByte()) & BYTE_MASK;\n+        int version = firstByte >> 1;\n+        FrameReader.FrameType type = FrameReader.FrameType.fromOrdinal(firstByte & IS_RESPONSE_MASK);\n+\n+        int destinationNameLength = byteBuf.readByte();\n+\n+        if (actualReadableBytes() < destinationNameLength) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        byte[] destinationNameByte = new byte[destinationNameLength];\n+        byteBuf.readBytes(destinationNameByte);\n+\n+        if (actualReadableBytes() < 6) {\n+            byteBuf.resetReaderIndex();", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzIyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503222", "bodyText": "I saw, but I don't want to add that complication in this PR right now, especially if we change the packet format and add a LengthFieldBasedDecoder.", "author": "MikeDombo", "createdAt": "2020-02-04T07:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjkyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\nindex 9fa912f06..c52ebbe74 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java\n\n@@ -15,12 +15,28 @@ import java.util.List;\n public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n     private static final int BYTE_MASK = 0xff;\n     private static final int IS_RESPONSE_MASK = 0x01;\n+    public static final int SEQ_NUM_AND_PAYLOAD_LENGTH_LENGTH = 6;\n+    public static final int VERSION_AND_DEST_LENGTH_LENGTH = 2;\n \n+    /**\n+     * Decode the input message.\n+     * Message format is\n+     *\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     * | Version + Type   |  Destination Length  |  Destination  |  Seq. Number  |  Payload Length  |  Payload   |\n+     * |     1 byte       |         1 byte       |    x bytes    |    4 bytes    |      2 bytes     |  y bytes   |\n+     * +------------------+----------------------+---------------+---------------+------------------+------------+\n+     *\n+     * @param channelHandlerContext\n+     * @param byteBuf\n+     * @param list\n+     * @throws Exception\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n         byteBuf.markReaderIndex();\n \n-        if (actualReadableBytes() < 2) {\n+        if (actualReadableBytes() < VERSION_AND_DEST_LENGTH_LENGTH) {\n             byteBuf.resetReaderIndex();\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzMyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374477321", "bodyText": "Why not just reuse the log message?", "author": "fengwang666", "createdAt": "2020-02-04T05:12:47Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;\n+\n+        // When there isn't context yet, we expect a call to be authorized first\n+        if (ctx.channel().attr(CONNECTION_CONTEXT_KEY).get() == null) {\n+            handleAuth(ctx, message);\n+            return;\n+        }\n+\n+        IPCCallback cb = router.getCallbackForDestination(message.destination);\n+        if (cb == null) {\n+            log.warn(\"Destination not found for packet from client\",\n+                    ctx.channel().remoteAddress(), message.destination);\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)\n+                                    .errorMessage(\"Destination handler not found\")", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzQzNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503434", "bodyText": "The messages are different, but sure I can reuse.", "author": "MikeDombo", "createdAt": "2020-02-04T07:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\nindex 4207b372a..6d35ed065 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n\n@@ -30,7 +30,9 @@ import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n  */\n @ChannelHandler.Sharable\n public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final String DEST_NOT_FOUND_ERROR = \"Destination handler not found\";\n     public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+\n     @Inject\n     private Log log;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzY4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374477681", "bodyText": "Why is the error code Unknown in this case?", "author": "fengwang666", "createdAt": "2020-02-04T05:14:40Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;\n+\n+        // When there isn't context yet, we expect a call to be authorized first\n+        if (ctx.channel().attr(CONNECTION_CONTEXT_KEY).get() == null) {\n+            handleAuth(ctx, message);\n+            return;\n+        }\n+\n+        IPCCallback cb = router.getCallbackForDestination(message.destination);\n+        if (cb == null) {\n+            log.warn(\"Destination not found for packet from client\",\n+                    ctx.channel().remoteAddress(), message.destination);\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)\n+                                    .errorMessage(\"Destination handler not found\")\n+                                    .build())),\n+                    message.sequenceNumber,\n+                    message.destination, ctx, false);\n+            return;\n+        }\n+\n+        try {\n+            // TODO: Be smart about timeouts? https://issues.amazon.com/issues/86453f7c-c94e-4a3c-b8ff-679767e7443c\n+            FrameReader.Message responseMessage = cb.onMessage(message.message,\n+                    ctx.channel().attr(CONNECTION_CONTEXT_KEY).get(),\n+                    ctx.channel())\n+                    // This .get() blocks forever waiting for the response to the request\n+                    .get();\n+            sendResponse(responseMessage,\n+                    message.sequenceNumber,\n+                    message.destination, ctx, false);\n+        } catch (Throwable throwable) {\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzYyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503621", "bodyText": "It is unknown because it could be any throwable. The onMessage handler should handle its own exceptions, this is just an extra catch-all just in case. I can add comments to make that more clear.", "author": "MikeDombo", "createdAt": "2020-02-04T07:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzY4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\nindex 4207b372a..6d35ed065 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n\n@@ -30,7 +30,9 @@ import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n  */\n @ChannelHandler.Sharable\n public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final String DEST_NOT_FOUND_ERROR = \"Destination handler not found\";\n     public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+\n     @Inject\n     private Log log;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3ODYwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374478601", "bodyText": "Add SIM?", "author": "fengwang666", "createdAt": "2020-02-04T05:19:09Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzM3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503376", "bodyText": "Can do.", "author": "MikeDombo", "createdAt": "2020-02-04T07:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3ODYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\nindex 4207b372a..6d35ed065 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n\n@@ -30,7 +30,9 @@ import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n  */\n @ChannelHandler.Sharable\n public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final String DEST_NOT_FOUND_ERROR = \"Destination handler not found\";\n     public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+\n     @Inject\n     private Log log;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTMxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374479311", "bodyText": "Why do you need to pass in channel? I didn't see it getting used.", "author": "fengwang666", "createdAt": "2020-02-04T05:22:30Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import io.netty.channel.Channel;\n+\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Interface for IPC message handlers\n+ */\n+@FunctionalInterface\n+public interface IPCCallback {\n+    Future<FrameReader.Message> onMessage(FrameReader.Message m, RequestContext ctx, Channel channel) throws Throwable;", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502041", "bodyText": "It isn't used by Service Discovery, but it would be used by lifecycle ipc in order to send messages back to the client as a server-push.", "author": "MikeDombo", "createdAt": "2020-02-04T07:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\nindex 9aeb1ea37..cf35124db 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\n\n@@ -6,7 +6,6 @@ package com.aws.iot.evergreen.ipc;\n \n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n-import io.netty.channel.Channel;\n \n import java.util.concurrent.Future;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MDYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374480617", "bodyText": "Why use an empty message? Do you handle the empty message at the caller side?", "author": "fengwang666", "createdAt": "2020-02-04T05:28:38Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java", "diffHunk": "@@ -89,20 +92,20 @@ public Message handleMessage(Message request, RequestContext context) {\n                     genResp.setErrorMessage(\"Unknown request type \" + obj.getType());\n                     break;\n             }\n-            return new Message(SendAndReceiveIPCUtil.encode(genResp));\n-\n+            fut.complete(new Message(SendAndReceiveIPCUtil.encode(genResp)));\n         } catch (Throwable e) {\n             log.log(Level.Error, \"Failed to respond to handleMessage\", e);\n \n             GeneralResponse<Void, ServiceDiscoveryResponseStatus> errorResponse = GeneralResponse.<Void,\n                     ServiceDiscoveryResponseStatus>builder().error(ServiceDiscoveryResponseStatus.Unknown).errorMessage(e.getMessage()).build();\n \n             try {\n-                return new Message(SendAndReceiveIPCUtil.encode(errorResponse));\n+                fut.complete(new Message(SendAndReceiveIPCUtil.encode(errorResponse)));\n             } catch (IOException ex) {\n                 log.log(Level.Error, \"Couldn't even send them the error back\", e);\n             }\n         }\n-        return null;\n+        fut.complete(new Message(new byte[0]));", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374503820", "bodyText": "This cannot ever execute since the only case it would happen is if we can't JSON encode the response or even the error response, but we know that they will be encodable.\nI will add more commentary around this.", "author": "MikeDombo", "createdAt": "2020-02-04T07:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MDYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjY5Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374792692", "bodyText": "Switched it to complete with an exception saying \"Unable to serialize any responses\" so it is very clear it is an error and what went wrong.", "author": "MikeDombo", "createdAt": "2020-02-04T16:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MDYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java\nindex 44fa6498e..a34a03b02 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java\n\n@@ -105,7 +105,11 @@ public class ServiceDiscoveryService extends EvergreenService {\n                 log.log(Level.Error, \"Couldn't even send them the error back\", e);\n             }\n         }\n-        fut.complete(new Message(new byte[0]));\n+\n+        if (!fut.isDone()) {\n+            fut.completeExceptionally(new IPCException(\"Unable to serialize any responses\"));\n+        }\n+\n         return fut;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTE1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374501151", "bodyText": "Can we try not to leak ipc service implementation, services registering callbacks should not know about channel.\nI would also prefer the IPCService to maintain the list of active connections, offloading that to callers would lead to repeated code for adding, removing connections.", "author": "fahadmohammed01", "createdAt": "2020-02-04T06:58:43Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import io.netty.channel.Channel;\n+\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Interface for IPC message handlers\n+ */\n+@FunctionalInterface\n+public interface IPCCallback {\n+    Future<FrameReader.Message> onMessage(FrameReader.Message m, RequestContext ctx, Channel channel) throws Throwable;", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwNDMxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374504310", "bodyText": "As we discussed, I disagree, but we can talk more tomorrow. Probably this will change when I migrate the lifecycle ipc to use Netty once this gets merged.", "author": "MikeDombo", "createdAt": "2020-02-04T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4Mzg0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374783846", "bodyText": "Since it is unused currently, I'm going to just remove it from this PR.", "author": "MikeDombo", "createdAt": "2020-02-04T16:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\nindex 9aeb1ea37..cf35124db 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java\n\n@@ -6,7 +6,6 @@ package com.aws.iot.evergreen.ipc;\n \n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n-import io.netty.channel.Channel;\n \n import java.util.concurrent.Future;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjYxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502617", "bodyText": "rename to messageRouter?", "author": "fahadmohammed01", "createdAt": "2020-02-04T07:04:15Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -17,65 +27,36 @@\n /**\n  * Entry point to the kernel service IPC mechanism. IPC service manages the lifecycle of all IPC components\n  * <p>\n- * Server:\n- * Listens for new connections and passes new connections to connection manager\n- * <p>\n- * Connection Manager:\n- * Manages connections created by Server, connection manager is responsible for\n- * - Authenticating a new connection\n- * - Creating readers and writers for a connection\n- * - Closes connection when read or write message has IOErrors\n- * - Closes connection during shutdown\n- * <p>\n- * ConnectionReader:\n- * - Reads messages from the connection input stream and forwards them to message dispatcher\n- * - Forwards IOErrors to connection manager\n- * <p>\n- * ConnectionWriter:\n- * - Writes messages to the connection output stream\n- * - Forwards IOErrors to connection manager\n- * <p>\n- * Message Dispatcher:\n- * - Handles incoming messages from connections\n- * - Acts as an interface for modules inside the kernel to\n- * - Register call backs for a destination\n- * - Send messages to an outside process\n- * - Manages the thread pool which process all incoming and outgoing messages\n- * <p>\n  * IPCService relies on the kernel to synchronize between startup() and run() calls.\n  * <p>\n  * How messages flow:\n  * <p>\n  * New connection:\n- * Server listens for new connections, new connections are forwarded to connection manager.\n- * Connection manager authorizes connection and creates connection reader and writer\n- * <p>\n- * Incoming message from an external process\n- * Connection reader is run on a separate thread which does the blocking read on connection input stream,\n- * Message read by connection reader is forwarded to connection dispatcher, if the message is a new request,\n- * dispatcher looks up the call back based on the request destination and invokes the callback. The result of the\n- * callback is sent out via the same connection.\n- * If the message is a response to a previous request, dispatcher looks up the future object associated with the\n- * request using the sequence number and updates the future.\n+ * Server listens for new connections, new connections are forwarded to MessageRouter using the Netty pipeline.\n+ * MessageRouter authorizes connection and will then allow further queries to be routed.\n  * <p>\n  * Outgoing messages:\n- * Modules in the kernel that need to send messages to an external process would inject into itself a\n- * reference of the message dispatcher. Module can send message using client Id of the process via\n- * dispatcher. Dispatcher will look up the connection associated with the clientId using connection manager\n- * and write the message to the connection. Dispatcher will return a future object to the module which\n- * will be marked as complete when connection responds to the message.\n+ * The client must first send a request to setup a \"listener\" on the server. As part of handling that request,\n+ * the service will receive a pointer to the channel that they will then be able to use to push messages\n+ * to the client at any time in the future.\n  */\n \n @ImplementsService(name = \"IPCService\", autostart = true)\n public class IPCService extends EvergreenService {\n+    private static final int MAX_SO_BACKLOG = 128;\n+\n+    public static final String KERNEL_URI_ENV_VARIABLE_NAME = \"AWS_GG_KERNEL_URI\";\n+    private static final String LOCAL_IP = \"127.0.0.1\";\n \n     @Inject\n     Log log;\n-    //TODO: figure out how to inject the interface ConnectionManager\n-    @Inject\n-    private ConnectionManager connectionManager;\n+\n+    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n+    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n+    private int port;\n+\n     @Inject\n-    private Server server;\n+    private MessageRouter messageHandler;", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\nindex 9ecb25b10..076d4fe8c 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/IPCService.java\n\n@@ -56,7 +56,7 @@ public class IPCService extends EvergreenService {\n     private int port;\n \n     @Inject\n-    private MessageRouter messageHandler;\n+    private MessageRouter messageRouter;\n \n     public IPCService(Topics c) {\n         super(c);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwOTQyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374509423", "bodyText": "For channels that are not authenticated , where do we specify a timeout to prevent clients that connect and do not produce an auth token", "author": "fahadmohammed01", "createdAt": "2020-02-04T07:28:26Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;", "originalCommit": "14349de350f5fb287cb1c7fb9160f90652376d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODQxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374788413", "bodyText": "We don't. This PR is only moving over the existing logic, not adding anything new. I will add a TODO and SIM. Though I'm not sure we need that feature.", "author": "MikeDombo", "createdAt": "2020-02-04T16:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwOTQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\nindex 4207b372a..6d35ed065 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java\n\n@@ -30,7 +30,9 @@ import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n  */\n @ChannelHandler.Sharable\n public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final String DEST_NOT_FOUND_ERROR = \"Destination handler not found\";\n     public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+\n     @Inject\n     private Log log;\n \n"}}, {"oid": "65a7b6d1bc9698e7f08a78f6efb226828a28e686", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65a7b6d1bc9698e7f08a78f6efb226828a28e686", "message": "Refactor EvergreenService with initial unit test", "committedDate": "2020-02-04T16:53:05Z", "type": "commit"}, {"oid": "8899bcb1307f83409c1f3a9492108737960cc7ca", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8899bcb1307f83409c1f3a9492108737960cc7ca", "message": "Revert \"Refactor EvergreenService with initial unit test\"\n\nThis reverts commit 773693892cd8e3e2db5ba89738ba4457fd5d5e57.", "committedDate": "2020-02-04T16:53:05Z", "type": "commit"}, {"oid": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "message": "Address PR comments", "committedDate": "2020-02-04T16:53:05Z", "type": "commit"}, {"oid": "aa3aaf651a8878b094d9293581e1c058f2c6e574", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aa3aaf651a8878b094d9293581e1c058f2c6e574", "message": "Merge branch 'master' into netty", "committedDate": "2020-02-04T16:55:26Z", "type": "commit"}]}